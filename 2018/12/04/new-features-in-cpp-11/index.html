<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/favicon-64x64.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
  <link rel="mask-icon" href="/favicon-128x128.png" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"bygeek.cn","root":"/","scheme":"Mist","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":true,"show_result":true,"style":null},"back2top":{"enable":true,"sidebar":true,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="本文转载自Herb Sutter的blog。Herb Sutter是C++标准委员会的主席，他在本文中主要讲述了C++ 11 带来的新的一些feature，同时建议尽量使用Modern C++ style编程。 同时我建议阅读Scott Mayers的《Effective Modern C++》一书。 原文如下。">
<meta property="og:type" content="article">
<meta property="og:title" content="C++ 11带来的新特性">
<meta property="og:url" content="https://bygeek.cn/2018/12/04/new-features-in-cpp-11/index.html">
<meta property="og:site_name" content="bygeek&#39;s Playground">
<meta property="og:description" content="本文转载自Herb Sutter的blog。Herb Sutter是C++标准委员会的主席，他在本文中主要讲述了C++ 11 带来的新的一些feature，同时建议尽量使用Modern C++ style编程。 同时我建议阅读Scott Mayers的《Effective Modern C++》一书。 原文如下。">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2018-12-04T01:56:55.000Z">
<meta property="article:modified_time" content="2021-05-30T13:08:49.970Z">
<meta property="article:author" content="byGeek">
<meta property="article:tag" content="c++">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="https://bygeek.cn/2018/12/04/new-features-in-cpp-11/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>C++ 11带来的新特性 | bygeek's Playground</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

<link rel="alternate" href="/atom.xml" title="bygeek's Playground" type="application/atom+xml">
</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">bygeek's Playground</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="reading-progress-bar"></div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://bygeek.cn/2018/12/04/new-features-in-cpp-11/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/uploads/avatar.jpg">
      <meta itemprop="name" content="byGeek">
      <meta itemprop="description" content="Never too late to lose weight!!!">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="bygeek's Playground">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          C++ 11带来的新特性
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2018-12-04 09:56:55" itemprop="dateCreated datePublished" datetime="2018-12-04T09:56:55+08:00">2018-12-04</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-05-30 21:08:49" itemprop="dateModified" datetime="2021-05-30T21:08:49+08:00">2021-05-30</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/coding/" itemprop="url" rel="index"><span itemprop="name">coding</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/coding/repost/" itemprop="url" rel="index"><span itemprop="name">repost</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <p>本文转载自Herb Sutter的<a target="_blank" rel="noopener" href="https://herbsutter.com/elements-of-modern-c-style/">blog</a>。Herb Sutter是C++标准委员会的主席，他在本文中主要讲述了C++ 11 带来的新的一些feature，同时建议尽量使用Modern C++ style编程。</p>
<p>同时我建议阅读Scott Mayers的《Effective Modern C++》一书。</p>
<p>原文如下。</p>
<span id="more"></span>

<p>The C++11 standard offers <a target="_blank" rel="noopener" href="http://www2.research.att.com/~bs/C++0xFAQ.html">many useful new features</a>. This page focuses specifically and only on those features that make C++11 really feel like a new language compared to C++98, because:</p>
<ul>
<li>They change the styles and idioms you’ll use when writing C++ code, often including the way you’ll design C++ libraries. For example, you’ll see more smart pointer parameters and return values, and functions that return big objects by value.</li>
<li>They will be used so pervasively that you’ll probably see them in most code examples. For example, virtually every five-line modern C++ code example will say “auto” somewhere.</li>
</ul>
<p>Use the other great C++11 features too. But get used to these ones first, because these are the pervasive ones that show why C++11 code is clean, safe, and fast – just as clean and safe as code written in any other modern mainstream language, and with C++’s traditional to-the-metal performance as strong as ever.</p>
<p>Notes:</p>
<ul>
<li>Like Strunk &amp; White, this page is deliberately focused on brief summary guidance. It is not intended to provide exhaustive rationale and pro/con analysis; that will go into other articles.</li>
<li>This is a living document. See the end for a list of the main changes and additions over time.</li>
</ul>
<h3 id="auto"><a href="#auto" class="headerlink" title="auto"></a>auto</h3><p>Use auto wherever possible. It is useful for two reasons. First, most obviously it’s a convenience that lets us avoid repeating a type name that we already stated and the compiler already knows.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// C++98</span></span><br><span class="line"><span class="built_in">map</span>&lt;<span class="keyword">int</span>,<span class="built_in">string</span>&gt;::iterator i = m.begin();</span><br><span class="line"><span class="keyword">double</span> <span class="keyword">const</span> xlimit = config[<span class="string">&quot;xlimit&quot;</span>];</span><br><span class="line">singleton&amp; s = singleton::instance();</span><br><span class="line"> </span><br><span class="line"><span class="comment">// C++11</span></span><br><span class="line"><span class="keyword">auto</span> i = begin(m);</span><br><span class="line"><span class="keyword">auto</span> <span class="keyword">const</span> xlimit = config[<span class="string">&quot;xlimit&quot;</span>];</span><br><span class="line"><span class="keyword">auto</span>&amp; s = singleton::instance();</span><br></pre></td></tr></table></figure>

<p>Second, it’s more than just a convenience when a type has an unknown or unutterable name, such as the type of most lambda functions, that you couldn’t otherwise spell easily or at all.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// C++98</span></span><br><span class="line">binder2nd&lt; greater &gt; x = bind2nd( greater(), <span class="number">42</span> );</span><br><span class="line"> </span><br><span class="line"><span class="comment">// C++11</span></span><br><span class="line"><span class="keyword">auto</span> x = [](<span class="keyword">int</span> i) &#123; <span class="keyword">return</span> i &gt; <span class="number">42</span>; &#125;;</span><br></pre></td></tr></table></figure>

<p>Note that using auto doesn’t change the code’s meaning. The code is still statically typed, and the type of every expression is already crisp and clear; the language just no longer forces us to redundantly restate the type’s name.</p>
<p>Some people are initially afraid of using auto here, because it may feel like not (re)stating the type we want could mean we’ll get a different type by accident. If you want to explicitly <em>enforce a type conversion</em>, that’s okay; state the target type. The vast majority of the time, however, just use auto; it will rarely be the case that you get a different type by mistake, and even in those cases the language’s strong static typing means the compiler will usually let you know because you’ll be trying to call a member function the variable doesn’t have or otherwise use it as something that it isn’t.</p>
<h3 id="Smart-pointers-No-delete"><a href="#Smart-pointers-No-delete" class="headerlink" title="Smart pointers: No delete"></a>Smart pointers: No delete</h3><p>Always use the standard smart pointers, and non-owning raw pointers. Never use owning raw pointers and delete, except in rare cases when implementing your own low-level data structure (and even then keep that well encapsulated inside a class boundary).</p>
<p>If you know you’re the only owner of another object, use unique_ptr to express unique ownership. A “new T” expression should immediately initialize another object that owns it, typically a unique_ptr. A classic example is the Pimpl Idiom (see <a target="_blank" rel="noopener" href="https://herbsutter.com/gotw/_100/">GotW #100</a>):</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// C++11 Pimpl idiom: header file</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">widget</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    widget();</span><br><span class="line">    <span class="comment">// ... (see GotW #100) ...</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">impl</span>;</span></span><br><span class="line">    <span class="built_in">unique_ptr</span>&lt;impl&gt; pimpl;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// implementation file</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">widget</span>:</span>:impl &#123; <span class="comment">/*...*/</span> &#125;;</span><br><span class="line"> </span><br><span class="line">widget::widget() : pimpl&#123; <span class="keyword">new</span> impl&#123; <span class="comment">/*...*/</span> &#125; &#125; &#123; &#125;</span><br><span class="line"><span class="comment">// ...</span></span><br></pre></td></tr></table></figure>

<p>Use shared_ptr to express shared ownership. Prefer to use make_shared to create shared objects efficiently.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; C++98</span><br><span class="line">widget* pw &#x3D; new widget();</span><br><span class="line">:::</span><br><span class="line">delete pw;</span><br><span class="line"> </span><br><span class="line">&#x2F;&#x2F; C++11</span><br><span class="line">auto pw &#x3D; make_shared&lt;widget&gt;();</span><br></pre></td></tr></table></figure>

<p>Use weak_ptr to break cycles and express optionality (e.g., implementing an object cache).</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// C++11</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">gadget</span>;</span></span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">widget</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">shared_ptr</span>&lt;gadget&gt; g; <span class="comment">// if shared ownership</span></span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">gadget</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    weak_ptr&lt;widget&gt; w;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br></pre></td></tr></table></figure>

<p>If you know another object is going to outlive you and you want to observe it, use a (non-owning) raw pointer.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// C++11</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">node</span> &#123;</span></span><br><span class="line"> <span class="built_in">vector</span>&lt;<span class="built_in">unique_ptr</span>&lt;node&gt;&gt; children;</span><br><span class="line"> node* parent;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"> :::</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="nullptr"><a href="#nullptr" class="headerlink" title="nullptr"></a>nullptr</h3><p>Always use nullptr for a null pointer value, never the literal 0 or the macro NULL which are ambiguous because they could be either an integer or a pointer.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// C++98</span></span><br><span class="line"><span class="keyword">int</span>* p = <span class="number">0</span>;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// C++11</span></span><br><span class="line"><span class="keyword">int</span>* p = <span class="literal">nullptr</span>;</span><br></pre></td></tr></table></figure>

<h3 id="Range-for"><a href="#Range-for" class="headerlink" title="Range for"></a>Range for</h3><p>The range-based for loop is a much more convenient way to visit every element of a range in order.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// C++98</span></span><br><span class="line"><span class="keyword">for</span>( <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::iterator i = v.begin(); i != v.end(); ++i ) &#123;</span><br><span class="line">    total += *i;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// C++11</span></span><br><span class="line"><span class="keyword">for</span>( <span class="keyword">auto</span> d : v ) &#123;</span><br><span class="line">    total += d;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Nonmember-begin-and-end"><a href="#Nonmember-begin-and-end" class="headerlink" title="Nonmember begin and end"></a>Nonmember begin and end</h3><p>Always use nonmember begin(x) and end(x) (not x.begin() and x.end()), because begin(x) and end(x) are extensible and can be adapted to work with all container types – even arrays – not just containers that follow the STL style of providing x.begin() and x.end() member functions.</p>
<p>If you’re using a non-STL collection type that provides iteration but not STL-style x.begin() and x.end(), you can often write your own non-member begin(x) and end(x) overloads for that type and then you can traverse collections of that type using the same coding style above as for STL containers. The standard has set the example: C arrays are such a type, and the standard provides begin and end for arrays.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v;</span><br><span class="line"><span class="keyword">int</span> a[<span class="number">100</span>];</span><br><span class="line"> </span><br><span class="line"><span class="comment">// C++98</span></span><br><span class="line">sort( v.begin(), v.end() );</span><br><span class="line">sort( &amp;a[<span class="number">0</span>], &amp;a[<span class="number">0</span>] + <span class="keyword">sizeof</span>(a)/<span class="keyword">sizeof</span>(a[<span class="number">0</span>]) );</span><br><span class="line"> </span><br><span class="line"><span class="comment">// C++11</span></span><br><span class="line">sort( begin(v), end(v) );</span><br><span class="line">sort( begin(a), end(a) );</span><br></pre></td></tr></table></figure>

<h3 id="Lambda-Functions-and-Algorithms"><a href="#Lambda-Functions-and-Algorithms" class="headerlink" title="Lambda Functions and Algorithms"></a>Lambda Functions and Algorithms</h3><p>Lambdas are a game-changer and will frequently change the way you write code to make it more elegant and faster. Lambdas make the existing STL algorithms roughly 100x more usable. Newer C++ libraries increasingly are designed assuming lambdas as available (e.g., PPL), and some even require you to write lambdas to use the library at all (e.g., C++ AMP).</p>
<p>Here’s one quick example: Find the first element in v that’s &gt;x and &lt;y. In C+11, the simplest and cleanest code is to use a standard algorithm.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// C++98: write a naked loop (using std::find_if is impractically difficult)</span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::iterator i = v.begin(); <span class="comment">// because we need to use i later</span></span><br><span class="line"><span class="keyword">for</span>( ; i != v.end(); ++i ) &#123;</span><br><span class="line">    <span class="keyword">if</span>( *i &gt; x &amp;&amp; *i &lt; y ) <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// C++11: use std::find_if</span></span><br><span class="line"><span class="keyword">auto</span> i = find_if( begin(v), end(v), [=](<span class="keyword">int</span> i) &#123; <span class="keyword">return</span> i &gt; x &amp;&amp; i &lt; y; &#125; );</span><br></pre></td></tr></table></figure>

<p>Want a loop or similar language feature that’s not actually in the language? No sweat; just write it as a template function (library algorithm), and thanks to lambdas you can use it with <em>almost</em> the same convenience as if it were a language feature, but with more flexibility because it really is a library and not a hardwired language feature.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// C#</span></span><br><span class="line">lock( mut_x ) &#123;</span><br><span class="line">    ... use x ...</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// C++11 without lambdas: already nice, and more flexible (e.g., can use timeouts, other options)</span></span><br><span class="line">&#123;</span><br><span class="line">    lock_guard&lt;mutex&gt; hold &#123; mut_x &#125;;</span><br><span class="line">    ... use x ...</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// C++11 with lambdas, and a helper algorithm: C# syntax in C++</span></span><br><span class="line"><span class="comment">// Algorithm: template&lt;typename T&gt; void lock( T&amp; t, F f ) &#123; lock_guard hold(t); f(); &#125;</span></span><br><span class="line">lock( mut_x, [&amp;]&#123;</span><br><span class="line">    ... use x ...</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>Get familiar with lambdas. You’ll use them a lot, and not just in C++ – they are already widely available and pervasively used in several popular mainstream languages. A good place to start is my talk <a target="_blank" rel="noopener" href="https://herbsutter.com/2010/10/30/pdc-languages-panel-andshortened-lambdas-talk/">Lambdas, Lambdas Everywhere</a> at PDC 2010.</p>
<h3 id="Move-amp-amp"><a href="#Move-amp-amp" class="headerlink" title="Move / &amp;&amp;"></a>Move / &amp;&amp;</h3><p>Move is best thought of as an optimization of copy, though it also enables other things like perfect forwarding.</p>
<p>Move semantics change the way we design our APIs. We’ll be designing for return by value a lot more often.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// C++98: alternatives to avoid copying</span></span><br><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;* <span class="title">make_big_vector</span><span class="params">()</span></span>; <span class="comment">// option 1: return by pointer: no copy, but don&#x27;t forget to delete</span></span><br><span class="line">:::</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;* result = make_big_vector();</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">make_big_vector</span><span class="params">( <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; out )</span></span>; <span class="comment">// option 2: pass out by reference: no copy, but caller needs a named object</span></span><br><span class="line">:::</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; result;</span><br><span class="line">make_big_vector( result );</span><br><span class="line"> </span><br><span class="line"><span class="comment">// C++11: move</span></span><br><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">make_big_vector</span><span class="params">()</span></span>; <span class="comment">// usually sufficient for &#x27;callee-allocated out&#x27; situations</span></span><br><span class="line">:::</span><br><span class="line"><span class="keyword">auto</span> result = make_big_vector(); <span class="comment">// guaranteed not to copy the vector</span></span><br></pre></td></tr></table></figure>

<p>Enable move semantics for your type when you can do something more efficient than copy.</p>
<h3 id="Uniform-Initialization-and-Initializer-Lists"><a href="#Uniform-Initialization-and-Initializer-Lists" class="headerlink" title="Uniform Initialization and Initializer Lists"></a>Uniform Initialization and Initializer Lists</h3><p>What hasn’t changed: When initializing a local variable whose type is non-POD or auto, continue using the familiar = syntax without extra { } braces.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// C++98 or C++11</span></span><br><span class="line"><span class="keyword">int</span> a = <span class="number">42</span>;        <span class="comment">// still fine, as always</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">// C++ 11</span></span><br><span class="line"><span class="keyword">auto</span> x = begin(v); <span class="comment">// no narrowing or non-initialization is possible</span></span><br></pre></td></tr></table></figure>

<p>In other cases, including especially everywhere that you would have used ( ) parentheses when constructing an object, prefer using { } braces instead. Using braces avoids several potential problems: you can’t accidentally get narrowing conversions (e.g., float to int), you won’t occasionally accidentally have uninitialized POD member variables or arrays, and you’ll avoid the occasional C++98 surprise that your code compiles but actually declares a function rather than a variable because of a declaration ambiguity in C++’s grammar – what Scott Meyers famously calls “C++’s most vexing parse.” There’s nothing vexing about the new style.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// C++98</span></span><br><span class="line"><span class="function">rectangle       <span class="title">w</span><span class="params">( origin(), extents() )</span></span>;   <span class="comment">// oops, declares a function, if origin and extents are types</span></span><br><span class="line"><span class="function"><span class="built_in">complex</span>&lt;<span class="keyword">double</span>&gt; <span class="title">c</span><span class="params">( <span class="number">2.71828</span>, <span class="number">3.14159</span> )</span></span>;</span><br><span class="line"><span class="keyword">int</span>             a[] = &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span> &#125;;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;     v;</span><br><span class="line"><span class="keyword">for</span>( <span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">4</span>; ++i ) v.push_back(i);</span><br><span class="line"> </span><br><span class="line"><span class="comment">// C++11</span></span><br><span class="line">rectangle       w   &#123; origin(), extents() &#125;;</span><br><span class="line"><span class="built_in">complex</span>&lt;<span class="keyword">double</span>&gt; c   &#123; <span class="number">2.71828</span>, <span class="number">3.14159</span> &#125;;</span><br><span class="line"><span class="keyword">int</span>             a[] &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span> &#125;;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;     v   &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span> &#125;;</span><br></pre></td></tr></table></figure>

<p>The new { } syntax works pretty much everywhere:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// C++98</span></span><br><span class="line">X::X( <span class="comment">/*...*/</span> ) : mem1(init1), mem2(init2, init3) &#123; <span class="comment">/*...*/</span> &#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// C++11</span></span><br><span class="line">X::X( <span class="comment">/*...*/</span> ) : mem1&#123;init1&#125;, mem2&#123;init2, init3&#125; &#123; <span class="comment">/*...*/</span> &#125;</span><br></pre></td></tr></table></figure>

<p>Finally, sometimes it’s just convenient to pass function arguments without a type-named temporary:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">draw_rect</span><span class="params">( rectangle )</span></span>;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// C++98</span></span><br><span class="line">draw_rect( rectangle( myobj.origin, selection.extents ) );</span><br><span class="line"> </span><br><span class="line"><span class="comment">// C++11</span></span><br><span class="line">draw_rect( &#123; myobj.origin, selection.extents &#125; );</span><br></pre></td></tr></table></figure>

<p>The only place where I prefer not to write the braces is on simple initialization of a non-POD variable, like <em>auto x = begin(v);</em> , where it would make the code needlessly ugly because I know it’s a class type, so I know I don’t need to worry about accidental narrowing conversions, and modern compilers already routinely perform the optimization to elide the extra copy (or the extra move, if the type is move-enabled).</p>
<h3 id="And-More"><a href="#And-More" class="headerlink" title="And More"></a>And More</h3><p>There’s more to modern C++. <a target="_blank" rel="noopener" href="http://www2.research.att.com/~bs/C++0xFAQ.html">Much more.</a> And in the future I plan to write more in-depth pieces about these and other features of C++11 we’ll get to know and love.</p>
<p>But for now, this is the list of must-know features. These features form the core that defines modern C++ style, that make C++ code look and perform the way it does, that you’ll see used pervasively in nearly every piece of modern code you’ll see or write… and that make modern C++ the clean, and safe, and fast language that our industry will continue relying on heavily for years to come.</p>
<h3 id="Major-Change-History"><a href="#Major-Change-History" class="headerlink" title="Major Change History"></a>Major Change History</h3><p>2011-10-30: Added C# lock example to lambdas. Reordered smart pointers to introduce unique_ptr first.</p>
<p>2011-11-01: Added uniform initialization.</p>

    </div>

    
    
    
        

<div>
<ul class="post-copyright">
  <li class="post-copyright-author">
    <strong>本文作者： </strong>byGeek
  </li>
  <li class="post-copyright-link">
    <strong>本文链接：</strong>
    <a href="https://bygeek.cn/2018/12/04/new-features-in-cpp-11/" title="C++ 11带来的新特性">https://bygeek.cn/2018/12/04/new-features-in-cpp-11/</a>
  </li>
  <li class="post-copyright-license">
    <strong>版权声明： </strong>本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" rel="noopener" target="_blank"><i class="fab fa-fw fa-creative-commons"></i>BY-NC-SA</a> 许可协议。转载请注明出处！
  </li>
</ul>
</div>


      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/c/" rel="tag"># c++</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2018/11/23/bitwise-copy-vs-memberwise-copy/" rel="prev" title="bitwise copy vs memberwise copy">
      <i class="fa fa-chevron-left"></i> bitwise copy vs memberwise copy
    </a></div>
      <div class="post-nav-item">
    <a href="/2018/12/04/smart-pointer-in-c-plus-plus/" rel="next" title="C++ 中的智能指针">
      C++ 中的智能指针 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-3"><a class="nav-link" href="#auto"><span class="nav-number">1.</span> <span class="nav-text">auto</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Smart-pointers-No-delete"><span class="nav-number">2.</span> <span class="nav-text">Smart pointers: No delete</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#nullptr"><span class="nav-number">3.</span> <span class="nav-text">nullptr</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Range-for"><span class="nav-number">4.</span> <span class="nav-text">Range for</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Nonmember-begin-and-end"><span class="nav-number">5.</span> <span class="nav-text">Nonmember begin and end</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Lambda-Functions-and-Algorithms"><span class="nav-number">6.</span> <span class="nav-text">Lambda Functions and Algorithms</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Move-amp-amp"><span class="nav-number">7.</span> <span class="nav-text">Move &#x2F; &amp;&amp;</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Uniform-Initialization-and-Initializer-Lists"><span class="nav-number">8.</span> <span class="nav-text">Uniform Initialization and Initializer Lists</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#And-More"><span class="nav-number">9.</span> <span class="nav-text">And More</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Major-Change-History"><span class="nav-number">10.</span> <span class="nav-text">Major Change History</span></a></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="byGeek"
      src="/uploads/avatar.jpg">
  <p class="site-author-name" itemprop="name">byGeek</p>
  <div class="site-description" itemprop="description">Never too late to lose weight!!!</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">70</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">7</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">45</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/byGeek" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;byGeek" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:byyangatchina@live.cn" title="E-Mail → mailto:byyangatchina@live.cn" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
  </div>



      </div>
        <div class="back-to-top motion-element">
          <i class="fa fa-arrow-up"></i>
          <span>0%</span>
        </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 2017 – 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">byGeek</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://mist.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Mist</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  




  
<script src="/js/local-search.js"></script>













  

  

</body>
</html>
