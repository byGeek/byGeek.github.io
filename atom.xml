<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>bygeek&#39;s Playground</title>
  
  
  <link href="https://bygeek.cn/atom.xml" rel="self"/>
  
  <link href="https://bygeek.cn/"/>
  <updated>2021-05-30T13:08:49.812Z</updated>
  <id>https://bygeek.cn/</id>
  
  <author>
    <name>byGeek</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>家庭影院折腾入门</title>
    <link href="https://bygeek.cn/2021/05/27/build-your-own-media-server/"/>
    <id>https://bygeek.cn/2021/05/27/build-your-own-media-server/</id>
    <published>2021-05-27T13:20:42.000Z</published>
    <updated>2021-05-30T13:08:49.812Z</updated>
    
    <content type="html"><![CDATA[<p>以前旧笔记本装的黑裙基本上只当下载机和文件共享中心。“斥巨资”组了黑裙之后，总想着多多利用起来。群晖上的套件一路折腾过来，踩了一些坑，也有了一些经验，此博文是为记。</p><span id="more"></span><h2 id="过往历程"><a href="#过往历程" class="headerlink" title="过往历程"></a>过往历程</h2><p>其实我的原始需求很简单：在电视上方便的观看下载的视频。在我的旧笔记本的黑裙基本已经可以满足这个需求了。</p><blockquote><p>trasmission BT下载 -&gt; NAS 共享文件夹 -&gt; 电视NPlayer播放视频</p></blockquote><p>这个方案基本不需要额外投入。直到一次黑五，购入了一个14T的硬盘，由于3.5寸盘无法直接用在笔记本上，只能外挂作为移动硬盘，用当然是可以用，但是旧笔记本USB2.0的速度在局域网动辄百兆千兆来说，简直有点侮辱了这块盘。于是有了装机的打算。</p><p>说到装机，还有一段插曲。当时公司正好有一批淘汰的机架式服务器，50块的价格感觉不要太香！抢购之后发现有两个致命缺点：1) 大，奈何家里小  2)噪音大，开机之后直接芜湖起飞。无奈出掉。又看了蜗牛星际和暴风几款矿渣主机，当时价格已经涨上来了，蜗牛星际黄鱼上基本400左右一套可以拿下，暴风主机大概贵一倍的价格。翻来覆去，最终选择了暴风二期，J3145比J1900还是强一些，而且网上对暴风二期的做工评价也不错。</p><p>于是在不想再次斥巨资的情况下，把14T的硬盘置换为了8T硬盘 + 暴风二期。（后来由于硬盘挖矿兴起，大容量硬盘价格被炒的翻倍，14T盘被我卖飞在涨价前夕，这是后话，含泪不表）</p><p>机器到手自然直接上了黑裙，这里踩了一个大坑。黑裙的版本分两个版本，一个是918版本，一个是3617版本。参考网上的教程，开始直接上918版本，因为据说918版本照片人脸识别功能做的更好。但是引导之后出现主机无法获取IP的情况，折腾两个晚上，无法解决，最终只能换3617，3617版本一切顺利。</p><p>后来才发现918版本的固件对暴风二期机子的螃蟹网卡驱动支持不是很完美，会导致机器IP获取慢的问题（需要3~5分钟才能分配到IP）。后来又发现只有918版本的黑裙才支持GPU硬件解码，当然这又是后话，暂且不表。</p><h2 id="我的需求"><a href="#我的需求" class="headerlink" title="我的需求"></a>我的需求</h2><p>群晖上的影音套件有很多，自带的Video Station，Emby， Jellifin， Plex等等。网上看了一些相关的文章，基本上比较推荐Emby和Plex。</p><p>下面是Emby和Plex两个方案试用下来的对比。</p><table><thead><tr><th>需求</th><th>Emby</th><th>Plex</th></tr></thead><tbody><tr><td>可以外挂字幕</td><td>可以自动挂载字幕</td><td>Plex集成自动搜索字幕</td></tr><tr><td>电视客户端，简单好用</td><td>有相应的Emby Android TV客户端</td><td>无TV客户端，但是可以作为KODI的插件，但是KODI反人类的操作界面…</td></tr><tr><td>自动刮削，生成海报墙</td><td>由于墙的原因，MovieDatabase等一些电影元素据的网站需要科学上网访问，但是Emby有相应的开心版docker镜像集成了代理服务器，但是海报墙效果差强人意，优点是nfo数据和海报数据直接保存在本地文件夹</td><td>Plex真正自动刮削，海报墙效果比Emby强不少</td></tr><tr><td>比较方便的外网访问</td><td>反向代理可解决</td><td>同样反向代理可解决，同时Plex登陆时使用HTTPS登录Plex账号，授权成功之后，自动跳转到自建的Plex服务，也就是说自建Plex服务开启HTTP即可，省去HTTPS申请证书等一套繁琐的操作。</td></tr><tr><td>最好免费</td><td>基本功能免费，Premium功能收费，当然有开心版本可白嫖</td><td>Premium功能收费</td></tr><tr><td>转码可有可无，有最好，不是强需求</td><td>有，需Premium会员</td><td>有且不收费</td></tr></tbody></table><p>这里多吐槽下KODI，不知道是不是电视的原因，KODI电视客户端无法安装插件，在路由器全局下科学上网下也无法work，使我不得不放弃KODI作为电视客户端。</p><p>Emby和Plex使用下来，最终我选择两个方案共存。因为Emby的电视客户端使用体验还不错，所以电视上，我使用Emby 来播放视频。在需要使用电脑的情况下，使用浏览器来访问Plex服务。话不多说，上图！</p><p><img src="/2021/05/27/build-your-own-media-server/plex_movie.png"></p><p><img src="/2021/05/27/build-your-own-media-server/plex_tvshow.png"></p><p><img src="/2021/05/27/build-your-own-media-server/plex_movie_intro.png"></p><p><img src="/2021/05/27/build-your-own-media-server/plex_intro.png"></p><h2 id="外网访问"><a href="#外网访问" class="headerlink" title="外网访问"></a>外网访问</h2><p>这里记录下Plex外网访问的方法。说白了就是内网穿透，这里也有两种方法。</p><ol><li>家里宽带有公网IP。这种情况只需要有一个域名即可。甚至不需要自己的域名，借助一些第三方的服务实现DDNS。比如TP路由器直接就提供了TPLINK的DDNS服务。</li><li>没有公网IP。需要有一台云主机，借助FRP来实现内网穿透。但是由于视频需要对VPS的带宽有一定的要求，国内VPS 带宽一般都比较贵，建议直接上国外的VPS，同样价格下带宽大且可以有“其他用途”。</li></ol><p>家里宽带有公网IP，但是由于公网IP一般都封禁了80,443,8080端口，同时公司出口又只放通了80,443,8080端口，所以我无法直接使用方案1。无奈只能通过nginx+frp方案来实现从公司访问到家里的Plex服务。</p><h3 id="DNS"><a href="#DNS" class="headerlink" title="DNS"></a>DNS</h3><p>在自己域名增加一个A记录，指向VPS IP地址，比如</p><p><code>media.bygeek.cn  -&gt; 123.123.123.123</code></p><h3 id="VPS端"><a href="#VPS端" class="headerlink" title="VPS端"></a>VPS端</h3><ol><li>安装frp，可以直接使用docker image</li></ol><p><code>docker pull snowdreamtech/frpc</code></p><p>通过volume挂载配置文件</p><p><code>docker run --restart=always --network host -d -v /etc/frp/frps.ini:/etc/frp/frps.ini --name frps snowdreamtech/frps</code></p><p>本地的frps.ini 配置示例</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">[common]</span></span><br><span class="line"><span class="attr">bind_addr</span> = <span class="number">0.0</span>.<span class="number">0.0</span></span><br><span class="line"><span class="attr">bind_port</span> = <span class="number">7024</span></span><br><span class="line"><span class="attr">vhost_http_port</span> = <span class="number">18080</span></span><br><span class="line"><span class="comment">#vhost_https_port = 443</span></span><br><span class="line"><span class="attr">dashboard_port</span> = <span class="number">7025</span></span><br><span class="line"><span class="attr">privilege_mode</span> = <span class="literal">true</span></span><br><span class="line"><span class="attr">privilege_token</span> = your_password_here</span><br></pre></td></tr></table></figure><p>vhost_http_port即为frp server监听并进行http转发的端口</p><ol start="2"><li><p>安装nginx</p><p>nginx的/etc/nginx/nginx.conf示例配置</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">        listen       80 default_server;</span><br><span class="line">        listen       [::]:80 default_server;</span><br><span class="line">        server_name  media.bygeek.cn;</span><br><span class="line">        <span class="comment">#root         /usr/share/nginx/html;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># Load configuration files for the default server block.</span></span><br><span class="line">        include /etc/nginx/default.d/*.conf;</span><br><span class="line"></span><br><span class="line">        location / &#123;</span><br><span class="line">          proxy_set_header Host $host;</span><br><span class="line">          proxy_set_header X-Real-IP $remote_addr;</span><br><span class="line">          proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;</span><br><span class="line">          proxy_set_header X-Forwarded-Scheme  $scheme;</span><br><span class="line">          proxy_redirect off;</span><br><span class="line">          proxy_pass http://localhost:18080;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        error_page 404 /404.html;</span><br><span class="line">        <span class="attr">location</span> = /<span class="number">404</span>.html &#123;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        error_page 500 502 503 504 /50x.html;</span><br><span class="line">        <span class="attr">location</span> = /<span class="number">50</span>x.html &#123;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>nginx会在将访问media.bygeek.cn的80端口的服务proxy到本地的18080端口http服务上去。也就是上文的frps。</p><p>注意location block里面的的proxy_set_header 字段，会将media.bygeek.cn这个host 设置为header送给frps。这个很重要，因为frps会根据custom domain来转发。</p></li></ol><h3 id="NAS端"><a href="#NAS端" class="headerlink" title="NAS端"></a>NAS端</h3><p>同样安装docker 版frp，可以ssh到nas上或者直接在群晖docker 套件中搜索<code>snowdreamtech/frpc</code></p><p>frpc的配置文件示例</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">[common]</span></span><br><span class="line"><span class="attr">server_addr</span> = <span class="number">123.123</span>.<span class="number">123.123</span></span><br><span class="line"><span class="attr">server_port</span> = <span class="number">7024</span></span><br><span class="line"><span class="attr">log_level</span> = info</span><br><span class="line"><span class="attr">authenticate_new_work_conns</span> = <span class="literal">true</span></span><br><span class="line"><span class="attr">authenticate_heartbeats</span> = <span class="literal">true</span></span><br><span class="line"><span class="attr">token</span> = your_password_here</span><br><span class="line"></span><br><span class="line"><span class="section">[media]</span></span><br><span class="line"><span class="attr">type</span> = http</span><br><span class="line"><span class="attr">local_ip</span> = <span class="number">127.0</span>.<span class="number">0.1</span></span><br><span class="line"><span class="attr">local_port</span> = <span class="number">32400</span></span><br><span class="line"><span class="attr">custom_domains</span> = media.bygeek.cn</span><br></pre></td></tr></table></figure><p>server_addr是安装frps的服务器的地址，也即你的VPS地址</p><p>token跟frps的privilege_token一致</p><p>custom_domains即是上文DNS增加的记录</p><p>local_port是你nas上Plex服务器的端口</p><h3 id="效果"><a href="#效果" class="headerlink" title="效果"></a>效果</h3><p>配置完成之后，即可在外网通过80端口访问内网的Plex服务了，且登录时通过跳转Plex域名完成授权，无需担心安全问题。</p><p><img src="/2021/05/27/build-your-own-media-server/plex_login.png"></p><p>经过实测，VPS的带宽可以满足自动转码下720p的外网流畅播放。</p><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>由于黑裙3617版本不支持硬件解码，在需要转码的情况下CPU的暂用率很高，如果需要充分发挥暴风二期J3145 的GPU 硬解4K的能力，需要安装918固件。而这，是下一次折腾的故事了。</p>]]></content>
    
    
    <summary type="html">利用NAS打造简单的家庭影院</summary>
    
    
    
    <category term="tutorial" scheme="https://bygeek.cn/categories/tutorial/"/>
    
    
    <category term="nas" scheme="https://bygeek.cn/tags/nas/"/>
    
    <category term="HTPC" scheme="https://bygeek.cn/tags/HTPC/"/>
    
  </entry>
  
  <entry>
    <title>大山</title>
    <link href="https://bygeek.cn/2021/01/10/in-memory-of-dashan/"/>
    <id>https://bygeek.cn/2021/01/10/in-memory-of-dashan/</id>
    <published>2021-01-10T03:37:32.000Z</published>
    <updated>2021-05-30T13:08:49.910Z</updated>
    
    <content type="html"><![CDATA[<p>大山是我捡到的一只泰迪。准确的说，是卷子注意到的。</p><span id="more"></span><h2 id="偶遇"><a href="#偶遇" class="headerlink" title="偶遇"></a>偶遇</h2><p>清明假期，在沿山大道骑车，我在前面，拉开距离后没看到卷子跟上来，回去找的时候她正蹲着注视着蜷在一米一外的狗子。狗子浑身沾满了叶子，明显在外面流浪好几天了，累的都走不动了。看着腿还有点瘸。犹豫了一会，我们把狗子放在自行车篮筐里，取消了接下来的行程，准备去宠物医院给狗子做个检查。</p><p>“既然在沿山达到捡到的，就叫他沿山吧”</p><p>“沿山太正式， 就叫大山吧”</p><h2 id="傻狗"><a href="#傻狗" class="headerlink" title="傻狗"></a>傻狗</h2><p>接大山回家之后，没来得及买狗窝，当时把一件旧衣服铺在框里，刚放下，大山就心领神会的爬上去窝着了。一开始大山与我不熟，天天要赖着卷子，娟子躺沙发，大山必要窝在她腿上。看着它尝试着跳上沙发却不得，眼巴巴的望着你，很难不把它抱在怀里。</p><p><img src="/2021/01/10/in-memory-of-dashan/dashan1.JPG"></p><p>大山睡觉的时候老是咧着嘴，让人觉得滑稽的很，“这傻狗”，让你忍不住去抱他。狗确实是一个忠实的伙伴，当你取得它的信任之后，它便会无条件的相信你，有你的地方，便可以睡的安详。</p><p><img src="/2021/01/10/in-memory-of-dashan/dashan2.JPG"></p><p>养狗之后，自己的生活作息也跟着变了。每天至少要遛狗两次，早上一次，晚上一次。早上啥时候出门取决于大山啥时候叫我。哦，对了，忘了说，由于卷子上门早，没时间遛狗，所以我开始照顾大山，大山也和我熟络了起来。大山粘人，晚上睡觉也想在卧室睡，但是我们还是决定让它在狗窝呆着。于是每天早上大山都会不定时的挠门，并可怜的哼唧吸引我们的注意。有的时候半夜三四点被吵醒，开门的一瞬间，它就顺势钻了进来，趴在床下面。我以为它只是要离我们近点，但是等你在床上躺下之后，它出来趴在床沿上跃跃欲试，你这时如果不制止他，它便像是得到了许可一样，一跃上床。</p><p><img src="/2021/01/10/in-memory-of-dashan/dashan6.JPG"></p><p>“欸呀呀，大山昨天还在小区草丛里钻来钻去的…”</p><p>我只得下床，做出怒目圆睁的样子，小声喝斥它，指着狗窝，让它退去。大山也不得趣，只能乖乖回到客厅，脑袋趴在狗窝沿上，用可怜的眼光瞟着我。我得赶紧多睡一会，等待它早上再一次叫我起床。有的时候，大山实在在磨人，我只能当“陪睡”了。</p><p><img src="/2021/01/10/in-memory-of-dashan/dashan7.JPG"></p><p>每次回家，刚从电梯口出来，就听到大山从次卧飞奔到门口的声音。我家的次卧是靠着连廊的，不知道大山在我们出门的时候，是不是都呆在次卧，以便能第一时间收到我们回家的信号。开门的一瞬间，大山便哇哇的边窜边叫，彷佛在哭诉自己独自在家，无人陪伴的苦水。大山太娇小了，腿又不好，它跳起来才勉强碰到我的膝盖，又被弹回摔到地板上，但是它还是执意再次跳着迎接我回家。我心疼它，顾不上吃晚饭，抱着大山出门遛去了。一出单元楼，大山开心极了，跑跳嗅尿，拽着我往前走。想起刚才的那一幕，也不知道它是想我们了，还是想它的自由了。</p><h2 id="冲突"><a href="#冲突" class="headerlink" title="冲突"></a>冲突</h2><p>后来工作渐渐忙了起来，卷子也是，大山晚上的吵闹，有点顶不住了。同时由于大山跟我越来越熟，慢慢对卷子充满了敌意。它要守护我和它的地盘。而这个地盘，卷子是不能插足的。有一次卷子从旁边经过，要拿个东西，大山呸了一声，作势要咬人的样子，把卷子给吓坏了。难道大山已经只认我为主人，却忘记了当时是卷子把它捡回来的么？</p><p>不得已，我们考虑将大山送养。开始小区沿街店铺的一个老板表示要收养大山，老板看起来不错，就是可能生意比较忙，担心会没多长时间照顾大山，有点犹豫。后来同小区有个人家也表示的收养的意愿，那人上门来看望大山时，没想到大山很快就跟那边男主人熟悉了起来。我也觉得有些宽慰，大山也算是喜欢那个男主人吧。但是好景不长，那家女主人说有点怕狗，后面又将大山送回来了。后面的事情一波三折，我们送给了那个商铺的老板，有几次远远的在商铺门口经过的时候，看到大山被栓在门口，一动不动，彷佛是等着我接它回家。后面我就不敢从商铺前走过了。</p><p>有一次晚上十点多，我听过有只狗子在外面叫了很久。下楼循声而去，果然是大山，它是自己跑到小区里来了，狗绳子被灌木丛给缠住了。当它看到我来救它，彷佛看到了希望一般，拼命想要挣脱绳子的束缚。当晚我把大山抱回家了。后面我就联系老板说自己养了。大山晚上还是太吵了，跟卷子吵了一架，我知道我可能还要继续给大山寻找一个好主人。</p><p>大山最后被隔壁的M市的一个妹子抱走了，她开车过来接的大山。大山被接走的时候，我给他接上狗绳，可能它还觉得是陪它出去玩吧，还是很兴奋。走到上车的时候，我把它抱给了那个妹子，它好像知道了什么，明白了过来，着急的叫我。我不敢看它，只希望车窗赶紧摇上去…</p><h2 id="后来"><a href="#后来" class="headerlink" title="后来"></a>后来</h2><p>后来有一天，在电梯里遇到一个小女孩。</p><p>“你就是住在X楼的吧？”</p><p>“是啊”</p><p>“上次你家的小狗，还是我给你送回去的哩。那小狗上电梯到了我家门口，一直叫，开门之后它又对着电梯一直叫，闹着要做电梯下去呢，那小狗真聪明。”</p><p>“是吗？哈哈，是啊…”</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;大山是我捡到的一只泰迪。准确的说，是卷子注意到的。&lt;/p&gt;</summary>
    
    
    
    
    <category term="notes" scheme="https://bygeek.cn/tags/notes/"/>
    
  </entry>
  
  <entry>
    <title>another normal weekend</title>
    <link href="https://bygeek.cn/2020/07/11/another-normal-day/"/>
    <id>https://bygeek.cn/2020/07/11/another-normal-day/</id>
    <published>2020-07-11T14:34:40.000Z</published>
    <updated>2021-05-30T13:08:49.799Z</updated>
    
    <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">  <script id="hbeData" type="hbeData" data-hmacdigest="c311b2ccefbaabd4b33495fe3b1e79bdaba8e07786ebfee428f02cb1c7c20176">59fd7a6a1f42c434984d9088bceb757958dcfc7bd45b1cf0001644c858799d569eafd51d5093c5ea0d82e358c7a299c009ae74705592c26c030da6eabbcaeb6fe99bc168592f24b35c3f3d5e28572af7644791f2f2c82d166fc1ec3b085aaa2a95af757de6031d258a5f4fda17ab375b78fdb5b87b82d1216dc268fd3aa027c2ee6a2a28725d248aa826b5dc3157650edf3d7b585843af84c3e8afe15f128655392e9edf9acd335e1ea887ba72550881071e24b6540c7194c2bd02a242c6330855f8561569dad891c1aadce4616eb4fcc93f09f8e87f2e6dfe0f95ceaf4b330bece15e559434833e8440ffab0ac334691142c9c264519cfaf54f9d90f9184625548ef26b5e5f01b1b190a1b622a646d1b39e1614faf43e618baac22addba4b7b5b6697ff66a26beb2dbf3fec789d49bd9bfa220bd4d79c6365ec307c6ca2a727fae2fc8803eb75feb60f328d147927a0f76a53adfed64452445a4bd3f30987b0ad23966cf4bef75b2bf91a6412e8900822072a9750f99dd11475d995e0aa3f03f1ea1604e0b00a9f5a50764c50e82ebd50e4121b565e0cc41f162ccffc232580caa02deb4da2b1e9ae99049715dc72b55bfa80702620a3df98899b775fa0f6509411da23b29db671b54cd9dc82d11228cce22bea368ea7dab17b4f7833122c8eaea9c152fdcdd8f3e5ca8f49157422f041f13799a3efcbfe821a0970fb249963fd3c8ccdb040b544d1a2ff30bb2c6fd82c350e42f56c0e22bdaa3e236511808f422e7bc1996616e2d00fe2f93c09057083a8819be6ec1e234264d923399561d540a3758d51775afd339475c53b1af174ae40827460cb38846ce03c6dc0a7c674806d03e73be2f0a49da3d3391f6d4b4d0138b117b1d9bbe79a7ed711509860e6818a3c1d6b30b053eba978fa7d7b24339cc5384c92b9b100681a37910b9d6a4efa07f65cfe9d30a5291a67199603d3a34501314f3a753ed9d3937667347765cbcfb0e42dec6235cc50b1665b776f29d178cd340f64564e55250e8e82323e317e126b10d0089a8ca1b8eee517315714b697a3638ccc1f531e6cd5fba3240cab099ac408296f97556738f6a31010122243885b8b84645ee3ce56325050834751001c83cfa34b926d2396c423384b95a55e651f813c53d285d271ae62f6d6e38f85c62c8d3e32868c9994fda2353ffabd4043eadc3a926136207eeb755b7a2b2f13cdca541849730c96d77a93ff8988af057a975801ca921e623fd06874f4cbd4a41ee2228b1e152d49c6a326788d850bdc7b8b4b2d906f12b8f6bbb0e5c3deeb236b36a263164748e15cdd0ea2319b0f476fdd6b525d660972d572cb268700efbd0f68bc0c5f1c3b880a0be3898dce1244314ac39ada241616338fd057d2c85b28a76d91b056ff2c04d4853dffc7ee8e3517305c4a10a47f104281a5c6ac3d92a6b31d9b9bfd4ec21b6e2948f6d1a9035d406d4cca3ff1a3ccaf6916c8af5b88874b215300f0e757b05b230b04cedaf81e7dc7b155eda64908df298a313bbfd84195d48b810fa7563a745f549a29a2615269f33ef837ec55a865a2ae607aaa2597a9a6f84c7d2dac9ef60eed3790dda4309a59f585b4e9477f4f4d5ac8e4e6ec04ce01417e218914ac5fa4392ec67d3542c2b8ab53d7aad16a4e38644d67bf31d7955c7492c83e735a0a032c793833fae9e0912f98b5686bd452df0025edea2f8dbd523c237088419f0c7f07b00604c744c42994a90154864cd47f61329778046021e33174187884956706f4626a299306e393383d9b1d035896cdf7817a3075212b45843c0042908a6190303a5d4db7115483102bd0493f87b776fce0a74e43a2494c8bc4b7c16de3d22d84bfdd2b1eb0ea2675bc2731eb4cad69ab5e0ad32f7d119bbb2ce8615697d4b348a45675e47929f7db86b3495bcb7fe4cf4e15b53c7473736eddefd16ebe2f75717536e54c3c9cc83663b402dd9281fb3ae9d7f80e93f28d44d833a3a3a9b5427ed42c2adf2e64de913fdfbce0d71bfe1f10cd63a71e5ff7301db54b330b13059b26b739a6e034f21ea2c855a495dabe1a3b3e25595fe2e09b4a5dcbae3b8387498e5b112014b61146979bfef43e7c003e25cb7eafc7cf68e98e32e717d89f074e7f0936fc5d9ec096dada0b5fb3df73efe58cd4b94b47e16a587570746739c8c9d01eb7a9efd5b7fc51583e62dd0acf9b10c6d09e6362dc7686ce49c65ce17e3f29c43e4c830c4ac84f5928c9068891644b1dcf3cb13e7de72594fa3b76daeb8b5bbee5f8f5759893ee1974ac773fab0aaa0f7348a1249449b7df24a44535212b348bea63cab59fa158cfe706b87b1bfaa0be3b270d2ad73e32f87520e811b77b637fe0931dc839d7789b6432c704f429760da63b2c30743926a24c8816f4f3dae0645e60afdafc3d9e9ab53a30eb1b850d73d388b2941f0ea833a11203274e7a5f453fd18373a04bbc062d14cbfbbe7d5ac6964e4c</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-default">      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-default">Hey, password is required here.</span>      </label>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
    
    
    <summary type="html">Here&#39;s something encrypted, password is required to continue reading.</summary>
    
    
    
    <category term="notes" scheme="https://bygeek.cn/categories/notes/"/>
    
    
  </entry>
  
  <entry>
    <title>最后生还者2的玩后感</title>
    <link href="https://bygeek.cn/2020/07/04/Reviews-of-TLUS2/"/>
    <id>https://bygeek.cn/2020/07/04/Reviews-of-TLUS2/</id>
    <published>2020-07-04T11:56:28.000Z</published>
    <updated>2021-05-30T13:08:49.777Z</updated>
    
    <content type="html"><![CDATA[<p>在端午节4天假期中打通了最后生还者2。现在已经过去一周了，闲来无事，写点感受。</p><span id="more"></span><h2 id="开篇"><a href="#开篇" class="headerlink" title="开篇"></a>开篇</h2><p>这是我唯一一款参与预售的游戏了。以前都是等等党。这次多多预售就百亿补贴，咱也不得不对生活低头，用上了多多==</p><p>没记错的话，应该是去年通的最后的生还者1（买PS4的时间比较晚），一代确实是一个不可多得的佳作，艾莉这个小蹄子，就爱她满嘴F word。历经千险万难，仿佛自己就是乔尔，艾莉就是自己的女儿一般。</p><p>三月份的跳票之后，当时网上就有剧透出来了，自己一直忍着没看。到19号发售，一直焦急的等待着卖家发货，到端午节当天下午，终于到货。连续肝了30多个小时，好久没有这么畅快的打游戏了。</p><h2 id="玩法"><a href="#玩法" class="headerlink" title="玩法"></a>玩法</h2><p>TLOUS2整个玩法跟1是差不太多的，包括游戏玩法，武器，狙击手剧情等。我印象深刻的就是两个部分，一个是WLF敌对势力中狗的加入。狗的加入确实令我蛋疼，基本每次遇到WLF，如果有狗的话，第一时间都是先把狗杀了，狗扑上来掉血太多。另外一个是疤脸帮中利用口哨来配合，一旦暗杀他们中的一个成员，其他人迅速寻找出事地点，手残如我，经常没有机动的变换位置，死了很多次。而且个人感觉与疤脸帮的战斗场景比一代中的火萤大很多。我个人在一中潜行居多，2的时候经常被发现，之后只能硬肝（技术菜，不是奖杯党）。</p><h2 id="剧情"><a href="#剧情" class="headerlink" title="剧情"></a>剧情</h2><p>剧情是大家喷的最多的地方，基本可以说是两点，一个是乔尔的死，死的太虐，太轻率。另外一个是结局最后艾莉在最后一刻放下太突然，玩家有点接受不能。</p><p>其实我通关下来，到没有这么强烈的感受。可能我不是太死忠粉。首先在玩到乔尔的死的时候，我也很惊异，一作中秒天秒地的乔尔尽然惨死在高尔夫下。但当时我更多想的是编剧在搞什么鬼，我很好奇艾比到底是个什么人，有什么不共戴天之仇。我很着急的想玩下去，看剧情如何发展。</p><p>艾莉线对于我来说，初了玩法上我上述说的两点外，其他对于我来说是乏善可陈的：在复仇的道路上，杀杀人，杀杀感染者，OVER。可能我是一个不太对开放世界感冒的低端玩家，在西雅图那张可以探索的地图上，我就拿了该拿的东西之后，就没有继续探索了。最后西雅图第三天，来到剧院，艾比拿着枪抵着艾莉的头。剧情切换到艾比线。</p><p>艾比线，我一开始是比较抵触的，一方面是艾比这个人物形象，与艾莉反差太大，强壮如牛，个人感觉丝毫没有美感，而且太残暴（虐杀乔尔）。后来才知道原来艾比是一代中火萤组织医生的女儿，心里慢慢理解的艾比。但是艾比反复冒着生命危险去就勒夫两人，感觉和前面艾比人设反差还是太大。到最后我真的想快点打完艾比的剧情，看在剧院和艾莉会发生什么。顺便说下，艾比在医院地下车库和鼠王的BOSS站，紧张刺激的氛围营造还是很成功的。</p><p>回到剧院那场戏，我以为艾比和艾莉对峙的时候，我会操纵艾莉。但是，竟然，我操作的尽然是艾比！操作艾比去狂揍艾莉！这太让我接受不能了。QTE的时候，默默的按键速度慢了下来。</p><p>第二点玩家喷的比价狠的是游戏最后没有给玩家选择，只能放走艾比。</p><p>先不说为何汤米为何在艾莉和蒂娜快乐的生活在小农场里，并育有一女的情况下神经质的要艾莉去复仇。剧情告诉我们的是艾莉在农场的生活并不那么快乐，一直在夜里梦到乔尔的惨死。所以最后又走上了复仇的道路。</p><p>这点其实对于当时正在玩游戏的我来说，似乎我已经潜意识的感觉艾莉怎么这么不懂事，艾比已经放走你两次，你还不能放下心中的仇恨吗？所以如果游戏最后让我选择是否放艾比一条生路，我还是会选择放的。毕竟作为一个玩家，在经历了艾比线之后，我可以知道艾比也是一个可怜人。</p><p>但是后面仔细想想，我作为玩家，是知道艾比的动机的，但是艾莉是不知道的呀。最后在网上看到了一个解释，我觉得给了我觉得艾莉放走艾比的合理性：艾莉在可以给艾比最后一击的时候，闪回她对乔尔说的，我觉得我这辈子都不会原谅你的，但是我仍然愿意试一试。在那一刻，艾莉想到也许现在的艾比就是当初保护她的乔尔，而勒夫就是当时的自己。</p><h2 id="最感动的地方"><a href="#最感动的地方" class="headerlink" title="最感动的地方"></a>最感动的地方</h2><p>游戏中最感动的地方是回忆的片段中乔尔给艾莉过生日，当他们躺在太空舱，艾莉听着乔尔给好不容易搞到的飞船发射的录音，脸上一脸满足，仿佛跟着飞船，最后畅游在太空。乔尔老父亲和天真可爱的艾莉，彷佛又回到了一作的那种温馨，温馨到让人泪目。</p><p>乔尔真的是以一己之力，对艾莉的爱，对抗着全世界。</p><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>最后生还者2远远不是网络上那些谩骂说的那样低劣。剧情是可以喷，但是也要看到顽皮狗在叙事手法上的创新，比如西雅图三天平行世界的叙事手法等等。同时期待下一部好作品。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;在端午节4天假期中打通了最后生还者2。现在已经过去一周了，闲来无事，写点感受。&lt;/p&gt;</summary>
    
    
    
    <category term="note" scheme="https://bygeek.cn/categories/note/"/>
    
    
    <category term="game" scheme="https://bygeek.cn/tags/game/"/>
    
  </entry>
  
  <entry>
    <title>关于网站改名</title>
    <link href="https://bygeek.cn/2020/02/25/change-website-title/"/>
    <id>https://bygeek.cn/2020/02/25/change-website-title/</id>
    <published>2020-02-25T11:30:41.000Z</published>
    <updated>2021-05-30T13:08:49.872Z</updated>
    
    <content type="html"><![CDATA[<p>今天收到通知，被告知网站title和备案不一致，需要更改，于是在未将服务迁出之前，本网站改名为”萝卜头的日志”…</p><span id="more"></span><img src="/2020/02/25/change-website-title/Big-Brother-1984.jpg" class="">]]></content>
    
    
    <summary type="html">&lt;p&gt;今天收到通知，被告知网站title和备案不一致，需要更改，于是在未将服务迁出之前，本网站改名为”萝卜头的日志”…&lt;/p&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>2020-new-year</title>
    <link href="https://bygeek.cn/2020/01/31/2020-new-year/"/>
    <id>https://bygeek.cn/2020/01/31/2020-new-year/</id>
    <published>2020-01-31T06:02:32.000Z</published>
    <updated>2021-05-30T13:08:49.769Z</updated>
    
    <content type="html"><![CDATA[<p>2019已经过去，2020已经来临，照例写点东西记录下吧。</p><span id="more"></span><p>看到19年当初定的一些计划，我都有点不太好意思，当初立的一些flag好多都没有做到，以至于今天我都不好再定2020的计划了。那就索性改变一下以前的形式吧。</p><h3 id="回望2019"><a href="#回望2019" class="headerlink" title="回望2019"></a>回望2019</h3><p>19年买了房子，开启了“百万负翁”的生活。以前想的是如何去周游世界，怎样去随性所欲，现在想着从每个月的工资扣掉房贷之后，平平凡凡的生活。这个算是好消息吧。虽然有时累的时候觉得不值，但是晚上睡在自己家的床上的时候，那种温暖还是跟以前不一样的。</p><p>19年8月换了份工作，结束了以前养老的工作。感谢现在的公司，在我换行业的时候，愿意给我一个学习的机会。也感谢上一家公司，可以让我有很多可以自我学习提高的机会。说到换工作的事情，跟买房子也有联系，当每个月的工资抵不上每个月的房贷时，让我不得不跳出自己的舒适圈。至于新的公司，到现在为止，有满意也有不满意的地方。经过几个月的工作，遇到了很多能力很强的同事，意识到了很多自己工作上问题，能力上的不足。我想我会努力的。</p><p>19年打脸最严重的就是跑步了。19年跑量不到500公里。在佳明上定的半马计划也搁置了。自从8月准备换工作到新公司上班之后，锻炼的少了，有那段时间忙碌的托辞，但是更重要的是是自己懒了。</p><p>19年倒是玩了好多游戏。看了下2019年play station的游戏游玩时间统计，花了259个小时在游戏上。</p><img src="/2020/01/31/2020-new-year/game_sumary.jpg" class=""><img src="/2020/01/31/2020-new-year/game_time.jpg" class=""><p>总的来说，可能因为上一份工作比较养老，所以花在游戏上的时间也比较多。而且正如PS有支广告说的，游戏是一种比较好的，花钱又比较少的娱乐活动了，哈哈。</p><h3 id="展望2020"><a href="#展望2020" class="headerlink" title="展望2020"></a>展望2020</h3><p>2020，我希望自己更加自信。在工作上，不仅仅是自己努力，需要多向同事学习，工作方式，沟通，如何解决问题，定时复盘。</p><p>我希望能报名一场半程马拉松比赛，半马应该不是问题，但是我想去赛场感受一下，和众多跑者一起奔跑。</p><p>我希望自己多看书，把自己买的书慢慢消化。</p><p>最重要的，希望自己，家人都身体健康，希望2020越来越好！</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;2019已经过去，2020已经来临，照例写点东西记录下吧。&lt;/p&gt;</summary>
    
    
    
    <category term="notes" scheme="https://bygeek.cn/categories/notes/"/>
    
    
  </entry>
  
  <entry>
    <title>My reviews about Red dead redemption 2</title>
    <link href="https://bygeek.cn/2020/01/30/my-review-on-rdr2/"/>
    <id>https://bygeek.cn/2020/01/30/my-review-on-rdr2/</id>
    <published>2020-01-30T13:07:04.000Z</published>
    <updated>2021-05-30T13:08:49.969Z</updated>
    
    <content type="html"><![CDATA[<p>前几天把荒野大镖客2通关了，今天专门找了下游戏中的原声带听了一下，很有感触，正好闲在家中，看看记录点东西吧。</p><span id="more"></span><p>大表哥这个游戏盘买了很久了，记得当时刚发售的时候，看到一些预告和别人试玩的视频片段，心里痒痒。上次去香港的时候本来打算买块盘，看了看新战神还没开坑，就作罢。后来是看到越来越多的报道，说R星七年磨一剑，于是果断买盘（想着以后还可出二手回血）。</p><p>其实大表哥这种题材的游戏还是蛮合我的胃口的。我个人更倾向于写实的游戏。比如一战，二战题材，以前玩的英雄连，COD二战等。我对一些比较科幻，武器很fancy的不是特别感冒。就玩法来说，我比较喜欢一本道的游戏，比如战神系列，神海系列，对开放世界比较无感，但是塞尔达荒野之息例外。当我玩完大表哥第一章的时候，还是很震撼的。但是到了第二章的时候，发现游戏节奏有点慢，大部分时间都是在骑马跑路，热情大减，于是弃坑了。</p><p>时隔一年，快到春节假期，游戏荒了，趁着周末，拿出大表哥盘，花了两个小时将光盘载入到PS4中。发现战斗系统都生疏了。依旧是骑马跑路，但是随着主线任务的推进，慢慢沉浸到了亚瑟摩根的西部世界中。下面说说在游戏中我印象比较深刻的人。</p><h3 id="亚瑟摩根"><a href="#亚瑟摩根" class="headerlink" title="亚瑟摩根"></a>亚瑟摩根</h3><p>亚瑟12岁被Dutch救了之后，跟随Dutch20多年，脏活苦活，出生入死。他对Dutch是很敬仰的，不管现在的情况多么穷困潦倒，坚定的相信Dutch可以work out a plan。中间被奥觉斯科帮派抓住，折磨，也丝毫没有透露出帮派的信息。每次Dutch计划失败，让大家深陷险境时，亚瑟都是去解决问题的那个人， 对Dutch无条件的信任。即使亚瑟最后发现Dutch是个不折不扣的利己主义者，对自己见死不救，还是希望Dutch可以回心转意。最终那一幕，亚瑟，麦卡，Dutch三人对质，此时的亚瑟已是濒死之人，”I did my best, I did”。不知道Dutch听到这些话是什么感受。</p><h3 id="沙迪艾德勒"><a href="#沙迪艾德勒" class="headerlink" title="沙迪艾德勒"></a>沙迪艾德勒</h3><p>沙迪是里面我最喜欢的一个女角色了。从被奥觉斯科帮派杀了丈夫，被Dutch就下，一直在皮尔逊的厨房打下手，但是她注定是个gunslinger！跟亚瑟出征，巾帼不让须眉。后期更是带领帮派藏身沼泽地，和亚瑟一起突破平克顿侦探的围剿。她应该是价值观最和亚瑟和的来的吧。有勇有谋，率性爽快。最后和马斯顿上雪山，杀迈卡，中枪之后，马斯顿说， “You are dying”, 沙迪果断说，“No, I ain’t! I ain’t‘”。最后反杀迈卡。沙迪是一个很要强的女性，最后成为一个赏金猎人我觉得是对她来说不失为一个很好的结局。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;前几天把荒野大镖客2通关了，今天专门找了下游戏中的原声带听了一下，很有感触，正好闲在家中，看看记录点东西吧。&lt;/p&gt;</summary>
    
    
    
    <category term="notes" scheme="https://bygeek.cn/categories/notes/"/>
    
    
    <category term="games" scheme="https://bygeek.cn/tags/games/"/>
    
  </entry>
  
  <entry>
    <title>记一次修改联通光猫为桥接模式的经历</title>
    <link href="https://bygeek.cn/2019/08/18/Change-Optical-modem-to-bridge-mode/"/>
    <id>https://bygeek.cn/2019/08/18/Change-Optical-modem-to-bridge-mode/</id>
    <published>2019-08-18T01:38:23.000Z</published>
    <updated>2021-05-30T13:08:49.774Z</updated>
    
    <content type="html"><![CDATA[<p>自从搬家换了宽带移机之后，本来群晖的外网访问就失效了。因为前段时间一直都比较忙，一直没好好解决这个问题。今天终于得闲，把这个问题整好了。以下是我的折腾记录。</p><span id="more"></span><h3 id="公网IP被取消？"><a href="#公网IP被取消？" class="headerlink" title="公网IP被取消？"></a>公网IP被取消？</h3><p>黑裙无法外网访问，首先想到的可能是联通这边不给公网IP了。打开ip138查看出口IP地址，是公网IP。当然这个并不能说明问题，因为这个检测到的只是出口IP，可能家里还是内网IP。</p><p>登录路由器管理界面，在远程管理看到路由器的IP地址为192.168的内网地址。内网IP无疑了。于是联系联通客服，质问为何移机之后的宽带取消了公网IP。一个工作日客服人员答复家里的宽带公网IP并未取消。</p><h3 id="无法ping通"><a href="#无法ping通" class="headerlink" title="无法ping通"></a>无法ping通</h3><p>其实确认有公网IP之后，路由器获取的又是内网地址，如果对网络拓扑和组网有简单的了解之后，已经可以确定可能是光猫的问题了，但是好久不搞这些东西，我已经把计算机网络的一些东西忘了差不多了。真是惭愧。</p><p>言归正传，当时我的想法是，既然我还是有公网IP，那么我试着ping下试试。使用我在腾讯云和GCP上的VPS对家里公网IP进行ping操作，无法ping通，100% package loss。有可能是封禁了ICMP response？</p><p>我又想到可以使用端口扫描工具，对该IP进行端口扫描，看是不是端口被封禁的问题。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nmap -Pn ip_addr</span><br></pre></td></tr></table></figure><p>找不到open的端口。端口都被封了？</p><h3 id="在群晖设置router-端口转发找到问题"><a href="#在群晖设置router-端口转发找到问题" class="headerlink" title="在群晖设置router 端口转发找到问题"></a>在群晖设置router 端口转发找到问题</h3><p>走投无路的情况下，通过内网，我打开群晖的external access的问题。在重新配置router 端口转发的时候，群晖自检网络时抛出了一个warning：网络里存在多个路由，需要将接入设置为桥接模式。</p><img src="/2019/08/18/Change-Optical-modem-to-bridge-mode/set_up_router.png" class=""><p>感觉找到了一个突破口。我马上找到光猫，开启无线功能，然后连上光猫的无线网之后，登录到web界面。但是发现由于是user用户，找不到修改光猫工作为桥接模式的设置。于是，在google上搜索“光猫 桥接”，找到了简书上的一篇文章： <a href="https://www.jianshu.com/p/0211c56c4945">电信光猫桥接模式的设置</a>。这篇文章也是碰到了外网访问的问题。修改光猫为桥接模式，必须要拿到管理员账户。那怎么搞到光猫的控制台密码呢？</p><h3 id="要到光猫管理员密码"><a href="#要到光猫管理员密码" class="headerlink" title="要到光猫管理员密码"></a>要到光猫管理员密码</h3><p>我直接在google上搜索的光猫的型号：吉比特TEWA 800G。找到一个知乎相关的问题：<a href="https://www.zhihu.com/question/316754462">吉比特TEWA 800G的管理员登录地址是什么？</a>。这个问题虽然没有人回答，但是在问题的描述中我知道了管理员登录的网址。这个光猫的登录界面还做的一个鸡贼的处理：当直接输入光猫的登录地址192.168.1.1时，只能看到普通用户登录的选项，没有管理员账户的登录选项。正好这个知乎问题上说明管理员的登录地址时: <code>192.168.1.1/cu.html</code>。</p><p>接下来就差密码了，我倒是想搜索相关的“破解”方法，不过本着试一试的想法，我直接打电话给装宽带小哥，询问他光猫的管理员的密码之后，没想到宽带小哥直接告诉了我！</p><p>使用管理员密码登录之后，我直接在光猫的快速设置向导中，将路由模式修改为桥接模式。然后在自己的路由器上使用PPPoE拨号。但是无法成功，提示没有连接到互联网。怎么回事呢？</p><h3 id="要到vlan-id"><a href="#要到vlan-id" class="headerlink" title="要到vlan id"></a>要到vlan id</h3><p>我重新看了简书上的<a href="https://www.jianshu.com/p/0211c56c4945">这篇文章</a>，里面说道改成桥接模式之后，需要修改VLAN ID，这个VLAN ID是原来路由模式的VLAN ID。再确认了一下我自家光猫的配合，没有问题，但是就是无法成功拨号。</p><p>无奈之下我再次拨打了宽带小哥的电话。小哥说让我加钱，他上门服务。我说别了吧，我自己弄就好了，不用上门，我请教你几个问题。没想到小哥也同意了。我加了小哥微信，把光猫的VLAN配置发他看了。他询问了我光猫上的一个参数之后，告诉我VLAN ID（这个VLAN ID并不是路由模式的VLAN ID），同时他说需要他在那边“操作一下”。</p><p>看来这个VLAN ID并不是像简书上的文章说的那样，而且需要宽带人员的操作（好像是要解绑什么东西？）。所以遇到问题需要按照实际情况进行分析。</p><p>我填入小哥说的VLAN ID之后，拨号成功！</p><h3 id="外网成功访问"><a href="#外网成功访问" class="headerlink" title="外网成功访问"></a>外网成功访问</h3><p>打开路由器的管理界面，在远程访问中可以看到路由器的IP不再是192.168了，而是公网IP。</p><p>然后在群晖上执行下DDNS脚本，终于搞定了外网访问的问题！</p><h3 id="桥接与VLAN"><a href="#桥接与VLAN" class="headerlink" title="桥接与VLAN"></a>桥接与VLAN</h3><p>其实这件事情很小，而且起初确认公网IP没有取消，路由器获取的是内网IP的时候，当时就应该可以判断是光猫的问题，但是由于还是一些组网知识都忘了，所以走了一些弯路。</p><p>下面在这里贴一下这期间碰到的知识点。</p><blockquote><p>Q: [What’s the difference between a bridge and a switch?(<a href="https://serverfault.com/questions/78184/whats-the-difference-between-a-bridge-and-a-switch">https://serverfault.com/questions/78184/whats-the-difference-between-a-bridge-and-a-switch</a>)</p><p>An ethernet switch is a multiport ethernet bridge. A bridge is a device that splits collision domains but not broadcast domains. A switch is simply a bridge with lots of ports. Other examples of bridges are wireless access points and dual speed hubs. </p></blockquote><blockquote><p>A <strong>virtual LAN</strong> (<strong>VLAN</strong>) is any <a href="https://en.wikipedia.org/wiki/Broadcast_domain">broadcast domain</a> that is <a href="https://en.wikipedia.org/wiki/Network_segmentation">partitioned</a> and isolated in a <a href="https://en.wikipedia.org/wiki/Computer_network">computer network</a> at the <a href="https://en.wikipedia.org/wiki/Data_link_layer">data link layer</a> (<a href="https://en.wikipedia.org/wiki/OSI_model#Layer_2:_Data_Link_Layer">OSI layer 2</a>).[<a href="https://en.wikipedia.org/wiki/Virtual_LAN#cite_note-1">1]</a>[<a href="https://en.wikipedia.org/wiki/Virtual_LAN#cite_note-802.1Q_1.4-2">2]</a> <em>LAN</em> is the abbreviation for <em>local area network</em> and in this context <em>virtual</em> refers to a physical object recreated and altered by additional logic. VLANs work by applying tags to network frames and handling these tags in networking systems – creating the appearance and functionality of <a href="https://en.wikipedia.org/wiki/Network_traffic">network traffic</a> that is physically on a single network but acts as if it is split between separate networks. In this way, VLANs can keep network applications separate despite being connected to the same physical network, and without requiring multiple sets of cabling and networking devices to be deployed.</p></blockquote>]]></content>
    
    
    <summary type="html">&lt;p&gt;自从搬家换了宽带移机之后，本来群晖的外网访问就失效了。因为前段时间一直都比较忙，一直没好好解决这个问题。今天终于得闲，把这个问题整好了。以下是我的折腾记录。&lt;/p&gt;</summary>
    
    
    
    <category term="notes" scheme="https://bygeek.cn/categories/notes/"/>
    
    
    <category term="geek" scheme="https://bygeek.cn/tags/geek/"/>
    
  </entry>
  
  <entry>
    <title>ios 13 beta降级到ios 12.3</title>
    <link href="https://bygeek.cn/2019/07/13/downgrade-ios-13-to-ios-12-3/"/>
    <id>https://bygeek.cn/2019/07/13/downgrade-ios-13-to-ios-12-3/</id>
    <published>2019-07-13T15:22:46.000Z</published>
    <updated>2021-05-30T13:08:49.906Z</updated>
    
    <content type="html"><![CDATA[<p>今天手贱把手机的IPhone 6s升级到ios public beta3。谁想到发热严重，app时不时闪退，必须重启才有效。不得已要要降级。本文就当自己今天的作死记录做个小记吧。</p><span id="more"></span><h3 id="起因"><a href="#起因" class="headerlink" title="起因"></a>起因</h3><p>我一直时不想当苹果的小白鼠的。Beta在软件上的含义不言而喻。但是实在是不能忍受在IOS 12.3.1短信拦截失效bug又一次复现！国内的垃圾短信太猖獗，我一直是用的“短信拦截”这个APP来拦截垃圾短信，好像是花了6块钱买的吧。我在IOS上使用的收费软件不多。但是升级到IOS 12.3.1版本之后，短信拦截失效了。我还以为是APP出现了问题，后来下载了另一款“熊猫吃短信”发现也无法拦截垃圾短信。在该APP的描述中才知道是IOS系统的bug导致短信无法拦截。</p><p>这个问题以前也出现过，本来拦截正常使用的情况下，在升级某个小版本的正式包之后，出现问题。现在果真BUG OS也越来越坐实了。后来在V2EX论坛上了解到在IOS13以及修正了这个BUG。于是乎，我在使用Itunes备份了数据之后，开启了升级之路。</p><h3 id="IOS-13-PB-BETA-2"><a href="#IOS-13-PB-BETA-2" class="headerlink" title="IOS 13 PB BETA 2"></a>IOS 13 PB BETA 2</h3><p>升级IOS 13 公测版2之后，系统发热严重，我想这可能是刚升级完系统，可能是正常现象，可能多重启几次就能“放凉”。没想到一重启之后，打开应用全部闪退。不得不再次重启，才恢复正常。</p><p>简单体验了下IOS 13，特别是Apple提到的Dark mode，有点新鲜感。Photos界面也重新设计了。短信界面好像变的更拟物化设计了。短信拦截也恢复正常了。但是发热严重。随便打开哪个APP，一会时间，手机就变的好烫，掉电量惊人。上午9点出门，下午3点就没电了，而且中间还开启了省电模式。</p><p>掉电这个还能忍，就是异常发热和APP偶尔闪退忍不了。没办法，只好选择降级。但是，数据咋办？</p><h3 id="降级"><a href="#降级" class="headerlink" title="降级"></a>降级</h3><p>降级一般都是要刷机，而刷机一般都是要抹除数据。幸好在油管上找到降级无损数据的方法。谢天谢地，否则折腾到明天也折腾不完了。</p><p>油管视频：<a href="https://www.youtube.com/watch?v=Ph5MGBeClv8">How to Downgrade iOS 13 to iOS 12! (Without Losing Data)</a></p><p>看视频应该很简单：</p><ol><li>在<a href="https://ipsw.me/">ipsw.me</a>上下载对应的固件，我是下载的IOS 12.3版本，因为12.3.1有短信无法拦截的版本，索性直接降级到12.3版本。幸好苹果还没有关闭12.3的激活通道。</li><li>使用Itunes备份数据。注意请先升级到itunes的最新版本再备份。</li><li>恢复数据。在恢复过程中出现一次白苹果。卡在苹果logo，无进度条显示。以为变砖了，在苹果官网找到进recovery方法，但是幸好在插上数据线之后，iTunes提示升级新版本即可。但是就是这个升级操作，导致后面“虚惊一场”！</li></ol><p>一开始itunes自动升级失败，所以我没在意，直接使用的老版本的itunes做backup，然后再restore的时候itunes提示要升级到最新版才可以restore到12.3。但是在我升级完itunes之后，发现新版的itunes无法找到我的backup记录了！当时感觉心都凉了，数据都没了。后来在查看info.plist文件，在文件结尾有itunes的版本号，怀疑是不是iTunes的版本差异，导致新版的iTunes无法识别使用旧版iTunes backup的文件。所以我在卸载新版itunes，并安装对应的旧版本的时候，终于恢复数据成功。</p><p>在卸载新版iTunes的时候，现在微软也慢慢使用Microsoft store作统一的软件分发平台了。新版的itunes就是在MS Store上下载。在卸载的时候没有在control panel中的卸载中找到itunes，后来是直接在windows上搜索iTunes，右键直接uninstall。</p><p>安装完旧版本的iTunes时，启动会发现提示一个文件由新版本的iTunes创建，导致无法启动成功。解决方法时直接将该文件删除即可。启动iTunes时，会自动创建该文件。安装成功之后，可以找到先前备份的数据。10G的恢复文件大概花了半个小时才恢复成功。</p><h3 id="降级之后"><a href="#降级之后" class="headerlink" title="降级之后"></a>降级之后</h3><p>降级之后，别完了卸载旧的iTunes，重新安装新版iTunes。并且充分备份下数据。最后在iCloud中也备份一份数据。</p><p>最重要的是，千万不要再手贱升级啦！</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;今天手贱把手机的IPhone 6s升级到ios public beta3。谁想到发热严重，app时不时闪退，必须重启才有效。不得已要要降级。本文就当自己今天的作死记录做个小记吧。&lt;/p&gt;</summary>
    
    
    
    <category term="notes" scheme="https://bygeek.cn/categories/notes/"/>
    
    
    <category term="apple" scheme="https://bygeek.cn/tags/apple/"/>
    
  </entry>
  
  <entry>
    <title>我与游戏的故事(一)</title>
    <link href="https://bygeek.cn/2019/06/03/my-story-with-video-games/"/>
    <id>https://bygeek.cn/2019/06/03/my-story-with-video-games/</id>
    <published>2019-06-03T14:06:26.000Z</published>
    <updated>2021-05-30T13:08:49.970Z</updated>
    
    <content type="html"><![CDATA[<p>买了Play Station已经快两个月了。玩了几款PS4平台的第一方大作之后，是时候来写写自己的感受了。说起买PS4这个经历，其实有点阴差阳错。不过在这之前，我打算先说一下以前我跟游戏的前世今生。</p><span id="more"></span><h3 id="令人怀念的“小霸王”"><a href="#令人怀念的“小霸王”" class="headerlink" title="令人怀念的“小霸王”"></a>令人怀念的“小霸王”</h3><p>作为一枚90后，我小时候接触到的其实是“小霸王”之类的“学习机”，以前并没有红白机之类的概念。可能是中国特殊的国情所致，特别是一些农村的父母，对游戏可是讳莫如深，想正大光明的买游戏机，那几乎是不可能的事。估计也是这个原因，国内的一些厂商将红白机包装为学习机，正好让我有了买“小霸王”的理由。那个时候基本都对父母说是买来“学电脑的”。也确实，当时随机器附带的卡带都是带五笔打字的，我估计应该有很多人对这个场景有印象：一艘艘小船上面是五笔的偏旁部首，只要敲如相应的键就可以将小船击沉。说实话，当时自己还是花了一些时间在“小霸王”上练习五笔打字的，还背诵了偏旁部首的记忆口诀。只可惜，这些打字诀窍最终只停留在了那个学习机上，等我真正接触到电脑，五笔打字早就忘了一干二净了。</p><p>那个时候还是比较痴迷在“小霸王”上的，而且自己还耗费了不少资金在上面。我记得当时一盘“四合一”的卡带要卖8块。那个时候应该大概是2000年左右。要是没记错的话，当时在小学的商店一支雪糕只要5分钱。前前后后应该买了不下20盘卡带。那个时候成绩好，每次基本都是以这个为后盾再加上撒娇，母亲也就顺了我的意。</p><p>想起那段时间，真实觉得很美好。小学放学之后，先把作业写完（那个时候作业应该简单吧，记得每次半个小时就写完了）。然后将“小霸王”接上家里的黑白电视机，拿着卡带在嘴边吹下卡带金手指（似乎这样能防止死机），小心翼翼的摁上去，开机！一个简单的游戏能不亦乐乎的玩上很久。当然了，最后肯定是在母亲一遍遍的催促下最后关了机。</p><p>除了一个人在家里开黑，最大的乐趣就是和村里的小伙伴一起玩了。当时隔壁院子里的一个小伙伴，暂且称之为玲，经常一起玩。印象最深游戏是“热血系列”中的“热血格斗”。这个游戏并不是类似拳皇之类的格斗游戏，而是每局4个人物，你，队友，还有两位对手。你和队友需要在规定时间内击败对手。每一局都是不同的场景，场景还有不同的辅助道具，例如电网，地雷，瀑布等。最后挑战最终的boss——两个带着虎头的对手。首先这个游戏带有一定的随机性（也可能是当时玩的日文版本，看不明白吧），因为每次无法直接选择游戏人物的“招数”，而是通过为人物选择名字，血型，然后系统会分配一个人物给你。可能人物可以有“连环拳”，或者“连环腿”，或者“地雷滚”。其次“热血格斗”场景比较多，每一局的场景设计都很有意思。比如电网那关，当时经常干的伎俩就是讲击倒后的NPC直接扔到电网里，给其造成二次伤害，而且由于击倒后到再起来，有一定的时间差，把握好这个时间差可以无限扔到电网里。还有地雷那关，故意引诱NPC去踩雷，但有的时候被NPC背摔自己去中雷了，哈哈。游戏里还可以跟队友“合体”放大招，变成旋风。由于看不懂日文，我和玲经常要去试看那个人物最厉害，后来还总结出一个“规律”：O型血比较“欧”。“殴”在我的家乡话里是有点类似撒泼比较厉害的意思。我们都觉得很形象。于是默默都给人物选择O型血。但也不总是能选择有“连环拳”或者“连环腿”的人物。</p><p>“热血格斗”卡带是玲的，我没有，于是我经常趁着玲妈不在跟玲一起玩。那个时候基本每个放学的下午，都能在玲的房间里昏天黑地的玩一两个小时。有的时候被玲妈发现我们在房间里背着她玩游戏，我只能尬笑着回家，偷偷约定这明天来我家玩。</p><p>学习机我一共买过两台，一台是在一个打着雷的雨天关机之后就无法再开机了。后来仗着自己成绩好，又让我妈给我买了一台新的。这台新的还带了一把“枪”。可以用来玩一个叫“打鸭子”的游戏。只要指着黑白电视机里的鸭子开枪，就可以将其击落。不过终归没有见到支持这种玩法的游戏了，渐渐的这把“枪”也吃灰了。</p><h3 id="街机"><a href="#街机" class="headerlink" title="街机"></a>街机</h3><p>我记得这个“学习机”一直没坏，只是后来上中学之后，当时慢慢迷上了街机。虽然经常是一个币都不买，但是却可以站在旁边看别人玩一天。当时比较火的几款游戏是恐龙岛和三国战记。看着别人摇杆拍的左来右去，按键拍的啪啪响，感觉自己也浑身充满了”干劲“。没记错的话，一块钱4个币，对于一些老手来说，可以玩一天了。对于我来说，可能四个币也就撑过一两关吧。输了不续币是要重来的，但即使这样，也乐此不疲。因为街机始终玩的很少。一个是费钱，另外就是家人的反对了。可能是街机厅里环境不是很好，有人经常逃学去玩，而且街机厅在家长的眼里就是游戏厅，好歹小霸王还打个掩护叫学习机呢。我妈很反对我去街机厅。一开始是表哥带我去，有一次被我妈发现了，直接冲到街机厅，把我两拎回来了。”你去玩吧，我看你以后有什么出息。“然后也数落其表哥来，后来表哥再也没带我去了。</p><p>我觉得街机当时对我的吸引力主要有三点吧。第一，相比与再黑白电视机上接上小霸王玩，街机的大彩屏简直就是现在的iPhone对于比诺基亚的功能机带来的震撼一样多。第二，街机满足了一定的社交需求。在家还是一个人玩小霸王的时候居多，有的时候我宁愿再与伙伴再通几局魂斗罗或者沙罗曼蛇，也不愿去玩一些角色扮演的”大型游戏“。可能一些角色扮演的游戏剧情多，但是玩游戏嘛还是需要玩伴才玩的开心。街机就不一样的，为什么即使自己不玩也能再游戏厅里呆一天，就是因为有那个氛围在那。投了多少个币，重生多少次之后，终于干倒了别人没干倒的boss，在别人的围观下，next mission！第三点，街机操作的快感。街机加入的摇杆，带来了一种很爽快的体验。那个时候我经常看别人玩，摇杆拍来拍去，特别是玩拳皇这种特别讲究操作的游戏，结合大大的摇杆和大大的按键，更能体验到那种拳拳到肉的感觉，仿佛你按键用多大力气，就能直接传递到游戏人物的打击中一样。</p><p>上面我说的小霸王上的”大游戏“，不仅仅是价格比普通的4合1的游戏贵好几倍，而且卡带也要更大。我记得有两个游戏，一个是角色扮演游戏（当然当时我还不知道），游戏开始掉到山洞里，然后4个人物，到后期可以给每个人选择不同的职业，拥有不同的技能。遗憾的是后来在一个地方卡关了，一块巨石挡在了王宫，然后就过不去了。当时还能玲一起尝试，最后我们一致认为是游戏的bug，再后来就不了了之了。直到我买了PS4之后，才知道原来这个游戏叫最终幻想。</p><p>还有一个游戏是再我玩了塞尔达荒野之息后（这个游戏真是赞誉再多也不为过），再网上看一些游戏视频，发现了一个FC上的游戏，突然发现我玩过，最后也没通关，原因好像是迷宫太多。这个游戏叫塞尔达！</p><p>未完待续！</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;买了Play Station已经快两个月了。玩了几款PS4平台的第一方大作之后，是时候来写写自己的感受了。说起买PS4这个经历，其实有点阴差阳错。不过在这之前，我打算先说一下以前我跟游戏的前世今生。&lt;/p&gt;</summary>
    
    
    
    <category term="notes" scheme="https://bygeek.cn/categories/notes/"/>
    
    
    <category term="games" scheme="https://bygeek.cn/tags/games/"/>
    
  </entry>
  
  <entry>
    <title>windows 开发遇到的一些权限问题</title>
    <link href="https://bygeek.cn/2019/05/15/it-is-all-about-security/"/>
    <id>https://bygeek.cn/2019/05/15/it-is-all-about-security/</id>
    <published>2019-05-15T02:21:39.000Z</published>
    <updated>2021-05-30T13:08:49.964Z</updated>
    
    <content type="html"><![CDATA[<p>最近碰到一个问题，折腾了很久。因为troubleshooting的过程中沟通不畅（种种原因暂且不表），导致像个无头苍蝇一样debug。最后发现是个windows权限的问题。好了，直接说问题。</p><span id="more"></span><h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><p>问题简化为以下代码，是在windows下使用PIPE来进行进程间通信。首先看下server 端代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;Windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">message</span> &#123;</span></span><br><span class="line"><span class="keyword">int</span> id;</span><br><span class="line"><span class="keyword">char</span> data[<span class="number">8</span>];</span><br><span class="line">&#125; Message;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">HANDLE h = INVALID_HANDLE_VALUE;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span>* pipename = <span class="string">&quot;\\\\.\\pipe\\mypipe&quot;</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> BUFSIZE = <span class="number">1024</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> DEFAULT_TIMEOUT = <span class="number">100</span>;</span><br><span class="line"><span class="keyword">char</span> buf[<span class="number">1024</span>];</span><br><span class="line"></span><br><span class="line">h = CreateNamedPipe(</span><br><span class="line">pipename,</span><br><span class="line">PIPE_ACCESS_DUPLEX,<span class="comment">/*| FILE_FLAG_OVERLAPPED*/</span></span><br><span class="line">PIPE_TYPE_MESSAGE | PIPE_READMODE_MESSAGE,</span><br><span class="line">PIPE_UNLIMITED_INSTANCES,</span><br><span class="line">BUFSIZE,</span><br><span class="line">BUFSIZE,</span><br><span class="line">DEFAULT_TIMEOUT,</span><br><span class="line"><span class="literal">NULL</span></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (h == INVALID_HANDLE_VALUE) &#123;</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (ConnectNamedPipe(h, <span class="literal">NULL</span>)) &#123;</span><br><span class="line">DWORD read = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span> (ReadFile(h, buf, <span class="keyword">sizeof</span>(Message), &amp;read, <span class="literal">NULL</span>)</span><br><span class="line">&amp;&amp; read == <span class="keyword">sizeof</span>(Message)) &#123;</span><br><span class="line">Message* msg = <span class="keyword">reinterpret_cast</span>&lt;Message*&gt;(buf);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;get message from client: id: %d, data: %s\n&quot;</span>, msg-&gt;id, msg-&gt;data);</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;ready to echo back!\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">DWORD written = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span> (WriteFile(h, msg, <span class="keyword">sizeof</span>(Message), &amp;written, <span class="literal">NULL</span>)</span><br><span class="line">&amp;&amp; written == <span class="keyword">sizeof</span>(Message)) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;echo back completed!\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;WriteFile failed: %d\n&quot;</span>, GetLastError());</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;ReadFile failed: %d\n&quot;</span>, GetLastError());</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;ConnectNamedPipe failed: %d\n&quot;</span>, GetLastError());</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">CloseHandle(h);</span><br><span class="line"></span><br><span class="line">getchar();</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码很简单，使用WIN32 API <code>CreateNamedPipe</code>创建一个命名管道，然后等待pipe client来建立连接。收到client的message之后再echo回去。</p><p>再看下client端代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">HANDLE h = INVALID_HANDLE_VALUE;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span>* pipename = <span class="string">&quot;\\\\.\\pipe\\mypipe&quot;</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> BUFSIZE = <span class="number">1024</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> DEFAULT_TIMEOUT = <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line">h = CreateFile(pipename,</span><br><span class="line">GENERIC_READ | GENERIC_WRITE,</span><br><span class="line"><span class="number">0</span>,</span><br><span class="line"><span class="literal">NULL</span>,</span><br><span class="line">OPEN_EXISTING,</span><br><span class="line"><span class="number">0</span>,</span><br><span class="line"><span class="literal">NULL</span></span><br><span class="line">);</span><br><span class="line"><span class="keyword">if</span> (h == INVALID_HANDLE_VALUE) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;open pipe failed: %d\n&quot;</span>, GetLastError());</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Message m = &#123; <span class="number">1</span>, <span class="string">&quot;hello&quot;</span> &#125;;</span><br><span class="line">DWORD written = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span> (WriteFile(h, &amp;m, <span class="keyword">sizeof</span>(Message), &amp;written, <span class="literal">NULL</span>)</span><br><span class="line">&amp;&amp; written == <span class="keyword">sizeof</span>(Message)) &#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;client write pipe finished\n&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> buf[<span class="number">1024</span>];</span><br><span class="line">DWORD read = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span> (ReadFile(h, buf, <span class="keyword">sizeof</span>(Message), &amp;read, <span class="literal">NULL</span>)</span><br><span class="line">&amp;&amp; read == <span class="keyword">sizeof</span>(Message)) &#123;</span><br><span class="line">Message* msg = <span class="keyword">reinterpret_cast</span>&lt;Message*&gt;(buf);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;received message: id: %d, data: %s\n&quot;</span>, msg-&gt;id, msg-&gt;data);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;read pipe failed: %d\n&quot;</span>, GetLastError());</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Write Pipe failed: %d\n&quot;</span>, GetLastError());</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">CloseHandle(h);</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">0</span>);</span><br></pre></td></tr></table></figure><p>client代码也很简单，发起pipe connect，之后发送一个简单的message，然后收到server回复后退出。</p><p>但是在实际的生产环境中，发现client端无法连接到server端。根据GetLastError返回值是5，对应的error message是“Access Deny”。那肯定是权限问题嘛。果然，server端是使用Administrator运行的，而client端只有standard user的权限，因为Windows vista中加入的<a href="https://en.wikipedia.org/wiki/Mandatory_Integrity_Control">Mandatory Integrity Control</a>(强制性完整性控制)，导致low integrity level的对象无法modify或者delete high integrity level的对象。</p><h3 id="什么是Integrity-Level"><a href="#什么是Integrity-Level" class="headerlink" title="什么是Integrity Level"></a>什么是Integrity Level</h3><p><a href="https://docs.microsoft.com/en-us/previous-versions/dotnet/articles/bb625957(v=msdn.10)">MSDN</a>上如是说：</p><blockquote><p>The integrity level is a representation of the trustworthiness of running application processes and objects, such as files created by the application. The integrity mechanism provides the ability for resource managers, such as the file system, to use pre-defined policies that block processes of lower integrity, or lower trustworthiness, from reading or modifying objects of higher integrity. The integrity mechanism allows the Windows security model to enforce new access control restrictions that cannot be defined by granting user or group permissions in access control lists (ACLs).</p></blockquote><p>抛开定义，首先先visualize一下Integrity level。我们使用<a href="https://docs.microsoft.com/en-us/sysinternals/downloads/process-explorer">process explorer</a>工具来查看，如果没有这一栏，可以在View-&gt;Select Columns-&gt;Process Image tab中勾选Integrity level。</p><img src="/2019/05/15/it-is-all-about-security/01_show_integrity_level.png" class=""><p>我们可以看到Integrity level(以下简写为IL)分为几个等级：low, medium, high, system。根据<a href="https://docs.microsoft.com/en-us/windows/desktop/secauthz/mandatory-integrity-control">MSDN</a>:</p><blockquote><p>Windows defines four integrity levels: low, medium, high, and system. Standard users receive medium, elevated users receive high. Processes you start and objects you create receive your integrity level (medium or high) or low if the executable file’s level is low; system services receive system integrity. Objects that lack an integrity label are treated as medium by the operating system; this prevents low-integrity code from modifying unlabeled objects. Additionally, Windows ensures that processes running with a low integrity level cannot obtain access a process which is associated with an app container.</p></blockquote><p>标准用户得到meduim IL，这意味着标准用户启动的程序或创建的内核对象都拥有medium IL，除非在程序或对象中指定其为low IL。特权用户得到high IL。系统服务得到system IL。任何其他没有声明IL 标签的，系统默认其为medium IL。windows系统会保证低IL的对象无法读写/访问高IL的对象。</p><p>摘录一张《windows via c++》第四章最后一节的图：</p><img src="/2019/05/15/it-is-all-about-security/02_integrity_level_example.png" class=""><blockquote><p>When a piece of code tries to access a kernel object, the system compares the integrity level of the<br>calling process with the integrity level associated to the kernel object. If the latter is higher than the<br>former, modify and delete actions are denied. Notice that this comparison is done before checking<br>ACLs. So, even though the process would have the right privileges to access the resource, the fact<br>that it runs with an integrity level lower than the one required by the resource denies the requested<br>access to the object.</p></blockquote><p>简单来说，就是当访问一个内核对象的时候，系统会比较调用进程的IL和与内核对象关联的IL，如果内核对象关联的IL更高，则无法对其进行修改或者删除操作。一般可以进行读操作。</p><p>所以在上面的demo中，由于pipe server使用的是管理员用户运行的，则其创建的PIPE 内核对象拥有high 级别的IL。pipe client 使用标准用户运行，去访问pipe 内核对象时，由于只有medium 级别的IL，所以发生access deny的错误。</p><p>除了在进程间访问内核对象提供保护之外，IL还用在windows 的用户界面中，用于防止low IL的进程去修改high IL的界面。我们知道，windows提供了SendMessage和PostMessage来在窗口之间发送消息。窗体可以根据收到的消息来更新UI等。当一个low IL的进程通过SendMessage、PostMessage、SendInput发送消息给high IL的窗体时，系统会屏幕掉这类消息， 这个时候SendInput会返回0，并且GetLastError也不会显示出异常。这种机制称为<strong>User Interface Privilege Isolation</strong>（UIPI）。</p><p>这里再多说一句，一些杀毒软件，如360安全卫士会主动拦截SendMessage发出的消息。曾经就遇到过bug排查一天，最后发现是这个问题。</p><p>关于详细内容，可以参考《windows via c++》中第四章的内容，中文书名为《windows 核心编程》。</p><h3 id="什么是UAC"><a href="#什么是UAC" class="headerlink" title="什么是UAC"></a>什么是UAC</h3><h3 id="什么事ACL"><a href="#什么事ACL" class="headerlink" title="什么事ACL"></a>什么事ACL</h3><h3 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h3><ul><li><p><a href="%5Bhttps://docs.microsoft.com/en-us/previous-versions/windows/it-pro/windows-server-2008-R2-and-2008/dd446675(v=ws.10)%5D(https://docs.microsoft.com/en-us/previous-versions/windows/it-pro/windows-server-2008-R2-and-2008/dd446675(v=ws.10))">What’s New in User Account Control</a></p></li><li><p><a href="https://social.technet.microsoft.com/wiki/contents/articles/2275.windows-security-survival-guide.aspx">Windows Security Survival Guide</a></p></li><li><p><a href="https://blogs.technet.microsoft.com/yuridiogenes/2011/04/13/exploring-the-windows-security-survival-guide-integrity/">Exploring the Windows Security Survival Guide – Integrity</a></p></li><li><p><a href="https://docs.microsoft.com/en-us/previous-versions/dotnet/articles/bb625957(v=msdn.10)">What is the Windows Integrity Mechanism?</a></p></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;最近碰到一个问题，折腾了很久。因为troubleshooting的过程中沟通不畅（种种原因暂且不表），导致像个无头苍蝇一样debug。最后发现是个windows权限的问题。好了，直接说问题。&lt;/p&gt;</summary>
    
    
    
    <category term="coding" scheme="https://bygeek.cn/categories/coding/"/>
    
    
    <category term="windows" scheme="https://bygeek.cn/tags/windows/"/>
    
  </entry>
  
  <entry>
    <title>使用DebugView来debug</title>
    <link href="https://bygeek.cn/2019/05/10/use-dbgviewer-to-debug-your-code/"/>
    <id>https://bygeek.cn/2019/05/10/use-dbgviewer-to-debug-your-code/</id>
    <published>2019-05-10T06:43:08.000Z</published>
    <updated>2021-05-30T13:08:50.020Z</updated>
    
    <content type="html"><![CDATA[<p>在windows开发的过程中，经常会碰到这样的问题：我们需要记录一些程序的运行期间的信息（log），但是又不想直接记录成log文件保存在用户磁盘上。一般在develop的过程中，我们会将 一些信息直接输入到console或者visual studio中的Output窗口中，但是一旦release给用户之后，我们无法获取这些信息。</p><p>That’s where DebugView COMES IN!</p><span id="more"></span><h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><p><a href="https://docs.microsoft.com/en-us/sysinternals/downloads/debugview">DebugView</a>原来是sysinternals开发的一系列工具包中的一个，现在早已被MS收购。简单来说，这个工具可以用来显示打印到Debug output windows中的信息。比如使用WIN32 OutputDebugString中的消息在visual studio中可以在output  windows中查看的信息。但是在release build版本中，可以通过DebugView工具查看。</p><blockquote><p><em>DebugView</em> is an application that lets you monitor debug output on your local system, or any computer on the network that you can reach via TCP/IP. It is capable of displaying both kernel-mode and Win32 debug output, so you don’t need a debugger to catch the debug output your applications or device drivers generate, nor do you need to modify your applications or drivers to use non-standard debug output APIs.</p></blockquote><h3 id="DebugView能做的"><a href="#DebugView能做的" class="headerlink" title="DebugView能做的"></a>DebugView能做的</h3><blockquote><p>Under Windows 2000, XP, Server 2003 and Vista <em>DebugView</em> will capture:</p><ul><li>Win32 <strong>OutputDebugString</strong></li><li>Kernel-mode <strong>DbgPrint</strong></li><li>All kernel-mode variants of <strong>DbgPrint</strong> implemented in Windows XP and Server 2003</li></ul><p><em>DebugView</em> also extracts kernel-mode debug output generated before a crash from Window’s 2000/XP crash dump files if <em>DebugView</em> was capturing at the time of the crash.</p></blockquote><p>就是说DebugView可以抓取到程序中的OutputDebugString, DbgPrint等函数调用。在.net中，同样抓取<code>System.Diagnostic.Debug.WriteLine</code>输出的信息。</p><h3 id="基本功能"><a href="#基本功能" class="headerlink" title="基本功能"></a>基本功能</h3><p>使用DebugView很简单，只需要设置下需要capture的类型，如下图只capture win32 调用OutputDebugString的输出，capture events指的是开始/暂停 捕捉。</p><img src="/2019/05/10/use-dbgviewer-to-debug-your-code/01_set_capture_type.png" class=""><h3 id="使用highlight高亮功能"><a href="#使用highlight高亮功能" class="headerlink" title="使用highlight高亮功能"></a>使用highlight高亮功能</h3><p>log一多久容易迷失方向，使用highlight功能，方便查找含有特定字符串的信息。注意是在include中输入通配符，然后在highlight下输入要包含的关键字，如下图。注意，在include中一般直接输入通配符*，如果想只显示包含特定字符的信息，可以输入关键字，多个关键词已；隔开。</p><h3 id="设置最多显示多少条记录"><a href="#设置最多显示多少条记录" class="headerlink" title="设置最多显示多少条记录"></a>设置最多显示多少条记录</h3><p>如下图，这样在GUI中只会显示最新的500条记录。</p><img src="/2019/05/10/use-dbgviewer-to-debug-your-code/03_maximum_record.png" class=""><h3 id="显示PID"><a href="#显示PID" class="headerlink" title="显示PID"></a>显示PID</h3><p>在option中可以设置是否显示进程的PID，如果勾选，则在每一行中都会显示进程的PID。这个功能可以配合highlight高亮功能，用来关注特定进程的log信息。</p><img src="/2019/05/10/use-dbgviewer-to-debug-your-code/04_use_pid.png" class=""><h3 id="查看帮助文档"><a href="#查看帮助文档" class="headerlink" title="查看帮助文档"></a>查看帮助文档</h3><p>以上只是debugview的简单功能的介绍，详细功能使用可以参考下载包里的帮助文件：dbgview.chm。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;在windows开发的过程中，经常会碰到这样的问题：我们需要记录一些程序的运行期间的信息（log），但是又不想直接记录成log文件保存在用户磁盘上。一般在develop的过程中，我们会将 一些信息直接输入到console或者visual studio中的Output窗口中，但是一旦release给用户之后，我们无法获取这些信息。&lt;/p&gt;
&lt;p&gt;That’s where DebugView COMES IN!&lt;/p&gt;</summary>
    
    
    
    <category term="coding" scheme="https://bygeek.cn/categories/coding/"/>
    
    
    <category term="windows" scheme="https://bygeek.cn/tags/windows/"/>
    
  </entry>
  
  <entry>
    <title>2019-new-year</title>
    <link href="https://bygeek.cn/2019/02/11/2019-new-year/"/>
    <id>https://bygeek.cn/2019/02/11/2019-new-year/</id>
    <published>2019-02-11T02:17:25.000Z</published>
    <updated>2021-05-30T13:08:49.769Z</updated>
    
    <content type="html"><![CDATA[<p>今天初七，2019年上班第一天。</p><span id="more"></span><p>今年的计划如下：</p><h3 id="减脂"><a href="#减脂" class="headerlink" title="减脂"></a>减脂</h3><p>体重控制在69kg，全年跑量1000km。我知道这个目标其实很弱鸡，如果不出问题，应该可以很轻松的达成。但贵在坚持。坚持跑步，要对得起18年自己买的跑鞋。注意更加科学的跑步，加强自己的核心力量。</p><h3 id="书单"><a href="#书单" class="headerlink" title="书单"></a>书单</h3><p>专业书：</p><ul><li>Windows via C++</li><li>APUE</li><li>Inside the C++ Object Model</li><li>Effective STL</li><li>COM技术内幕-微软组件模型</li></ul><p>非专业书</p><ul><li>二战全史</li><li>尤瓦尔·赫拉利 三部曲：人类简史（看过了觉得还要重新看一遍），未来简史，今日简史</li><li>Kindle上ISIS的崛起</li><li>中央帝国的财政密码（去年未看完）</li></ul><h3 id="人生大事"><a href="#人生大事" class="headerlink" title="人生大事"></a>人生大事</h3><p>打算今年多关注一些房子的信息，多收集收集资料。</p><h3 id="旅游"><a href="#旅游" class="headerlink" title="旅游"></a>旅游</h3><p>暂定东南亚吧，泰国？或者重庆成都也可以，待西乡计划。</p><h3 id="工作"><a href="#工作" class="headerlink" title="工作"></a>工作</h3><p>希望可以通过慢慢参与到开源社区，贡献自己的力量。</p><h3 id="博客"><a href="#博客" class="headerlink" title="博客"></a>博客</h3><p>关于自己博客的内容，不一定是专业相关的文章，也可以是自己的见闻游记，思考等。</p><p>其他想到在补充吧。</p><p>2019/02/11 于南京</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;今天初七，2019年上班第一天。&lt;/p&gt;</summary>
    
    
    
    <category term="notes" scheme="https://bygeek.cn/categories/notes/"/>
    
    
    <category term="plan" scheme="https://bygeek.cn/tags/plan/"/>
    
  </entry>
  
  <entry>
    <title>关于神秘海域系列的玩后感</title>
    <link href="https://bygeek.cn/2019/01/31/thoughts-on-Sony-s-Uncharted-series/"/>
    <id>https://bygeek.cn/2019/01/31/thoughts-on-Sony-s-Uncharted-series/</id>
    <published>2019-01-31T05:31:30.000Z</published>
    <updated>2021-05-30T13:08:50.011Z</updated>
    
    <content type="html"><![CDATA[<p>拖延症害死人啊，这篇文章写于一个月之前吧。如今已通关神海3和资料片失落遗产。</p><span id="more"></span><p>—分割线—</p><p>上次打折（2018年圣诞促销）买了神海合集和神海4。</p><p>目前通了神海4，1和2。说下感受吧。</p><p>我先玩的4，画面真的很赞，第一次玩类似的游戏，电影大片即视感，既有点fps还有点揭秘冒险。而且个人觉得枪战，冒险和解谜都恰到好处。诶琳娜真的好美，哈哈。</p><p>后来开始玩合集，神海1感觉一直是突突突，枪战，从神海4画面过来看1的画面还是下降挺多，当然了，神海1是十几年前的老游戏，画面在现在看来也是可以理解。就是打到最后变电室出来怪物有点瘆人，有点像指环王的那个咕噜，死了好多次，把难度调到简单通关。</p><p>之前在论坛看到说神海2不错。果真，从1开始玩2的时候，电影大片即视感，而且射击可以看到子弹轨迹了，手柄反馈比1要好很多。而且剧情好太多，场面也很足，追火车，打飞机，打坦克。不过个人感觉有点不足的是，为啥非要跟1一样最后整出个怪物来？这点我还是比较喜欢4中，更现实一点。</p><p>接下来准备玩3，然后4的dlc。未完待续。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;拖延症害死人啊，这篇文章写于一个月之前吧。如今已通关神海3和资料片失落遗产。&lt;/p&gt;</summary>
    
    
    
    <category term="notes" scheme="https://bygeek.cn/categories/notes/"/>
    
    
    <category term="game" scheme="https://bygeek.cn/tags/game/"/>
    
  </entry>
  
  <entry>
    <title>2018年回顾</title>
    <link href="https://bygeek.cn/2019/01/07/2018-review/"/>
    <id>https://bygeek.cn/2019/01/07/2018-review/</id>
    <published>2019-01-07T01:54:53.000Z</published>
    <updated>2021-05-30T13:08:49.768Z</updated>
    
    <content type="html"><![CDATA[<p>2019年的元旦都过完好几天了，新年计划还一直没出来。迫于“新年新FLAG”，下面即是新年计划以及对过去一年的回顾。</p><span id="more"></span><p>一一对照下去年的计划吧。</p><blockquote><p>跑步减肥，目标是73KG</p></blockquote><p>今天早上上秤称了一下，正好达到目标。好悬！从8月底办了健身卡督促自己，一直到12月中旬，大概4个月，基本月跑量在130KM左右。自己的体重确实有下降。我也慢慢重新爱上了跑步，隔两天不跑感觉不舒服。单次距离从3K到5K到10K再到21K。10KM配速从6分半提高到5分，同时尝试了两次半马，一次2小时10分，一次1小时55分。总体来说对自己的成绩还是比较满意。但是后来右膝关节有点不舒服，跑步间隔也从一周4跑改成了一周2跑或3跑。</p><p>总的来说，下半年减重还是有效果的，也基本达到了预期，但是后面有所懈怠，当然有部分是膝关节的原因，但是个人主观上也有部分原因。</p><blockquote><p>把博客运行起来。 </p></blockquote><p>当初的计划是一周两篇博客，将自己积累的一些东西，或者遇到的一些问题，想法，记录下来，主要目的是方便自己以后查阅。开始的一两个月，确实保持这个频率更新，后来发现整理笔记成博客挺耗时间的，一般自己整理在onenote上的笔记，都是专业技术文章的剪贴，格式凌乱，自己看懂就行。一些文章要理出成自己的文字还是需要一定的时间。二来慢慢的以前的积累也慢慢消耗了。所以后来博文基本都已最近遇到问题或者看到的资料为基础。</p><p>本来博客是托管在Github上，后来趁着腾讯云搞活动，买了3年的云主机，就迁移到了腾讯云上。期间购买了域名并进行了网站备案。总的来说，这个Flag实现的还算合格吧。</p><blockquote><p>看书，专业书和自己买的两本社科书。</p></blockquote><p>这里先列下去年计划书单。</p><table><thead><tr><th>书名</th><th>完成情况</th><th>备注</th></tr></thead><tbody><tr><td>操作系统：精髓与设计原理</td><td>GOOD</td><td></td></tr><tr><td>深入理解操作系统（CSAPP）</td><td>NG</td><td>读完上一本书，发现CSAPP这本书受到推崇更多，于是又买了这本，但是没看了，估计以后这本书作为工具书查阅吧</td></tr><tr><td>程序员的自我修养–链接，装载与库</td><td>GOOD</td><td></td></tr><tr><td>C++ Primer</td><td>GOOD</td><td></td></tr><tr><td>Effective C++</td><td>GOOD</td><td>看的电子版，但是值得经常查阅，反复看</td></tr><tr><td>Effective Modern C++</td><td>ALMOST GOOD</td><td>看了大半部分，还未看完</td></tr><tr><td>COM技术内幕–微软组件对象模型</td><td>NG</td><td>未看完，看了开头</td></tr><tr><td>Inside the C++ Object Model</td><td>ALMOST GOOD</td><td>Lippman出的一本小册子，英文版，共180多页6个chapter，看了4个，算看完了大部分吧</td></tr><tr><td>深入理解Nginx</td><td>NG</td><td>看了部分，这本书当时还是跟前端的书一起买的，一直没看，后来为了折腾VPS的时候，以及阅读Nginx源码看了部分。</td></tr><tr><td>Docker入门实战</td><td>NG</td><td>看了部分</td></tr><tr><td></td><td></td><td></td></tr><tr><td>GEB</td><td>NG</td><td>当初在StackOverflow看到很多人推荐这本书，就买了，看了一章就没咋看了</td></tr><tr><td>货币金融学</td><td>NG</td><td>看了部分，金融学确实比较难啊</td></tr></tbody></table><p>去年大概是下半年才开始看专业书的。因为项目的原因，阅读了几本C++方面以及操作系统相关的书籍。好多书都是看了部分，然后因为各种各样的原因没有完整阅读完毕。</p><blockquote><p>开发一个能上线的小程序/app，或者有自己的一个开源项目。</p></blockquote><p>这个算是做的比较失败了。小程序和APP没影，就是Github上有自己的几个Toy Project，都是简单的自己学习C++写的代码。发现这个还是比较难坚持下去，动力有点不足。</p><blockquote><p>去一趟香港</p></blockquote><p>在12月份的时候去了一趟。这个也是准备了好久的事，期间从办居住证，护照，通行证，拖了很长时间。整体去香港的感受一般，住宿，交通，吃饭都挺贵的。有时间写篇博文记录下吧。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;2019年的元旦都过完好几天了，新年计划还一直没出来。迫于“新年新FLAG”，下面即是新年计划以及对过去一年的回顾。&lt;/p&gt;</summary>
    
    
    
    <category term="notes" scheme="https://bygeek.cn/categories/notes/"/>
    
    
    <category term="plan" scheme="https://bygeek.cn/tags/plan/"/>
    
  </entry>
  
  <entry>
    <title>关于正则表达式的简单总结</title>
    <link href="https://bygeek.cn/2018/12/18/personal-summary-on-regular-expression/"/>
    <id>https://bygeek.cn/2018/12/18/personal-summary-on-regular-expression/</id>
    <published>2018-12-18T08:03:31.000Z</published>
    <updated>2021-05-30T13:08:49.982Z</updated>
    
    <content type="html"><![CDATA[<p>本文记录一下正则表达式的一些语法和常见用法。以备后查。</p><p>在线regex测试网站推荐<a href="https://regex101.com/">regex101</a>。</p><p>有关regex的资料推荐: </p><ul><li><a href="https://www.regular-expressions.info/quickstart.html">regular-expressions.info</a></li><li><a href="http://www.runoob.com/regexp/regexp-metachar.html">runoob.com</a></li></ul><span id="more"></span><h2 id="基础概念语法"><a href="#基础概念语法" class="headerlink" title="基础概念语法"></a>基础概念语法</h2><h3 id="Text-patterns-and-Matches"><a href="#Text-patterns-and-Matches" class="headerlink" title="Text patterns and Matches"></a>Text patterns and Matches</h3><p>pattern表示一个规则。在本文中将正则表达式的Text pattern使用<code>/</code>包裹起来。如<code>/cat/</code></p><h3 id="Literal-Characters"><a href="#Literal-Characters" class="headerlink" title="Literal Characters"></a>Literal Characters</h3><p>字面量字符，最普通的一种情况。比如<code>/cat/</code>, 输入字符串<code>he catch a catfish for his cat.</code> 在字符串的第4个位置找到匹配。</p><p>如果想继续匹配。则需要设置为全局模式。<code>/cat/g</code>，则会对输入字符串进行全局搜索。</p><p>在正则表达式中有12个字符有着特殊的含义，分别是：</p><blockquote><p>the backslash <code>\</code>, the caret <code>^</code>, the dollar sign <code>$</code>, the period or dot <code>.</code>, the vertical bar or pipe symbol <code>|</code>, the question mark <code>?</code>, the asterisk or star <code>*</code>, the plus sign <code>+</code>, the opening parenthesis <code>(</code>, the closing parenthesis <code>)</code>, the opening square bracket <code>[</code>, and the opening curly brace <code>&#123;</code></p></blockquote><p>它们也叫做<code>metacharacters</code>。这些字符如果想被当成普通字符使用，需要使用<code>\</code>进行转译。如如果你想匹配<code>1+1=2</code>，你需要的Text pattern是<code>/1\+1=2/</code></p><h3 id="Character-Classes-or-Character-Sets"><a href="#Character-Classes-or-Character-Sets" class="headerlink" title="Character Classes or Character Sets"></a>Character Classes or Character Sets</h3><p>Character Class 只能在几个字符中匹配到其中一个。比如<code>/gr[ae]y/</code>可以匹配<code>gray</code>, <code>grey</code>, 但不能匹配<code>graey</code>。可以使用hyphen（连字符-）来表示一个候选范围，如<code>/[0-9]/</code>可匹配一个数字。<code>/[a-zA-Z]/</code>可用来匹配<code>bH</code>, <code>cD</code>等。也可以单字符和连字符一起使用，如<code>/[x0-9]/</code>用来匹配字符<code>x</code>或<code>0-9</code>的数字。</p><p>在方括号里使用<code>^</code>用来表示取否。如<code>/[^abc]/</code>可匹配非a非b非c的字符，<code>/[^ ]/</code>可匹配非空格（blank space）的字符。</p><h3 id="Shorthand-Character-Classes"><a href="#Shorthand-Character-Classes" class="headerlink" title="Shorthand Character Classes"></a>Shorthand Character Classes</h3><p>正则表达式提供了一些更简便的方式（Shorthand）来匹配一些常用的字符串。注意，这些shorthand具体包含的字符跟不同的regex flavour有关。不同的flavour可能还有其他的一些shorthand。这里讲一些通用的shorhand放在下表中。</p><table><thead><tr><th>Shorthand</th><th>Equals</th><th>Match</th></tr></thead><tbody><tr><td>\d</td><td>[0-9]</td><td>digit: 0-9的数字</td></tr><tr><td>\w</td><td>[a-zA-Z0-9_]</td><td>Word character: 用于组成单词的字符，下划线和数字</td></tr><tr><td>\s</td><td>[ \t\r\n\f]</td><td>Whitespace ：空格，tab，换行符, form feed</td></tr></tbody></table><p>Shorthand也可以有shorthand。一般用大写字母来表示取否。</p><table><thead><tr><th>Negated Shorthand</th><th>Equals</th></tr></thead><tbody><tr><td>\D</td><td>[^\d]</td></tr><tr><td>\W</td><td>[^\w]</td></tr><tr><td>\S</td><td>[^\s]</td></tr></tbody></table><p>在中括号中使用Negated Shorthand需要注意。如<code>[\D\S]</code>与<code>[^\d\s]</code>表达的含义不一样。<code>[^\d\s]</code>用来匹配即不是White space又不是数字的字符，而<code>[\D\S]</code>两个条件（\D或\S）满足一个即可匹配，换句话说，<code>[\D\S]</code>可以匹配数字，whitespace或者其他字符。这里面涉及的是逻辑上与或非关系。</p><p>可以在<a href="https://regex101.com/">regex101</a>上进行在线测试每个shorthand代表的简写。</p><img src="/2018/12/18/personal-summary-on-regular-expression/regex101.png" class=""><h3 id="Non-Printable-Characters"><a href="#Non-Printable-Characters" class="headerlink" title="Non-Printable Characters"></a>Non-Printable Characters</h3><p>在正则表达式中可以使用特殊字符来匹配不可打印字符。</p><table><thead><tr><th>pattern</th><th>match</th><th>pattern</th><th>match</th></tr></thead><tbody><tr><td>\t</td><td>tab字符（ASCII 0x09）</td><td>\r</td><td>carriage return(0x0D)</td></tr><tr><td>\n</td><td>line feed(0x0A)</td><td>\f</td><td>form feed(0x0C)</td></tr></tbody></table><p>需要注意的是，在windows上使用<code>\r\n</code>来用作line break, 而unix上是<code>\n</code>.</p><h3 id="The-Dot-matches-Almost-any-character"><a href="#The-Dot-matches-Almost-any-character" class="headerlink" title="The Dot matches (Almost) any character"></a>The Dot matches (Almost) any character</h3><p><code>.</code>可以匹配除了line break之外的所有字符。如<code>/gr.y/</code>可以匹配<code>gray</code>, <code>grey</code>, <code>/gr%y</code>. 谨慎的使用dot 字符。因为使用Character class匹配的速度回更快也更精确.</p><h3 id="Anchors"><a href="#Anchors" class="headerlink" title="Anchors"></a>Anchors</h3><blockquote><p>Anchors do not match any characters. They match a position.</p></blockquote><p>Anchors（锚）用来匹配一个位置。<code>^</code>用于匹配输入字符串的开始位置，<code>$</code>用于匹配输入字符串的结束位置。在<code>multi-line</code>模式下，<code>^</code>用来匹配每一行的开始位置，<code>$</code>用来匹配每一行的结束位置。如<code>/^a/</code>可以匹配<code>abc</code>中的a，但是再<code>bca</code>中找不到匹配。</p><p><code>\b</code>用来匹配word boundary。</p><blockquote><p>A word boundary is a position between a character that can be matched by <code>\w</code> and a character that cannot be matched by <code>\w</code></p></blockquote><p><code>\B</code>正好相反，用来匹配<code>\b</code>无法匹配的地方。</p><p>更多的内容相关请参考: <a href="https://www.regular-expressions.info/anchors.html">Learn more about anchors</a>.</p><h3 id="Alternation"><a href="#Alternation" class="headerlink" title="Alternation"></a>Alternation</h3><p>Alternation相当于正则表达式中的”或”。如<code>/cat|dog/</code>匹配<code>cat and dogs</code>中的<code>cat</code>,如果再次匹配（如使用global模式），才会再次匹配到<code>dog</code>.</p><p>Alternation在正则表达式中的操作符中优先级最低。如<code>cat|dog food</code>可以用来匹配<code>cat</code>或者<code>dog food</code>。如果想要匹配<code>cat food</code>或者<code>dog food</code>，需要使用捕获组<code>(cat|dog)food</code>.</p><h3 id="Repetition"><a href="#Repetition" class="headerlink" title="Repetition"></a>Repetition</h3><ul><li><p>quantifier <code>?</code>用来使得前面的token最多可以出现一次（0次或一次）。如<code>colou?r</code>匹配<code>colour</code>或<code>color</code> .</p></li><li><p>quantifier <code>*</code>用来使得前面的token出现0次，一次，或多次。</p></li><li><p>quentifier <code>+</code>用来使得前面的token至少出现一次（一次或多次）。</p></li><li><p>使用大括号<code>&#123;&#125;</code>用来表示前面的token出现特定次数。如<code>/\b[1-9][0-9]&#123;3&#125;\b/</code>匹配<code>1000-9999</code>的数字.</p></li></ul><p><code>/\b[1-9][0-9]&#123;2,4&#125;\b/</code>匹配100-9999.</p><h3 id="Greedy-and-Lazy-Repetition"><a href="#Greedy-and-Lazy-Repetition" class="headerlink" title="Greedy and Lazy Repetition"></a>Greedy and Lazy Repetition</h3><p>Repetition的匹配符都是“贪婪”的，他们会尽可能多的匹配，返回尽可能长的匹配字符串。如<code>/&lt;.+&gt;/</code>在输入字符串为<code>This is a &lt;EM&gt;first&lt;/EM&gt; test</code>中返回的匹配字符串为<code>&lt;EM&gt;first&lt;/EM&gt;</code>。</p><p>在<code>+</code>之后使用<code>?</code>使得匹配变为lazy. 使用<code>/&lt;.+?&gt;/</code>来匹配上面的字符串，则返回的是<code>&lt;EM&gt;</code>.</p><p>更好的方式是使用dot 运算符。</p><blockquote><p>Use <code>&lt;[^&lt;&gt;]+&gt;</code> to quickly match an HTML tag without regard to attributes. The negated character class is more specific than the dot, which helps the regex engine find matches quickly.</p></blockquote><h3 id="Grouping-and-Capturing"><a href="#Grouping-and-Capturing" class="headerlink" title="Grouping and Capturing"></a>Grouping and Capturing</h3><p>使用<code>()</code>来对多个字符进行分组，可以使用repetition运算符来修饰分组。如<code>/set(value)?/ 可以匹配</code>set<code>或</code>setvalue`.</p><p>使用小括号分组即创建了一个捕获组。上面的例子有一个分组，如果匹配set，则group1什么都没有，如果匹配setvalue，则group1是<code>value</code>。group0总是整个匹配的字符串。至于如何访问group，这个跟你使用的编程语言有关。</p><p>创建捕获组之后，可以使用backreference来引用捕获组。backreference即使用backslash和group number来表示捕获组的内容。</p><p>如<code>/([abc])=\1/</code>可以匹配<code>a=a</code>,或<code>b=b</code>，或<code>c=c</code></p><p>如果你只想分组不想创建捕获组可以使用<code>(？:)?</code>。如上面的例子，<code>set(?:value)?</code>, 这样只会创建分组，但不会创建捕获组。这样做的目的可以使得正则表达式匹配更快，性能更高。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;本文记录一下正则表达式的一些语法和常见用法。以备后查。&lt;/p&gt;
&lt;p&gt;在线regex测试网站推荐&lt;a href=&quot;https://regex101.com/&quot;&gt;regex101&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;有关regex的资料推荐: &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://www.regular-expressions.info/quickstart.html&quot;&gt;regular-expressions.info&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://www.runoob.com/regexp/regexp-metachar.html&quot;&gt;runoob.com&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    <category term="coding" scheme="https://bygeek.cn/categories/coding/"/>
    
    
    <category term="regex" scheme="https://bygeek.cn/tags/regex/"/>
    
  </entry>
  
  <entry>
    <title>在VS C++工程中使用Auto versionning</title>
    <link href="https://bygeek.cn/2018/12/17/auto-versioning-in-cpp-project/"/>
    <id>https://bygeek.cn/2018/12/17/auto-versioning-in-cpp-project/</id>
    <published>2018-12-17T08:12:33.000Z</published>
    <updated>2021-05-30T13:08:49.800Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://bygeek.cn/2018/04/04/automatic-versionning-in-visual-studio/">前面</a>我已经总结了在csharp中如何auto versionning来管理Assembly的版本号。本文总结一下在C++下如何方便的管理DLL的版本号。</p><span id="more"></span><h3 id="遇到的问题"><a href="#遇到的问题" class="headerlink" title="遇到的问题"></a>遇到的问题</h3><p>首先明确一下本文要解决的问题：</p><blockquote><p>在一个C++ solution中实现DLL或者EXE共享同一个版本号。</p></blockquote><p>既然要共享同一个版本号，那么最简单的类似csharp中的共享同一个AssemblyInfo文件了。csharp工程可以通过Add as Link方式将一个文件共享给其他project。在C++ project中自然也可以通过Add Existing File来实现这个目的。不过在VS2015之后Visual Studio支持了Shared Project Template。那么可以将version的信息放在Shared Project中，这样修改起来也方便。</p><h3 id="解决办法"><a href="#解决办法" class="headerlink" title="解决办法"></a>解决办法</h3><p>在C++ project中version信息是放在Resource.rc中的。</p><p>假设现在我们的代码结构是这样的：</p><blockquote><p>solution</p><p>+– project1</p><p>+– project2</p><p>+– sharedproject</p></blockquote><p>首先我们给project1和project2工程建立Resource文件。</p><blockquote><p>Project-&gt; Add-&gt;Resource-&gt;Version-&gt;New</p></blockquote><p>右击生成的Resource.rc文件, 选择View Code，滑动到Version部分。可以看到Version信息。</p><p>接下来在sharedproject中建立一个头文件verson.h</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> STRINGIZE2(s) #s   <span class="comment">//stringizing operator</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> STRINGIZE(s) STRINGIZE2(s)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> VERSION_MAJOR               1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> VERSION_MINOR               0</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> VERSION_REVISION            0</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> VERSION_BUILD               0</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//#define VER_FILE_DESCRIPTION_STR    &quot;Description&quot;  //decription和productionname各自独立，需要单独定义</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> VER_FILE_VERSION            VERSION_MAJOR, VERSION_MINOR, VERSION_REVISION, VERSION_BUILD</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> VER_FILE_VERSION_STR        STRINGIZE(VERSION_MAJOR)        \</span></span><br><span class="line">                                    <span class="string">&quot;.&quot;</span> STRINGIZE(VERSION_MINOR)    \</span><br><span class="line">                                    <span class="string">&quot;.&quot;</span> STRINGIZE(VERSION_REVISION) \</span><br><span class="line">                                    <span class="string">&quot;.&quot;</span> STRINGIZE(VERSION_BUILD)    \</span><br><span class="line"></span><br><span class="line"><span class="comment">//#define VER_PRODUCTNAME_STR         &quot;c_version_binary&quot;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> VER_PRODUCT_VERSION         VER_FILE_VERSION</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> VER_PRODUCT_VERSION_STR     VER_FILE_VERSION_STR</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> VER_ORIGINAL_FILENAME_STR   VER_PRODUCTNAME_STR <span class="meta-string">&quot;.exe&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> VER_INTERNAL_NAME_STR       VER_ORIGINAL_FILENAME_STR</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> VER_COPYRIGHT_STR           <span class="meta-string">&quot;Copyright (C) 2011&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> _DEBUG</span></span><br><span class="line">  <span class="meta">#<span class="meta-keyword">define</span> VER_VER_DEBUG             VS_FF_DEBUG</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">  <span class="meta">#<span class="meta-keyword">define</span> VER_VER_DEBUG             0</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> VER_FILEOS                  VOS_NT_WINDOWS32</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> VER_FILEFLAGS               VER_VER_DEBUG</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> VER_FILETYPE                VFT_APP</span></span><br><span class="line"><span class="comment">//注意，这里需要有一个空行，否则在resource中include这个头文件会报&quot;unexpected end of file&quot;错误</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>然后分别在project1和project2的Resource 属性中将Additional Include Directory将version.h的路径加进去。</p><blockquote><p>Project Property -&gt;Resource -&gt; General -&gt; Additional Include Directories</p></blockquote><p>注意是Resource选项卡，不是C++选项卡中的设置。</p><p>然后分别对project1和project2的Resource文件做如下操作：</p><ul><li><p>include version.h，定义description和product name</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Microsoft Visual C++ generated resource script.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;resource.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> VER_PRODUCTNAME_STR         <span class="meta-string">&quot;product_name_here&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> VER_FILE_DESCRIPTION_STR    <span class="meta-string">&quot;description_here&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;version.h&quot;</span></span></span><br></pre></td></tr></table></figure></li><li><p>替换version section</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/////////////////////////////////////////////////////////////////////////////</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Version</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line">VS_VERSION_INFO VERSIONINFO</span><br><span class="line"> FILEVERSION        VER_FILE_VERSION</span><br><span class="line"> PRODUCTVERSION     VER_PRODUCT_VERSION</span><br><span class="line"> FILEFLAGSMASK      <span class="number">0x3f</span>L</span><br><span class="line"> FILEFLAGS          VER_FILEFLAGS</span><br><span class="line"> FILEOS             VER_FILEOS</span><br><span class="line"> FILETYPE           VER_FILETYPE</span><br><span class="line"> FILESUBTYPE        <span class="number">0x0</span>L</span><br><span class="line">BEGIN</span><br><span class="line">    BLOCK <span class="string">&quot;StringFileInfo&quot;</span></span><br><span class="line">    BEGIN</span><br><span class="line">        BLOCK <span class="string">&quot;040904b0&quot;</span></span><br><span class="line">        BEGIN</span><br><span class="line">            VALUE <span class="string">&quot;FileDescription&quot;</span>,  VER_FILE_DESCRIPTION_STR <span class="string">&quot;\0&quot;</span></span><br><span class="line">            VALUE <span class="string">&quot;FileVersion&quot;</span>,      VER_FILE_VERSION_STR <span class="string">&quot;\0&quot;</span></span><br><span class="line">            VALUE <span class="string">&quot;InternalName&quot;</span>,     VER_INTERNAL_NAME_STR <span class="string">&quot;\0&quot;</span></span><br><span class="line">            VALUE <span class="string">&quot;LegalCopyright&quot;</span>,   VER_COPYRIGHT_STR <span class="string">&quot;\0&quot;</span></span><br><span class="line">            VALUE <span class="string">&quot;OriginalFilename&quot;</span>, VER_ORIGINAL_FILENAME_STR <span class="string">&quot;\0&quot;</span></span><br><span class="line">            VALUE <span class="string">&quot;ProductName&quot;</span>,      VER_PRODUCTNAME_STR</span><br><span class="line">            VALUE <span class="string">&quot;ProductVersion&quot;</span>,   VER_PRODUCT_VERSION_STR <span class="string">&quot;\0&quot;</span></span><br><span class="line">        END</span><br><span class="line">    END</span><br><span class="line">    BLOCK <span class="string">&quot;VarFileInfo&quot;</span></span><br><span class="line">    BEGIN</span><br><span class="line">        VALUE <span class="string">&quot;Translation&quot;</span>, <span class="number">0x409</span>, <span class="number">1200</span></span><br><span class="line">    END</span><br><span class="line">END</span><br></pre></td></tr></table></figure></li></ul><p>Build一下工程，并修改version.h头文件，看project1和project2的版本号是否是version里设置的版本号。</p><p>下次如果要修改版本号，就不用一个个去改每个工程的resource.rc文件了，直接修改version.h即可。</p><h3 id="进阶"><a href="#进阶" class="headerlink" title="进阶"></a>进阶</h3><p>上面的方法需要每次都手动修改version信息，可以利用visual studio中的Build Event自动将version.h信息更新。Share Project Template不支持VS project Build Event，可以将其换正常的Project类型。</p><p>具体请参考Code Project的一篇文章：<a href="https://www.codeproject.com/Articles/10313/Automatic-Build-Versioning-in-Visual-Studio">Automatic Build Versioning in Visual Studio</a>.</p><h3 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h3><ul><li><a href="https://www.zachburlingame.com/2011/02/versioning-a-native-cc-binary-with-visual-studio/">Versioning a Native C/C++ Binary with Visual Studio</a></li><li><a href="http://www.cplusplus.com/forum/windows/64819/">unexpected end of file found</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;a href=&quot;https://bygeek.cn/2018/04/04/automatic-versionning-in-visual-studio/&quot;&gt;前面&lt;/a&gt;我已经总结了在csharp中如何auto versionning来管理Assembly的版本号。本文总结一下在C++下如何方便的管理DLL的版本号。&lt;/p&gt;</summary>
    
    
    
    <category term="coding" scheme="https://bygeek.cn/categories/coding/"/>
    
    
    <category term="C++" scheme="https://bygeek.cn/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>C++ 中的智能指针</title>
    <link href="https://bygeek.cn/2018/12/04/smart-pointer-in-c-plus-plus/"/>
    <id>https://bygeek.cn/2018/12/04/smart-pointer-in-c-plus-plus/</id>
    <published>2018-12-04T05:58:59.000Z</published>
    <updated>2021-05-30T13:08:50.008Z</updated>
    
    <content type="html"><![CDATA[<p>C++ 11中共有四种智能指针(Smart Pointers)：<code>std::auto_ptr</code>,<code>std::unique_ptr</code>,<code>std::shared_ptr</code>,<code>std::weak_ptr</code>。其中<code>std::auto_ptr</code>是在C++98中就引入的智能指针，在C++11中已经被<code>std::unique_ptr</code>所取代。所以本文主要讨论讨论剩下的三种智能指针。</p><span id="more"></span><h3 id="为什么要使用智能指针？"><a href="#为什么要使用智能指针？" class="headerlink" title="为什么要使用智能指针？"></a>为什么要使用智能指针？</h3><p>不像C#/Java等语言拥有垃圾回收机制，C++必须靠程序员自己申请和释放内存。这样就给内存泄漏带来了机会。智能指针就是为了解决可能的内存泄漏的风险而设计的。在C++中局部变量在离开作用域之后，编译器会自动调用变量的析构函数对其进行析构，即使在发生异常的情况下也可以保证对象被析构。</p><p>智能指针其实就是贯彻了<a href="https://en.wikipedia.org/wiki/Resource_acquisition_is_initialization"><strong>RAII</strong></a>(Resource acquisition is initialization)的思想。将Raw Pointer作为资源托管起来，在离开作用域之后，自动调用Raw pointer的deletor。智能指针就是对象。</p><p>查看智能指针的头文件: memory，这里摘录下MSVC的实现：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// DECLARATIONS</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> _<span class="title">Ty</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">default_delete</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> _<span class="title">Ty</span>,</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> _<span class="title">Dx</span> =</span> default_delete&lt;_Ty&gt;&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">unique_ptr</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> _<span class="title">Ty</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">shared_ptr</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> _<span class="title">Ty</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">weak_ptr</span>;</span></span><br></pre></td></tr></table></figure><p>可以看到三种智能指针被声明为带有模板参数的类，其中unique_ptr带有两个模板参数，shared_ptr和weak_ptr都只有一个模板参数。</p><p>下面我们来分别详细来分析下三种智能指针的使用场景和一些注意事项。</p><h3 id="std-unique-ptr"><a href="#std-unique-ptr" class="headerlink" title="std::unique_ptr"></a>std::unique_ptr</h3><p>当需要使用智能指针时，<code>std::unique_ptr</code>应该作为首选，用来表达对资源的专属所有权。</p><p>当使用默认deletor时，<code>std::unique_ptr</code>跟裸指针尺寸相同，这意味着不会带来memory overhead。一个非空的<code>std::unique_ptr</code>总是指向涉及的资源。移动一个<code>std::unique_ptr</code>会将所有权将源指针移至目标指针(源指针被置空)。<code>std::unique_ptr</code>不支持复制操作。</p><h4 id="创建std-unique-ptr的方法"><a href="#创建std-unique-ptr的方法" class="headerlink" title="创建std::unique_ptr的方法"></a>创建std::unique_ptr的方法</h4><p>我们可以用以下方式来创建<code>std::unique_ptr</code>。</p><ul><li>通过C++14 引入的标准make函数<code>std::make_unique</code></li><li>直接接管newly allocated object</li><li>创建自己的make函数</li></ul><p>举例如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;memory&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MY_PRINT std::cout&lt;&lt; __FUNCTION__ &lt;&lt; std::endl;</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Investment</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">Investment(<span class="keyword">const</span> <span class="keyword">char</span>* name) : m_name(<span class="keyword">new</span> <span class="keyword">char</span>[<span class="number">128</span>])&#123;</span><br><span class="line">strcpy_s(m_name, <span class="number">128</span>, name);</span><br><span class="line">MY_PRINT;</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">virtual</span> ~Investment() &#123;</span><br><span class="line"><span class="keyword">delete</span> m_name;</span><br><span class="line">MY_PRINT;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line"><span class="keyword">char</span>* m_name;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Stock</span> :</span> <span class="keyword">public</span> Investment &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">Stock(<span class="keyword">const</span> <span class="keyword">char</span>* name) : Investment(name)&#123;</span><br><span class="line">MY_PRINT;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">~Stock() &#123;</span><br><span class="line">MY_PRINT;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;Investment&gt; <span class="title">makeInvestment</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">//in c++ 11</span></span><br><span class="line"><span class="comment">//std::unique_ptr&lt;Stock&gt; stock(new Stock(&quot;hello&quot;));</span></span><br><span class="line"><span class="comment">//return stock;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;Stock&gt;(<span class="keyword">new</span> Stock(<span class="string">&quot;hello&quot;</span>));  <span class="comment">//newly allocated object是一个右值</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;Investment&gt; <span class="title">makeInvestment2</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">//in c++ 14</span></span><br><span class="line"><span class="keyword">return</span> <span class="built_in">std</span>::make_unique&lt;Stock&gt;(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>在C++11中，由于没有引入unique_ptr的make函数，我们应该直接从new object接管pointer的控制权。如果使用以下方式来创建unique_ptr，会增加内存泄漏的风险。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> ptr = <span class="keyword">new</span> Stock(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line"><span class="function"><span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;Investment&gt; <span class="title">pInvest</span><span class="params">(ptr)</span></span>;  </span><br></pre></td></tr></table></figure><p>通过左值来初始化一个unique_ptr不是一个好的选择，因为ptr这个裸指针有可能会被delete掉，而pInvest在析构的时候会再次delete 裸指针，这时会造成未定义行为。</p><p>Best practice是通过make函数来创建智能指针。如果使用的是C++11，还有一种方式是创建自定义的make函数。如下是一个简单的版本。当然了，也可以直接去标准库中copy make_unique函数的实现代码。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> ... Args&gt;</span><br><span class="line"><span class="function"><span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;T&gt; <span class="title">make_unique</span><span class="params">(Args&amp;&amp;... params)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;T&gt;(<span class="keyword">new</span> T(<span class="built_in">std</span>::forward&lt;Args&gt;(params)...));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="自定义deletor"><a href="#自定义deletor" class="headerlink" title="自定义deletor"></a>自定义deletor</h4><p>我们也可以为unique_ptr自定义deletor。有以下两种方式：</p><ul><li>函数对象，如lambda表达式</li><li>函数指针</li></ul><p>举例如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//use lambda expression</span></span><br><span class="line"><span class="keyword">auto</span> delInvest = [](Investment* pInvestment) &#123;</span><br><span class="line"><span class="comment">//do something</span></span><br><span class="line"><span class="keyword">delete</span> pInvestment;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line">std::unique_ptr&lt;Investment, decltype(delInvest)&gt; ptr(new Stock(&quot;hello&quot;), delInvest);</span><br><span class="line"></span><br><span class="line"><span class="comment">//use function pointer</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">delInv</span><span class="params">(Investment* pInvestment)</span> </span>&#123;</span><br><span class="line"><span class="keyword">delete</span> pInvestment;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">std::unique_ptr&lt;Investment, void(*)(Investment* pInvestment)&gt; ptr2(new Stock(&quot;hello&quot;), delInv);</span><br><span class="line"></span><br><span class="line"><span class="comment">//或者使用decltype</span></span><br><span class="line">std::unique_ptr&lt;Investment, decltype(&amp;delInv)&gt; ptr2(new Stock(&quot;hello&quot;), delInv);</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>一般来说对于std::unique_ptr，在默认deletor的情况下，unique_ptr和裸指针的大小一样，但是使用自定义的deletor之后，情况变得有所不同。如果自定义的deletor是函数指针，则unique_ptr的大小会至少增加一个函数指针的大小。如果是函数对象，则带来的尺寸变化取决于函数对象中存储了多少状态。无状态的函数对象，如无捕获的lambda表达式不会浪费任何尺寸。 </p><p>这意味着一个自定义deletor可以用函数指针也可以使用无捕获的lambda表达式时，lambda表达式是更好的选择。</p><p>注意，自定义deletor必须是一个directly-callable object，如果想让一个member function作为deletor的话，可以使用<code>std::mem_fn</code>将其转化为函数对象。</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;functional&gt; //for std::mem_fn</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;memory&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Investment::release</span><span class="params">()</span></span>&#123;  <span class="comment">//release is a member function</span></span><br><span class="line">    <span class="comment">//do something</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">std::unique_ptr&lt;Investment, decltype(std::mem_fn(&amp;Investment::release))&gt; pInvest(new Stock(&quot;hello&quot;), std::mem_fn(&amp;Investment::release));</span><br></pre></td></tr></table></figure><h4 id="转化为shared-ptr"><a href="#转化为shared-ptr" class="headerlink" title="转化为shared_ptr"></a>转化为shared_ptr</h4><p><code>std::unique_ptr</code>可以很方便的转换为<code>std::shared_ptr</code>，所以适合作为工厂函数的返回型别。具体可以参考《Modern Effective C++》 item18。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>&gt; unique = <span class="built_in">std</span>::make_unique&lt;<span class="built_in">std</span>::<span class="built_in">string</span>&gt;(<span class="string">&quot;test&quot;</span>);</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>&gt; shared = <span class="built_in">std</span>::move(unique);</span><br><span class="line"></span><br><span class="line"><span class="comment">//or</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>&gt; shared = <span class="built_in">std</span>::make_unique&lt;<span class="built_in">std</span>::<span class="built_in">string</span>&gt;(<span class="string">&quot;test&quot;</span>);</span><br></pre></td></tr></table></figure><h4 id="auto-ptr-vs-unique-ptr"><a href="#auto-ptr-vs-unique-ptr" class="headerlink" title="auto_ptr vs unique_ptr"></a>auto_ptr vs unique_ptr</h4><p>在C98标准的时候，由于没有移动语义（move sematic），引入了auto_ptr来表示对资源的所有权。在表示所有权转移的时候，auto_ptr实际是通过拷贝操作来实现的。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">std</span>::<span class="built_in">auto_ptr</span>&lt;Stock&gt; <span class="title">ap</span><span class="params">(<span class="keyword">new</span> Stock(<span class="string">&quot;hello&quot;</span>))</span></span>;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">auto_ptr</span>&lt;Stock&gt; ap2 = ap;  <span class="comment">//compile success, while unique_ptr don&#x27;t</span></span><br><span class="line"></span><br><span class="line">ap-&gt;foo();  <span class="comment">//crash because ap is set to NULL</span></span><br></pre></td></tr></table></figure><p>通过auto_ptr的拷贝赋值运算符之后，ap已经置为了NULL，无法再使用ap2。</p><p>在使用unique_ptr时，由于unique_ptr将copy ctor和copy assign operator声明为delete function，所以编译无法通过。如果想转移资源的所有权，必须使用<code>std::move</code>（位于utility头文件）。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;Stock&gt; <span class="title">up</span><span class="params">(<span class="keyword">new</span> Stock(<span class="string">&quot;hello&quot;</span>))</span></span>;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;Stock&gt; up1 = <span class="built_in">std</span>::move(up);  <span class="comment">//use std::move to explicitly transfer ownership, and up is empty, can not use it again</span></span><br><span class="line"></span><br><span class="line">up.foo();  <span class="comment">//crash, can not use up again because ownership has transferred to up1</span></span><br></pre></td></tr></table></figure><h4 id="unique-ptr-源码剖析"><a href="#unique-ptr-源码剖析" class="headerlink" title="unique_ptr 源码剖析"></a>unique_ptr 源码剖析</h4><p>从上面unique_ptr的声明可以看到unique_ptr的类型中第二个模板参数默认时一个<code>default_delete</code>。查看其源码发现<code>default_delete</code>就是一个定义了函数调用运算符的函数对象:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> _<span class="title">Ty</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">default_delete</span></span></span><br><span class="line"><span class="class">&#123;</span><span class="comment">// default deleter for unique_ptr</span></span><br><span class="line"><span class="function"><span class="keyword">constexpr</span> <span class="title">default_delete</span><span class="params">()</span> <span class="keyword">noexcept</span> </span>= <span class="keyword">default</span>;</span><br><span class="line">        <span class="comment">//...省略部分</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">(_Ty * _Ptr)</span> <span class="keyword">const</span> <span class="keyword">noexcept</span></span></span><br><span class="line"><span class="function"></span>&#123;<span class="comment">// delete a pointer</span></span><br><span class="line"><span class="keyword">static_assert</span>(<span class="number">0</span> &lt; <span class="keyword">sizeof</span> (_Ty),</span><br><span class="line"><span class="string">&quot;can&#x27;t delete an incomplete type&quot;</span>);</span><br><span class="line"><span class="keyword">delete</span> _Ptr;  <span class="comment">//调用delete</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>在函数调用中直接调用delete，delete操作会调用_Ty类型的析构函数。这就是unique_ptr的默认析构所做的事。再看下unique_ptr的具体定义：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> _<span class="title">Ty</span>,</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> _<span class="title">Dx</span>&gt;</span><span class="comment">// = default_delete&lt;_Ty&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">unique_ptr</span></span></span><br><span class="line"><span class="class">:</span> <span class="keyword">public</span> _Unique_ptr_base&lt;_Ty, _Dx&gt;</span><br><span class="line">&#123;<span class="comment">// non-copyable pointer to an object</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="comment">//...省略</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>unique_ptr继承自<code>_Unique_ptr_base&lt;_Ty, _Dx&gt;</code>，继续看<code>_Unique_ptr_base&lt;_Ty, _Dx&gt;</code>的代码，其中包含一个成员变量：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">_Compressed_pair&lt;_Dx, pointer&gt; _Mypair;</span><br></pre></td></tr></table></figure><p>这里的pointer就是unique_ptr实际的对象的指针。接着在头文件<code>xutility</code>中可以看到<code>_Compressed_pair</code>的两个定义：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//定义1</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> _<span class="title">Ty1</span>,</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> _<span class="title">Ty2</span>,</span></span><br><span class="line"><span class="class"><span class="title">bool</span> =</span> is_empty_v&lt;_Ty1&gt; &amp;&amp; !is_final_v&lt;_Ty1&gt;&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> _<span class="title">Compressed_pair</span> <span class="keyword">final</span></span></span><br><span class="line"><span class="class">:</span> <span class="keyword">private</span> _Ty1</span><br><span class="line">&#123;<span class="comment">// store a pair of values, deriving from empty first</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">_Ty2 _Myval2;</span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> _Mybase = _Ty1;<span class="comment">// for visualization</span></span><br><span class="line"><span class="comment">//...省略</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//定义2</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> _<span class="title">Ty1</span>,</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> _<span class="title">Ty2</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> _<span class="title">Compressed_pair</span>&lt;</span>_Ty1, _Ty2, <span class="literal">false</span>&gt; <span class="keyword">final</span></span><br><span class="line">&#123;<span class="comment">// store a pair of values, not deriving from first</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">_Ty1 _Myval1;</span><br><span class="line">_Ty2 _Myval2;</span><br><span class="line">        <span class="comment">//...省略</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>这两个定义的区别直观上来说声明的内部成员变量不同，一个只有一个实际对象的指针（_Ty2）,另外一个不仅有_Ty2，还包含deletor类型变量。换句话说，这个区别影响了unique_ptr指针所占用的内存大小。</p><p><code>_Ty1</code>就是<code>_Dx</code>，也就是deletor的类型，<code>_Ty2</code>也就是unique_ptr实际指向的对象的指针。这里应该是通过重载的机制，让编译器去选择实例化哪个<code>_Compressed_pair</code>模板的代码。这个判断条件就是:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">is_empty_v&lt;_Ty1&gt; &amp;&amp; !is_final_v&lt;_Ty1&gt;</span><br></pre></td></tr></table></figure><p>查询cpp reference可以<code>is_empty_v</code>用来标识类是否是一个empty类</p><blockquote><p>Trait class that identifies whether <em>T</em> is an empty class.</p><p>An empty class is a class that stores no data, either cv-qualified or not.  </p></blockquote><p><code>is_final_v</code>用来标识是否是final类（使用final关键字声明类）。</p><p>至此我们可以看到unique_ptr所占空间的大小跟deletor有关，如果使用默认的deletor，则显然<code>default_delete</code>是一个空类，那么unique_ptr跟裸指针具有相同的大小。而如果自定义的deletor（可以理解为function object）包含了其他的data，则unique_ptr的大小是裸指针和function object占用大小之和。</p><h3 id="std-shared-ptr"><a href="#std-shared-ptr" class="headerlink" title="std::shared_ptr"></a>std::shared_ptr</h3><h4 id="控制块"><a href="#控制块" class="headerlink" title="控制块"></a>控制块</h4><p>和<code>std::unique_ptr</code>用来表示对资源的独占性相反，<code>std::shared_ptr</code>用来表示对资源的共享。创建的shared_ptr对象共享同一个资源。shared_ptr在内部实现使用引用计数的方式。每个<code>shared_ptr&lt;T&gt;</code>对象都包含两个部分，一个是指向T型别对象的指针，一个是指向控制块的指针，如下图：</p><img src="/2018/12/04/smart-pointer-in-c-plus-plus/shared_ptr%20memory%20layout.png" class=""><p>很显然，从shared_ptr的memory layout可以看到，shared_ptr的大小为裸指针的两倍。</p><p>注意：<strong>必须保证对同一个资源只创建一个控制块</strong>。因为当控制块中的引用计数为0时，资源被销毁。如果违反了这个约定，资源会被“销毁两次”，也就是说会造成未定义行为。控制块需要动态分配。控制块的创建遵循以下规则：</p><ul><li>std::make_shared总是创建一个控制块</li><li>从具备专属所有权的指针(即unique_ptr或auto_ptr指针)出发构造一个shared_ptr时，会创建一个控制块。</li><li>使用裸指针作为实参来调用（创建）shared_ptr时，会创建一个控制块。如果使用shared_ptr或者weak_ptr来创建shared_ptr，则不会创建控制块。</li></ul><h4 id="创建std-shared-ptr"><a href="#创建std-shared-ptr" class="headerlink" title="创建std::shared_ptr"></a>创建std::shared_ptr</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Stock和Investment接上面unique_ptr中的定义</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//通过make函数构造</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;Stock&gt; ptr = <span class="built_in">std</span>::make_shared&lt;Stock&gt;(<span class="string">&quot;hello&quot;</span>);  <span class="comment">//创建一个控制块</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//通过传递右值构造</span></span><br><span class="line"><span class="function"><span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;Stock&gt; <span class="title">ptr</span><span class="params">(<span class="keyword">new</span> Stock(<span class="string">&quot;hello&quot;</span>))</span></span>;  <span class="comment">//创建一个控制块</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//bad code: 通过裸指针，左值构造</span></span><br><span class="line"><span class="keyword">auto</span> raw_ptr = <span class="keyword">new</span> Stock(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line"><span class="function"><span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;Stock&gt; <span class="title">ptr1</span><span class="params">(raw_ptr)</span></span>;  <span class="comment">//为raw_ptr创建了一个控制块</span></span><br><span class="line"><span class="function"><span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;Stock&gt; <span class="title">ptr2</span><span class="params">(raw_ptr)</span></span>;  <span class="comment">//又创建了一个控制块，在析构时，会造成未定义行为。</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;Stock&gt; <span class="title">ptr3</span><span class="params">(ptr1)</span></span>;  <span class="comment">//从一个已有的shared_ptr创建另一个shared_ptr，调用shared_ptr的copy ctor，不会再次创建控制块，</span></span><br></pre></td></tr></table></figure><p>Best Practice是使用make函数来构造shared_ptr。最后的例子通过裸指针来构造，会为同一个资源创建两个控制块，也就是会有两个引用计数，当一个引用计数为0时，会发生析构，这样会对同一个资源析构两次，造成未定义行为。</p><h4 id="自定义deletor-1"><a href="#自定义deletor-1" class="headerlink" title="自定义deletor"></a>自定义deletor</h4><p>在unique_ptr的类型中，自定义的deletor是作为一个模板参数，所以deletor的型别是作为unique_ptr型别的一部分的，而shared_ptr则不一样。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">delete_stock</span><span class="params">(Stock* s)</span> </span>&#123;</span><br><span class="line"><span class="keyword">delete</span> s;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> stockDeletor = [](Stock* s) &#123;</span><br><span class="line"><span class="comment">//logsomething();</span></span><br><span class="line"><span class="keyword">delete</span> s;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//自定义析构</span></span><br><span class="line"><span class="function"><span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;Stock&gt; <span class="title">ptr1</span><span class="params">(<span class="keyword">new</span> Stock(<span class="string">&quot;hello&quot;</span>), stockDeletor)</span></span>;</span><br><span class="line"><span class="function"><span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;Stock&gt; <span class="title">ptr2</span><span class="params">(<span class="keyword">new</span> Stock(<span class="string">&quot;hello&quot;</span>), delete_stock)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;Stock&gt;&gt; v&#123;ptr1, ptr2&#125;;  <span class="comment">//不同的deletor，但是属于同一个类型，可以放在vector容器中，如果是unique_ptr，则不行</span></span><br></pre></td></tr></table></figure><h4 id="shared-from-this"><a href="#shared-from-this" class="headerlink" title="shared_from_this"></a>shared_from_this</h4><p>考虑这样一种情况，如果使用this指针直接来创建shared_ptr，会发生什么。以下代码来自<a href="https://en.cppreference.com/w/cpp/memory/enable_shared_from_this">cpp reference</a>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Good</span>:</span> <span class="built_in">std</span>::enable_shared_from_this&lt;Good&gt; <span class="comment">// note: public inheritance</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;Good&gt; <span class="title">getptr</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> shared_from_this();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Bad</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="function"><span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;Bad&gt; <span class="title">getptr</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;Bad&gt;(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    ~Bad() &#123; <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Bad::~Bad() called\n&quot;</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//example 1</span></span><br><span class="line">    <span class="comment">// Good: the two shared_ptr&#x27;s share the same object</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;Good&gt; gp1 = <span class="built_in">std</span>::make_shared&lt;Good&gt;();</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;Good&gt; gp2 = gp1-&gt;getptr();</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;gp2.use_count() = &quot;</span> &lt;&lt; gp2.use_count() &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">//example 2</span></span><br><span class="line">    <span class="comment">// Bad: shared_from_this is called without having std::shared_ptr owning the caller </span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        Good not_so_good;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;Good&gt; gp1 = not_so_good.getptr();</span><br><span class="line">    &#125; <span class="keyword">catch</span>(<span class="built_in">std</span>::bad_weak_ptr&amp; e) &#123;</span><br><span class="line">        <span class="comment">// undefined behavior (until C++17) and std::bad_weak_ptr thrown (since C++17)</span></span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; e.what() &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;    </span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">//example 3</span></span><br><span class="line">    <span class="comment">// Bad, each shared_ptr thinks it&#x27;s the only owner of the object</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;Bad&gt; bp1 = <span class="built_in">std</span>::make_shared&lt;Bad&gt;();</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;Bad&gt; bp2 = bp1-&gt;getptr();</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;bp2.use_count() = &quot;</span> &lt;&lt; bp2.use_count() &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">&#125; <span class="comment">// UB: double-delete of Bad</span></span><br></pre></td></tr></table></figure><p>在example 3，使用make函数来创建bp1，这是会创建一个控制块，后面又通过this裸指针又会创建一个控制块，所以会发生double delete。</p><p>在标准库中已经提供了<code>enable_shared_from_this</code>模板来解决这个问题。让类继承自<code>enable_shared_from_this</code>的特化版本，这个模板提供一个<code>shared_from_this</code>成员函数，可以使用这个成员函数来构造新的shared_ptr。但是注意，必须当前shared_ptr已经有一个相关联的控制块之后，才可以安全的使用<code>shared_from_this</code>，否则也会发生未定义行为。如上面的example 2。</p><h3 id="std-weak-ptr"><a href="#std-weak-ptr" class="headerlink" title="std::weak_ptr"></a>std::weak_ptr</h3><h4 id="weak-ptr-vs-shared-ptr"><a href="#weak-ptr-vs-shared-ptr" class="headerlink" title="weak_ptr vs shared_ptr"></a>weak_ptr vs shared_ptr</h4><p>weak_ptr并不是一种独立的智能指针，是对shared_ptr的一种扩充。<strong>weak_ptr不能直接由裸指针来构造，只能通过shared_ptr或者其他的weak_ptr来构造</strong>。cpp reference对weak_ptr的定义：</p><blockquote><p><code>std::weak_ptr</code> is a smart pointer that holds a non-owning (“weak”) reference to an object that is managed by <a href="https://en.cppreference.com/w/cpp/memory/shared_ptr">std::shared_ptr</a>. It must be converted to <a href="https://en.cppreference.com/w/cpp/memory/shared_ptr">std::shared_ptr</a> in order to access the referenced object.</p></blockquote><p>weak_ptr并不影响指向同一个资源对象的shared_ptr的引用计数，换句话说，weak_ptr不影响对象的共享所有权。前面在shared_ptr中提到的控制块中包含一个弱引用计数，weak_ptr影响的就是这个弱引用计数。当这个弱引用计数为0时，也即没有shared_ptr涉及到这个对象时，weak_ptr失效（过期）。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//call use_count function to get the numbers of shared_ptr instances that</span></span><br><span class="line">   <span class="comment">//shared ownship of the managed object, if 0 then the object has been deleted</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;Stock&gt; sp = <span class="built_in">std</span>::make_shared&lt;Stock&gt;(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; sp.use_count() &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;  <span class="comment">//1</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">std</span>::weak_ptr&lt;Stock&gt; wp = sp;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; sp.use_count() &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;  <span class="comment">//1</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; wp.use_count() &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;  <span class="comment">//1</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">std</span>::weak_ptr&lt;Stock&gt; wp2 = wp;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; wp.use_count() &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;  <span class="comment">//1</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; wp2.use_count() &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">//1</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;Stock&gt; sp2 = wp.lock();  <span class="comment">//use lock to get a shared_ptr instance</span></span><br><span class="line"><span class="keyword">if</span> (sp2) &#123;</span><br><span class="line"><span class="comment">//sp2 not null</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">//sp2 null, mean weak_ptr is expired</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在weak_ptr中使用<code>lock</code>方法来新建一个shared_ptr对象并返回，如果为空，则说明weak_ptr已经过期。也可以使用<code>expired</code>来检测weak_ptr是否过期，在多线程的环境中，可能会带来竞争风险。所以还是推荐使用<code>lock</code>方法。</p><h4 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h4><p>weak_ptr可以有以下几种使用场景。</p><ul><li>用作cache（缓存）</li><li>观察者模式</li><li>避免shared_ptr指针环路</li></ul><h5 id="用作cache（缓存）"><a href="#用作cache（缓存）" class="headerlink" title="用作cache（缓存）"></a>用作cache（缓存）</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//use weak_ptr in cache scenario</span></span><br><span class="line"><span class="function"><span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;Widget&gt; <span class="title">loadWidget</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">std</span>::make_shared&lt;Widget&gt;();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;Widget&gt; <span class="title">fast_load_widget</span><span class="params">(<span class="keyword">int</span> id)</span> </span>&#123;</span><br><span class="line"><span class="keyword">static</span> <span class="built_in">std</span>::<span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="built_in">std</span>::weak_ptr&lt;Widget&gt;&gt; cache;</span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> sp = cache[id].lock();  <span class="comment">//check if exist in cache</span></span><br><span class="line"><span class="keyword">if</span> (!sp) &#123;</span><br><span class="line">sp = loadWidget();</span><br><span class="line">cache[id] = sp;  <span class="comment">//put to cache</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> sp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="观察者模式"><a href="#观察者模式" class="headerlink" title="观察者模式"></a>观察者模式</h5><p>Subject类有一个vector容器，用于保存observers，当需要通知observer时，先检查observer是否还有效。注意：通过<code>std::make_shared</code>创建了一个临时的shared_ptr直接复制给weak_ptr，这个时候shared_ptr即被销毁。在调用<code>lock</code>测试weak_ptr是否过期时，这个observer是过期的。所以在测试函数中另外一个observer能收到通知。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Observer</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DoStuff</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Got notified&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Subject</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Notify</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span>&amp; ob : m_obs) &#123;</span><br><span class="line"><span class="keyword">auto</span> sp = ob.lock();  <span class="comment">//convert to shared_ptr</span></span><br><span class="line"><span class="keyword">if</span> (sp) &#123;  <span class="comment">//test if converted shared_ptr is valid</span></span><br><span class="line">sp-&gt;DoStuff();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">AddToObserver</span><span class="params">(<span class="built_in">std</span>::weak_ptr&lt;Observer&gt;&amp; ob)</span> </span>&#123;</span><br><span class="line">m_obs.push_back(ob);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::weak_ptr&lt;Observer&gt;&gt; m_obs;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test_observer_pattern_using_weak_ptr</span><span class="params">()</span> </span>&#123;</span><br><span class="line">Subject s;</span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> sp = <span class="built_in">std</span>::make_shared&lt;Observer&gt;();  <span class="comment">//make a shared_ptr obj</span></span><br><span class="line"><span class="built_in">std</span>::weak_ptr&lt;Observer&gt; ob1 = <span class="built_in">std</span>::make_shared&lt;Observer&gt;();  <span class="comment">//make a temp shared_ptr, after the assignment, shared_ptr is deleted</span></span><br><span class="line"><span class="function"><span class="built_in">std</span>::weak_ptr&lt;Observer&gt; <span class="title">ob2</span><span class="params">(sp)</span></span>;  <span class="comment">//only this observer can receive notification!!!</span></span><br><span class="line"></span><br><span class="line">s.AddToObserver(ob1);  </span><br><span class="line">s.AddToObserver(ob2);</span><br><span class="line"></span><br><span class="line">s.Notify();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="避免shared-ptr指针环路"><a href="#避免shared-ptr指针环路" class="headerlink" title="避免shared_ptr指针环路"></a>避免shared_ptr指针环路</h5><img src="/2018/12/04/smart-pointer-in-c-plus-plus/avoid_shared_ptr_loop.png" class=""><p>A, C都共享B，如果B需要保有一个对A的指针，这时候如果使用shared_ptr的话，会造成shared_ptr 环路，A, B互相保持引用，这样A和B的引用计数都不为0，无法析构，造成内存泄漏。</p><p>weak_ptr可以避免这个问题。当A的引用计数为0，即使B保有一个指向A的weak_ptr，不影响A被销毁。</p><h3 id="Make函数的几个注意点"><a href="#Make函数的几个注意点" class="headerlink" title="Make函数的几个注意点"></a>Make函数的几个注意点</h3><p>在使用智能指针时，Best Practice都是使用make函数来创建。特别是对于shared_ptr， 因为与之相关的控制块需要动态分配，如果使用make函数，则可以进行一次系统调用来分配内存（包含控制块和shared_ptr对象的内存）。而如果使用先创建裸指针，然后再创建shared_ptr的方法，需要进行两次系统调用来申请内存。这样做带来裸指针安全性的问题，也增加的性能上的开销。</p><p>当然了，make函数也不是万能的，如果需要使用自定义的deletor，那么只能通过其他方式来创建智能指针。</p><p>本文主要参考了Scott Meyers大师的  ***Effective Modern C++***，可以直接在网络上阅读：<a href="https://www.oreilly.com/library/view/effective-modern-c/9781491908419/ch04.html">地址在这</a>.</p><h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><ul><li>Scott Meyers <em><strong>Effective Modern C++</strong></em></li><li><a href="https://herbsutter.com/2013/06/05/gotw-91-solution-smart-pointer-parameters/">GotW91: Smart Pointer Parameters</a></li><li><a href="https://www.acodersjourney.com/top-10-dumb-mistakes-avoid-c-11-smart-pointers/">top-10-dumb-mistakes-avoid-c-11-smart-pointers</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;C++ 11中共有四种智能指针(Smart Pointers)：&lt;code&gt;std::auto_ptr&lt;/code&gt;,&lt;code&gt;std::unique_ptr&lt;/code&gt;,&lt;code&gt;std::shared_ptr&lt;/code&gt;,&lt;code&gt;std::weak_ptr&lt;/code&gt;。其中&lt;code&gt;std::auto_ptr&lt;/code&gt;是在C++98中就引入的智能指针，在C++11中已经被&lt;code&gt;std::unique_ptr&lt;/code&gt;所取代。所以本文主要讨论讨论剩下的三种智能指针。&lt;/p&gt;</summary>
    
    
    
    <category term="coding" scheme="https://bygeek.cn/categories/coding/"/>
    
    
    <category term="c++" scheme="https://bygeek.cn/tags/c/"/>
    
  </entry>
  
  <entry>
    <title>C++ 11带来的新特性</title>
    <link href="https://bygeek.cn/2018/12/04/new-features-in-cpp-11/"/>
    <id>https://bygeek.cn/2018/12/04/new-features-in-cpp-11/</id>
    <published>2018-12-04T01:56:55.000Z</published>
    <updated>2021-05-30T13:08:49.970Z</updated>
    
    <content type="html"><![CDATA[<p>本文转载自Herb Sutter的<a href="https://herbsutter.com/elements-of-modern-c-style/">blog</a>。Herb Sutter是C++标准委员会的主席，他在本文中主要讲述了C++ 11 带来的新的一些feature，同时建议尽量使用Modern C++ style编程。</p><p>同时我建议阅读Scott Mayers的《Effective Modern C++》一书。</p><p>原文如下。</p><span id="more"></span><p>The C++11 standard offers <a href="http://www2.research.att.com/~bs/C++0xFAQ.html">many useful new features</a>. This page focuses specifically and only on those features that make C++11 really feel like a new language compared to C++98, because:</p><ul><li>They change the styles and idioms you’ll use when writing C++ code, often including the way you’ll design C++ libraries. For example, you’ll see more smart pointer parameters and return values, and functions that return big objects by value.</li><li>They will be used so pervasively that you’ll probably see them in most code examples. For example, virtually every five-line modern C++ code example will say “auto” somewhere.</li></ul><p>Use the other great C++11 features too. But get used to these ones first, because these are the pervasive ones that show why C++11 code is clean, safe, and fast – just as clean and safe as code written in any other modern mainstream language, and with C++’s traditional to-the-metal performance as strong as ever.</p><p>Notes:</p><ul><li>Like Strunk &amp; White, this page is deliberately focused on brief summary guidance. It is not intended to provide exhaustive rationale and pro/con analysis; that will go into other articles.</li><li>This is a living document. See the end for a list of the main changes and additions over time.</li></ul><h3 id="auto"><a href="#auto" class="headerlink" title="auto"></a>auto</h3><p>Use auto wherever possible. It is useful for two reasons. First, most obviously it’s a convenience that lets us avoid repeating a type name that we already stated and the compiler already knows.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// C++98</span></span><br><span class="line"><span class="built_in">map</span>&lt;<span class="keyword">int</span>,<span class="built_in">string</span>&gt;::iterator i = m.begin();</span><br><span class="line"><span class="keyword">double</span> <span class="keyword">const</span> xlimit = config[<span class="string">&quot;xlimit&quot;</span>];</span><br><span class="line">singleton&amp; s = singleton::instance();</span><br><span class="line"> </span><br><span class="line"><span class="comment">// C++11</span></span><br><span class="line"><span class="keyword">auto</span> i = begin(m);</span><br><span class="line"><span class="keyword">auto</span> <span class="keyword">const</span> xlimit = config[<span class="string">&quot;xlimit&quot;</span>];</span><br><span class="line"><span class="keyword">auto</span>&amp; s = singleton::instance();</span><br></pre></td></tr></table></figure><p>Second, it’s more than just a convenience when a type has an unknown or unutterable name, such as the type of most lambda functions, that you couldn’t otherwise spell easily or at all.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// C++98</span></span><br><span class="line">binder2nd&lt; greater &gt; x = bind2nd( greater(), <span class="number">42</span> );</span><br><span class="line"> </span><br><span class="line"><span class="comment">// C++11</span></span><br><span class="line"><span class="keyword">auto</span> x = [](<span class="keyword">int</span> i) &#123; <span class="keyword">return</span> i &gt; <span class="number">42</span>; &#125;;</span><br></pre></td></tr></table></figure><p>Note that using auto doesn’t change the code’s meaning. The code is still statically typed, and the type of every expression is already crisp and clear; the language just no longer forces us to redundantly restate the type’s name.</p><p>Some people are initially afraid of using auto here, because it may feel like not (re)stating the type we want could mean we’ll get a different type by accident. If you want to explicitly <em>enforce a type conversion</em>, that’s okay; state the target type. The vast majority of the time, however, just use auto; it will rarely be the case that you get a different type by mistake, and even in those cases the language’s strong static typing means the compiler will usually let you know because you’ll be trying to call a member function the variable doesn’t have or otherwise use it as something that it isn’t.</p><h3 id="Smart-pointers-No-delete"><a href="#Smart-pointers-No-delete" class="headerlink" title="Smart pointers: No delete"></a>Smart pointers: No delete</h3><p>Always use the standard smart pointers, and non-owning raw pointers. Never use owning raw pointers and delete, except in rare cases when implementing your own low-level data structure (and even then keep that well encapsulated inside a class boundary).</p><p>If you know you’re the only owner of another object, use unique_ptr to express unique ownership. A “new T” expression should immediately initialize another object that owns it, typically a unique_ptr. A classic example is the Pimpl Idiom (see <a href="https://herbsutter.com/gotw/_100/">GotW #100</a>):</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// C++11 Pimpl idiom: header file</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">widget</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    widget();</span><br><span class="line">    <span class="comment">// ... (see GotW #100) ...</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">impl</span>;</span></span><br><span class="line">    <span class="built_in">unique_ptr</span>&lt;impl&gt; pimpl;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// implementation file</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">widget</span>:</span>:impl &#123; <span class="comment">/*...*/</span> &#125;;</span><br><span class="line"> </span><br><span class="line">widget::widget() : pimpl&#123; <span class="keyword">new</span> impl&#123; <span class="comment">/*...*/</span> &#125; &#125; &#123; &#125;</span><br><span class="line"><span class="comment">// ...</span></span><br></pre></td></tr></table></figure><p>Use shared_ptr to express shared ownership. Prefer to use make_shared to create shared objects efficiently.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; C++98</span><br><span class="line">widget* pw &#x3D; new widget();</span><br><span class="line">:::</span><br><span class="line">delete pw;</span><br><span class="line"> </span><br><span class="line">&#x2F;&#x2F; C++11</span><br><span class="line">auto pw &#x3D; make_shared&lt;widget&gt;();</span><br></pre></td></tr></table></figure><p>Use weak_ptr to break cycles and express optionality (e.g., implementing an object cache).</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// C++11</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">gadget</span>;</span></span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">widget</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">shared_ptr</span>&lt;gadget&gt; g; <span class="comment">// if shared ownership</span></span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">gadget</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    weak_ptr&lt;widget&gt; w;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br></pre></td></tr></table></figure><p>If you know another object is going to outlive you and you want to observe it, use a (non-owning) raw pointer.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// C++11</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">node</span> &#123;</span></span><br><span class="line"> <span class="built_in">vector</span>&lt;<span class="built_in">unique_ptr</span>&lt;node&gt;&gt; children;</span><br><span class="line"> node* parent;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"> :::</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="nullptr"><a href="#nullptr" class="headerlink" title="nullptr"></a>nullptr</h3><p>Always use nullptr for a null pointer value, never the literal 0 or the macro NULL which are ambiguous because they could be either an integer or a pointer.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// C++98</span></span><br><span class="line"><span class="keyword">int</span>* p = <span class="number">0</span>;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// C++11</span></span><br><span class="line"><span class="keyword">int</span>* p = <span class="literal">nullptr</span>;</span><br></pre></td></tr></table></figure><h3 id="Range-for"><a href="#Range-for" class="headerlink" title="Range for"></a>Range for</h3><p>The range-based for loop is a much more convenient way to visit every element of a range in order.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// C++98</span></span><br><span class="line"><span class="keyword">for</span>( <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::iterator i = v.begin(); i != v.end(); ++i ) &#123;</span><br><span class="line">    total += *i;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// C++11</span></span><br><span class="line"><span class="keyword">for</span>( <span class="keyword">auto</span> d : v ) &#123;</span><br><span class="line">    total += d;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Nonmember-begin-and-end"><a href="#Nonmember-begin-and-end" class="headerlink" title="Nonmember begin and end"></a>Nonmember begin and end</h3><p>Always use nonmember begin(x) and end(x) (not x.begin() and x.end()), because begin(x) and end(x) are extensible and can be adapted to work with all container types – even arrays – not just containers that follow the STL style of providing x.begin() and x.end() member functions.</p><p>If you’re using a non-STL collection type that provides iteration but not STL-style x.begin() and x.end(), you can often write your own non-member begin(x) and end(x) overloads for that type and then you can traverse collections of that type using the same coding style above as for STL containers. The standard has set the example: C arrays are such a type, and the standard provides begin and end for arrays.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v;</span><br><span class="line"><span class="keyword">int</span> a[<span class="number">100</span>];</span><br><span class="line"> </span><br><span class="line"><span class="comment">// C++98</span></span><br><span class="line">sort( v.begin(), v.end() );</span><br><span class="line">sort( &amp;a[<span class="number">0</span>], &amp;a[<span class="number">0</span>] + <span class="keyword">sizeof</span>(a)/<span class="keyword">sizeof</span>(a[<span class="number">0</span>]) );</span><br><span class="line"> </span><br><span class="line"><span class="comment">// C++11</span></span><br><span class="line">sort( begin(v), end(v) );</span><br><span class="line">sort( begin(a), end(a) );</span><br></pre></td></tr></table></figure><h3 id="Lambda-Functions-and-Algorithms"><a href="#Lambda-Functions-and-Algorithms" class="headerlink" title="Lambda Functions and Algorithms"></a>Lambda Functions and Algorithms</h3><p>Lambdas are a game-changer and will frequently change the way you write code to make it more elegant and faster. Lambdas make the existing STL algorithms roughly 100x more usable. Newer C++ libraries increasingly are designed assuming lambdas as available (e.g., PPL), and some even require you to write lambdas to use the library at all (e.g., C++ AMP).</p><p>Here’s one quick example: Find the first element in v that’s &gt;x and &lt;y. In C+11, the simplest and cleanest code is to use a standard algorithm.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// C++98: write a naked loop (using std::find_if is impractically difficult)</span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::iterator i = v.begin(); <span class="comment">// because we need to use i later</span></span><br><span class="line"><span class="keyword">for</span>( ; i != v.end(); ++i ) &#123;</span><br><span class="line">    <span class="keyword">if</span>( *i &gt; x &amp;&amp; *i &lt; y ) <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// C++11: use std::find_if</span></span><br><span class="line"><span class="keyword">auto</span> i = find_if( begin(v), end(v), [=](<span class="keyword">int</span> i) &#123; <span class="keyword">return</span> i &gt; x &amp;&amp; i &lt; y; &#125; );</span><br></pre></td></tr></table></figure><p>Want a loop or similar language feature that’s not actually in the language? No sweat; just write it as a template function (library algorithm), and thanks to lambdas you can use it with <em>almost</em> the same convenience as if it were a language feature, but with more flexibility because it really is a library and not a hardwired language feature.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// C#</span></span><br><span class="line">lock( mut_x ) &#123;</span><br><span class="line">    ... use x ...</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// C++11 without lambdas: already nice, and more flexible (e.g., can use timeouts, other options)</span></span><br><span class="line">&#123;</span><br><span class="line">    lock_guard&lt;mutex&gt; hold &#123; mut_x &#125;;</span><br><span class="line">    ... use x ...</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// C++11 with lambdas, and a helper algorithm: C# syntax in C++</span></span><br><span class="line"><span class="comment">// Algorithm: template&lt;typename T&gt; void lock( T&amp; t, F f ) &#123; lock_guard hold(t); f(); &#125;</span></span><br><span class="line">lock( mut_x, [&amp;]&#123;</span><br><span class="line">    ... use x ...</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>Get familiar with lambdas. You’ll use them a lot, and not just in C++ – they are already widely available and pervasively used in several popular mainstream languages. A good place to start is my talk <a href="https://herbsutter.com/2010/10/30/pdc-languages-panel-andshortened-lambdas-talk/">Lambdas, Lambdas Everywhere</a> at PDC 2010.</p><h3 id="Move-amp-amp"><a href="#Move-amp-amp" class="headerlink" title="Move / &amp;&amp;"></a>Move / &amp;&amp;</h3><p>Move is best thought of as an optimization of copy, though it also enables other things like perfect forwarding.</p><p>Move semantics change the way we design our APIs. We’ll be designing for return by value a lot more often.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// C++98: alternatives to avoid copying</span></span><br><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;* <span class="title">make_big_vector</span><span class="params">()</span></span>; <span class="comment">// option 1: return by pointer: no copy, but don&#x27;t forget to delete</span></span><br><span class="line">:::</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;* result = make_big_vector();</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">make_big_vector</span><span class="params">( <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; out )</span></span>; <span class="comment">// option 2: pass out by reference: no copy, but caller needs a named object</span></span><br><span class="line">:::</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; result;</span><br><span class="line">make_big_vector( result );</span><br><span class="line"> </span><br><span class="line"><span class="comment">// C++11: move</span></span><br><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">make_big_vector</span><span class="params">()</span></span>; <span class="comment">// usually sufficient for &#x27;callee-allocated out&#x27; situations</span></span><br><span class="line">:::</span><br><span class="line"><span class="keyword">auto</span> result = make_big_vector(); <span class="comment">// guaranteed not to copy the vector</span></span><br></pre></td></tr></table></figure><p>Enable move semantics for your type when you can do something more efficient than copy.</p><h3 id="Uniform-Initialization-and-Initializer-Lists"><a href="#Uniform-Initialization-and-Initializer-Lists" class="headerlink" title="Uniform Initialization and Initializer Lists"></a>Uniform Initialization and Initializer Lists</h3><p>What hasn’t changed: When initializing a local variable whose type is non-POD or auto, continue using the familiar = syntax without extra { } braces.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// C++98 or C++11</span></span><br><span class="line"><span class="keyword">int</span> a = <span class="number">42</span>;        <span class="comment">// still fine, as always</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">// C++ 11</span></span><br><span class="line"><span class="keyword">auto</span> x = begin(v); <span class="comment">// no narrowing or non-initialization is possible</span></span><br></pre></td></tr></table></figure><p>In other cases, including especially everywhere that you would have used ( ) parentheses when constructing an object, prefer using { } braces instead. Using braces avoids several potential problems: you can’t accidentally get narrowing conversions (e.g., float to int), you won’t occasionally accidentally have uninitialized POD member variables or arrays, and you’ll avoid the occasional C++98 surprise that your code compiles but actually declares a function rather than a variable because of a declaration ambiguity in C++’s grammar – what Scott Meyers famously calls “C++’s most vexing parse.” There’s nothing vexing about the new style.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// C++98</span></span><br><span class="line"><span class="function">rectangle       <span class="title">w</span><span class="params">( origin(), extents() )</span></span>;   <span class="comment">// oops, declares a function, if origin and extents are types</span></span><br><span class="line"><span class="function"><span class="built_in">complex</span>&lt;<span class="keyword">double</span>&gt; <span class="title">c</span><span class="params">( <span class="number">2.71828</span>, <span class="number">3.14159</span> )</span></span>;</span><br><span class="line"><span class="keyword">int</span>             a[] = &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span> &#125;;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;     v;</span><br><span class="line"><span class="keyword">for</span>( <span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">4</span>; ++i ) v.push_back(i);</span><br><span class="line"> </span><br><span class="line"><span class="comment">// C++11</span></span><br><span class="line">rectangle       w   &#123; origin(), extents() &#125;;</span><br><span class="line"><span class="built_in">complex</span>&lt;<span class="keyword">double</span>&gt; c   &#123; <span class="number">2.71828</span>, <span class="number">3.14159</span> &#125;;</span><br><span class="line"><span class="keyword">int</span>             a[] &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span> &#125;;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;     v   &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span> &#125;;</span><br></pre></td></tr></table></figure><p>The new { } syntax works pretty much everywhere:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// C++98</span></span><br><span class="line">X::X( <span class="comment">/*...*/</span> ) : mem1(init1), mem2(init2, init3) &#123; <span class="comment">/*...*/</span> &#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// C++11</span></span><br><span class="line">X::X( <span class="comment">/*...*/</span> ) : mem1&#123;init1&#125;, mem2&#123;init2, init3&#125; &#123; <span class="comment">/*...*/</span> &#125;</span><br></pre></td></tr></table></figure><p>Finally, sometimes it’s just convenient to pass function arguments without a type-named temporary:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">draw_rect</span><span class="params">( rectangle )</span></span>;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// C++98</span></span><br><span class="line">draw_rect( rectangle( myobj.origin, selection.extents ) );</span><br><span class="line"> </span><br><span class="line"><span class="comment">// C++11</span></span><br><span class="line">draw_rect( &#123; myobj.origin, selection.extents &#125; );</span><br></pre></td></tr></table></figure><p>The only place where I prefer not to write the braces is on simple initialization of a non-POD variable, like <em>auto x = begin(v);</em> , where it would make the code needlessly ugly because I know it’s a class type, so I know I don’t need to worry about accidental narrowing conversions, and modern compilers already routinely perform the optimization to elide the extra copy (or the extra move, if the type is move-enabled).</p><h3 id="And-More"><a href="#And-More" class="headerlink" title="And More"></a>And More</h3><p>There’s more to modern C++. <a href="http://www2.research.att.com/~bs/C++0xFAQ.html">Much more.</a> And in the future I plan to write more in-depth pieces about these and other features of C++11 we’ll get to know and love.</p><p>But for now, this is the list of must-know features. These features form the core that defines modern C++ style, that make C++ code look and perform the way it does, that you’ll see used pervasively in nearly every piece of modern code you’ll see or write… and that make modern C++ the clean, and safe, and fast language that our industry will continue relying on heavily for years to come.</p><h3 id="Major-Change-History"><a href="#Major-Change-History" class="headerlink" title="Major Change History"></a>Major Change History</h3><p>2011-10-30: Added C# lock example to lambdas. Reordered smart pointers to introduce unique_ptr first.</p><p>2011-11-01: Added uniform initialization.</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;本文转载自Herb Sutter的&lt;a href=&quot;https://herbsutter.com/elements-of-modern-c-style/&quot;&gt;blog&lt;/a&gt;。Herb Sutter是C++标准委员会的主席，他在本文中主要讲述了C++ 11 带来的新的一些feature，同时建议尽量使用Modern C++ style编程。&lt;/p&gt;
&lt;p&gt;同时我建议阅读Scott Mayers的《Effective Modern C++》一书。&lt;/p&gt;
&lt;p&gt;原文如下。&lt;/p&gt;</summary>
    
    
    
    <category term="coding" scheme="https://bygeek.cn/categories/coding/"/>
    
    <category term="repost" scheme="https://bygeek.cn/categories/coding/repost/"/>
    
    
    <category term="c++" scheme="https://bygeek.cn/tags/c/"/>
    
  </entry>
  
  <entry>
    <title>bitwise copy vs memberwise copy</title>
    <link href="https://bygeek.cn/2018/11/23/bitwise-copy-vs-memberwise-copy/"/>
    <id>https://bygeek.cn/2018/11/23/bitwise-copy-vs-memberwise-copy/</id>
    <published>2018-11-23T00:52:46.000Z</published>
    <updated>2021-05-30T13:08:49.808Z</updated>
    
    <content type="html"><![CDATA[<p>本文转自<a href="https://stackoverflow.com/questions/42749439/what-is-the-difference-between-memberwise-copy-bitwise-copy-shallow-copy-and-d">Stack Overflow</a>，对几种copy的概念将的通熟易懂。</p><span id="more"></span><p><strong>Member-wise Copy</strong></p><p>Is when you visit each member and explicitly copy it, invoking its copy constructor. It is usually tantamount to deep-copy. It is the right and proper way of copying things. The opposite is bit-wise copy, which is a hack, see below.</p><p><strong>Bit-wise Copy</strong></p><p>Is a specific form of shallow copy. It is when you simply copy the bits of the source class to the target class, using <code>memcpy()</code> or something similar. Constructors are not invoked, so you tend to get a class which <em>appears</em> to be all right but things start breaking in horrible ways as soon as you start using it. This is the opposite of member-wise copy, and is a quick and dirty hack that can sometimes be used when we know that there are no constructors to be invoked and no internal structures to be duplicated. For a discussion of what may go wrong with this, see this Q&amp;A: <a href="https://stackoverflow.com/questions/15123516/c-bitwise-vs-memberwise-copying">C++ bitwise vs memberwise copying?</a></p><p><strong>Shallow Copy</strong></p><p>Refers to copying just the immediate members of an object, without duplicating whatever structures are pointed by them. It is what you get when you do a bit-wise copy.</p><p>(Note that there is no such thing as “shadow copy”. I mean, there is such a thing, in file systems, but that’s probably <em>not</em> what you had in mind.)</p><p><strong>Deep Copy</strong></p><p>Refers to not only copying the immediate members of an object, but also duplicating whatever structures are pointed by them. It is what you normally get when you do member-wise copy.</p><p><strong>To summarize:</strong></p><p>There are two categories:</p><ul><li>Shallow Copy</li><li>Deep Copy</li></ul><p>Then, there are two widely used techniques:</p><ul><li>Bit-wise Copy (a form of Shallow Copy)</li><li>Member-wise Copy (a form of Deep Copy)</li></ul><p>As for the hear-say about someone who said something and someone who said something else: bit-wise copy is definitely always shallow copy. Member-wise copy is usually deep copy, but you may of course foul it up, so you may be thinking that you are making a deep copy while in fact you are not. Proper member-wise copy relies on having proper copy constructors.</p><p>Finally:</p><p>The default copy constructor will do a bit-wise copy if the object is known to be trivially copyable, or a member-wise copy if not. However, the compiler does not always have enough information to perform a proper copy of each member. For example, a pointer is copied by making a copy of the pointer, not by making a copy of the pointed object. That’s why you should generally not rely on the compiler providing you with a default copy constructor when your object is not trivially copyable.</p><p>A user-supplied constructor may do whatever type of copy the user likes. Hopefully, the user will choose wisely and do a member-wise copy.</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;本文转自&lt;a href=&quot;https://stackoverflow.com/questions/42749439/what-is-the-difference-between-memberwise-copy-bitwise-copy-shallow-copy-and-d&quot;&gt;Stack Overflow&lt;/a&gt;，对几种copy的概念将的通熟易懂。&lt;/p&gt;</summary>
    
    
    
    <category term="coding" scheme="https://bygeek.cn/categories/coding/"/>
    
    
    <category term="copy" scheme="https://bygeek.cn/tags/copy/"/>
    
  </entry>
  
</feed>
