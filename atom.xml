<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>萝卜头的日志</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://bygeek.cn/"/>
  <updated>2020-01-31T16:23:02.467Z</updated>
  <id>https://bygeek.cn/</id>
  
  <author>
    <name>byGeek</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>2020-new-year</title>
    <link href="https://bygeek.cn/2020/01/31/2020-new-year/"/>
    <id>https://bygeek.cn/2020/01/31/2020-new-year/</id>
    <published>2020-01-31T06:02:32.000Z</published>
    <updated>2020-01-31T16:23:02.467Z</updated>
    
    <content type="html"><![CDATA[<p>2019已经过去，2020已经来临，照例写点东西记录下吧。</p><a id="more"></a><p>看到19年当初定的一些计划，我都有点不太好意思，当初立的一些flag好多都没有做到，以至于今天我都不好再定2020的计划了。那就索性改变一下以前的形式吧。</p><h3 id="回望2019"><a href="#回望2019" class="headerlink" title="回望2019"></a>回望2019</h3><p>19年买了房子，开启了“百万负翁”的生活。以前想的是如何去周游世界，怎样去随性所欲，现在想着从每个月的工资扣掉房贷之后，平平凡凡的生活。这个算是好消息吧。虽然有时累的时候觉得不值，但是晚上睡在自己家的床上的时候，那种温暖还是跟以前不一样的。</p><p>19年8月换了份工作，结束了以前养老的工作。感谢现在的公司，在我换行业的时候，愿意给我一个学习的机会。也感谢上一家公司，可以让我有很多可以自我学习提高的机会。说到换工作的事情，跟买房子也有联系，当每个月的工资抵不上每个月的房贷时，让我不得不跳出自己的舒适圈。至于新的公司，到现在为止，有满意也有不满意的地方。经过几个月的工作，遇到了很多能力很强的同事，意识到了很多自己工作上问题，能力上的不足。我想我会努力的。</p><p>19年打脸最严重的就是跑步了。19年跑量不到500公里。在佳明上定的半马计划也搁置了。自从8月准备换工作到新公司上班之后，锻炼的少了，有那段时间忙碌的托辞，但是更重要的是是自己懒了。</p><p>19年倒是玩了好多游戏。看了下2019年play station的游戏游玩时间统计，花了259个小时在游戏上。</p><img src="/2020/01/31/2020-new-year/game_sumary.jpg"><img src="/2020/01/31/2020-new-year/game_time.jpg"><p>总的来说，可能因为上一份工作比较养老，所以花在游戏上的时间也比较多。而且正如PS有支广告说的，游戏是一种比较好的，花钱又比较少的娱乐活动了，哈哈。</p><h3 id="展望2020"><a href="#展望2020" class="headerlink" title="展望2020"></a>展望2020</h3><p>2020，我希望自己更加自信。在工作上，不仅仅是自己努力，需要多向同事学习，工作方式，沟通，如何解决问题，定时复盘。</p><p>我希望能报名一场半程马拉松比赛，半马应该不是问题，但是我想去赛场感受一下，和众多跑者一起奔跑。</p><p>我希望自己多看书，把自己买的书慢慢消化。</p><p>最重要的，希望自己，家人都身体健康，希望2020越来越好！</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;2019已经过去，2020已经来临，照例写点东西记录下吧。&lt;/p&gt;
    
    </summary>
    
      <category term="notes" scheme="https://bygeek.cn/categories/notes/"/>
    
    
  </entry>
  
  <entry>
    <title>My reviews about Red dead redemption 2</title>
    <link href="https://bygeek.cn/2020/01/30/my-review-on-rdr2/"/>
    <id>https://bygeek.cn/2020/01/30/my-review-on-rdr2/</id>
    <published>2020-01-30T13:07:04.000Z</published>
    <updated>2020-01-31T16:23:02.640Z</updated>
    
    <content type="html"><![CDATA[<p>前几天把荒野大镖客2通关了，今天专门找了下游戏中的原声带听了一下，很有感触，正好闲在家中，看看记录点东西吧。</p><a id="more"></a><p>大表哥这个游戏盘买了很久了，记得当时刚发售的时候，看到一些预告和别人试玩的视频片段，心里痒痒。上次去香港的时候本来打算买块盘，看了看新战神还没开坑，就作罢。后来是看到越来越多的报道，说R星七年磨一剑，于是果断买盘（想着以后还可出二手回血）。</p><p>其实大表哥这种题材的游戏还是蛮合我的胃口的。我个人更倾向于写实的游戏。比如一战，二战题材，以前玩的英雄连，COD二战等。我对一些比较科幻，武器很fancy的不是特别感冒。就玩法来说，我比较喜欢一本道的游戏，比如战神系列，神海系列，对开放世界比较无感，但是塞尔达荒野之息例外。当我玩完大表哥第一章的时候，还是很震撼的。但是到了第二章的时候，发现游戏节奏有点慢，大部分时间都是在骑马跑路，热情大减，于是弃坑了。</p><p>时隔一年，快到春节假期，游戏荒了，趁着周末，拿出大表哥盘，花了两个小时将光盘载入到PS4中。发现战斗系统都生疏了。依旧是骑马跑路，但是随着主线任务的推进，慢慢沉浸到了亚瑟摩根的西部世界中。下面说说在游戏中我印象比较深刻的人。</p><h3 id="亚瑟摩根"><a href="#亚瑟摩根" class="headerlink" title="亚瑟摩根"></a>亚瑟摩根</h3><p>亚瑟12岁被Dutch救了之后，跟随Dutch20多年，脏活苦活，出生入死。他对Dutch是很敬仰的，不管现在的情况多么穷困潦倒，坚定的相信Dutch可以work out a plan。中间被奥觉斯科帮派抓住，折磨，也丝毫没有透露出帮派的信息。每次Dutch计划失败，让大家深陷险境时，亚瑟都是去解决问题的那个人， 对Dutch无条件的信任。即使亚瑟最后发现Dutch是个不折不扣的利己主义者，对自己见死不救，还是希望Dutch可以回心转意。最终那一幕，亚瑟，麦卡，Dutch三人对质，此时的亚瑟已是濒死之人，”I did my best, I did”。不知道Dutch听到这些话是什么感受。</p><h3 id="沙迪艾德勒"><a href="#沙迪艾德勒" class="headerlink" title="沙迪艾德勒"></a>沙迪艾德勒</h3><p>沙迪是里面我最喜欢的一个女角色了。从被奥觉斯科帮派杀了丈夫，被Dutch就下，一直在皮尔逊的厨房打下手，但是她注定是个gunslinger！跟亚瑟出征，巾帼不让须眉。后期更是带领帮派藏身沼泽地，和亚瑟一起突破平克顿侦探的围剿。她应该是价值观最和亚瑟和的来的吧。有勇有谋，率性爽快。最后和马斯顿上雪山，杀迈卡，中枪之后，马斯顿说， “You are dying”, 沙迪果断说，“No, I ain’t! I ain’t‘”。最后反杀迈卡。沙迪是一个很要强的女性，最后成为一个赏金猎人我觉得是对她来说不失为一个很好的结局。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;前几天把荒野大镖客2通关了，今天专门找了下游戏中的原声带听了一下，很有感触，正好闲在家中，看看记录点东西吧。&lt;/p&gt;
    
    </summary>
    
      <category term="notes" scheme="https://bygeek.cn/categories/notes/"/>
    
    
      <category term="games" scheme="https://bygeek.cn/tags/games/"/>
    
  </entry>
  
  <entry>
    <title>记一次修改联通光猫为桥接模式的经历</title>
    <link href="https://bygeek.cn/2019/08/18/Change-Optical-modem-to-bridge-mode/"/>
    <id>https://bygeek.cn/2019/08/18/Change-Optical-modem-to-bridge-mode/</id>
    <published>2019-08-18T01:38:23.000Z</published>
    <updated>2020-01-31T16:23:02.477Z</updated>
    
    <content type="html"><![CDATA[<p>自从搬家换了宽带移机之后，本来群晖的外网访问就失效了。因为前段时间一直都比较忙，一直没好好解决这个问题。今天终于得闲，把这个问题整好了。以下是我的折腾记录。</p><a id="more"></a><h3 id="公网IP被取消？"><a href="#公网IP被取消？" class="headerlink" title="公网IP被取消？"></a>公网IP被取消？</h3><p>黑裙无法外网访问，首先想到的可能是联通这边不给公网IP了。打开ip138查看出口IP地址，是公网IP。当然这个并不能说明问题，因为这个检测到的只是出口IP，可能家里还是内网IP。</p><p>登录路由器管理界面，在远程管理看到路由器的IP地址为192.168的内网地址。内网IP无疑了。于是联系联通客服，质问为何移机之后的宽带取消了公网IP。一个工作日客服人员答复家里的宽带公网IP并未取消。</p><h3 id="无法ping通"><a href="#无法ping通" class="headerlink" title="无法ping通"></a>无法ping通</h3><p>其实确认有公网IP之后，路由器获取的又是内网地址，如果对网络拓扑和组网有简单的了解之后，已经可以确定可能是光猫的问题了，但是好久不搞这些东西，我已经把计算机网络的一些东西忘了差不多了。真是惭愧。</p><p>言归正传，当时我的想法是，既然我还是有公网IP，那么我试着ping下试试。使用我在腾讯云和GCP上的VPS对家里公网IP进行ping操作，无法ping通，100% package loss。有可能是封禁了ICMP response？</p><p>我又想到可以使用端口扫描工具，对该IP进行端口扫描，看是不是端口被封禁的问题。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nmap -Pn ip_addr</span><br></pre></td></tr></table></figure><p>找不到open的端口。端口都被封了？</p><h3 id="在群晖设置router-端口转发找到问题"><a href="#在群晖设置router-端口转发找到问题" class="headerlink" title="在群晖设置router 端口转发找到问题"></a>在群晖设置router 端口转发找到问题</h3><p>走投无路的情况下，通过内网，我打开群晖的external access的问题。在重新配置router 端口转发的时候，群晖自检网络时抛出了一个warning：网络里存在多个路由，需要将接入设置为桥接模式。</p><img src="/2019/08/18/Change-Optical-modem-to-bridge-mode/set_up_router.png"><p>感觉找到了一个突破口。我马上找到光猫，开启无线功能，然后连上光猫的无线网之后，登录到web界面。但是发现由于是user用户，找不到修改光猫工作为桥接模式的设置。于是，在google上搜索“光猫 桥接”，找到了简书上的一篇文章： <a href="https://www.jianshu.com/p/0211c56c4945" target="_blank" rel="noopener">电信光猫桥接模式的设置</a>。这篇文章也是碰到了外网访问的问题。修改光猫为桥接模式，必须要拿到管理员账户。那怎么搞到光猫的控制台密码呢？</p><h3 id="要到光猫管理员密码"><a href="#要到光猫管理员密码" class="headerlink" title="要到光猫管理员密码"></a>要到光猫管理员密码</h3><p>我直接在google上搜索的光猫的型号：吉比特TEWA 800G。找到一个知乎相关的问题：<a href="https://www.zhihu.com/question/316754462" target="_blank" rel="noopener">吉比特TEWA 800G的管理员登录地址是什么？</a>。这个问题虽然没有人回答，但是在问题的描述中我知道了管理员登录的网址。这个光猫的登录界面还做的一个鸡贼的处理：当直接输入光猫的登录地址192.168.1.1时，只能看到普通用户登录的选项，没有管理员账户的登录选项。正好这个知乎问题上说明管理员的登录地址时: <code>192.168.1.1/cu.html</code>。</p><p>接下来就差密码了，我倒是想搜索相关的“破解”方法，不过本着试一试的想法，我直接打电话给装宽带小哥，询问他光猫的管理员的密码之后，没想到宽带小哥直接告诉了我！</p><p>使用管理员密码登录之后，我直接在光猫的快速设置向导中，将路由模式修改为桥接模式。然后在自己的路由器上使用PPPoE拨号。但是无法成功，提示没有连接到互联网。怎么回事呢？</p><h3 id="要到vlan-id"><a href="#要到vlan-id" class="headerlink" title="要到vlan id"></a>要到vlan id</h3><p>我重新看了简书上的<a href="https://www.jianshu.com/p/0211c56c4945" target="_blank" rel="noopener">这篇文章</a>，里面说道改成桥接模式之后，需要修改VLAN ID，这个VLAN ID是原来路由模式的VLAN ID。再确认了一下我自家光猫的配合，没有问题，但是就是无法成功拨号。</p><p>无奈之下我再次拨打了宽带小哥的电话。小哥说让我加钱，他上门服务。我说别了吧，我自己弄就好了，不用上门，我请教你几个问题。没想到小哥也同意了。我加了小哥微信，把光猫的VLAN配置发他看了。他询问了我光猫上的一个参数之后，告诉我VLAN ID（这个VLAN ID并不是路由模式的VLAN ID），同时他说需要他在那边“操作一下”。</p><p>看来这个VLAN ID并不是像简书上的文章说的那样，而且需要宽带人员的操作（好像是要解绑什么东西？）。所以遇到问题需要按照实际情况进行分析。</p><p>我填入小哥说的VLAN ID之后，拨号成功！</p><h3 id="外网成功访问"><a href="#外网成功访问" class="headerlink" title="外网成功访问"></a>外网成功访问</h3><p>打开路由器的管理界面，在远程访问中可以看到路由器的IP不再是192.168了，而是公网IP。</p><p>然后在群晖上执行下DDNS脚本，终于搞定了外网访问的问题！</p><h3 id="桥接与VLAN"><a href="#桥接与VLAN" class="headerlink" title="桥接与VLAN"></a>桥接与VLAN</h3><p>其实这件事情很小，而且起初确认公网IP没有取消，路由器获取的是内网IP的时候，当时就应该可以判断是光猫的问题，但是由于还是一些组网知识都忘了，所以走了一些弯路。</p><p>下面在这里贴一下这期间碰到的知识点。</p><blockquote><p>Q: [What’s the difference between a bridge and a switch?(<a href="https://serverfault.com/questions/78184/whats-the-difference-between-a-bridge-and-a-switch" target="_blank" rel="noopener">https://serverfault.com/questions/78184/whats-the-difference-between-a-bridge-and-a-switch</a>)</p><p>An ethernet switch is a multiport ethernet bridge. A bridge is a device that splits collision domains but not broadcast domains. A switch is simply a bridge with lots of ports. Other examples of bridges are wireless access points and dual speed hubs. </p></blockquote><blockquote><p>A <strong>virtual LAN</strong> (<strong>VLAN</strong>) is any <a href="https://en.wikipedia.org/wiki/Broadcast_domain" target="_blank" rel="noopener">broadcast domain</a> that is <a href="https://en.wikipedia.org/wiki/Network_segmentation" target="_blank" rel="noopener">partitioned</a> and isolated in a <a href="https://en.wikipedia.org/wiki/Computer_network" target="_blank" rel="noopener">computer network</a> at the <a href="https://en.wikipedia.org/wiki/Data_link_layer" target="_blank" rel="noopener">data link layer</a> (<a href="https://en.wikipedia.org/wiki/OSI_model#Layer_2:_Data_Link_Layer" target="_blank" rel="noopener">OSI layer 2</a>).<a href="https://en.wikipedia.org/wiki/Virtual_LAN#cite_note-1" target="_blank" rel="noopener">[1]</a><a href="https://en.wikipedia.org/wiki/Virtual_LAN#cite_note-802.1Q_1.4-2" target="_blank" rel="noopener">[2]</a> <em>LAN</em> is the abbreviation for <em>local area network</em> and in this context <em>virtual</em> refers to a physical object recreated and altered by additional logic. VLANs work by applying tags to network frames and handling these tags in networking systems – creating the appearance and functionality of <a href="https://en.wikipedia.org/wiki/Network_traffic" target="_blank" rel="noopener">network traffic</a> that is physically on a single network but acts as if it is split between separate networks. In this way, VLANs can keep network applications separate despite being connected to the same physical network, and without requiring multiple sets of cabling and networking devices to be deployed.</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;自从搬家换了宽带移机之后，本来群晖的外网访问就失效了。因为前段时间一直都比较忙，一直没好好解决这个问题。今天终于得闲，把这个问题整好了。以下是我的折腾记录。&lt;/p&gt;
    
    </summary>
    
      <category term="notes" scheme="https://bygeek.cn/categories/notes/"/>
    
    
      <category term="geek" scheme="https://bygeek.cn/tags/geek/"/>
    
  </entry>
  
  <entry>
    <title>ios 13 beta降级到ios 12.3</title>
    <link href="https://bygeek.cn/2019/07/13/downgrade-ios-13-to-ios-12-3/"/>
    <id>https://bygeek.cn/2019/07/13/downgrade-ios-13-to-ios-12-3/</id>
    <published>2019-07-13T15:22:46.000Z</published>
    <updated>2020-01-31T16:23:02.578Z</updated>
    
    <content type="html"><![CDATA[<p>今天手贱把手机的IPhone 6s升级到ios public beta3。谁想到发热严重，app时不时闪退，必须重启才有效。不得已要要降级。本文就当自己今天的作死记录做个小记吧。</p><a id="more"></a><h3 id="起因"><a href="#起因" class="headerlink" title="起因"></a>起因</h3><p>我一直时不想当苹果的小白鼠的。Beta在软件上的含义不言而喻。但是实在是不能忍受在IOS 12.3.1短信拦截失效bug又一次复现！国内的垃圾短信太猖獗，我一直是用的“短信拦截”这个APP来拦截垃圾短信，好像是花了6块钱买的吧。我在IOS上使用的收费软件不多。但是升级到IOS 12.3.1版本之后，短信拦截失效了。我还以为是APP出现了问题，后来下载了另一款“熊猫吃短信”发现也无法拦截垃圾短信。在该APP的描述中才知道是IOS系统的bug导致短信无法拦截。</p><p>这个问题以前也出现过，本来拦截正常使用的情况下，在升级某个小版本的正式包之后，出现问题。现在果真BUG OS也越来越坐实了。后来在V2EX论坛上了解到在IOS13以及修正了这个BUG。于是乎，我在使用Itunes备份了数据之后，开启了升级之路。</p><h3 id="IOS-13-PB-BETA-2"><a href="#IOS-13-PB-BETA-2" class="headerlink" title="IOS 13 PB BETA 2"></a>IOS 13 PB BETA 2</h3><p>升级IOS 13 公测版2之后，系统发热严重，我想这可能是刚升级完系统，可能是正常现象，可能多重启几次就能“放凉”。没想到一重启之后，打开应用全部闪退。不得不再次重启，才恢复正常。</p><p>简单体验了下IOS 13，特别是Apple提到的Dark mode，有点新鲜感。Photos界面也重新设计了。短信界面好像变的更拟物化设计了。短信拦截也恢复正常了。但是发热严重。随便打开哪个APP，一会时间，手机就变的好烫，掉电量惊人。上午9点出门，下午3点就没电了，而且中间还开启了省电模式。</p><p>掉电这个还能忍，就是异常发热和APP偶尔闪退忍不了。没办法，只好选择降级。但是，数据咋办？</p><h3 id="降级"><a href="#降级" class="headerlink" title="降级"></a>降级</h3><p>降级一般都是要刷机，而刷机一般都是要抹除数据。幸好在油管上找到降级无损数据的方法。谢天谢地，否则折腾到明天也折腾不完了。</p><p>油管视频：<a href="https://www.youtube.com/watch?v=Ph5MGBeClv8" target="_blank" rel="noopener">How to Downgrade iOS 13 to iOS 12! (Without Losing Data)</a></p><p>看视频应该很简单：</p><ol><li>在<a href="https://ipsw.me" target="_blank" rel="noopener">ipsw.me</a>上下载对应的固件，我是下载的IOS 12.3版本，因为12.3.1有短信无法拦截的版本，索性直接降级到12.3版本。幸好苹果还没有关闭12.3的激活通道。</li><li>使用Itunes备份数据。注意请先升级到itunes的最新版本再备份。</li><li>恢复数据。在恢复过程中出现一次白苹果。卡在苹果logo，无进度条显示。以为变砖了，在苹果官网找到进recovery方法，但是幸好在插上数据线之后，iTunes提示升级新版本即可。但是就是这个升级操作，导致后面“虚惊一场”！</li></ol><p>一开始itunes自动升级失败，所以我没在意，直接使用的老版本的itunes做backup，然后再restore的时候itunes提示要升级到最新版才可以restore到12.3。但是在我升级完itunes之后，发现新版的itunes无法找到我的backup记录了！当时感觉心都凉了，数据都没了。后来在查看info.plist文件，在文件结尾有itunes的版本号，怀疑是不是iTunes的版本差异，导致新版的iTunes无法识别使用旧版iTunes backup的文件。所以我在卸载新版itunes，并安装对应的旧版本的时候，终于恢复数据成功。</p><p>在卸载新版iTunes的时候，现在微软也慢慢使用Microsoft store作统一的软件分发平台了。新版的itunes就是在MS Store上下载。在卸载的时候没有在control panel中的卸载中找到itunes，后来是直接在windows上搜索iTunes，右键直接uninstall。</p><p>安装完旧版本的iTunes时，启动会发现提示一个文件由新版本的iTunes创建，导致无法启动成功。解决方法时直接将该文件删除即可。启动iTunes时，会自动创建该文件。安装成功之后，可以找到先前备份的数据。10G的恢复文件大概花了半个小时才恢复成功。</p><h3 id="降级之后"><a href="#降级之后" class="headerlink" title="降级之后"></a>降级之后</h3><p>降级之后，别完了卸载旧的iTunes，重新安装新版iTunes。并且充分备份下数据。最后在iCloud中也备份一份数据。</p><p>最重要的是，千万不要再手贱升级啦！</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;今天手贱把手机的IPhone 6s升级到ios public beta3。谁想到发热严重，app时不时闪退，必须重启才有效。不得已要要降级。本文就当自己今天的作死记录做个小记吧。&lt;/p&gt;
    
    </summary>
    
      <category term="notes" scheme="https://bygeek.cn/categories/notes/"/>
    
    
      <category term="apple" scheme="https://bygeek.cn/tags/apple/"/>
    
  </entry>
  
  <entry>
    <title>我与游戏的故事(一)</title>
    <link href="https://bygeek.cn/2019/06/03/my-story-with-video-games/"/>
    <id>https://bygeek.cn/2019/06/03/my-story-with-video-games/</id>
    <published>2019-06-03T14:06:26.000Z</published>
    <updated>2020-01-31T16:23:02.641Z</updated>
    
    <content type="html"><![CDATA[<p>买了Play Station已经快两个月了。玩了几款PS4平台的第一方大作之后，是时候来写写自己的感受了。说起买PS4这个经历，其实有点阴差阳错。不过在这之前，我打算先说一下以前我跟游戏的前世今生。</p><a id="more"></a><h3 id="令人怀念的“小霸王”"><a href="#令人怀念的“小霸王”" class="headerlink" title="令人怀念的“小霸王”"></a>令人怀念的“小霸王”</h3><p>作为一枚90后，我小时候接触到的其实是“小霸王”之类的“学习机”，以前并没有红白机之类的概念。可能是中国特殊的国情所致，特别是一些农村的父母，对游戏可是讳莫如深，想正大光明的买游戏机，那几乎是不可能的事。估计也是这个原因，国内的一些厂商将红白机包装为学习机，正好让我有了买“小霸王”的理由。那个时候基本都对父母说是买来“学电脑的”。也确实，当时随机器附带的卡带都是带五笔打字的，我估计应该有很多人对这个场景有印象：一艘艘小船上面是五笔的偏旁部首，只要敲如相应的键就可以将小船击沉。说实话，当时自己还是花了一些时间在“小霸王”上练习五笔打字的，还背诵了偏旁部首的记忆口诀。只可惜，这些打字诀窍最终只停留在了那个学习机上，等我真正接触到电脑，五笔打字早就忘了一干二净了。</p><p>那个时候还是比较痴迷在“小霸王”上的，而且自己还耗费了不少资金在上面。我记得当时一盘“四合一”的卡带要卖8块。那个时候应该大概是2000年左右。要是没记错的话，当时在小学的商店一支雪糕只要5分钱。前前后后应该买了不下20盘卡带。那个时候成绩好，每次基本都是以这个为后盾再加上撒娇，母亲也就顺了我的意。</p><p>想起那段时间，真实觉得很美好。小学放学之后，先把作业写完（那个时候作业应该简单吧，记得每次半个小时就写完了）。然后将“小霸王”接上家里的黑白电视机，拿着卡带在嘴边吹下卡带金手指（似乎这样能防止死机），小心翼翼的摁上去，开机！一个简单的游戏能不亦乐乎的玩上很久。当然了，最后肯定是在母亲一遍遍的催促下最后关了机。</p><p>除了一个人在家里开黑，最大的乐趣就是和村里的小伙伴一起玩了。当时隔壁院子里的一个小伙伴，暂且称之为玲，经常一起玩。印象最深游戏是“热血系列”中的“热血格斗”。这个游戏并不是类似拳皇之类的格斗游戏，而是每局4个人物，你，队友，还有两位对手。你和队友需要在规定时间内击败对手。每一局都是不同的场景，场景还有不同的辅助道具，例如电网，地雷，瀑布等。最后挑战最终的boss——两个带着虎头的对手。首先这个游戏带有一定的随机性（也可能是当时玩的日文版本，看不明白吧），因为每次无法直接选择游戏人物的“招数”，而是通过为人物选择名字，血型，然后系统会分配一个人物给你。可能人物可以有“连环拳”，或者“连环腿”，或者“地雷滚”。其次“热血格斗”场景比较多，每一局的场景设计都很有意思。比如电网那关，当时经常干的伎俩就是讲击倒后的NPC直接扔到电网里，给其造成二次伤害，而且由于击倒后到再起来，有一定的时间差，把握好这个时间差可以无限扔到电网里。还有地雷那关，故意引诱NPC去踩雷，但有的时候被NPC背摔自己去中雷了，哈哈。游戏里还可以跟队友“合体”放大招，变成旋风。由于看不懂日文，我和玲经常要去试看那个人物最厉害，后来还总结出一个“规律”：O型血比较“欧”。“殴”在我的家乡话里是有点类似撒泼比较厉害的意思。我们都觉得很形象。于是默默都给人物选择O型血。但也不总是能选择有“连环拳”或者“连环腿”的人物。</p><p>“热血格斗”卡带是玲的，我没有，于是我经常趁着玲妈不在跟玲一起玩。那个时候基本每个放学的下午，都能在玲的房间里昏天黑地的玩一两个小时。有的时候被玲妈发现我们在房间里背着她玩游戏，我只能尬笑着回家，偷偷约定这明天来我家玩。</p><p>学习机我一共买过两台，一台是在一个打着雷的雨天关机之后就无法再开机了。后来仗着自己成绩好，又让我妈给我买了一台新的。这台新的还带了一把“枪”。可以用来玩一个叫“打鸭子”的游戏。只要指着黑白电视机里的鸭子开枪，就可以将其击落。不过终归没有见到支持这种玩法的游戏了，渐渐的这把“枪”也吃灰了。</p><h3 id="街机"><a href="#街机" class="headerlink" title="街机"></a>街机</h3><p>我记得这个“学习机”一直没坏，只是后来上中学之后，当时慢慢迷上了街机。虽然经常是一个币都不买，但是却可以站在旁边看别人玩一天。当时比较火的几款游戏是恐龙岛和三国战记。看着别人摇杆拍的左来右去，按键拍的啪啪响，感觉自己也浑身充满了”干劲“。没记错的话，一块钱4个币，对于一些老手来说，可以玩一天了。对于我来说，可能四个币也就撑过一两关吧。输了不续币是要重来的，但即使这样，也乐此不疲。因为街机始终玩的很少。一个是费钱，另外就是家人的反对了。可能是街机厅里环境不是很好，有人经常逃学去玩，而且街机厅在家长的眼里就是游戏厅，好歹小霸王还打个掩护叫学习机呢。我妈很反对我去街机厅。一开始是表哥带我去，有一次被我妈发现了，直接冲到街机厅，把我两拎回来了。”你去玩吧，我看你以后有什么出息。“然后也数落其表哥来，后来表哥再也没带我去了。</p><p>我觉得街机当时对我的吸引力主要有三点吧。第一，相比与再黑白电视机上接上小霸王玩，街机的大彩屏简直就是现在的iPhone对于比诺基亚的功能机带来的震撼一样多。第二，街机满足了一定的社交需求。在家还是一个人玩小霸王的时候居多，有的时候我宁愿再与伙伴再通几局魂斗罗或者沙罗曼蛇，也不愿去玩一些角色扮演的”大型游戏“。可能一些角色扮演的游戏剧情多，但是玩游戏嘛还是需要玩伴才玩的开心。街机就不一样的，为什么即使自己不玩也能再游戏厅里呆一天，就是因为有那个氛围在那。投了多少个币，重生多少次之后，终于干倒了别人没干倒的boss，在别人的围观下，next mission！第三点，街机操作的快感。街机加入的摇杆，带来了一种很爽快的体验。那个时候我经常看别人玩，摇杆拍来拍去，特别是玩拳皇这种特别讲究操作的游戏，结合大大的摇杆和大大的按键，更能体验到那种拳拳到肉的感觉，仿佛你按键用多大力气，就能直接传递到游戏人物的打击中一样。</p><p>上面我说的小霸王上的”大游戏“，不仅仅是价格比普通的4合1的游戏贵好几倍，而且卡带也要更大。我记得有两个游戏，一个是角色扮演游戏（当然当时我还不知道），游戏开始掉到山洞里，然后4个人物，到后期可以给每个人选择不同的职业，拥有不同的技能。遗憾的是后来在一个地方卡关了，一块巨石挡在了王宫，然后就过不去了。当时还能玲一起尝试，最后我们一致认为是游戏的bug，再后来就不了了之了。直到我买了PS4之后，才知道原来这个游戏叫最终幻想。</p><p>还有一个游戏是再我玩了塞尔达荒野之息后（这个游戏真是赞誉再多也不为过），再网上看一些游戏视频，发现了一个FC上的游戏，突然发现我玩过，最后也没通关，原因好像是迷宫太多。这个游戏叫塞尔达！</p><p>未完待续！</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;买了Play Station已经快两个月了。玩了几款PS4平台的第一方大作之后，是时候来写写自己的感受了。说起买PS4这个经历，其实有点阴差阳错。不过在这之前，我打算先说一下以前我跟游戏的前世今生。&lt;/p&gt;
    
    </summary>
    
      <category term="notes" scheme="https://bygeek.cn/categories/notes/"/>
    
    
      <category term="games" scheme="https://bygeek.cn/tags/games/"/>
    
  </entry>
  
  <entry>
    <title>windows 开发遇到的一些权限问题</title>
    <link href="https://bygeek.cn/2019/05/15/it-is-all-about-security/"/>
    <id>https://bygeek.cn/2019/05/15/it-is-all-about-security/</id>
    <published>2019-05-15T02:21:39.000Z</published>
    <updated>2020-01-31T16:23:02.631Z</updated>
    
    <content type="html"><![CDATA[<p>最近碰到一个问题，折腾了很久。因为troubleshooting的过程中沟通不畅（种种原因暂且不表），导致像个无头苍蝇一样debug。最后发现是个windows权限的问题。好了，直接说问题。</p><a id="more"></a><h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><p>问题简化为以下代码，是在windows下使用PIPE来进行进程间通信。首先看下server 端代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;Windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">message</span> &#123;</span></span><br><span class="line"><span class="keyword">int</span> id;</span><br><span class="line"><span class="keyword">char</span> data[<span class="number">8</span>];</span><br><span class="line">&#125; Message;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">HANDLE h = INVALID_HANDLE_VALUE;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span>* pipename = <span class="string">"\\\\.\\pipe\\mypipe"</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> BUFSIZE = <span class="number">1024</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> DEFAULT_TIMEOUT = <span class="number">100</span>;</span><br><span class="line"><span class="keyword">char</span> buf[<span class="number">1024</span>];</span><br><span class="line"></span><br><span class="line">h = CreateNamedPipe(</span><br><span class="line">pipename,</span><br><span class="line">PIPE_ACCESS_DUPLEX,<span class="comment">/*| FILE_FLAG_OVERLAPPED*/</span></span><br><span class="line">PIPE_TYPE_MESSAGE | PIPE_READMODE_MESSAGE,</span><br><span class="line">PIPE_UNLIMITED_INSTANCES,</span><br><span class="line">BUFSIZE,</span><br><span class="line">BUFSIZE,</span><br><span class="line">DEFAULT_TIMEOUT,</span><br><span class="line"><span class="literal">NULL</span></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (h == INVALID_HANDLE_VALUE) &#123;</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (ConnectNamedPipe(h, <span class="literal">NULL</span>)) &#123;</span><br><span class="line">DWORD read = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span> (ReadFile(h, buf, <span class="keyword">sizeof</span>(Message), &amp;read, <span class="literal">NULL</span>)</span><br><span class="line">&amp;&amp; read == <span class="keyword">sizeof</span>(Message)) &#123;</span><br><span class="line">Message* msg = <span class="keyword">reinterpret_cast</span>&lt;Message*&gt;(buf);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"get message from client: id: %d, data: %s\n"</span>, msg-&gt;id, msg-&gt;data);</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"ready to echo back!\n"</span>);</span><br><span class="line"></span><br><span class="line">DWORD written = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span> (WriteFile(h, msg, <span class="keyword">sizeof</span>(Message), &amp;written, <span class="literal">NULL</span>)</span><br><span class="line">&amp;&amp; written == <span class="keyword">sizeof</span>(Message)) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"echo back completed!\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"WriteFile failed: %d\n"</span>, GetLastError());</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"ReadFile failed: %d\n"</span>, GetLastError());</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"ConnectNamedPipe failed: %d\n"</span>, GetLastError());</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">CloseHandle(h);</span><br><span class="line"></span><br><span class="line">getchar();</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码很简单，使用WIN32 API <code>CreateNamedPipe</code>创建一个命名管道，然后等待pipe client来建立连接。收到client的message之后再echo回去。</p><p>再看下client端代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">HANDLE h = INVALID_HANDLE_VALUE;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span>* pipename = <span class="string">"\\\\.\\pipe\\mypipe"</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> BUFSIZE = <span class="number">1024</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> DEFAULT_TIMEOUT = <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line">h = CreateFile(pipename,</span><br><span class="line">GENERIC_READ | GENERIC_WRITE,</span><br><span class="line"><span class="number">0</span>,</span><br><span class="line"><span class="literal">NULL</span>,</span><br><span class="line">OPEN_EXISTING,</span><br><span class="line"><span class="number">0</span>,</span><br><span class="line"><span class="literal">NULL</span></span><br><span class="line">);</span><br><span class="line"><span class="keyword">if</span> (h == INVALID_HANDLE_VALUE) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"open pipe failed: %d\n"</span>, GetLastError());</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Message m = &#123; <span class="number">1</span>, <span class="string">"hello"</span> &#125;;</span><br><span class="line">DWORD written = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span> (WriteFile(h, &amp;m, <span class="keyword">sizeof</span>(Message), &amp;written, <span class="literal">NULL</span>)</span><br><span class="line">&amp;&amp; written == <span class="keyword">sizeof</span>(Message)) &#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"client write pipe finished\n"</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> buf[<span class="number">1024</span>];</span><br><span class="line">DWORD read = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span> (ReadFile(h, buf, <span class="keyword">sizeof</span>(Message), &amp;read, <span class="literal">NULL</span>)</span><br><span class="line">&amp;&amp; read == <span class="keyword">sizeof</span>(Message)) &#123;</span><br><span class="line">Message* msg = <span class="keyword">reinterpret_cast</span>&lt;Message*&gt;(buf);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"received message: id: %d, data: %s\n"</span>, msg-&gt;id, msg-&gt;data);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"read pipe failed: %d\n"</span>, GetLastError());</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"Write Pipe failed: %d\n"</span>, GetLastError());</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">CloseHandle(h);</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">0</span>);</span><br></pre></td></tr></table></figure><p>client代码也很简单，发起pipe connect，之后发送一个简单的message，然后收到server回复后退出。</p><p>但是在实际的生产环境中，发现client端无法连接到server端。根据GetLastError返回值是5，对应的error message是“Access Deny”。那肯定是权限问题嘛。果然，server端是使用Administrator运行的，而client端只有standard user的权限，因为Windows vista中加入的<a href="https://en.wikipedia.org/wiki/Mandatory_Integrity_Control" target="_blank" rel="noopener">Mandatory Integrity Control</a>(强制性完整性控制)，导致low integrity level的对象无法modify或者delete high integrity level的对象。</p><h3 id="什么是Integrity-Level"><a href="#什么是Integrity-Level" class="headerlink" title="什么是Integrity Level"></a>什么是Integrity Level</h3><p><a href="https://docs.microsoft.com/en-us/previous-versions/dotnet/articles/bb625957(v=msdn.10" target="_blank" rel="noopener">MSDN</a>&gt;)上如是说：</p><blockquote><p>The integrity level is a representation of the trustworthiness of running application processes and objects, such as files created by the application. The integrity mechanism provides the ability for resource managers, such as the file system, to use pre-defined policies that block processes of lower integrity, or lower trustworthiness, from reading or modifying objects of higher integrity. The integrity mechanism allows the Windows security model to enforce new access control restrictions that cannot be defined by granting user or group permissions in access control lists (ACLs).</p></blockquote><p>抛开定义，首先先visualize一下Integrity level。我们使用<a href="https://docs.microsoft.com/en-us/sysinternals/downloads/process-explorer" target="_blank" rel="noopener">process explorer</a>工具来查看，如果没有这一栏，可以在View-&gt;Select Columns-&gt;Process Image tab中勾选Integrity level。</p><img src="/2019/05/15/it-is-all-about-security/01_show_integrity_level.png"><p>我们可以看到Integrity level(以下简写为IL)分为几个等级：low, medium, high, system。根据<a href="https://docs.microsoft.com/en-us/windows/desktop/secauthz/mandatory-integrity-control" target="_blank" rel="noopener">MSDN</a>:</p><blockquote><p>Windows defines four integrity levels: low, medium, high, and system. Standard users receive medium, elevated users receive high. Processes you start and objects you create receive your integrity level (medium or high) or low if the executable file’s level is low; system services receive system integrity. Objects that lack an integrity label are treated as medium by the operating system; this prevents low-integrity code from modifying unlabeled objects. Additionally, Windows ensures that processes running with a low integrity level cannot obtain access a process which is associated with an app container.</p></blockquote><p>标准用户得到meduim IL，这意味着标准用户启动的程序或创建的内核对象都拥有medium IL，除非在程序或对象中指定其为low IL。特权用户得到high IL。系统服务得到system IL。任何其他没有声明IL 标签的，系统默认其为medium IL。windows系统会保证低IL的对象无法读写/访问高IL的对象。</p><p>摘录一张《windows via c++》第四章最后一节的图：</p><img src="/2019/05/15/it-is-all-about-security/02_integrity_level_example.png"><blockquote><p>When a piece of code tries to access a kernel object, the system compares the integrity level of the<br>calling process with the integrity level associated to the kernel object. If the latter is higher than the<br>former, modify and delete actions are denied. Notice that this comparison is done before checking<br>ACLs. So, even though the process would have the right privileges to access the resource, the fact<br>that it runs with an integrity level lower than the one required by the resource denies the requested<br>access to the object.</p></blockquote><p>简单来说，就是当访问一个内核对象的时候，系统会比较调用进程的IL和与内核对象关联的IL，如果内核对象关联的IL更高，则无法对其进行修改或者删除操作。一般可以进行读操作。</p><p>所以在上面的demo中，由于pipe server使用的是管理员用户运行的，则其创建的PIPE 内核对象拥有high 级别的IL。pipe client 使用标准用户运行，去访问pipe 内核对象时，由于只有medium 级别的IL，所以发生access deny的错误。</p><p>除了在进程间访问内核对象提供保护之外，IL还用在windows 的用户界面中，用于防止low IL的进程去修改high IL的界面。我们知道，windows提供了SendMessage和PostMessage来在窗口之间发送消息。窗体可以根据收到的消息来更新UI等。当一个low IL的进程通过SendMessage、PostMessage、SendInput发送消息给high IL的窗体时，系统会屏幕掉这类消息， 这个时候SendInput会返回0，并且GetLastError也不会显示出异常。这种机制称为<strong>User Interface Privilege Isolation</strong>（UIPI）。</p><p>这里再多说一句，一些杀毒软件，如360安全卫士会主动拦截SendMessage发出的消息。曾经就遇到过bug排查一天，最后发现是这个问题。</p><p>关于详细内容，可以参考《windows via c++》中第四章的内容，中文书名为《windows 核心编程》。</p><h3 id="什么是UAC"><a href="#什么是UAC" class="headerlink" title="什么是UAC"></a>什么是UAC</h3><h3 id="什么事ACL"><a href="#什么事ACL" class="headerlink" title="什么事ACL"></a>什么事ACL</h3><h3 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h3><ul><li><p><a href="[https://docs.microsoft.com/en-us/previous-versions/windows/it-pro/windows-server-2008-R2-and-2008/dd446675%28v%3dws.10%29](https://docs.microsoft.com/en-us/previous-versions/windows/it-pro/windows-server-2008-R2-and-2008/dd446675(v%3dws.10">What’s New in User Account Control</a>))</p></li><li><p><a href="https://social.technet.microsoft.com/wiki/contents/articles/2275.windows-security-survival-guide.aspx" target="_blank" rel="noopener">Windows Security Survival Guide</a></p></li><li><a href="https://blogs.technet.microsoft.com/yuridiogenes/2011/04/13/exploring-the-windows-security-survival-guide-integrity/" target="_blank" rel="noopener">Exploring the Windows Security Survival Guide – Integrity</a></li><li><a href="https://docs.microsoft.com/en-us/previous-versions/dotnet/articles/bb625957(v=msdn.10" target="_blank" rel="noopener">What is the Windows Integrity Mechanism?</a>&gt;)</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近碰到一个问题，折腾了很久。因为troubleshooting的过程中沟通不畅（种种原因暂且不表），导致像个无头苍蝇一样debug。最后发现是个windows权限的问题。好了，直接说问题。&lt;/p&gt;
    
    </summary>
    
      <category term="coding" scheme="https://bygeek.cn/categories/coding/"/>
    
    
      <category term="windows" scheme="https://bygeek.cn/tags/windows/"/>
    
  </entry>
  
  <entry>
    <title>使用DebugView来debug</title>
    <link href="https://bygeek.cn/2019/05/10/use-dbgviewer-to-debug-your-code/"/>
    <id>https://bygeek.cn/2019/05/10/use-dbgviewer-to-debug-your-code/</id>
    <published>2019-05-10T06:43:08.000Z</published>
    <updated>2020-01-31T16:23:02.731Z</updated>
    
    <content type="html"><![CDATA[<p>在windows开发的过程中，经常会碰到这样的问题：我们需要记录一些程序的运行期间的信息（log），但是又不想直接记录成log文件保存在用户磁盘上。一般在develop的过程中，我们会将 一些信息直接输入到console或者visual studio中的Output窗口中，但是一旦release给用户之后，我们无法获取这些信息。</p><p>That’s where DebugView COMES IN!</p><a id="more"></a><h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><p><a href="https://docs.microsoft.com/en-us/sysinternals/downloads/debugview" target="_blank" rel="noopener">DebugView</a>原来是sysinternals开发的一系列工具包中的一个，现在早已被MS收购。简单来说，这个工具可以用来显示打印到Debug output windows中的信息。比如使用WIN32 OutputDebugString中的消息在visual studio中可以在output  windows中查看的信息。但是在release build版本中，可以通过DebugView工具查看。</p><blockquote><p><em>DebugView</em> is an application that lets you monitor debug output on your local system, or any computer on the network that you can reach via TCP/IP. It is capable of displaying both kernel-mode and Win32 debug output, so you don’t need a debugger to catch the debug output your applications or device drivers generate, nor do you need to modify your applications or drivers to use non-standard debug output APIs.</p></blockquote><h3 id="DebugView能做的"><a href="#DebugView能做的" class="headerlink" title="DebugView能做的"></a>DebugView能做的</h3><blockquote><p>Under Windows 2000, XP, Server 2003 and Vista <em>DebugView</em> will capture:</p><ul><li>Win32 <strong>OutputDebugString</strong></li><li>Kernel-mode <strong>DbgPrint</strong></li><li>All kernel-mode variants of <strong>DbgPrint</strong> implemented in Windows XP and Server 2003</li></ul><p><em>DebugView</em> also extracts kernel-mode debug output generated before a crash from Window’s 2000/XP crash dump files if <em>DebugView</em> was capturing at the time of the crash.</p></blockquote><p>就是说DebugView可以抓取到程序中的OutputDebugString, DbgPrint等函数调用。在.net中，同样抓取<code>System.Diagnostic.Debug.WriteLine</code>输出的信息。</p><h3 id="基本功能"><a href="#基本功能" class="headerlink" title="基本功能"></a>基本功能</h3><p>使用DebugView很简单，只需要设置下需要capture的类型，如下图只capture win32 调用OutputDebugString的输出，capture events指的是开始/暂停 捕捉。</p><img src="/2019/05/10/use-dbgviewer-to-debug-your-code/01_set_capture_type.png"><h3 id="使用highlight高亮功能"><a href="#使用highlight高亮功能" class="headerlink" title="使用highlight高亮功能"></a>使用highlight高亮功能</h3><p>log一多久容易迷失方向，使用highlight功能，方便查找含有特定字符串的信息。注意是在include中输入通配符，然后在highlight下输入要包含的关键字，如下图。注意，在include中一般直接输入通配符*，如果想只显示包含特定字符的信息，可以输入关键字，多个关键词已；隔开。</p><h3 id="设置最多显示多少条记录"><a href="#设置最多显示多少条记录" class="headerlink" title="设置最多显示多少条记录"></a>设置最多显示多少条记录</h3><p>如下图，这样在GUI中只会显示最新的500条记录。</p><img src="/2019/05/10/use-dbgviewer-to-debug-your-code/03_maximum_record.png"><h3 id="显示PID"><a href="#显示PID" class="headerlink" title="显示PID"></a>显示PID</h3><p>在option中可以设置是否显示进程的PID，如果勾选，则在每一行中都会显示进程的PID。这个功能可以配合highlight高亮功能，用来关注特定进程的log信息。</p><img src="/2019/05/10/use-dbgviewer-to-debug-your-code/04_use_pid.png"><h3 id="查看帮助文档"><a href="#查看帮助文档" class="headerlink" title="查看帮助文档"></a>查看帮助文档</h3><p>以上只是debugview的简单功能的介绍，详细功能使用可以参考下载包里的帮助文件：dbgview.chm。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在windows开发的过程中，经常会碰到这样的问题：我们需要记录一些程序的运行期间的信息（log），但是又不想直接记录成log文件保存在用户磁盘上。一般在develop的过程中，我们会将 一些信息直接输入到console或者visual studio中的Output窗口中，但是一旦release给用户之后，我们无法获取这些信息。&lt;/p&gt;
&lt;p&gt;That’s where DebugView COMES IN!&lt;/p&gt;
    
    </summary>
    
      <category term="coding" scheme="https://bygeek.cn/categories/coding/"/>
    
    
      <category term="windows" scheme="https://bygeek.cn/tags/windows/"/>
    
  </entry>
  
  <entry>
    <title>2019-new-year</title>
    <link href="https://bygeek.cn/2019/02/11/2019-new-year/"/>
    <id>https://bygeek.cn/2019/02/11/2019-new-year/</id>
    <published>2019-02-11T02:17:25.000Z</published>
    <updated>2020-01-31T16:23:02.466Z</updated>
    
    <content type="html"><![CDATA[<p>今天初七，2019年上班第一天。</p><a id="more"></a><p>今年的计划如下：</p><h3 id="减脂"><a href="#减脂" class="headerlink" title="减脂"></a>减脂</h3><p>体重控制在69kg，全年跑量1000km。我知道这个目标其实很弱鸡，如果不出问题，应该可以很轻松的达成。但贵在坚持。坚持跑步，要对得起18年自己买的跑鞋。注意更加科学的跑步，加强自己的核心力量。</p><h3 id="书单"><a href="#书单" class="headerlink" title="书单"></a>书单</h3><p>专业书：</p><ul><li>Windows via C++</li><li>APUE</li><li>Inside the C++ Object Model</li><li>Effective STL</li><li>COM技术内幕-微软组件模型</li></ul><p>非专业书</p><ul><li>二战全史</li><li>尤瓦尔·赫拉利 三部曲：人类简史（看过了觉得还要重新看一遍），未来简史，今日简史</li><li>Kindle上ISIS的崛起</li><li>中央帝国的财政密码（去年未看完）</li></ul><h3 id="人生大事"><a href="#人生大事" class="headerlink" title="人生大事"></a>人生大事</h3><p>打算今年多关注一些房子的信息，多收集收集资料。</p><h3 id="旅游"><a href="#旅游" class="headerlink" title="旅游"></a>旅游</h3><p>暂定东南亚吧，泰国？或者重庆成都也可以，待西乡计划。</p><h3 id="工作"><a href="#工作" class="headerlink" title="工作"></a>工作</h3><p>希望可以通过慢慢参与到开源社区，贡献自己的力量。</p><h3 id="博客"><a href="#博客" class="headerlink" title="博客"></a>博客</h3><p>关于自己博客的内容，不一定是专业相关的文章，也可以是自己的见闻游记，思考等。</p><p>其他想到在补充吧。</p><p>2019/02/11 于南京</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;今天初七，2019年上班第一天。&lt;/p&gt;
    
    </summary>
    
      <category term="notes" scheme="https://bygeek.cn/categories/notes/"/>
    
    
      <category term="plan" scheme="https://bygeek.cn/tags/plan/"/>
    
  </entry>
  
  <entry>
    <title>关于神秘海域系列的玩后感</title>
    <link href="https://bygeek.cn/2019/01/31/thoughts-on-Sony-s-Uncharted-series/"/>
    <id>https://bygeek.cn/2019/01/31/thoughts-on-Sony-s-Uncharted-series/</id>
    <published>2019-01-31T05:31:30.000Z</published>
    <updated>2020-01-31T16:23:02.720Z</updated>
    
    <content type="html"><![CDATA[<p>拖延症害死人啊，这篇文章写于一个月之前吧。如今已通关神海3和资料片失落遗产。</p><a id="more"></a><p>—分割线—</p><p>上次打折（2018年圣诞促销）买了神海合集和神海4。</p><p>目前通了神海4，1和2。说下感受吧。</p><p>我先玩的4，画面真的很赞，第一次玩类似的游戏，电影大片即视感，既有点fps还有点揭秘冒险。而且个人觉得枪战，冒险和解谜都恰到好处。诶琳娜真的好美，哈哈。</p><p>后来开始玩合集，神海1感觉一直是突突突，枪战，从神海4画面过来看1的画面还是下降挺多，当然了，神海1是十几年前的老游戏，画面在现在看来也是可以理解。就是打到最后变电室出来怪物有点瘆人，有点像指环王的那个咕噜，死了好多次，把难度调到简单通关。</p><p>之前在论坛看到说神海2不错。果真，从1开始玩2的时候，电影大片即视感，而且射击可以看到子弹轨迹了，手柄反馈比1要好很多。而且剧情好太多，场面也很足，追火车，打飞机，打坦克。不过个人感觉有点不足的是，为啥非要跟1一样最后整出个怪物来？这点我还是比较喜欢4中，更现实一点。</p><p>接下来准备玩3，然后4的dlc。未完待续。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;拖延症害死人啊，这篇文章写于一个月之前吧。如今已通关神海3和资料片失落遗产。&lt;/p&gt;
    
    </summary>
    
      <category term="notes" scheme="https://bygeek.cn/categories/notes/"/>
    
    
      <category term="game" scheme="https://bygeek.cn/tags/game/"/>
    
  </entry>
  
  <entry>
    <title>2018年回顾</title>
    <link href="https://bygeek.cn/2019/01/07/2018-review/"/>
    <id>https://bygeek.cn/2019/01/07/2018-review/</id>
    <published>2019-01-07T01:54:53.000Z</published>
    <updated>2020-01-31T16:23:02.465Z</updated>
    
    <content type="html"><![CDATA[<p>2019年的元旦都过完好几天了，新年计划还一直没出来。迫于“新年新FLAG”，下面即是新年计划以及对过去一年的回顾。</p><a id="more"></a><p>一一对照下去年的计划吧。</p><blockquote><p>跑步减肥，目标是73KG</p></blockquote><p>今天早上上秤称了一下，正好达到目标。好悬！从8月底办了健身卡督促自己，一直到12月中旬，大概4个月，基本月跑量在130KM左右。自己的体重确实有下降。我也慢慢重新爱上了跑步，隔两天不跑感觉不舒服。单次距离从3K到5K到10K再到21K。10KM配速从6分半提高到5分，同时尝试了两次半马，一次2小时10分，一次1小时55分。总体来说对自己的成绩还是比较满意。但是后来右膝关节有点不舒服，跑步间隔也从一周4跑改成了一周2跑或3跑。</p><p>总的来说，下半年减重还是有效果的，也基本达到了预期，但是后面有所懈怠，当然有部分是膝关节的原因，但是个人主观上也有部分原因。</p><blockquote><p>把博客运行起来。 </p></blockquote><p>当初的计划是一周两篇博客，将自己积累的一些东西，或者遇到的一些问题，想法，记录下来，主要目的是方便自己以后查阅。开始的一两个月，确实保持这个频率更新，后来发现整理笔记成博客挺耗时间的，一般自己整理在onenote上的笔记，都是专业技术文章的剪贴，格式凌乱，自己看懂就行。一些文章要理出成自己的文字还是需要一定的时间。二来慢慢的以前的积累也慢慢消耗了。所以后来博文基本都已最近遇到问题或者看到的资料为基础。</p><p>本来博客是托管在Github上，后来趁着腾讯云搞活动，买了3年的云主机，就迁移到了腾讯云上。期间购买了域名并进行了网站备案。总的来说，这个Flag实现的还算合格吧。</p><blockquote><p>看书，专业书和自己买的两本社科书。</p></blockquote><p>这里先列下去年计划书单。</p><table><thead><tr><th>书名</th><th>完成情况</th><th>备注</th></tr></thead><tbody><tr><td>操作系统：精髓与设计原理</td><td>GOOD</td><td></td></tr><tr><td>深入理解操作系统（CSAPP）</td><td>NG</td><td>读完上一本书，发现CSAPP这本书受到推崇更多，于是又买了这本，但是没看了，估计以后这本书作为工具书查阅吧</td></tr><tr><td>程序员的自我修养–链接，装载与库</td><td>GOOD</td><td></td></tr><tr><td>C++ Primer</td><td>GOOD</td><td></td></tr><tr><td>Effective C++</td><td>GOOD</td><td>看的电子版，但是值得经常查阅，反复看</td></tr><tr><td>Effective Modern C++</td><td>ALMOST GOOD</td><td>看了大半部分，还未看完</td></tr><tr><td>COM技术内幕–微软组件对象模型</td><td>NG</td><td>未看完，看了开头</td></tr><tr><td>Inside the C++ Object Model</td><td>ALMOST GOOD</td><td>Lippman出的一本小册子，英文版，共180多页6个chapter，看了4个，算看完了大部分吧</td></tr><tr><td>深入理解Nginx</td><td>NG</td><td>看了部分，这本书当时还是跟前端的书一起买的，一直没看，后来为了折腾VPS的时候，以及阅读Nginx源码看了部分。</td></tr><tr><td>Docker入门实战</td><td>NG</td><td>看了部分</td></tr><tr><td></td><td></td><td></td></tr><tr><td>GEB</td><td>NG</td><td>当初在StackOverflow看到很多人推荐这本书，就买了，看了一章就没咋看了</td></tr><tr><td>货币金融学</td><td>NG</td><td>看了部分，金融学确实比较难啊</td></tr></tbody></table><p>去年大概是下半年才开始看专业书的。因为项目的原因，阅读了几本C++方面以及操作系统相关的书籍。好多书都是看了部分，然后因为各种各样的原因没有完整阅读完毕。</p><blockquote><p>开发一个能上线的小程序/app，或者有自己的一个开源项目。</p></blockquote><p>这个算是做的比较失败了。小程序和APP没影，就是Github上有自己的几个Toy Project，都是简单的自己学习C++写的代码。发现这个还是比较难坚持下去，动力有点不足。</p><blockquote><p>去一趟香港</p></blockquote><p>在12月份的时候去了一趟。这个也是准备了好久的事，期间从办居住证，护照，通行证，拖了很长时间。整体去香港的感受一般，住宿，交通，吃饭都挺贵的。有时间写篇博文记录下吧。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;2019年的元旦都过完好几天了，新年计划还一直没出来。迫于“新年新FLAG”，下面即是新年计划以及对过去一年的回顾。&lt;/p&gt;
    
    </summary>
    
      <category term="notes" scheme="https://bygeek.cn/categories/notes/"/>
    
    
      <category term="plan" scheme="https://bygeek.cn/tags/plan/"/>
    
  </entry>
  
  <entry>
    <title>关于正则表达式的简单总结</title>
    <link href="https://bygeek.cn/2018/12/18/personal-summary-on-regular-expression/"/>
    <id>https://bygeek.cn/2018/12/18/personal-summary-on-regular-expression/</id>
    <published>2018-12-18T08:03:31.000Z</published>
    <updated>2020-01-31T16:23:02.663Z</updated>
    
    <content type="html"><![CDATA[<p>本文记录一下正则表达式的一些语法和常见用法。以备后查。</p><p>在线regex测试网站推荐<a href="https://regex101.com" target="_blank" rel="noopener">regex101</a>。</p><p>有关regex的资料推荐: </p><ul><li><a href="https://www.regular-expressions.info/quickstart.html" target="_blank" rel="noopener">regular-expressions.info</a></li><li><a href="http://www.runoob.com/regexp/regexp-metachar.html" target="_blank" rel="noopener">runoob.com</a></li></ul><a id="more"></a><h2 id="基础概念语法"><a href="#基础概念语法" class="headerlink" title="基础概念语法"></a>基础概念语法</h2><h3 id="Text-patterns-and-Matches"><a href="#Text-patterns-and-Matches" class="headerlink" title="Text patterns and Matches"></a>Text patterns and Matches</h3><p>pattern表示一个规则。在本文中将正则表达式的Text pattern使用<code>/</code>包裹起来。如<code>/cat/</code></p><h3 id="Literal-Characters"><a href="#Literal-Characters" class="headerlink" title="Literal Characters"></a>Literal Characters</h3><p>字面量字符，最普通的一种情况。比如<code>/cat/</code>, 输入字符串<code>he catch a catfish for his cat.</code> 在字符串的第4个位置找到匹配。</p><p>如果想继续匹配。则需要设置为全局模式。<code>/cat/g</code>，则会对输入字符串进行全局搜索。</p><p>在正则表达式中有12个字符有着特殊的含义，分别是：</p><blockquote><p>the backslash <code>\</code>, the caret <code>^</code>, the dollar sign <code>$</code>, the period or dot <code>.</code>, the vertical bar or pipe symbol <code>|</code>, the question mark <code>?</code>, the asterisk or star <code>*</code>, the plus sign <code>+</code>, the opening parenthesis <code>(</code>, the closing parenthesis <code>)</code>, the opening square bracket <code>[</code>, and the opening curly brace <code>{</code></p></blockquote><p>它们也叫做<code>metacharacters</code>。这些字符如果想被当成普通字符使用，需要使用<code>\</code>进行转译。如如果你想匹配<code>1+1=2</code>，你需要的Text pattern是<code>/1\+1=2/</code></p><h3 id="Character-Classes-or-Character-Sets"><a href="#Character-Classes-or-Character-Sets" class="headerlink" title="Character Classes or Character Sets"></a>Character Classes or Character Sets</h3><p>Character Class 只能在几个字符中匹配到其中一个。比如<code>/gr[ae]y/</code>可以匹配<code>gray</code>, <code>grey</code>, 但不能匹配<code>graey</code>。可以使用hyphen（连字符-）来表示一个候选范围，如<code>/[0-9]/</code>可匹配一个数字。<code>/[a-zA-Z]/</code>可用来匹配<code>bH</code>, <code>cD</code>等。也可以单字符和连字符一起使用，如<code>/[x0-9]/</code>用来匹配字符<code>x</code>或<code>0-9</code>的数字。</p><p>在方括号里使用<code>^</code>用来表示取否。如<code>/[^abc]/</code>可匹配非a非b非c的字符，<code>/[^ ]/</code>可匹配非空格（blank space）的字符。</p><h3 id="Shorthand-Character-Classes"><a href="#Shorthand-Character-Classes" class="headerlink" title="Shorthand Character Classes"></a>Shorthand Character Classes</h3><p>正则表达式提供了一些更简便的方式（Shorthand）来匹配一些常用的字符串。注意，这些shorthand具体包含的字符跟不同的regex flavour有关。不同的flavour可能还有其他的一些shorthand。这里讲一些通用的shorhand放在下表中。</p><table><thead><tr><th>Shorthand</th><th>Equals</th><th>Match</th></tr></thead><tbody><tr><td>\d</td><td>[0-9]</td><td>digit: 0-9的数字</td></tr><tr><td>\w</td><td>[a-zA-Z0-9_]</td><td>Word character: 用于组成单词的字符，下划线和数字</td></tr><tr><td>\s</td><td>[ \t\r\n\f]</td><td>Whitespace ：空格，tab，换行符, form feed</td></tr></tbody></table><p>Shorthand也可以有shorthand。一般用大写字母来表示取否。</p><table><thead><tr><th>Negated Shorthand</th><th>Equals</th></tr></thead><tbody><tr><td>\D</td><td>[^\d]</td></tr><tr><td>\W</td><td>[^\w]</td></tr><tr><td>\S</td><td>[^\s]</td></tr></tbody></table><p>在中括号中使用Negated Shorthand需要注意。如<code>[\D\S]</code>与<code>[^\d\s]</code>表达的含义不一样。<code>[^\d\s]</code>用来匹配即不是White space又不是数字的字符，而<code>[\D\S]</code>两个条件（\D或\S）满足一个即可匹配，换句话说，<code>[\D\S]</code>可以匹配数字，whitespace或者其他字符。这里面涉及的是逻辑上与或非关系。</p><p>可以在<a href="https://regex101.com" target="_blank" rel="noopener">regex101</a>上进行在线测试每个shorthand代表的简写。</p><img src="/2018/12/18/personal-summary-on-regular-expression/regex101.png"><h3 id="Non-Printable-Characters"><a href="#Non-Printable-Characters" class="headerlink" title="Non-Printable Characters"></a>Non-Printable Characters</h3><p>在正则表达式中可以使用特殊字符来匹配不可打印字符。</p><table><thead><tr><th>pattern</th><th>match</th><th>pattern</th><th>match</th></tr></thead><tbody><tr><td>\t</td><td>tab字符（ASCII 0x09）</td><td>\r</td><td>carriage return(0x0D)</td></tr><tr><td>\n</td><td>line feed(0x0A)</td><td>\f</td><td>form feed(0x0C)</td></tr></tbody></table><p>需要注意的是，在windows上使用<code>\r\n</code>来用作line break, 而unix上是<code>\n</code>.</p><h3 id="The-Dot-matches-Almost-any-character"><a href="#The-Dot-matches-Almost-any-character" class="headerlink" title="The Dot matches (Almost) any character"></a>The Dot matches (Almost) any character</h3><p><code>.</code>可以匹配除了line break之外的所有字符。如<code>/gr.y/</code>可以匹配<code>gray</code>, <code>grey</code>, <code>/gr%y</code>. 谨慎的使用dot 字符。因为使用Character class匹配的速度回更快也更精确.</p><h3 id="Anchors"><a href="#Anchors" class="headerlink" title="Anchors"></a>Anchors</h3><blockquote><p>Anchors do not match any characters. They match a position.</p></blockquote><p>Anchors（锚）用来匹配一个位置。<code>^</code>用于匹配输入字符串的开始位置，<code>$</code>用于匹配输入字符串的结束位置。在<code>multi-line</code>模式下，<code>^</code>用来匹配每一行的开始位置，<code>$</code>用来匹配每一行的结束位置。如<code>/^a/</code>可以匹配<code>abc</code>中的a，但是再<code>bca</code>中找不到匹配。</p><p><code>\b</code>用来匹配word boundary。</p><blockquote><p>A word boundary is a position between a character that can be matched by <code>\w</code> and a character that cannot be matched by <code>\w</code></p></blockquote><p><code>\B</code>正好相反，用来匹配<code>\b</code>无法匹配的地方。</p><p>更多的内容相关请参考: <a href="https://www.regular-expressions.info/anchors.html" target="_blank" rel="noopener">Learn more about anchors</a>.</p><h3 id="Alternation"><a href="#Alternation" class="headerlink" title="Alternation"></a>Alternation</h3><p>Alternation相当于正则表达式中的”或”。如<code>/cat|dog/</code>匹配<code>cat and dogs</code>中的<code>cat</code>,如果再次匹配（如使用global模式），才会再次匹配到<code>dog</code>.</p><p>Alternation在正则表达式中的操作符中优先级最低。如<code>cat|dog food</code>可以用来匹配<code>cat</code>或者<code>dog food</code>。如果想要匹配<code>cat food</code>或者<code>dog food</code>，需要使用捕获组<code>(cat|dog)food</code>.</p><h3 id="Repetition"><a href="#Repetition" class="headerlink" title="Repetition"></a>Repetition</h3><ul><li><p>quantifier <code>?</code>用来使得前面的token最多可以出现一次（0次或一次）。如<code>colou?r</code>匹配<code>colour</code>或<code>color</code> .</p></li><li><p>quantifier <code>*</code>用来使得前面的token出现0次，一次，或多次。</p></li><li><p>quentifier <code>+</code>用来使得前面的token至少出现一次（一次或多次）。</p></li><li><p>使用大括号<code>{}</code>用来表示前面的token出现特定次数。如<code>/\b[1-9][0-9]{3}\b/</code>匹配<code>1000-9999</code>的数字.</p></li></ul><p><code>/\b[1-9][0-9]{2,4}\b/</code>匹配100-9999.</p><h3 id="Greedy-and-Lazy-Repetition"><a href="#Greedy-and-Lazy-Repetition" class="headerlink" title="Greedy and Lazy Repetition"></a>Greedy and Lazy Repetition</h3><p>Repetition的匹配符都是“贪婪”的，他们会尽可能多的匹配，返回尽可能长的匹配字符串。如<code>/&lt;.+&gt;/</code>在输入字符串为<code>This is a &lt;EM&gt;first&lt;/EM&gt; test</code>中返回的匹配字符串为<code>&lt;EM&gt;first&lt;/EM&gt;</code>。</p><p>在<code>+</code>之后使用<code>?</code>使得匹配变为lazy. 使用<code>/&lt;.+?&gt;/</code>来匹配上面的字符串，则返回的是<code>&lt;EM&gt;</code>.</p><p>更好的方式是使用dot 运算符。</p><blockquote><p>Use <code>&lt;[^&lt;&gt;]+&gt;</code> to quickly match an HTML tag without regard to attributes. The negated character class is more specific than the dot, which helps the regex engine find matches quickly.</p></blockquote><h3 id="Grouping-and-Capturing"><a href="#Grouping-and-Capturing" class="headerlink" title="Grouping and Capturing"></a>Grouping and Capturing</h3><p>使用<code>()</code>来对多个字符进行分组，可以使用repetition运算符来修饰分组。如<code>/set(value)?/ 可以匹配</code>set<code>或</code>setvalue`.</p><p>使用小括号分组即创建了一个捕获组。上面的例子有一个分组，如果匹配set，则group1什么都没有，如果匹配setvalue，则group1是<code>value</code>。group0总是整个匹配的字符串。至于如何访问group，这个跟你使用的编程语言有关。</p><p>创建捕获组之后，可以使用backreference来引用捕获组。backreference即使用backslash和group number来表示捕获组的内容。</p><p>如<code>/([abc])=\1/</code>可以匹配<code>a=a</code>,或<code>b=b</code>，或<code>c=c</code></p><p>如果你只想分组不想创建捕获组可以使用<code>(？:)?</code>。如上面的例子，<code>set(?:value)?</code>, 这样只会创建分组，但不会创建捕获组。这样做的目的可以使得正则表达式匹配更快，性能更高。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文记录一下正则表达式的一些语法和常见用法。以备后查。&lt;/p&gt;
&lt;p&gt;在线regex测试网站推荐&lt;a href=&quot;https://regex101.com&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;regex101&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;有关regex的资料推荐: &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://www.regular-expressions.info/quickstart.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;regular-expressions.info&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://www.runoob.com/regexp/regexp-metachar.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;runoob.com&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="coding" scheme="https://bygeek.cn/categories/coding/"/>
    
    
      <category term="regex" scheme="https://bygeek.cn/tags/regex/"/>
    
  </entry>
  
  <entry>
    <title>在VS C++工程中使用Auto versionning</title>
    <link href="https://bygeek.cn/2018/12/17/auto-versioning-in-cpp-project/"/>
    <id>https://bygeek.cn/2018/12/17/auto-versioning-in-cpp-project/</id>
    <published>2018-12-17T08:12:33.000Z</published>
    <updated>2020-01-31T16:23:02.525Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://bygeek.cn/2018/04/04/automatic-versionning-in-visual-studio/">前面</a>我已经总结了在csharp中如何auto versionning来管理Assembly的版本号。本文总结一下在C++下如何方便的管理DLL的版本号。</p><a id="more"></a><h3 id="遇到的问题"><a href="#遇到的问题" class="headerlink" title="遇到的问题"></a>遇到的问题</h3><p>首先明确一下本文要解决的问题：</p><blockquote><p>在一个C++ solution中实现DLL或者EXE共享同一个版本号。</p></blockquote><p>既然要共享同一个版本号，那么最简单的类似csharp中的共享同一个AssemblyInfo文件了。csharp工程可以通过Add as Link方式将一个文件共享给其他project。在C++ project中自然也可以通过Add Existing File来实现这个目的。不过在VS2015之后Visual Studio支持了Shared Project Template。那么可以将version的信息放在Shared Project中，这样修改起来也方便。</p><h3 id="解决办法"><a href="#解决办法" class="headerlink" title="解决办法"></a>解决办法</h3><p>在C++ project中version信息是放在Resource.rc中的。</p><p>假设现在我们的代码结构是这样的：</p><blockquote><p>solution</p><p>+– project1</p><p>+– project2</p><p>+– sharedproject</p></blockquote><p>首先我们给project1和project2工程建立Resource文件。</p><blockquote><p>Project-&gt; Add-&gt;Resource-&gt;Version-&gt;New</p></blockquote><p>右击生成的Resource.rc文件, 选择View Code，滑动到Version部分。可以看到Version信息。</p><p>接下来在sharedproject中建立一个头文件verson.h</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> STRINGIZE2(s) #s   <span class="comment">//stringizing operator</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> STRINGIZE(s) STRINGIZE2(s)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> VERSION_MAJOR               1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> VERSION_MINOR               0</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> VERSION_REVISION            0</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> VERSION_BUILD               0</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//#define VER_FILE_DESCRIPTION_STR    "Description"  //decription和productionname各自独立，需要单独定义</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> VER_FILE_VERSION            VERSION_MAJOR, VERSION_MINOR, VERSION_REVISION, VERSION_BUILD</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> VER_FILE_VERSION_STR        STRINGIZE(VERSION_MAJOR)        \</span></span><br><span class="line">                                    <span class="string">"."</span> STRINGIZE(VERSION_MINOR)    \</span><br><span class="line">                                    <span class="string">"."</span> STRINGIZE(VERSION_REVISION) \</span><br><span class="line">                                    <span class="string">"."</span> STRINGIZE(VERSION_BUILD)    \</span><br><span class="line"></span><br><span class="line"><span class="comment">//#define VER_PRODUCTNAME_STR         "c_version_binary"</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> VER_PRODUCT_VERSION         VER_FILE_VERSION</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> VER_PRODUCT_VERSION_STR     VER_FILE_VERSION_STR</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> VER_ORIGINAL_FILENAME_STR   VER_PRODUCTNAME_STR <span class="meta-string">".exe"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> VER_INTERNAL_NAME_STR       VER_ORIGINAL_FILENAME_STR</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> VER_COPYRIGHT_STR           <span class="meta-string">"Copyright (C) 2011"</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> _DEBUG</span></span><br><span class="line">  <span class="meta">#<span class="meta-keyword">define</span> VER_VER_DEBUG             VS_FF_DEBUG</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">  <span class="meta">#<span class="meta-keyword">define</span> VER_VER_DEBUG             0</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> VER_FILEOS                  VOS_NT_WINDOWS32</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> VER_FILEFLAGS               VER_VER_DEBUG</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> VER_FILETYPE                VFT_APP</span></span><br><span class="line"><span class="comment">//注意，这里需要有一个空行，否则在resource中include这个头文件会报"unexpected end of file"错误</span></span><br></pre></td></tr></table></figure><p>然后分别在project1和project2的Resource 属性中将Additional Include Directory将version.h的路径加进去。</p><blockquote><p>Project Property -&gt;Resource -&gt; General -&gt; Additional Include Directories</p></blockquote><p>注意是Resource选项卡，不是C++选项卡中的设置。</p><p>然后分别对project1和project2的Resource文件做如下操作：</p><ul><li><p>include version.h，定义description和product name</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Microsoft Visual C++ generated resource script.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"resource.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> VER_PRODUCTNAME_STR         <span class="meta-string">"product_name_here"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> VER_FILE_DESCRIPTION_STR    <span class="meta-string">"description_here"</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"version.h"</span></span></span><br></pre></td></tr></table></figure></li><li><p>替换version section</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/////////////////////////////////////////////////////////////////////////////</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Version</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line">VS_VERSION_INFO VERSIONINFO</span><br><span class="line"> FILEVERSION        VER_FILE_VERSION</span><br><span class="line"> PRODUCTVERSION     VER_PRODUCT_VERSION</span><br><span class="line"> FILEFLAGSMASK      <span class="number">0x3f</span>L</span><br><span class="line"> FILEFLAGS          VER_FILEFLAGS</span><br><span class="line"> FILEOS             VER_FILEOS</span><br><span class="line"> FILETYPE           VER_FILETYPE</span><br><span class="line"> FILESUBTYPE        <span class="number">0x0</span>L</span><br><span class="line">BEGIN</span><br><span class="line">    BLOCK <span class="string">"StringFileInfo"</span></span><br><span class="line">    BEGIN</span><br><span class="line">        BLOCK <span class="string">"040904b0"</span></span><br><span class="line">        BEGIN</span><br><span class="line">            VALUE <span class="string">"FileDescription"</span>,  VER_FILE_DESCRIPTION_STR <span class="string">"\0"</span></span><br><span class="line">            VALUE <span class="string">"FileVersion"</span>,      VER_FILE_VERSION_STR <span class="string">"\0"</span></span><br><span class="line">            VALUE <span class="string">"InternalName"</span>,     VER_INTERNAL_NAME_STR <span class="string">"\0"</span></span><br><span class="line">            VALUE <span class="string">"LegalCopyright"</span>,   VER_COPYRIGHT_STR <span class="string">"\0"</span></span><br><span class="line">            VALUE <span class="string">"OriginalFilename"</span>, VER_ORIGINAL_FILENAME_STR <span class="string">"\0"</span></span><br><span class="line">            VALUE <span class="string">"ProductName"</span>,      VER_PRODUCTNAME_STR</span><br><span class="line">            VALUE <span class="string">"ProductVersion"</span>,   VER_PRODUCT_VERSION_STR <span class="string">"\0"</span></span><br><span class="line">        END</span><br><span class="line">    END</span><br><span class="line">    BLOCK <span class="string">"VarFileInfo"</span></span><br><span class="line">    BEGIN</span><br><span class="line">        VALUE <span class="string">"Translation"</span>, <span class="number">0x409</span>, <span class="number">1200</span></span><br><span class="line">    END</span><br><span class="line">END</span><br></pre></td></tr></table></figure></li></ul><p>Build一下工程，并修改version.h头文件，看project1和project2的版本号是否是version里设置的版本号。</p><p>下次如果要修改版本号，就不用一个个去改每个工程的resource.rc文件了，直接修改version.h即可。</p><h3 id="进阶"><a href="#进阶" class="headerlink" title="进阶"></a>进阶</h3><p>上面的方法需要每次都手动修改version信息，可以利用visual studio中的Build Event自动将version.h信息更新。Share Project Template不支持VS project Build Event，可以将其换正常的Project类型。</p><p>具体请参考Code Project的一篇文章：<a href="https://www.codeproject.com/Articles/10313/Automatic-Build-Versioning-in-Visual-Studio" target="_blank" rel="noopener">Automatic Build Versioning in Visual Studio</a>.</p><h3 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h3><ul><li><a href="https://www.zachburlingame.com/2011/02/versioning-a-native-cc-binary-with-visual-studio/" target="_blank" rel="noopener">Versioning a Native C/C++ Binary with Visual Studio</a></li><li><a href="http://www.cplusplus.com/forum/windows/64819/" target="_blank" rel="noopener">unexpected end of file found</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;https://bygeek.cn/2018/04/04/automatic-versionning-in-visual-studio/&quot;&gt;前面&lt;/a&gt;我已经总结了在csharp中如何auto versionning来管理Assembly的版本号。本文总结一下在C++下如何方便的管理DLL的版本号。&lt;/p&gt;
    
    </summary>
    
      <category term="coding" scheme="https://bygeek.cn/categories/coding/"/>
    
    
      <category term="C++" scheme="https://bygeek.cn/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>C++ 中的智能指针</title>
    <link href="https://bygeek.cn/2018/12/04/smart-pointer-in-c-plus-plus/"/>
    <id>https://bygeek.cn/2018/12/04/smart-pointer-in-c-plus-plus/</id>
    <published>2018-12-04T05:58:59.000Z</published>
    <updated>2020-01-31T16:23:02.715Z</updated>
    
    <content type="html"><![CDATA[<p>C++ 11中共有四种智能指针(Smart Pointers)：<code>std::auto_ptr</code>,<code>std::unique_ptr</code>,<code>std::shared_ptr</code>,<code>std::weak_ptr</code>。其中<code>std::auto_ptr</code>是在C++98中就引入的智能指针，在C++11中已经被<code>std::unique_ptr</code>所取代。所以本文主要讨论讨论剩下的三种智能指针。</p><a id="more"></a><h3 id="为什么要使用智能指针？"><a href="#为什么要使用智能指针？" class="headerlink" title="为什么要使用智能指针？"></a>为什么要使用智能指针？</h3><p>不像C#/Java等语言拥有垃圾回收机制，C++必须靠程序员自己申请和释放内存。这样就给内存泄漏带来了机会。智能指针就是为了解决可能的内存泄漏的风险而设计的。在C++中局部变量在离开作用域之后，编译器会自动调用变量的析构函数对其进行析构，即使在发生异常的情况下也可以保证对象被析构。</p><p>智能指针其实就是贯彻了<a href="https://en.wikipedia.org/wiki/Resource_acquisition_is_initialization" target="_blank" rel="noopener"><strong>RAII</strong></a>(Resource acquisition is initialization)的思想。将Raw Pointer作为资源托管起来，在离开作用域之后，自动调用Raw pointer的deletor。智能指针就是对象。</p><p>查看智能指针的头文件: memory，这里摘录下MSVC的实现：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// DECLARATIONS</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> _<span class="title">Ty</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">struct</span> <span class="title">default_delete</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> _<span class="title">Ty</span>,</span></span><br><span class="line"><span class="class"><span class="title">class</span> _<span class="title">Dx</span> = <span class="title">default_delete</span>&lt;_Ty&gt;&gt;</span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">unique_ptr</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> _<span class="title">Ty</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">shared_ptr</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> _<span class="title">Ty</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">weak_ptr</span>;</span></span><br></pre></td></tr></table></figure><p>可以看到三种智能指针被声明为带有模板参数的类，其中unique_ptr带有两个模板参数，shared_ptr和weak_ptr都只有一个模板参数。</p><p>下面我们来分别详细来分析下三种智能指针的使用场景和一些注意事项。</p><h3 id="std-unique-ptr"><a href="#std-unique-ptr" class="headerlink" title="std::unique_ptr"></a>std::unique_ptr</h3><p>当需要使用智能指针时，<code>std::unique_ptr</code>应该作为首选，用来表达对资源的专属所有权。</p><p>当使用默认deletor时，<code>std::unique_ptr</code>跟裸指针尺寸相同，这意味着不会带来memory overhead。一个非空的<code>std::unique_ptr</code>总是指向涉及的资源。移动一个<code>std::unique_ptr</code>会将所有权将源指针移至目标指针(源指针被置空)。<code>std::unique_ptr</code>不支持复制操作。</p><h4 id="创建std-unique-ptr的方法"><a href="#创建std-unique-ptr的方法" class="headerlink" title="创建std::unique_ptr的方法"></a>创建std::unique_ptr的方法</h4><p>我们可以用以下方式来创建<code>std::unique_ptr</code>。</p><ul><li>通过C++14 引入的标准make函数<code>std::make_unique</code></li><li>直接接管newly allocated object</li><li>创建自己的make函数</li></ul><p>举例如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;memory&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MY_PRINT std::cout&lt;&lt; __FUNCTION__ &lt;&lt; std::endl;</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Investment</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">Investment(<span class="keyword">const</span> <span class="keyword">char</span>* name) : m_name(<span class="keyword">new</span> <span class="keyword">char</span>[<span class="number">128</span>])&#123;</span><br><span class="line">strcpy_s(m_name, <span class="number">128</span>, name);</span><br><span class="line">MY_PRINT;</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">virtual</span> ~Investment() &#123;</span><br><span class="line"><span class="keyword">delete</span> m_name;</span><br><span class="line">MY_PRINT;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line"><span class="keyword">char</span>* m_name;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Stock</span> :</span> <span class="keyword">public</span> Investment &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">Stock(<span class="keyword">const</span> <span class="keyword">char</span>* name) : Investment(name)&#123;</span><br><span class="line">MY_PRINT;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">~Stock() &#123;</span><br><span class="line">MY_PRINT;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;Investment&gt; makeInvestment() &#123;</span><br><span class="line"><span class="comment">//in c++ 11</span></span><br><span class="line"><span class="comment">//std::unique_ptr&lt;Stock&gt; stock(new Stock("hello"));</span></span><br><span class="line"><span class="comment">//return stock;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;Stock&gt;(<span class="keyword">new</span> Stock(<span class="string">"hello"</span>));  <span class="comment">//newly allocated object是一个右值</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;Investment&gt; makeInvestment2() &#123;</span><br><span class="line"><span class="comment">//in c++ 14</span></span><br><span class="line"><span class="keyword">return</span> <span class="built_in">std</span>::make_unique&lt;Stock&gt;(<span class="string">"hello"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在C++11中，由于没有引入unique_ptr的make函数，我们应该直接从new object接管pointer的控制权。如果使用以下方式来创建unique_ptr，会增加内存泄漏的风险。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> ptr = <span class="keyword">new</span> Stock(<span class="string">"hello"</span>);</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;Investment&gt; pInvest(ptr);</span><br></pre></td></tr></table></figure><p>通过左值来初始化一个unique_ptr不是一个好的选择，因为ptr这个裸指针有可能会被delete掉，而pInvest在析构的时候会再次delete 裸指针，这时会造成未定义行为。</p><p>Best practice是通过make函数来创建智能指针。如果使用的是C++11，还有一种方式是创建自定义的make函数。如下是一个简单的版本。当然了，也可以直接去标准库中copy make_unique函数的实现代码。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> ... Args&gt;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;T&gt; make_unique(Args&amp;&amp;... params) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;T&gt;(<span class="keyword">new</span> T(<span class="built_in">std</span>::forward&lt;Args&gt;(params)...));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="自定义deletor"><a href="#自定义deletor" class="headerlink" title="自定义deletor"></a>自定义deletor</h4><p>我们也可以为unique_ptr自定义deletor。有以下两种方式：</p><ul><li>函数对象，如lambda表达式</li><li>函数指针</li></ul><p>举例如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//use lambda expression</span></span><br><span class="line"><span class="keyword">auto</span> delInvest = [](Investment* pInvestment) &#123;</span><br><span class="line"><span class="comment">//do something</span></span><br><span class="line"><span class="keyword">delete</span> pInvestment;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;Investment, <span class="keyword">decltype</span>(delInvest)&gt; ptr(<span class="keyword">new</span> Stock(<span class="string">"hello"</span>), delInvest);</span><br><span class="line"></span><br><span class="line"><span class="comment">//use function pointer</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">delInv</span><span class="params">(Investment* pInvestment)</span> </span>&#123;</span><br><span class="line"><span class="keyword">delete</span> pInvestment;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;Investment, <span class="keyword">void</span>(*)(Investment* pInvestment)&gt; ptr2(<span class="keyword">new</span> Stock(<span class="string">"hello"</span>), delInv);</span><br><span class="line"></span><br><span class="line"><span class="comment">//或者使用decltype</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;Investment, <span class="keyword">decltype</span>(&amp;delInv)&gt; ptr2(<span class="keyword">new</span> Stock(<span class="string">"hello"</span>), delInv);</span><br></pre></td></tr></table></figure><p>一般来说对于std::unique_ptr，在默认deletor的情况下，unique_ptr和裸指针的大小一样，但是使用自定义的deletor之后，情况变得有所不同。如果自定义的deletor是函数指针，则unique_ptr的大小会至少增加一个函数指针的大小。如果是函数对象，则带来的尺寸变化取决于函数对象中存储了多少状态。无状态的函数对象，如无捕获的lambda表达式不会浪费任何尺寸。 </p><p>这意味着一个自定义deletor可以用函数指针也可以使用无捕获的lambda表达式时，lambda表达式是更好的选择。</p><p>注意，自定义deletor必须是一个directly-callable object，如果想让一个member function作为deletor的话，可以使用<code>std::mem_fn</code>将其转化为函数对象。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;functional&gt; //for std::mem_fn</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;memory&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> Investment::release()&#123;  <span class="comment">//release is a member function</span></span><br><span class="line">    <span class="comment">//do something</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;Investment, <span class="keyword">decltype</span>(<span class="built_in">std</span>::mem_fn(&amp;Investment::release))&gt; pInvest(<span class="keyword">new</span> Stock(<span class="string">"hello"</span>), <span class="built_in">std</span>::mem_fn(&amp;Investment::release));</span><br></pre></td></tr></table></figure><h4 id="转化为shared-ptr"><a href="#转化为shared-ptr" class="headerlink" title="转化为shared_ptr"></a>转化为shared_ptr</h4><p><code>std::unique_ptr</code>可以很方便的转换为<code>std::shared_ptr</code>，所以适合作为工厂函数的返回型别。具体可以参考《Modern Effective C++》 item18。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>&gt; unique = <span class="built_in">std</span>::make_unique&lt;<span class="built_in">std</span>::<span class="built_in">string</span>&gt;(<span class="string">"test"</span>);</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>&gt; shared = <span class="built_in">std</span>::move(unique);</span><br><span class="line"></span><br><span class="line"><span class="comment">//or</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>&gt; shared = <span class="built_in">std</span>::make_unique&lt;<span class="built_in">std</span>::<span class="built_in">string</span>&gt;(<span class="string">"test"</span>);</span><br></pre></td></tr></table></figure><h4 id="auto-ptr-vs-unique-ptr"><a href="#auto-ptr-vs-unique-ptr" class="headerlink" title="auto_ptr vs unique_ptr"></a>auto_ptr vs unique_ptr</h4><p>在C98标准的时候，由于没有移动语义（move sematic），引入了auto_ptr来表示对资源的所有权。在表示所有权转移的时候，auto_ptr实际是通过拷贝操作来实现的。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">auto_ptr</span>&lt;Stock&gt; ap(<span class="keyword">new</span> Stock(<span class="string">"hello"</span>));</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">auto_ptr</span>&lt;Stock&gt; ap2 = ap;  <span class="comment">//compile success, while unique_ptr don't</span></span><br><span class="line"></span><br><span class="line">ap-&gt;foo();  <span class="comment">//crash because ap is set to NULL</span></span><br></pre></td></tr></table></figure><p>通过auto_ptr的拷贝赋值运算符之后，ap已经置为了NULL，无法再使用ap2。</p><p>在使用unique_ptr时，由于unique_ptr将copy ctor和copy assign operator声明为delete function，所以编译无法通过。如果想转移资源的所有权，必须使用<code>std::move</code>（位于utility头文件）。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;Stock&gt; up(<span class="keyword">new</span> Stock(<span class="string">"hello"</span>));</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;Stock&gt; up1 = <span class="built_in">std</span>::move(up);  <span class="comment">//use std::move to explicitly transfer ownership, and up is empty, can not use it again</span></span><br><span class="line"></span><br><span class="line">up.foo();  <span class="comment">//crash, can not use up again because ownership has transferred to up1</span></span><br></pre></td></tr></table></figure><h4 id="unique-ptr-源码剖析"><a href="#unique-ptr-源码剖析" class="headerlink" title="unique_ptr 源码剖析"></a>unique_ptr 源码剖析</h4><p>从上面unique_ptr的声明可以看到unique_ptr的类型中第二个模板参数默认时一个<code>default_delete</code>。查看其源码发现<code>default_delete</code>就是一个定义了函数调用运算符的函数对象:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> _<span class="title">Ty</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">struct</span> <span class="title">default_delete</span></span></span><br><span class="line"><span class="class">&#123;</span><span class="comment">// default deleter for unique_ptr</span></span><br><span class="line"><span class="function"><span class="keyword">constexpr</span> <span class="title">default_delete</span><span class="params">()</span> <span class="keyword">noexcept</span> </span>= <span class="keyword">default</span>;</span><br><span class="line">        <span class="comment">//...省略部分</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">(_Ty * _Ptr)</span> <span class="keyword">const</span> <span class="keyword">noexcept</span></span></span><br><span class="line"><span class="function"></span>&#123;<span class="comment">// delete a pointer</span></span><br><span class="line"><span class="keyword">static_assert</span>(<span class="number">0</span> &lt; <span class="keyword">sizeof</span> (_Ty),</span><br><span class="line"><span class="string">"can't delete an incomplete type"</span>);</span><br><span class="line"><span class="keyword">delete</span> _Ptr;  <span class="comment">//调用delete</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>在函数调用中直接调用delete，delete操作会调用_Ty类型的析构函数。这就是unique_ptr的默认析构所做的事。再看下unique_ptr的具体定义：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> _<span class="title">Ty</span>,</span></span><br><span class="line"><span class="class"><span class="title">class</span> _<span class="title">Dx</span>&gt;// = <span class="title">default_delete</span>&lt;_Ty&gt;</span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">unique_ptr</span></span></span><br><span class="line"><span class="class">:</span> <span class="keyword">public</span> _Unique_ptr_base&lt;_Ty, _Dx&gt;</span><br><span class="line">&#123;<span class="comment">// non-copyable pointer to an object</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="comment">//...省略</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>unique_ptr继承自<code>_Unique_ptr_base&lt;_Ty, _Dx&gt;</code>，继续看<code>_Unique_ptr_base&lt;_Ty, _Dx&gt;</code>的代码，其中包含一个成员变量：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">_Compressed_pair&lt;_Dx, pointer&gt; _Mypair;</span><br></pre></td></tr></table></figure><p>这里的pointer就是unique_ptr实际的对象的指针。接着在头文件<code>xutility</code>中可以看到<code>_Compressed_pair</code>的两个定义：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//定义1</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> _<span class="title">Ty1</span>,</span></span><br><span class="line"><span class="class"><span class="title">class</span> _<span class="title">Ty2</span>,</span></span><br><span class="line"><span class="class"><span class="title">bool</span> = <span class="title">is_empty_v</span>&lt;_Ty1&gt; &amp;&amp; !<span class="title">is_final_v</span>&lt;_Ty1&gt;&gt;</span></span><br><span class="line"><span class="class"><span class="title">class</span> _<span class="title">Compressed_pair</span> <span class="title">final</span></span></span><br><span class="line"><span class="class">:</span> <span class="keyword">private</span> _Ty1</span><br><span class="line">&#123;<span class="comment">// store a pair of values, deriving from empty first</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">_Ty2 _Myval2;</span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> _Mybase = _Ty1;<span class="comment">// for visualization</span></span><br><span class="line"><span class="comment">//...省略</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//定义2</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> _<span class="title">Ty1</span>,</span></span><br><span class="line"><span class="class"><span class="title">class</span> _<span class="title">Ty2</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">class</span> _<span class="title">Compressed_pair</span>&lt;_Ty1, _Ty2, false&gt; <span class="title">final</span></span></span><br><span class="line"><span class="class">&#123;</span><span class="comment">// store a pair of values, not deriving from first</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">_Ty1 _Myval1;</span><br><span class="line">_Ty2 _Myval2;</span><br><span class="line">        <span class="comment">//...省略</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>这两个定义的区别直观上来说声明的内部成员变量不同，一个只有一个实际对象的指针（_Ty2）,另外一个不仅有_Ty2，还包含deletor类型变量。换句话说，这个区别影响了unique_ptr指针所占用的内存大小。</p><p><code>_Ty1</code>就是<code>_Dx</code>，也就是deletor的类型，<code>_Ty2</code>也就是unique_ptr实际指向的对象的指针。这里应该是通过重载的机制，让编译器去选择实例化哪个<code>_Compressed_pair</code>模板的代码。这个判断条件就是:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">is_empty_v&lt;_Ty1&gt; &amp;&amp; !is_final_v&lt;_Ty1&gt;</span><br></pre></td></tr></table></figure><p>查询cpp reference可以<code>is_empty_v</code>用来标识类是否是一个empty类</p><blockquote><p>Trait class that identifies whether <em>T</em> is an empty class.</p><p>An empty class is a class that stores no data, either cv-qualified or not.  </p></blockquote><p><code>is_final_v</code>用来标识是否是final类（使用final关键字声明类）。</p><p>至此我们可以看到unique_ptr所占空间的大小跟deletor有关，如果使用默认的deletor，则显然<code>default_delete</code>是一个空类，那么unique_ptr跟裸指针具有相同的大小。而如果自定义的deletor（可以理解为function object）包含了其他的data，则unique_ptr的大小是裸指针和function object占用大小之和。</p><h3 id="std-shared-ptr"><a href="#std-shared-ptr" class="headerlink" title="std::shared_ptr"></a>std::shared_ptr</h3><h4 id="控制块"><a href="#控制块" class="headerlink" title="控制块"></a>控制块</h4><p>和<code>std::unique_ptr</code>用来表示对资源的独占性相反，<code>std::shared_ptr</code>用来表示对资源的共享。创建的shared_ptr对象共享同一个资源。shared_ptr在内部实现使用引用计数的方式。每个<code>shared_ptr&lt;T&gt;</code>对象都包含两个部分，一个是指向T型别对象的指针，一个是指向控制块的指针，如下图：</p><img src="/2018/12/04/smart-pointer-in-c-plus-plus/shared_ptr%20memory%20layout.png"><p>很显然，从shared_ptr的memory layout可以看到，shared_ptr的大小为裸指针的两倍。</p><p>注意：<strong>必须保证对同一个资源只创建一个控制块</strong>。因为当控制块中的引用计数为0时，资源被销毁。如果违反了这个约定，资源会被“销毁两次”，也就是说会造成未定义行为。控制块需要动态分配。控制块的创建遵循以下规则：</p><ul><li>std::make_shared总是创建一个控制块</li><li>从具备专属所有权的指针(即unique_ptr或auto_ptr指针)出发构造一个shared_ptr时，会创建一个控制块。</li><li>使用裸指针作为实参来调用（创建）shared_ptr时，会创建一个控制块。如果使用shared_ptr或者weak_ptr来创建shared_ptr，则不会创建控制块。</li></ul><h4 id="创建std-shared-ptr"><a href="#创建std-shared-ptr" class="headerlink" title="创建std::shared_ptr"></a>创建std::shared_ptr</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Stock和Investment接上面unique_ptr中的定义</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//通过make函数构造</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;Stock&gt; ptr = <span class="built_in">std</span>::make_shared&lt;Stock&gt;(<span class="string">"hello"</span>);  <span class="comment">//创建一个控制块</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//通过传递右值构造</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;Stock&gt; ptr(<span class="keyword">new</span> Stock(<span class="string">"hello"</span>));  <span class="comment">//创建一个控制块</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//bad code: 通过裸指针，左值构造</span></span><br><span class="line"><span class="keyword">auto</span> raw_ptr = <span class="keyword">new</span> Stock(<span class="string">"hello"</span>);</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;Stock&gt; ptr1(raw_ptr);  <span class="comment">//为raw_ptr创建了一个控制块</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;Stock&gt; ptr2(raw_ptr);  <span class="comment">//又创建了一个控制块，在析构时，会造成未定义行为。</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;Stock&gt; ptr3(ptr1);  <span class="comment">//从一个已有的shared_ptr创建另一个shared_ptr，调用shared_ptr的copy ctor，不会再次创建控制块，</span></span><br></pre></td></tr></table></figure><p>Best Practice是使用make函数来构造shared_ptr。最后的例子通过裸指针来构造，会为同一个资源创建两个控制块，也就是会有两个引用计数，当一个引用计数为0时，会发生析构，这样会对同一个资源析构两次，造成未定义行为。</p><h4 id="自定义deletor-1"><a href="#自定义deletor-1" class="headerlink" title="自定义deletor"></a>自定义deletor</h4><p>在unique_ptr的类型中，自定义的deletor是作为一个模板参数，所以deletor的型别是作为unique_ptr型别的一部分的，而shared_ptr则不一样。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">delete_stock</span><span class="params">(Stock* s)</span> </span>&#123;</span><br><span class="line"><span class="keyword">delete</span> s;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> stockDeletor = [](Stock* s) &#123;</span><br><span class="line"><span class="comment">//logsomething();</span></span><br><span class="line"><span class="keyword">delete</span> s;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//自定义析构</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;Stock&gt; ptr1(<span class="keyword">new</span> Stock(<span class="string">"hello"</span>), stockDeletor);</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;Stock&gt; ptr2(<span class="keyword">new</span> Stock(<span class="string">"hello"</span>), delete_stock);</span><br><span class="line"></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;Stock&gt;&gt; v&#123;ptr1, ptr2&#125;;  <span class="comment">//不同的deletor，但是属于同一个类型，可以放在vector容器中，如果是unique_ptr，则不行</span></span><br></pre></td></tr></table></figure><h4 id="shared-from-this"><a href="#shared-from-this" class="headerlink" title="shared_from_this"></a>shared_from_this</h4><p>考虑这样一种情况，如果使用this指针直接来创建shared_ptr，会发生什么。以下代码来自<a href="https://en.cppreference.com/w/cpp/memory/enable_shared_from_this" target="_blank" rel="noopener">cpp reference</a>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Good</span>:</span> <span class="built_in">std</span>::enable_shared_from_this&lt;Good&gt; <span class="comment">// note: public inheritance</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;Good&gt; getptr() &#123;</span><br><span class="line">        <span class="keyword">return</span> shared_from_this();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Bad</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;Bad&gt; getptr() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;Bad&gt;(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    ~Bad() &#123; <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Bad::~Bad() called\n"</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//example 1</span></span><br><span class="line">    <span class="comment">// Good: the two shared_ptr's share the same object</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;Good&gt; gp1 = <span class="built_in">std</span>::make_shared&lt;Good&gt;();</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;Good&gt; gp2 = gp1-&gt;getptr();</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"gp2.use_count() = "</span> &lt;&lt; gp2.use_count() &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">//example 2</span></span><br><span class="line">    <span class="comment">// Bad: shared_from_this is called without having std::shared_ptr owning the caller </span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        Good not_so_good;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;Good&gt; gp1 = not_so_good.getptr();</span><br><span class="line">    &#125; <span class="keyword">catch</span>(<span class="built_in">std</span>::bad_weak_ptr&amp; e) &#123;</span><br><span class="line">        <span class="comment">// undefined behavior (until C++17) and std::bad_weak_ptr thrown (since C++17)</span></span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; e.what() &lt;&lt; <span class="string">'\n'</span>;    </span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">//example 3</span></span><br><span class="line">    <span class="comment">// Bad, each shared_ptr thinks it's the only owner of the object</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;Bad&gt; bp1 = <span class="built_in">std</span>::make_shared&lt;Bad&gt;();</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;Bad&gt; bp2 = bp1-&gt;getptr();</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"bp2.use_count() = "</span> &lt;&lt; bp2.use_count() &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">&#125; <span class="comment">// UB: double-delete of Bad</span></span><br></pre></td></tr></table></figure><p>在example 3，使用make函数来创建bp1，这是会创建一个控制块，后面又通过this裸指针又会创建一个控制块，所以会发生double delete。</p><p>在标准库中已经提供了<code>enable_shared_from_this</code>模板来解决这个问题。让类继承自<code>enable_shared_from_this</code>的特化版本，这个模板提供一个<code>shared_from_this</code>成员函数，可以使用这个成员函数来构造新的shared_ptr。但是注意，必须当前shared_ptr已经有一个相关联的控制块之后，才可以安全的使用<code>shared_from_this</code>，否则也会发生未定义行为。如上面的example 2。</p><h3 id="std-weak-ptr"><a href="#std-weak-ptr" class="headerlink" title="std::weak_ptr"></a>std::weak_ptr</h3><h4 id="weak-ptr-vs-shared-ptr"><a href="#weak-ptr-vs-shared-ptr" class="headerlink" title="weak_ptr vs shared_ptr"></a>weak_ptr vs shared_ptr</h4><p>weak_ptr并不是一种独立的智能指针，是对shared_ptr的一种扩充。<strong>weak_ptr不能直接由裸指针来构造，只能通过shared_ptr或者其他的weak_ptr来构造</strong>。cpp reference对weak_ptr的定义：</p><blockquote><p><code>std::weak_ptr</code> is a smart pointer that holds a non-owning (“weak”) reference to an object that is managed by <a href="https://en.cppreference.com/w/cpp/memory/shared_ptr" target="_blank" rel="noopener">std::shared_ptr</a>. It must be converted to <a href="https://en.cppreference.com/w/cpp/memory/shared_ptr" target="_blank" rel="noopener">std::shared_ptr</a> in order to access the referenced object.</p></blockquote><p>weak_ptr并不影响指向同一个资源对象的shared_ptr的引用计数，换句话说，weak_ptr不影响对象的共享所有权。前面在shared_ptr中提到的控制块中包含一个弱引用计数，weak_ptr影响的就是这个弱引用计数。当这个弱引用计数为0时，也即没有shared_ptr涉及到这个对象时，weak_ptr失效（过期）。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//call use_count function to get the numbers of shared_ptr instances that</span></span><br><span class="line">   <span class="comment">//shared ownship of the managed object, if 0 then the object has been deleted</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;Stock&gt; sp = <span class="built_in">std</span>::make_shared&lt;Stock&gt;(<span class="string">"hello"</span>);</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; sp.use_count() &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;  <span class="comment">//1</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">std</span>::weak_ptr&lt;Stock&gt; wp = sp;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; sp.use_count() &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;  <span class="comment">//1</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; wp.use_count() &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;  <span class="comment">//1</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">std</span>::weak_ptr&lt;Stock&gt; wp2 = wp;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; wp.use_count() &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;  <span class="comment">//1</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; wp2.use_count() &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">//1</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;Stock&gt; sp2 = wp.lock();  <span class="comment">//use lock to get a shared_ptr instance</span></span><br><span class="line"><span class="keyword">if</span> (sp2) &#123;</span><br><span class="line"><span class="comment">//sp2 not null</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">//sp2 null, mean weak_ptr is expired</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在weak_ptr中使用<code>lock</code>方法来新建一个shared_ptr对象并返回，如果为空，则说明weak_ptr已经过期。也可以使用<code>expired</code>来检测weak_ptr是否过期，在多线程的环境中，可能会带来竞争风险。所以还是推荐使用<code>lock</code>方法。</p><h4 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h4><p>weak_ptr可以有以下几种使用场景。</p><ul><li>用作cache（缓存）</li><li>观察者模式</li><li>避免shared_ptr指针环路</li></ul><h5 id="用作cache（缓存）"><a href="#用作cache（缓存）" class="headerlink" title="用作cache（缓存）"></a>用作cache（缓存）</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//use weak_ptr in cache scenario</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;Widget&gt; loadWidget() &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">std</span>::make_shared&lt;Widget&gt;();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;Widget&gt; fast_load_widget(<span class="keyword">int</span> id) &#123;</span><br><span class="line"><span class="keyword">static</span> <span class="built_in">std</span>::<span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="built_in">std</span>::weak_ptr&lt;Widget&gt;&gt; cache;</span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> sp = cache[id].lock();  <span class="comment">//check if exist in cache</span></span><br><span class="line"><span class="keyword">if</span> (!sp) &#123;</span><br><span class="line">sp = loadWidget();</span><br><span class="line">cache[id] = sp;  <span class="comment">//put to cache</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> sp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="观察者模式"><a href="#观察者模式" class="headerlink" title="观察者模式"></a>观察者模式</h5><p>Subject类有一个vector容器，用于保存observers，当需要通知observer时，先检查observer是否还有效。注意：通过<code>std::make_shared</code>创建了一个临时的shared_ptr直接复制给weak_ptr，这个时候shared_ptr即被销毁。在调用<code>lock</code>测试weak_ptr是否过期时，这个observer是过期的。所以在测试函数中另外一个observer能收到通知。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Observer</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DoStuff</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Got notified"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Subject</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Notify</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span>&amp; ob : m_obs) &#123;</span><br><span class="line"><span class="keyword">auto</span> sp = ob.lock();  <span class="comment">//convert to shared_ptr</span></span><br><span class="line"><span class="keyword">if</span> (sp) &#123;  <span class="comment">//test if converted shared_ptr is valid</span></span><br><span class="line">sp-&gt;DoStuff();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">AddToObserver</span><span class="params">(<span class="built_in">std</span>::weak_ptr&lt;Observer&gt;&amp; ob)</span> </span>&#123;</span><br><span class="line">m_obs.push_back(ob);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::weak_ptr&lt;Observer&gt;&gt; m_obs;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test_observer_pattern_using_weak_ptr</span><span class="params">()</span> </span>&#123;</span><br><span class="line">Subject s;</span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> sp = <span class="built_in">std</span>::make_shared&lt;Observer&gt;();  <span class="comment">//make a shared_ptr obj</span></span><br><span class="line"><span class="built_in">std</span>::weak_ptr&lt;Observer&gt; ob1 = <span class="built_in">std</span>::make_shared&lt;Observer&gt;();  <span class="comment">//make a temp shared_ptr, after the assignment, shared_ptr is deleted</span></span><br><span class="line"><span class="built_in">std</span>::weak_ptr&lt;Observer&gt; ob2(sp);  <span class="comment">//only this observer can receive notification!!!</span></span><br><span class="line"></span><br><span class="line">s.AddToObserver(ob1);  </span><br><span class="line">s.AddToObserver(ob2);</span><br><span class="line"></span><br><span class="line">s.Notify();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="避免shared-ptr指针环路"><a href="#避免shared-ptr指针环路" class="headerlink" title="避免shared_ptr指针环路"></a>避免shared_ptr指针环路</h5><img src="/2018/12/04/smart-pointer-in-c-plus-plus/avoid_shared_ptr_loop.png"><p>A, C都共享B，如果B需要保有一个对A的指针，这时候如果使用shared_ptr的话，会造成shared_ptr 环路，A, B互相保持引用，这样A和B的引用计数都不为0，无法析构，造成内存泄漏。</p><p>weak_ptr可以避免这个问题。当A的引用计数为0，即使B保有一个指向A的weak_ptr，不影响A被销毁。</p><h3 id="Make函数的几个注意点"><a href="#Make函数的几个注意点" class="headerlink" title="Make函数的几个注意点"></a>Make函数的几个注意点</h3><p>在使用智能指针时，Best Practice都是使用make函数来创建。特别是对于shared_ptr， 因为与之相关的控制块需要动态分配，如果使用make函数，则可以进行一次系统调用来分配内存（包含控制块和shared_ptr对象的内存）。而如果使用先创建裸指针，然后再创建shared_ptr的方法，需要进行两次系统调用来申请内存。这样做带来裸指针安全性的问题，也增加的性能上的开销。</p><p>当然了，make函数也不是万能的，如果需要使用自定义的deletor，那么只能通过其他方式来创建智能指针。</p><p>本文主要参考了Scott Meyers大师的  <strong><em>Effective Modern C++</em></strong>，可以直接在网络上阅读：<a href="https://www.oreilly.com/library/view/effective-modern-c/9781491908419/ch04.html" target="_blank" rel="noopener">地址在这</a>.</p><h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><ul><li>Scott Meyers <strong><em>Effective Modern C++</em></strong></li><li><a href="https://herbsutter.com/2013/06/05/gotw-91-solution-smart-pointer-parameters/" target="_blank" rel="noopener">GotW91: Smart Pointer Parameters</a></li><li><a href="https://www.acodersjourney.com/top-10-dumb-mistakes-avoid-c-11-smart-pointers/" target="_blank" rel="noopener">top-10-dumb-mistakes-avoid-c-11-smart-pointers</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;C++ 11中共有四种智能指针(Smart Pointers)：&lt;code&gt;std::auto_ptr&lt;/code&gt;,&lt;code&gt;std::unique_ptr&lt;/code&gt;,&lt;code&gt;std::shared_ptr&lt;/code&gt;,&lt;code&gt;std::weak_ptr&lt;/code&gt;。其中&lt;code&gt;std::auto_ptr&lt;/code&gt;是在C++98中就引入的智能指针，在C++11中已经被&lt;code&gt;std::unique_ptr&lt;/code&gt;所取代。所以本文主要讨论讨论剩下的三种智能指针。&lt;/p&gt;
    
    </summary>
    
      <category term="coding" scheme="https://bygeek.cn/categories/coding/"/>
    
    
      <category term="c++" scheme="https://bygeek.cn/tags/c/"/>
    
  </entry>
  
  <entry>
    <title>C++ 11带来的新特性</title>
    <link href="https://bygeek.cn/2018/12/04/new-features-in-cpp-11/"/>
    <id>https://bygeek.cn/2018/12/04/new-features-in-cpp-11/</id>
    <published>2018-12-04T01:56:55.000Z</published>
    <updated>2020-01-31T16:23:02.642Z</updated>
    
    <content type="html"><![CDATA[<p>本文转载自Herb Sutter的<a href="https://herbsutter.com/elements-of-modern-c-style/" target="_blank" rel="noopener">blog</a>。Herb Sutter是C++标准委员会的主席，他在本文中主要讲述了C++ 11 带来的新的一些feature，同时建议尽量使用Modern C++ style编程。</p><p>同时我建议阅读Scott Mayers的《Effective Modern C++》一书。</p><p>原文如下。</p><a id="more"></a><p>The C++11 standard offers <a href="http://www2.research.att.com/~bs/C++0xFAQ.html" target="_blank" rel="noopener">many useful new features</a>. This page focuses specifically and only on those features that make C++11 really feel like a new language compared to C++98, because:</p><ul><li>They change the styles and idioms you’ll use when writing C++ code, often including the way you’ll design C++ libraries. For example, you’ll see more smart pointer parameters and return values, and functions that return big objects by value.</li><li>They will be used so pervasively that you’ll probably see them in most code examples. For example, virtually every five-line modern C++ code example will say “auto” somewhere.</li></ul><p>Use the other great C++11 features too. But get used to these ones first, because these are the pervasive ones that show why C++11 code is clean, safe, and fast – just as clean and safe as code written in any other modern mainstream language, and with C++’s traditional to-the-metal performance as strong as ever.</p><p>Notes:</p><ul><li>Like Strunk &amp; White, this page is deliberately focused on brief summary guidance. It is not intended to provide exhaustive rationale and pro/con analysis; that will go into other articles.</li><li>This is a living document. See the end for a list of the main changes and additions over time.</li></ul><h3 id="auto"><a href="#auto" class="headerlink" title="auto"></a>auto</h3><p>Use auto wherever possible. It is useful for two reasons. First, most obviously it’s a convenience that lets us avoid repeating a type name that we already stated and the compiler already knows.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// C++98</span></span><br><span class="line"><span class="built_in">map</span>&lt;<span class="keyword">int</span>,<span class="built_in">string</span>&gt;::iterator i = m.begin();</span><br><span class="line"><span class="keyword">double</span> <span class="keyword">const</span> xlimit = config[<span class="string">"xlimit"</span>];</span><br><span class="line">singleton&amp; s = singleton::instance();</span><br><span class="line"> </span><br><span class="line"><span class="comment">// C++11</span></span><br><span class="line"><span class="keyword">auto</span> i = begin(m);</span><br><span class="line"><span class="keyword">auto</span> <span class="keyword">const</span> xlimit = config[<span class="string">"xlimit"</span>];</span><br><span class="line"><span class="keyword">auto</span>&amp; s = singleton::instance();</span><br></pre></td></tr></table></figure><p>Second, it’s more than just a convenience when a type has an unknown or unutterable name, such as the type of most lambda functions, that you couldn’t otherwise spell easily or at all.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// C++98</span></span><br><span class="line">binder2nd&lt; greater &gt; x = bind2nd( greater(), <span class="number">42</span> );</span><br><span class="line"> </span><br><span class="line"><span class="comment">// C++11</span></span><br><span class="line"><span class="keyword">auto</span> x = [](<span class="keyword">int</span> i) &#123; <span class="keyword">return</span> i &gt; <span class="number">42</span>; &#125;;</span><br></pre></td></tr></table></figure><p>Note that using auto doesn’t change the code’s meaning. The code is still statically typed, and the type of every expression is already crisp and clear; the language just no longer forces us to redundantly restate the type’s name.</p><p>Some people are initially afraid of using auto here, because it may feel like not (re)stating the type we want could mean we’ll get a different type by accident. If you want to explicitly <em>enforce a type conversion</em>, that’s okay; state the target type. The vast majority of the time, however, just use auto; it will rarely be the case that you get a different type by mistake, and even in those cases the language’s strong static typing means the compiler will usually let you know because you’ll be trying to call a member function the variable doesn’t have or otherwise use it as something that it isn’t.</p><h3 id="Smart-pointers-No-delete"><a href="#Smart-pointers-No-delete" class="headerlink" title="Smart pointers: No delete"></a>Smart pointers: No delete</h3><p>Always use the standard smart pointers, and non-owning raw pointers. Never use owning raw pointers and delete, except in rare cases when implementing your own low-level data structure (and even then keep that well encapsulated inside a class boundary).</p><p>If you know you’re the only owner of another object, use unique_ptr to express unique ownership. A “new T” expression should immediately initialize another object that owns it, typically a unique_ptr. A classic example is the Pimpl Idiom (see <a href="https://herbsutter.com/gotw/_100/" target="_blank" rel="noopener">GotW #100</a>):</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// C++11 Pimpl idiom: header file</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">widget</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    widget();</span><br><span class="line">    <span class="comment">// ... (see GotW #100) ...</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">impl</span>;</span></span><br><span class="line">    <span class="built_in">unique_ptr</span>&lt;impl&gt; pimpl;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// implementation file</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">widget</span>:</span>:impl &#123; <span class="comment">/*...*/</span> &#125;;</span><br><span class="line"> </span><br><span class="line">widget::widget() : pimpl&#123; <span class="keyword">new</span> impl&#123; <span class="comment">/*...*/</span> &#125; &#125; &#123; &#125;</span><br><span class="line"><span class="comment">// ...</span></span><br></pre></td></tr></table></figure><p>Use shared_ptr to express shared ownership. Prefer to use make_shared to create shared objects efficiently.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// C++98</span><br><span class="line">widget* pw = new widget();</span><br><span class="line">:::</span><br><span class="line">delete pw;</span><br><span class="line"> </span><br><span class="line">// C++11</span><br><span class="line">auto pw = make_shared&lt;widget&gt;();</span><br></pre></td></tr></table></figure><p>Use weak_ptr to break cycles and express optionality (e.g., implementing an object cache).</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// C++11</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">gadget</span>;</span></span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">widget</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">shared_ptr</span>&lt;gadget&gt; g; <span class="comment">// if shared ownership</span></span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">gadget</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    weak_ptr&lt;widget&gt; w;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>If you know another object is going to outlive you and you want to observe it, use a (non-owning) raw pointer.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// C++11</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">node</span> &#123;</span></span><br><span class="line"> <span class="built_in">vector</span>&lt;<span class="built_in">unique_ptr</span>&lt;node&gt;&gt; children;</span><br><span class="line"> node* parent;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"> :::</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="nullptr"><a href="#nullptr" class="headerlink" title="nullptr"></a>nullptr</h3><p>Always use nullptr for a null pointer value, never the literal 0 or the macro NULL which are ambiguous because they could be either an integer or a pointer.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// C++98</span></span><br><span class="line"><span class="keyword">int</span>* p = <span class="number">0</span>;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// C++11</span></span><br><span class="line"><span class="keyword">int</span>* p = <span class="literal">nullptr</span>;</span><br></pre></td></tr></table></figure><h3 id="Range-for"><a href="#Range-for" class="headerlink" title="Range for"></a>Range for</h3><p>The range-based for loop is a much more convenient way to visit every element of a range in order.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// C++98</span></span><br><span class="line"><span class="keyword">for</span>( <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::iterator i = v.begin(); i != v.end(); ++i ) &#123;</span><br><span class="line">    total += *i;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// C++11</span></span><br><span class="line"><span class="keyword">for</span>( <span class="keyword">auto</span> d : v ) &#123;</span><br><span class="line">    total += d;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Nonmember-begin-and-end"><a href="#Nonmember-begin-and-end" class="headerlink" title="Nonmember begin and end"></a>Nonmember begin and end</h3><p>Always use nonmember begin(x) and end(x) (not x.begin() and x.end()), because begin(x) and end(x) are extensible and can be adapted to work with all container types – even arrays – not just containers that follow the STL style of providing x.begin() and x.end() member functions.</p><p>If you’re using a non-STL collection type that provides iteration but not STL-style x.begin() and x.end(), you can often write your own non-member begin(x) and end(x) overloads for that type and then you can traverse collections of that type using the same coding style above as for STL containers. The standard has set the example: C arrays are such a type, and the standard provides begin and end for arrays.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v;</span><br><span class="line"><span class="keyword">int</span> a[<span class="number">100</span>];</span><br><span class="line"> </span><br><span class="line"><span class="comment">// C++98</span></span><br><span class="line">sort( v.begin(), v.end() );</span><br><span class="line">sort( &amp;a[<span class="number">0</span>], &amp;a[<span class="number">0</span>] + <span class="keyword">sizeof</span>(a)/<span class="keyword">sizeof</span>(a[<span class="number">0</span>]) );</span><br><span class="line"> </span><br><span class="line"><span class="comment">// C++11</span></span><br><span class="line">sort( begin(v), end(v) );</span><br><span class="line">sort( begin(a), end(a) );</span><br></pre></td></tr></table></figure><h3 id="Lambda-Functions-and-Algorithms"><a href="#Lambda-Functions-and-Algorithms" class="headerlink" title="Lambda Functions and Algorithms"></a>Lambda Functions and Algorithms</h3><p>Lambdas are a game-changer and will frequently change the way you write code to make it more elegant and faster. Lambdas make the existing STL algorithms roughly 100x more usable. Newer C++ libraries increasingly are designed assuming lambdas as available (e.g., PPL), and some even require you to write lambdas to use the library at all (e.g., C++ AMP).</p><p>Here’s one quick example: Find the first element in v that’s &gt;x and &lt;y. In C+11, the simplest and cleanest code is to use a standard algorithm.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// C++98: write a naked loop (using std::find_if is impractically difficult)</span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::iterator i = v.begin(); <span class="comment">// because we need to use i later</span></span><br><span class="line"><span class="keyword">for</span>( ; i != v.end(); ++i ) &#123;</span><br><span class="line">    <span class="keyword">if</span>( *i &gt; x &amp;&amp; *i &lt; y ) <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// C++11: use std::find_if</span></span><br><span class="line"><span class="keyword">auto</span> i = find_if( begin(v), end(v), [=](<span class="keyword">int</span> i) &#123; <span class="keyword">return</span> i &gt; x &amp;&amp; i &lt; y; &#125; );</span><br></pre></td></tr></table></figure><p>Want a loop or similar language feature that’s not actually in the language? No sweat; just write it as a template function (library algorithm), and thanks to lambdas you can use it with <em>almost</em> the same convenience as if it were a language feature, but with more flexibility because it really is a library and not a hardwired language feature.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// C#</span></span><br><span class="line">lock( mut_x ) &#123;</span><br><span class="line">    ... use x ...</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// C++11 without lambdas: already nice, and more flexible (e.g., can use timeouts, other options)</span></span><br><span class="line">&#123;</span><br><span class="line">    lock_guard&lt;mutex&gt; hold &#123; mut_x &#125;;</span><br><span class="line">    ... use x ...</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// C++11 with lambdas, and a helper algorithm: C# syntax in C++</span></span><br><span class="line"><span class="comment">// Algorithm: template&lt;typename T&gt; void lock( T&amp; t, F f ) &#123; lock_guard hold(t); f(); &#125;</span></span><br><span class="line">lock( mut_x, [&amp;]&#123;</span><br><span class="line">    ... use x ...</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>Get familiar with lambdas. You’ll use them a lot, and not just in C++ – they are already widely available and pervasively used in several popular mainstream languages. A good place to start is my talk <a href="https://herbsutter.com/2010/10/30/pdc-languages-panel-andshortened-lambdas-talk/" target="_blank" rel="noopener">Lambdas, Lambdas Everywhere</a> at PDC 2010.</p><h3 id="Move-amp-amp"><a href="#Move-amp-amp" class="headerlink" title="Move / &amp;&amp;"></a>Move / &amp;&amp;</h3><p>Move is best thought of as an optimization of copy, though it also enables other things like perfect forwarding.</p><p>Move semantics change the way we design our APIs. We’ll be designing for return by value a lot more often.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// C++98: alternatives to avoid copying</span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;* make_big_vector(); <span class="comment">// option 1: return by pointer: no copy, but don't forget to delete</span></span><br><span class="line">:::</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;* result = make_big_vector();</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">make_big_vector</span><span class="params">( <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; out )</span></span>; <span class="comment">// option 2: pass out by reference: no copy, but caller needs a named object</span></span><br><span class="line">:::</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; result;</span><br><span class="line">make_big_vector( result );</span><br><span class="line"> </span><br><span class="line"><span class="comment">// C++11: move</span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; make_big_vector(); <span class="comment">// usually sufficient for 'callee-allocated out' situations</span></span><br><span class="line">:::</span><br><span class="line"><span class="keyword">auto</span> result = make_big_vector(); <span class="comment">// guaranteed not to copy the vector</span></span><br></pre></td></tr></table></figure><p>Enable move semantics for your type when you can do something more efficient than copy.</p><h3 id="Uniform-Initialization-and-Initializer-Lists"><a href="#Uniform-Initialization-and-Initializer-Lists" class="headerlink" title="Uniform Initialization and Initializer Lists"></a>Uniform Initialization and Initializer Lists</h3><p>What hasn’t changed: When initializing a local variable whose type is non-POD or auto, continue using the familiar = syntax without extra { } braces.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// C++98 or C++11</span></span><br><span class="line"><span class="keyword">int</span> a = <span class="number">42</span>;        <span class="comment">// still fine, as always</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">// C++ 11</span></span><br><span class="line"><span class="keyword">auto</span> x = begin(v); <span class="comment">// no narrowing or non-initialization is possible</span></span><br></pre></td></tr></table></figure><p>In other cases, including especially everywhere that you would have used ( ) parentheses when constructing an object, prefer using { } braces instead. Using braces avoids several potential problems: you can’t accidentally get narrowing conversions (e.g., float to int), you won’t occasionally accidentally have uninitialized POD member variables or arrays, and you’ll avoid the occasional C++98 surprise that your code compiles but actually declares a function rather than a variable because of a declaration ambiguity in C++’s grammar – what Scott Meyers famously calls “C++’s most vexing parse.” There’s nothing vexing about the new style.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// C++98</span></span><br><span class="line">rectangle       w( origin(), extents() );   // oops, declares a function, if origin and extents are types</span><br><span class="line"><span class="keyword">complex</span>&lt;<span class="keyword">double</span>&gt; c( <span class="number">2.71828</span>, <span class="number">3.14159</span> );</span><br><span class="line"><span class="keyword">int</span>             a[] = &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span> &#125;;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;     v;</span><br><span class="line"><span class="keyword">for</span>( <span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">4</span>; ++i ) v.push_back(i);</span><br><span class="line"> </span><br><span class="line"><span class="comment">// C++11</span></span><br><span class="line">rectangle       w   &#123; origin(), extents() &#125;;</span><br><span class="line"><span class="keyword">complex</span>&lt;<span class="keyword">double</span>&gt; c   &#123; <span class="number">2.71828</span>, <span class="number">3.14159</span> &#125;;</span><br><span class="line"><span class="keyword">int</span>             a[] &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span> &#125;;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;     v   &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span> &#125;;</span><br></pre></td></tr></table></figure><p>The new { } syntax works pretty much everywhere:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// C++98</span></span><br><span class="line">X::X( <span class="comment">/*...*/</span> ) : mem1(init1), mem2(init2, init3) &#123; <span class="comment">/*...*/</span> &#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// C++11</span></span><br><span class="line">X::X( <span class="comment">/*...*/</span> ) : mem1&#123;init1&#125;, mem2&#123;init2, init3&#125; &#123; <span class="comment">/*...*/</span> &#125;</span><br></pre></td></tr></table></figure><p>Finally, sometimes it’s just convenient to pass function arguments without a type-named temporary:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">draw_rect</span><span class="params">( rectangle )</span></span>;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// C++98</span></span><br><span class="line">draw_rect( rectangle( myobj.origin, selection.extents ) );</span><br><span class="line"> </span><br><span class="line"><span class="comment">// C++11</span></span><br><span class="line">draw_rect( &#123; myobj.origin, selection.extents &#125; );</span><br></pre></td></tr></table></figure><p>The only place where I prefer not to write the braces is on simple initialization of a non-POD variable, like <em>auto x = begin(v);</em> , where it would make the code needlessly ugly because I know it’s a class type, so I know I don’t need to worry about accidental narrowing conversions, and modern compilers already routinely perform the optimization to elide the extra copy (or the extra move, if the type is move-enabled).</p><h3 id="And-More"><a href="#And-More" class="headerlink" title="And More"></a>And More</h3><p>There’s more to modern C++. <a href="http://www2.research.att.com/~bs/C++0xFAQ.html" target="_blank" rel="noopener">Much more.</a> And in the future I plan to write more in-depth pieces about these and other features of C++11 we’ll get to know and love.</p><p>But for now, this is the list of must-know features. These features form the core that defines modern C++ style, that make C++ code look and perform the way it does, that you’ll see used pervasively in nearly every piece of modern code you’ll see or write… and that make modern C++ the clean, and safe, and fast language that our industry will continue relying on heavily for years to come.</p><h3 id="Major-Change-History"><a href="#Major-Change-History" class="headerlink" title="Major Change History"></a>Major Change History</h3><p>2011-10-30: Added C# lock example to lambdas. Reordered smart pointers to introduce unique_ptr first.</p><p>2011-11-01: Added uniform initialization.</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文转载自Herb Sutter的&lt;a href=&quot;https://herbsutter.com/elements-of-modern-c-style/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;blog&lt;/a&gt;。Herb Sutter是C++标准委员会的主席，他在本文中主要讲述了C++ 11 带来的新的一些feature，同时建议尽量使用Modern C++ style编程。&lt;/p&gt;
&lt;p&gt;同时我建议阅读Scott Mayers的《Effective Modern C++》一书。&lt;/p&gt;
&lt;p&gt;原文如下。&lt;/p&gt;
    
    </summary>
    
      <category term="coding" scheme="https://bygeek.cn/categories/coding/"/>
    
      <category term="repost" scheme="https://bygeek.cn/categories/coding/repost/"/>
    
    
      <category term="c++" scheme="https://bygeek.cn/tags/c/"/>
    
  </entry>
  
  <entry>
    <title>bitwise copy vs memberwise copy</title>
    <link href="https://bygeek.cn/2018/11/23/bitwise-copy-vs-memberwise-copy/"/>
    <id>https://bygeek.cn/2018/11/23/bitwise-copy-vs-memberwise-copy/</id>
    <published>2018-11-23T00:52:46.000Z</published>
    <updated>2020-01-31T16:23:02.544Z</updated>
    
    <content type="html"><![CDATA[<p>本文转自<a href="https://stackoverflow.com/questions/42749439/what-is-the-difference-between-memberwise-copy-bitwise-copy-shallow-copy-and-d" target="_blank" rel="noopener">Stack Overflow</a>，对几种copy的概念将的通熟易懂。</p><a id="more"></a><p><strong>Member-wise Copy</strong></p><p>Is when you visit each member and explicitly copy it, invoking its copy constructor. It is usually tantamount to deep-copy. It is the right and proper way of copying things. The opposite is bit-wise copy, which is a hack, see below.</p><p><strong>Bit-wise Copy</strong></p><p>Is a specific form of shallow copy. It is when you simply copy the bits of the source class to the target class, using <code>memcpy()</code> or something similar. Constructors are not invoked, so you tend to get a class which <em>appears</em> to be all right but things start breaking in horrible ways as soon as you start using it. This is the opposite of member-wise copy, and is a quick and dirty hack that can sometimes be used when we know that there are no constructors to be invoked and no internal structures to be duplicated. For a discussion of what may go wrong with this, see this Q&amp;A: <a href="https://stackoverflow.com/questions/15123516/c-bitwise-vs-memberwise-copying" target="_blank" rel="noopener">C++ bitwise vs memberwise copying?</a></p><p><strong>Shallow Copy</strong></p><p>Refers to copying just the immediate members of an object, without duplicating whatever structures are pointed by them. It is what you get when you do a bit-wise copy.</p><p>(Note that there is no such thing as “shadow copy”. I mean, there is such a thing, in file systems, but that’s probably <em>not</em> what you had in mind.)</p><p><strong>Deep Copy</strong></p><p>Refers to not only copying the immediate members of an object, but also duplicating whatever structures are pointed by them. It is what you normally get when you do member-wise copy.</p><p><strong>To summarize:</strong></p><p>There are two categories:</p><ul><li>Shallow Copy</li><li>Deep Copy</li></ul><p>Then, there are two widely used techniques:</p><ul><li>Bit-wise Copy (a form of Shallow Copy)</li><li>Member-wise Copy (a form of Deep Copy)</li></ul><p>As for the hear-say about someone who said something and someone who said something else: bit-wise copy is definitely always shallow copy. Member-wise copy is usually deep copy, but you may of course foul it up, so you may be thinking that you are making a deep copy while in fact you are not. Proper member-wise copy relies on having proper copy constructors.</p><p>Finally:</p><p>The default copy constructor will do a bit-wise copy if the object is known to be trivially copyable, or a member-wise copy if not. However, the compiler does not always have enough information to perform a proper copy of each member. For example, a pointer is copied by making a copy of the pointer, not by making a copy of the pointed object. That’s why you should generally not rely on the compiler providing you with a default copy constructor when your object is not trivially copyable.</p><p>A user-supplied constructor may do whatever type of copy the user likes. Hopefully, the user will choose wisely and do a member-wise copy.</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文转自&lt;a href=&quot;https://stackoverflow.com/questions/42749439/what-is-the-difference-between-memberwise-copy-bitwise-copy-shallow-copy-and-d&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Stack Overflow&lt;/a&gt;，对几种copy的概念将的通熟易懂。&lt;/p&gt;
    
    </summary>
    
      <category term="coding" scheme="https://bygeek.cn/categories/coding/"/>
    
    
      <category term="copy" scheme="https://bygeek.cn/tags/copy/"/>
    
  </entry>
  
  <entry>
    <title>同步与锁</title>
    <link href="https://bygeek.cn/2018/11/15/about-synchronization/"/>
    <id>https://bygeek.cn/2018/11/15/about-synchronization/</id>
    <published>2018-11-15T02:56:24.000Z</published>
    <updated>2020-01-31T16:23:02.522Z</updated>
    
    <content type="html"><![CDATA[<p>本文摘录自《程序员的自我修养》第一章。</p><a id="more"></a><h2 id="二元信号量-Binary-Semaphore"><a href="#二元信号量-Binary-Semaphore" class="headerlink" title="二元信号量(Binary Semaphore):"></a>二元信号量(Binary Semaphore):</h2><p>最简单的一种锁, 只有两种状态: 占用与非占用.</p><p>它适合只能被唯一一个线程独占访问的资源.    </p><h2 id="信号量-Semaphore"><a href="#信号量-Semaphore" class="headerlink" title="信号量(Semaphore):"></a>信号量(Semaphore):</h2><p>允许多个线程并发访问的资源.  </p><h2 id="互斥量-Mutex"><a href="#互斥量-Mutex" class="headerlink" title="互斥量(Mutex):"></a>互斥量(Mutex):</h2><p>资源仅同时允许一个线程访问.</p><p> 但和信号量不同的是, 信号量在整个系统可以被任意线程获取并释放, 也就是说, 同一个信号量可以被系统中的一个线程获取之后由另一个线程释放. 而互斥量则要求哪个线程获取了互斥量, 哪个线程就要负责释放这个锁, 其他线程越俎代庖去释放互斥量是无效的.  </p><h2 id="临界锁-Critical-Section"><a href="#临界锁-Critical-Section" class="headerlink" title="临界锁(Critical Section):"></a>临界锁(Critical Section):</h2><p>是比互斥量更加严格的同步手段.</p><p>临界区和互斥量与信号量的区别在于, 互斥量和信号量在系统的任何进程里都是可见的, 也就是说, 一个进程创建了一个互斥量或信号量, 另一个进程试图去获取该锁是合法的. 然而, 临界区的作用范围仅限于本进程, 其他的进程无法获取该锁. 除此之外, 临界区具有和互斥量相同的性质.  </p><h2 id="读写锁-Read-Write-Lock"><a href="#读写锁-Read-Write-Lock" class="headerlink" title="读写锁(Read-Write Lock):"></a>读写锁(Read-Write Lock):</h2><p>致力于一种更加特定的场合的同步.</p><p>读写锁的状态如下:  </p><table><thead><tr><th>读写锁状态</th><th>以共享方式获取</th><th>以独占方式获取</th></tr></thead><tbody><tr><td>自由</td><td>成功</td><td>成功</td></tr><tr><td>共享</td><td>成功</td><td>等待</td></tr><tr><td>独占</td><td>成功</td><td>等待</td></tr></tbody></table>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文摘录自《程序员的自我修养》第一章。&lt;/p&gt;
    
    </summary>
    
      <category term="coding" scheme="https://bygeek.cn/categories/coding/"/>
    
    
      <category term="lock" scheme="https://bygeek.cn/tags/lock/"/>
    
      <category term="synchronization" scheme="https://bygeek.cn/tags/synchronization/"/>
    
  </entry>
  
  <entry>
    <title>build c/c++ extension for python</title>
    <link href="https://bygeek.cn/2018/11/08/build-c-c-extension-for-python/"/>
    <id>https://bygeek.cn/2018/11/08/build-c-c-extension-for-python/</id>
    <published>2018-11-08T02:30:26.000Z</published>
    <updated>2020-01-31T16:23:02.548Z</updated>
    
    <content type="html"><![CDATA[<p>本文记录下如何在python中调用C/C++中函数。本文主要参考MSDN 中<a href="https://docs.microsoft.com/en-us/visualstudio/python/working-with-c-cpp-python-in-visual-studio?view=vs-2017" target="_blank" rel="noopener">Create a C++ extension for Python</a> 一文。</p><a id="more"></a><h2 id="搭建python环境"><a href="#搭建python环境" class="headerlink" title="搭建python环境"></a>搭建python环境</h2><p>由于我是直接参考的MSDN上的教程，所以没有直接下载python安装包，而是直接通过Visual Studio 2017来安装的python。所以按照MSDN上的步骤，通过Visual Studio Installer来安装Python模块。建议同时安装32bit和64bit。</p><p>安装好之后，默认安装的路径是<code>C:\Program Files (x86)\Microsoft Visual Studio\Shared</code>。可以建立一个文件夹快捷方式放在C盘根目录，方便以后导航。</p><p>接下来设置一下系统的环境变量，首先建立PATHHOME环境变量为Python安装目录：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">C:\Program Files (x86)\Microsoft Visual Studio\Shared\Python36_86\</span><br></pre></td></tr></table></figure><p>然后修改PATH环境变量，加入以下路径：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">;%PYTHONHOME%;%PYTHONHOME%\Scripts;%PYTHONHOME%\DLLS;</span><br></pre></td></tr></table></figure><p>以后如果想使用Python 64位的，直接修改PYTHONHOME环境变量为Python 64目录即可。</p><h2 id="验证环境"><a href="#验证环境" class="headerlink" title="验证环境"></a>验证环境</h2><p>按照MSDN上，建立一个Python工程，直接run一下试试，验证Python环境是否成功。</p><p>按照MSDN上，建立一个c++ 工程，然后设置下project property，<strong>具体设置项按照MSDN上的设置项</strong>。然后编写c++ function。build以下，验证C++工程无问题。</p><p>注意:</p><ul><li>根据MSDN，需要将在Project Property中C/C++ Code Generation -&gt; Runtime Library 设置为Multi-threaded DLL(/MD)</li><li>工程设置中将<code>$(PYTHONHOME)\include</code>加入到Additional Include directory中。<code>$(PYTHONHOME)</code>即是我们在上一步中设置的环境变量。</li><li>在Linker -&gt; General -&gt; Additional Library Directories 中加入<code>$(PYTHONHOME)\libs</code></li><li>将Project platform设置为win32 平台。</li></ul><h2 id="编写代码"><a href="#编写代码" class="headerlink" title="编写代码"></a>编写代码</h2><p>在原有的c++工程中新建一个cpp文件，然后加入以下代码</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//always put Python header first, if not found this header, </span></span><br><span class="line"><span class="comment">//check c++ Additional library include setting ：$(PYTHONHOME)\include</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;Python.h&gt;  </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;Windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"math.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="function">PyObject* <span class="title">test_mul</span><span class="params">(PyObject *self, PyObject* args)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> a, b;</span><br><span class="line">PyArg_ParseTuple(args, <span class="string">"ii"</span>, &amp;a, &amp;b);  <span class="comment">//format string ref: https://docs.python.org/3.7/c-api/arg.html</span></span><br><span class="line"><span class="comment">//return PyLong_FromLong(a*b);</span></span><br><span class="line"><span class="keyword">int</span> result = mul(a, b);</span><br><span class="line"><span class="keyword">return</span> PyLong_FromLong(result);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">PyObject* <span class="title">test_sub</span><span class="params">(PyObject* self, PyObject* args)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> a, b;</span><br><span class="line">PyArg_ParseTuple(args, <span class="string">"ii"</span>, &amp;a, &amp;b);</span><br><span class="line"><span class="keyword">int</span> result = sub(a, b);</span><br><span class="line"><span class="keyword">return</span> PyLong_FromLong(result);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> PyMethodDef superfastcode_methods[] = &#123;</span><br><span class="line"><span class="comment">// The first property is the name exposed to Python, fast_tanh, the second is the C++</span></span><br><span class="line"><span class="comment">// function name that contains the implementation.</span></span><br><span class="line"><span class="comment">//&#123; "fast_tanh", (PyCFunction)tanh_impl, METH_O, nullptr &#125;,  //METH_O means only passing one argument</span></span><br><span class="line">&#123;<span class="string">"test_mul"</span>, (PyCFunction)test_mul, METH_VARARGS, <span class="literal">nullptr</span>&#125;,  <span class="comment">//METH_VARARGS ref: https://docs.python.org/3/c-api/structures.html</span></span><br><span class="line">&#123;<span class="string">"test_sub"</span>, (PyCFunction)test_sub, METH_VARARGS, <span class="literal">nullptr</span>&#125;,</span><br><span class="line"><span class="comment">// Terminate the array with an object containing nulls.</span></span><br><span class="line">&#123; <span class="literal">nullptr</span>, <span class="literal">nullptr</span>, <span class="number">0</span>, <span class="literal">nullptr</span> &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> PyModuleDef superfastcode_module = &#123;</span><br><span class="line">PyModuleDef_HEAD_INIT,</span><br><span class="line"><span class="string">"superfastcode"</span>,                        <span class="comment">// Module name to use with Python import statements</span></span><br><span class="line"><span class="string">"Provides some functions, but faster"</span>,  <span class="comment">// Module description</span></span><br><span class="line"><span class="number">0</span>,</span><br><span class="line">superfastcode_methods                   <span class="comment">// Structure that defines the methods of the module</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">PyMODINIT_FUNC <span class="title">PyInit_superfastcode</span><span class="params">()</span> </span>&#123;  <span class="comment">//PyInit_&lt;module_name&gt;  module_name must be your module name</span></span><br><span class="line"><span class="keyword">return</span> PyModule_Create(&amp;superfastcode_module);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>build工程查看是否成功。下面是对其几点说明。</p><ol><li><p>必须要有一个<code>PyInit_&lt;model_name&gt;</code>导出函数，Python会通过这个函数来初始化模块。</p></li><li><p>给C++函数写一个对应的wrapper 函数，比如上述中的<code>test_mul</code>函数，wrapper函数的签名是<code>Pyobject* (Pyobject* self, Pyobject* args)</code>。在Python中所有的type都是“继承”自Pyobject（之所以打引号，是因为python是用C写的，并没有继承的概念）。</p></li><li><p>在wrapper函数中的第二个参数是args表示从Python脚本中传递过来的参数包。可以使用PyArg_ParseTuple来取得。</p><blockquote><p>int <code>PyArg_ParseTuple</code>(<a href="https://docs.python.org/3/c-api/structures.html#c.PyObject" target="_blank" rel="noopener">PyObject</a> <strong>args*, const char </strong>format*, …)</p><p>Parse the parameters of a function that takes only positional parameters into local variables. Returns true on success; on failure, it returns false and raises the appropriate exception.</p></blockquote><p>其中第二个参数format表示如何解析传递的参数包，”ii”表示两个integer，”s”表示字符串，具体请参考<a href="https://docs.python.org/3/c-api/arg.html" target="_blank" rel="noopener">Parsing arguments and building values</a></p></li><li><p>定义一个数组，并枚举需要导出的C++函数，如上面的<code>superfastcode_methods</code>，数组中每个元素都是一个<code>PyMethodDef</code>结构体。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">PyMethodDef</span> &#123;</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span>  *ml_name;   <span class="comment">/* The name of the built-in function/method */</span></span><br><span class="line">    PyCFunction ml_meth;    <span class="comment">/* The C function that implements it */</span></span><br><span class="line">    <span class="keyword">int</span>         ml_flags;   <span class="comment">/* Combination of METH_xxx flags, which mostly</span></span><br><span class="line"><span class="comment">                               describe the args expected by the C func */</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span>  *ml_doc;    <span class="comment">/* The __doc__ attribute, or NULL */</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">PyMethodDef</span> <span class="title">PyMethodDef</span>;</span></span><br></pre></td></tr></table></figure><p>其中ml_flags中METH_O表示只有一个参数，METH_VARARGS表示可以有多个参数。在wrapper class中会使用这些”声明”来取得参数。</p></li><li><p>定义一个<code>PyModuleDef</code>结构体，如上面的<code>superfastcode_module</code>。表示module名称等信息。</p></li></ol><h2 id="使用定义好的Module"><a href="#使用定义好的Module" class="headerlink" title="使用定义好的Module"></a>使用定义好的Module</h2><p>Module定义好之后，可以有两种方式导入到python中。</p><p>如果跟Python工程属于同一个Solution，可以直接在Python Project中直接Reference过来。具体做法是在Python工程-&gt; References -&gt; Add References。</p><p>另外一种方式，可以通过<code>distutils</code>来编译成Python的一个模块。<code>distutils</code>通过setup.py 脚本来编译C/C++ 源文件。一个简单的setup.py如下。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> distutils.core <span class="keyword">import</span> setup, Extension, DEBUG</span><br><span class="line"></span><br><span class="line"><span class="comment">#more info about setup.py, please ref: https://docs.python.org/3/extending/building.html</span></span><br><span class="line"></span><br><span class="line">sfc_module = Extension(<span class="string">'superfastcode'</span>, </span><br><span class="line">                       libraries=[<span class="string">'StaticLib1'</span>],  <span class="comment">#dependency</span></span><br><span class="line">                       sources = [<span class="string">'source.cpp'</span>])</span><br><span class="line"></span><br><span class="line">setup(name = <span class="string">'superfastcode'</span>, version = <span class="string">'1.0'</span>,</span><br><span class="line">    description = <span class="string">'Python Package with superfastcode C++ extension'</span>,</span><br><span class="line">    ext_modules = [sfc_module]</span><br><span class="line">    )</span><br></pre></td></tr></table></figure><p>上面source.cpp中依赖了一个StaticLib1中的函数，所以加入了libraries 供链接用。</p><p>目前文件结构如下图：</p><img src="/2018/11/08/build-c-c-extension-for-python/file_structure.png"><p>其中math.h 是StaticLib1的头文件。PythonApplication1.py是测试用的脚本。</p><p>我们首先需要编译source.cpp。在该目录下打开cmder(cmder一款统一命令行工具，也可以用cmd命令行)，执行</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install .</span><br></pre></td></tr></table></figure><p>此操作会将module安装到Python的site-package中。然后我们就可以在python脚本中使用了</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#demo test</span></span><br><span class="line"><span class="comment">#import function from module</span></span><br><span class="line"><span class="keyword">from</span> superfastcode <span class="keyword">import</span> test_mul, test_sub</span><br><span class="line"></span><br><span class="line">result = test_mul(<span class="number">2</span>,<span class="number">2</span>)</span><br><span class="line">print(result);</span><br><span class="line"></span><br><span class="line">result = test_sub(<span class="number">5</span>,<span class="number">1</span>);</span><br><span class="line">print(result);</span><br></pre></td></tr></table></figure><p>在Visual Studio中F5运行或者在命令行执行<code>python PythonApplication1.py</code>，验证是否成功。</p><h2 id="卸载已安装的包"><a href="#卸载已安装的包" class="headerlink" title="卸载已安装的包"></a>卸载已安装的包</h2><p>如果在上一步执行<code>pip install .</code>的时候提示已经该包已经安装过，无法卸载。执行<code>pip uninstall your_module_name</code>也无法卸载。可以通过删除Python安装目录下的site-packages来卸载该包。</p><img src="/2018/11/08/build-c-c-extension-for-python/site-package.png"><p>注意采用这种卸载方式是因为我们使用的distutils来安装package的，Python下可以使用其他包管理来管理，如<a href="http://peak.telecommunity.com/DevCenter/EasyInstall" target="_blank" rel="noopener">easy_install</a></p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><a href="https://docs.python.org/3/c-api/arg.html" target="_blank" rel="noopener">https://docs.python.org/3/c-api/arg.html</a></li><li><a href="https://docs.python.org/3/extending/building.html" target="_blank" rel="noopener">https://docs.python.org/3/extending/building.html</a></li><li><a href="https://docs.python.org/3/c-api/structures.html" target="_blank" rel="noopener">https://docs.python.org/3/c-api/structures.html</a></li><li><a href="https://stackoverflow.com/questions/402359/how-do-you-uninstall-a-python-package-that-was-installed-using-distutils" target="_blank" rel="noopener">https://stackoverflow.com/questions/402359/how-do-you-uninstall-a-python-package-that-was-installed-using-distutils</a></li><li><a href="https://docs.python.org/3.7/c-api/arg.html" target="_blank" rel="noopener">https://docs.python.org/3.7/c-api/arg.html</a></li><li><a href="https://docs.microsoft.com/en-us/visualstudio/python/working-with-c-cpp-python-in-visual-studio?view=vs-2017" target="_blank" rel="noopener">https://docs.microsoft.com/en-us/visualstudio/python/working-with-c-cpp-python-in-visual-studio?view=vs-2017</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文记录下如何在python中调用C/C++中函数。本文主要参考MSDN 中&lt;a href=&quot;https://docs.microsoft.com/en-us/visualstudio/python/working-with-c-cpp-python-in-visual-studio?view=vs-2017&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Create a C++ extension for Python&lt;/a&gt; 一文。&lt;/p&gt;
    
    </summary>
    
      <category term="coding" scheme="https://bygeek.cn/categories/coding/"/>
    
    
      <category term="c++" scheme="https://bygeek.cn/tags/c/"/>
    
      <category term="python" scheme="https://bygeek.cn/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>由sizeof引起的问题</title>
    <link href="https://bygeek.cn/2018/11/06/sizeof-question-in-cpp/"/>
    <id>https://bygeek.cn/2018/11/06/sizeof-question-in-cpp/</id>
    <published>2018-11-06T07:48:46.000Z</published>
    <updated>2020-01-31T16:23:02.711Z</updated>
    
    <content type="html"><![CDATA[<p>最近在看Lippman的《Inside the c++ object model》，书中Lippman说有人发邮件问了他一个问题。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">X</span> &#123;</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Y</span> :</span> <span class="keyword">public</span> <span class="keyword">virtual</span> X&#123;&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Z</span>:</span> <span class="keyword">public</span> <span class="keyword">virtual</span> X&#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>:</span><span class="keyword">public</span> Y, <span class="keyword">public</span> Z&#123;&#125;;</span><br></pre></td></tr></table></figure><p>根据以上定义，使用sizeof运算符分别计算类X,Y,Z,A的所占大小。</p><a id="more"></a><p>答案公布：</p><p>在msvc140和gcc 5.4环境下测试：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">size_t</span> temp = <span class="keyword">sizeof</span>(X); <span class="comment">//1</span></span><br><span class="line">temp = <span class="keyword">sizeof</span>(Y);  <span class="comment">//4</span></span><br><span class="line">temp = <span class="keyword">sizeof</span>(Z);  <span class="comment">//4</span></span><br><span class="line">temp = <span class="keyword">sizeof</span>(A);  <span class="comment">//8</span></span><br></pre></td></tr></table></figure><h2 id="为什么sizeof-X-为1？"><a href="#为什么sizeof-X-为1？" class="headerlink" title="为什么sizeof(X)为1？"></a>为什么sizeof(X)为1？</h2><p>X是一个”空类”，按理来说sizeof(X)应该是0，因为没有数据需要存储。为何sizeof(X)为1呢？</p><p>Lippman给出的解释是，如果空类所占空间为0，则类的两个不同的实例地址就相同，这样的结果显然不是我们想要的。编译器自动给空类插入占用一字节的char数据成员，这样可以保证不同的对象会分配唯一的地址空间。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">X a, b;</span><br><span class="line"><span class="keyword">if</span>(&amp;a == &amp;b) <span class="built_in">cerr</span> &lt;&lt; <span class="string">"yipes"</span> &lt;&lt;<span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure><p>在《Effective c++》中item 39中，作者提到：freestanding objects必须有Non-zero size，对于大多数编译器，sizeof(X)是1，是因为编译器插入一个char完成的。</p><p>在<a href="https://en.cppreference.com/w/cpp/language/ebo" target="_blank" rel="noopener">cppreference</a>可以找到相关的标准规定:</p><blockquote><p>The size of any <a href="https://en.cppreference.com/w/cpp/language/object" target="_blank" rel="noopener">object</a> or member subobject (unless [[no_unique_address]] – see below) (since C++20) is required to be at least 1 even if the type is an empty <a href="https://en.cppreference.com/w/cpp/language/class" target="_blank" rel="noopener">class type</a> (that is, a class or struct that has no non-static data members), in order to be able to guarantee that the addresses of distinct objects of the same type are always distinct.</p></blockquote><h2 id="为什么sizeof-Y-sizeof-Z-为4？"><a href="#为什么sizeof-Y-sizeof-Z-为4？" class="headerlink" title="为什么sizeof(Y), sizeof(Z)为4？"></a>为什么sizeof(Y), sizeof(Z)为4？</h2><p>先来考虑另外一个问题</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">X</span>&#123;</span>&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Q</span>:</span> <span class="keyword">public</span> X&#123;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> data;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Q继承自空类X，考虑到sizeof(X) = 1, 那么Q类的所占空间是sizeof(int)还是sizeof(int) + 1?</p><p>答案是根据Empty base optimization原则，Q所占空间为sizeof(int)。也就是说base class所占空间被“优化”掉了。但是这里我们class Y， Z并没有数据成员，sizeof(Y) == sizeof(Z)  == 4。</p><p>这是因为使用了virtual inheritance。一旦跟<strong>virtual</strong>扯上关系，编译器又在背后偷偷的做了一些事情。</p><p>为了实现面向对象中的多态特性，大多数编译器都会将一个vptr插入到the most base class中，vptr指向vtable。关于vtable的相关知识，请参考我的这篇<a href="https://bygeek.cn/2018/10/22/vtable-and-object-memory-layout-in-cpp-language/">博文</a>。正是因为vptr指针占用4个字节，并且基于empty base optimization原则，所以sizeof(Y) = 4。</p><h2 id="为什么sizeof-A-为8？"><a href="#为什么sizeof-A-为8？" class="headerlink" title="为什么sizeof(A)为8？"></a>为什么sizeof(A)为8？</h2><p>因为virtual继承关系，编译器会在Y，Z的memory layout中加入一个vptr指针。在多重继承下，X的memory layout会包含Y,Z的vptr，所以sizeof(A)为8。</p><h2 id="如看查看memory-layout"><a href="#如看查看memory-layout" class="headerlink" title="如看查看memory layout"></a>如看查看memory layout</h2><h3 id="MSVC"><a href="#MSVC" class="headerlink" title="MSVC"></a>MSVC</h3><p>在msvc下我们可以使用编译器选项<code>/d1reportSingleClassLayout&lt;classname&gt;</code>， <code>/d1reportAllClassLayout</code>来查看memory layout。打开visual studio 开发者prompt</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cl.exe your_source_file_path.cpp /d1reportAllClassLayout</span><br></pre></td></tr></table></figure><p>如果包含的类比较多，可以将输出信息重定向到文件中，方便查看。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cl.exe your_source_file_path.cpp /d1reportAllClassLayout &gt; &quot;d:\out.txt&quot;</span><br></pre></td></tr></table></figure><p>在MSVC140下dump出来的memory layout如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">class Xsize(1):</span><br><span class="line">+---</span><br><span class="line">+---</span><br><span class="line"></span><br><span class="line">class Ysize(4):</span><br><span class="line">+---</span><br><span class="line"> 0| &#123;vbptr&#125;</span><br><span class="line">+---</span><br><span class="line">+--- (virtual base X)</span><br><span class="line">+---</span><br><span class="line"></span><br><span class="line">Y::$vbtable@:</span><br><span class="line"> 0| 0</span><br><span class="line"> 1| 4 (Yd(Y+0)X)</span><br><span class="line">vbi:   class  offset o.vbptr  o.vbte fVtorDisp</span><br><span class="line">               X       4       0       4 0</span><br><span class="line"></span><br><span class="line">class Zsize(4):</span><br><span class="line">+---</span><br><span class="line"> 0| &#123;vbptr&#125;</span><br><span class="line">+---</span><br><span class="line">+--- (virtual base X)</span><br><span class="line">+---</span><br><span class="line"></span><br><span class="line">Z::$vbtable@:</span><br><span class="line"> 0| 0</span><br><span class="line"> 1| 4 (Zd(Z+0)X)</span><br><span class="line">vbi:   class  offset o.vbptr  o.vbte fVtorDisp</span><br><span class="line">               X       4       0       4 0</span><br><span class="line"></span><br><span class="line">class Asize(8):</span><br><span class="line">+---</span><br><span class="line"> 0| +--- (base class Y)</span><br><span class="line"> 0| | &#123;vbptr&#125;</span><br><span class="line">| +---</span><br><span class="line"> 4| +--- (base class Z)</span><br><span class="line"> 4| | &#123;vbptr&#125;</span><br><span class="line">| +---</span><br><span class="line">+---</span><br><span class="line">+--- (virtual base X)</span><br><span class="line">+---</span><br><span class="line"></span><br><span class="line">A::$vbtable@Y@:</span><br><span class="line"> 0| 0</span><br><span class="line"> 1| 8 (Ad(Y+0)X)</span><br><span class="line"></span><br><span class="line">A::$vbtable@Z@:</span><br><span class="line"> 0| 0</span><br><span class="line"> 1| 4 (Ad(Z+0)X)</span><br><span class="line">vbi:   class  offset o.vbptr  o.vbte fVtorDisp</span><br><span class="line">               X       8       0       4 0</span><br></pre></td></tr></table></figure><h3 id="GCC"><a href="#GCC" class="headerlink" title="GCC"></a>GCC</h3><p>在gcc中可以通过编译选项<code>-fdump-class-hierarchy</code>来查看。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">g++ main.cpp -fdump-class-hierarchy</span><br></pre></td></tr></table></figure><p>编程成功后，会生成一个main.cpp.002t.class的文件，搜索想要查看的类的memory layout即可。</p><p>载g++ 5.4 ubuntu下dump出来的main.cpp.002t.class文件如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line">Class X</span><br><span class="line">   size=1 align=1</span><br><span class="line">   base size=0 base align=1</span><br><span class="line">X (0x0x7f34c09cf5a0) 0 empty</span><br><span class="line"></span><br><span class="line">Vtable for Y</span><br><span class="line">Y::_ZTV1Y: 3u entries</span><br><span class="line">0     0u</span><br><span class="line">8     (int (*)(...))0</span><br><span class="line">16    (int (*)(...))(&amp; _ZTI1Y)</span><br><span class="line"></span><br><span class="line">VTT for Y</span><br><span class="line">Y::_ZTT1Y: 1u entries</span><br><span class="line">0     ((&amp; Y::_ZTV1Y) + 24u)</span><br><span class="line"></span><br><span class="line">Class Y</span><br><span class="line">   size=8 align=8</span><br><span class="line">   base size=8 base align=8</span><br><span class="line">Y (0x0x7f34c08661a0) 0 nearly-empty</span><br><span class="line">    vptridx=0u vptr=((&amp; Y::_ZTV1Y) + 24u)</span><br><span class="line">  X (0x0x7f34c09cf600) 0 empty virtual</span><br><span class="line">      vbaseoffset=-24</span><br><span class="line"></span><br><span class="line">Vtable for Z</span><br><span class="line">Z::_ZTV1Z: 3u entries</span><br><span class="line">0     0u</span><br><span class="line">8     (int (*)(...))0</span><br><span class="line">16    (int (*)(...))(&amp; _ZTI1Z)</span><br><span class="line"></span><br><span class="line">VTT for Z</span><br><span class="line">Z::_ZTT1Z: 1u entries</span><br><span class="line">0     ((&amp; Z::_ZTV1Z) + 24u)</span><br><span class="line"></span><br><span class="line">Class Z</span><br><span class="line">   size=8 align=8</span><br><span class="line">   base size=8 base align=8</span><br><span class="line">Z (0x0x7f34c0866208) 0 nearly-empty</span><br><span class="line">    vptridx=0u vptr=((&amp; Z::_ZTV1Z) + 24u)</span><br><span class="line">  X (0x0x7f34c09cf660) 0 empty virtual</span><br><span class="line">      vbaseoffset=-24</span><br><span class="line"></span><br><span class="line">Vtable for A</span><br><span class="line">A::_ZTV1A: 6u entries</span><br><span class="line">0     0u</span><br><span class="line">8     (int (*)(...))0</span><br><span class="line">16    (int (*)(...))(&amp; _ZTI1A)</span><br><span class="line">24    18446744073709551608u</span><br><span class="line">32    (int (*)(...))-8</span><br><span class="line">40    (int (*)(...))(&amp; _ZTI1A)</span><br><span class="line"></span><br><span class="line">Construction vtable for Y (0x0x7f34c0866270 instance) in A</span><br><span class="line">A::_ZTC1A0_1Y: 3u entries</span><br><span class="line">0     0u</span><br><span class="line">8     (int (*)(...))0</span><br><span class="line">16    (int (*)(...))(&amp; _ZTI1Y)</span><br><span class="line"></span><br><span class="line">Construction vtable for Z (0x0x7f34c08662d8 instance) in A</span><br><span class="line">A::_ZTC1A8_1Z: 3u entries</span><br><span class="line">0     18446744073709551608u</span><br><span class="line">8     (int (*)(...))0</span><br><span class="line">16    (int (*)(...))(&amp; _ZTI1Z)</span><br><span class="line"></span><br><span class="line">VTT for A</span><br><span class="line">A::_ZTT1A: 4u entries</span><br><span class="line">0     ((&amp; A::_ZTV1A) + 24u)</span><br><span class="line">8     ((&amp; A::_ZTC1A0_1Y) + 24u)</span><br><span class="line">16    ((&amp; A::_ZTC1A8_1Z) + 24u)</span><br><span class="line">24    ((&amp; A::_ZTV1A) + 48u)</span><br><span class="line"></span><br><span class="line">Class A</span><br><span class="line">   size=16 align=8</span><br><span class="line">   base size=16 base align=8</span><br><span class="line">A (0x0x7f34c0878310) 0</span><br><span class="line">    vptridx=0u vptr=((&amp; A::_ZTV1A) + 24u)</span><br><span class="line">  Y (0x0x7f34c0866270) 0 nearly-empty</span><br><span class="line">      primary-for A (0x0x7f34c0878310)</span><br><span class="line">      subvttidx=8u</span><br><span class="line">    X (0x0x7f34c09cf6c0) 0 empty virtual</span><br><span class="line">        vbaseoffset=-24</span><br><span class="line">  Z (0x0x7f34c08662d8) 8 nearly-empty</span><br><span class="line">      subvttidx=16u vptridx=24u vptr=((&amp; A::_ZTV1A) + 48u)</span><br><span class="line">    X (0x0x7f34c09cf6c0) alternative-path</span><br></pre></td></tr></table></figure><p>在调试的时候还可以通过GDB命令<code>info vtbl</code>来查看vtable，下面是在vscode中调试示例。</p><img src="/2018/11/06/sizeof-question-in-cpp/vtable1.png"><p>如果想更多了解C++背后的故事，推荐阅读Lippman的《Inside the C++ Object Model》一书。</p><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ul><li><p><a href="https://ofekshilon.com/2010/11/07/d1reportallclasslayout-dumping-object-memory-layout/" target="_blank" rel="noopener">https://ofekshilon.com/2010/11/07/d1reportallclasslayout-dumping-object-memory-layout/</a></p></li><li><p><a href="http://visualgdb.com/gdbreference/commands/info_vtbl" target="_blank" rel="noopener">http://visualgdb.com/gdbreference/commands/info_vtbl</a></p></li><li><a href="https://www.gonwan.com/2010/09/20/c-class-layout-using-msvc/" target="_blank" rel="noopener">https://www.gonwan.com/2010/09/20/c-class-layout-using-msvc/</a></li><li><a href="https://stackoverflow.com/questions/99297/how-are-virtual-functions-and-vtable-implemented" target="_blank" rel="noopener">https://stackoverflow.com/questions/99297/how-are-virtual-functions-and-vtable-implemented</a></li><li><a href="https://www.v2ex.com/t/500682#reply10" target="_blank" rel="noopener">https://www.v2ex.com/t/500682#reply10</a></li><li><a href="https://isocpp.org/wiki/faq/pointers-to-members" target="_blank" rel="noopener">https://isocpp.org/wiki/faq/pointers-to-members</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近在看Lippman的《Inside the c++ object model》，书中Lippman说有人发邮件问了他一个问题。&lt;/p&gt;
&lt;figure class=&quot;highlight cpp&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;X&lt;/span&gt; &amp;#123;&lt;/span&gt;&amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;Y&lt;/span&gt; :&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;virtual&lt;/span&gt; X&amp;#123;&amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;Z&lt;/span&gt;:&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;virtual&lt;/span&gt; X&amp;#123;&amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;A&lt;/span&gt;:&lt;/span&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; Y, &lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; Z&amp;#123;&amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;根据以上定义，使用sizeof运算符分别计算类X,Y,Z,A的所占大小。&lt;/p&gt;
    
    </summary>
    
      <category term="coding" scheme="https://bygeek.cn/categories/coding/"/>
    
    
      <category term="c++" scheme="https://bygeek.cn/tags/c/"/>
    
  </entry>
  
  <entry>
    <title>VMware虚拟机中设置网络代理</title>
    <link href="https://bygeek.cn/2018/10/24/set-network-proxy-in-vmware-virtual-machine/"/>
    <id>https://bygeek.cn/2018/10/24/set-network-proxy-in-vmware-virtual-machine/</id>
    <published>2018-10-24T05:53:13.000Z</published>
    <updated>2020-01-31T16:23:02.668Z</updated>
    
    <content type="html"><![CDATA[<p>本文是为vmware中安装的ubuntu设置代理的备忘。</p><a id="more"></a><h2 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h2><ul><li><p>在宿主机中安装好shadowsocks，并允许局域网连接。</p><img src="/2018/10/24/set-network-proxy-in-vmware-virtual-machine/shadowsocks_setting.png"></li><li><p>在vmware中设置虚拟机的网络为NAT模式，这时虚拟机对外来说共享宿主的IP地址，对内于宿主是属于局域网</p><img src="/2018/10/24/set-network-proxy-in-vmware-virtual-machine/vmware_setting.png"></li><li><p>在ubuntu中，system settings-&gt;network -&gt; network proxy 中勾选Manual（手动）,地址全部填宿主机IP（局域网网段），设置好代理端口（可在windows下的shadowsocks查看，一般为默认1080）</p><img src="/2018/10/24/set-network-proxy-in-vmware-virtual-machine/ubuntu_setting.png"></li><li><p>访问下不可知的网站试试。</p></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文是为vmware中安装的ubuntu设置代理的备忘。&lt;/p&gt;
    
    </summary>
    
      <category term="tutorial" scheme="https://bygeek.cn/categories/tutorial/"/>
    
    
      <category term="shadowsocks" scheme="https://bygeek.cn/tags/shadowsocks/"/>
    
      <category term="vmware" scheme="https://bygeek.cn/tags/vmware/"/>
    
  </entry>
  
  <entry>
    <title>vtable and object memory layout in cpp</title>
    <link href="https://bygeek.cn/2018/10/22/vtable-and-object-memory-layout-in-cpp-language/"/>
    <id>https://bygeek.cn/2018/10/22/vtable-and-object-memory-layout-in-cpp-language/</id>
    <published>2018-10-22T03:07:44.000Z</published>
    <updated>2020-01-31T16:23:02.777Z</updated>
    
    <content type="html"><![CDATA[<p>在C语言中，data和function是独立的entity，换句话说data和function是没有直接关联的。所以说使用C编程是面向过程编程，使用一个个的function来操作外在的data。而在C++中，通过Class将data和function集合在一起，形成一个Object。通过面向对象编程的三大特点：1)封装2)继承3)多态 来实现更好的灵活性。</p><a id="more"></a><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">//c style： declare data structure and function seperately</span></span><br><span class="line"><span class="comment">//data</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">point</span>&#123;</span></span><br><span class="line">    <span class="keyword">float</span> x;</span><br><span class="line">    <span class="keyword">float</span> y;</span><br><span class="line">&#125;Point_t;</span><br><span class="line"></span><br><span class="line"><span class="comment">//function</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print_point</span><span class="params">(<span class="keyword">const</span> Point_t* ptr)</span></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%f %f"</span>, ptr-&gt;x, ptr-&gt;y);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//c++ style: use class</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Point(<span class="keyword">float</span> x, <span class="keyword">float</span> y): m_x(x), m_y(y)&#123;&#125;</span><br><span class="line">    ~Point() = <span class="keyword">default</span>;</span><br><span class="line">   </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%f %f"</span>, m_x, m_y);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">float</span> <span class="title">x</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> m_x;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">float</span> <span class="title">y</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> m_y;&#125;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">float</span> m_x;</span><br><span class="line">    <span class="keyword">float</span> m_y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="c-Object-Memory-Model"><a href="#c-Object-Memory-Model" class="headerlink" title="c++ Object Memory Model"></a>c++ Object Memory Model</h2><p>在上述代码中，Point类的大小跟C语言中的Point 结构体的大小是一致的，在64bit机器上使用sizeof运算符得到大小都是8 byte。考虑下面的一个例子：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> a;</span><br><span class="line">    <span class="keyword">float</span> f;</span><br><span class="line">    <span class="keyword">char</span> c1;</span><br><span class="line">    <span class="keyword">char</span> c2;</span><br><span class="line">    <span class="keyword">char</span> d[<span class="number">4</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一个对象所占的内存空间是一块连续的地址，且后声明的数据成员具有更高的地址。</p><h2 id="what-is-vtable"><a href="#what-is-vtable" class="headerlink" title="what is vtable"></a>what is vtable</h2><ul><li>static array usually the first slot in c++ object model</li><li>class-specific</li><li>vptr, vptr is assigned in constructor by compiler generated code, that is why member initialization list is different with initialization in constructor body.</li><li>polymorphic can be implemented differently between compilers. But generally implement using vtable</li><li>use sample code in linux, use gdb to show vtable: -exec info vtbl objectname</li></ul><h2 id="object-memory-model"><a href="#object-memory-model" class="headerlink" title="object memory model"></a>object memory model</h2><ul><li>alignment</li></ul><h2 id="member-function"><a href="#member-function" class="headerlink" title="member function"></a>member function</h2><ul><li>member function is just a tag in code segment, is not include in object memory layout</li></ul><h2 id="single-inheritance-and-multi-inheritance"><a href="#single-inheritance-and-multi-inheritance" class="headerlink" title="single inheritance and multi-inheritance"></a>single inheritance and multi-inheritance</h2><ul><li>pointer fix needed in multi-inheritance</li></ul><h2 id="notes"><a href="#notes" class="headerlink" title="notes"></a>notes</h2><ul><li><a href="https://isocpp.org/wiki/faq/pointers-to-members" target="_blank" rel="noopener">pointers-to-members</a></li><li>PPT material</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在C语言中，data和function是独立的entity，换句话说data和function是没有直接关联的。所以说使用C编程是面向过程编程，使用一个个的function来操作外在的data。而在C++中，通过Class将data和function集合在一起，形成一个Object。通过面向对象编程的三大特点：1)封装2)继承3)多态 来实现更好的灵活性。&lt;/p&gt;
    
    </summary>
    
      <category term="coding" scheme="https://bygeek.cn/categories/coding/"/>
    
    
      <category term="c++" scheme="https://bygeek.cn/tags/c/"/>
    
  </entry>
  
</feed>
