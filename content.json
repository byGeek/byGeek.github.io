{"meta":{"title":"byGeek's Playground","subtitle":null,"description":"记录世界，记录自己","author":"byGeek","url":"bygeek.cn"},"pages":[{"title":"About","date":"2018-02-26T01:57:31.000Z","updated":"2018-03-17T13:27:33.249Z","comments":false,"path":"about/index.html","permalink":"bygeek.cn/about/index.html","excerpt":"","text":"胖子 毕业于大连理工大学 程序汪"},{"title":"categories","date":"2018-02-26T05:43:01.000Z","updated":"2018-03-11T12:58:33.440Z","comments":false,"path":"categories/index.html","permalink":"bygeek.cn/categories/index.html","excerpt":"","text":""},{"title":"tags","date":"2018-02-26T03:30:11.000Z","updated":"2018-03-11T12:58:33.442Z","comments":false,"path":"tags/index.html","permalink":"bygeek.cn/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"网站备案","slug":"网站备案","date":"2018-03-13T01:24:58.000Z","updated":"2018-03-17T13:27:33.246Z","comments":true,"path":"2018/03/13/网站备案/","link":"","permalink":"bygeek.cn/2018/03/13/网站备案/","excerpt":"","text":"今天打开博客，发现无法访问了，腾讯云提示需要网站备案。打开备案网址，每个省的备案规则还不一样，江苏省备案要求非省户籍必须提供居住证明。证明链如下： 网站备案 -&gt; 居住证明 -&gt; 房屋租赁备案证明 -&gt; 房产证 好吧，看来居住证明是非办理不可了。 现在域名无法解析，暂时将nginx监听端口修改为8080，只能通过ip访问。","categories":[{"name":"hexo","slug":"hexo","permalink":"bygeek.cn/categories/hexo/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"bygeek.cn/tags/hexo/"}]},{"title":"centos 初始化简单配置","slug":"centos-初始化简单配置","date":"2018-03-12T14:08:30.000Z","updated":"2018-03-18T13:09:48.095Z","comments":true,"path":"2018/03/12/centos-初始化简单配置/","link":"","permalink":"bygeek.cn/2018/03/12/centos-初始化简单配置/","excerpt":"","text":"centos简单折腾记录。 新建用户 使用root用户登录到server端。 新建用户账号：adduser robert 设置密码: passwd robert 增加用户到sudoer中root用户拥有系统的最高权限，但是为了系统的安全性，一般不会直接使用root用户。相反我们会使用sudo命令来暂时提高当前用户的权限。下一步我们将新建的用户robert加入到sudoer中。在centos中，在wheel用户组的用户具有sudo权限。 1usermod -aG wheel robert 测试是否成功。 12su robertsudo ls -al /root 修改SSH默认端口ssh是一个安全的加密协议，用于主机之间的通信。为了加强系统的安全性，修改默认的ssh的22端口。 修改ssh_config文件中的默认端口号 1vim /etc/ssh/sshd_config 找到#Port 22这一行，去掉#，取消注释，修改为你想要该的端口号，如10086。 按需修改修改防火墙规则和更新selinux规则。 centos7执行： 12firewall-cmd --add-port 10086firewall-cmd --add-port 2345/tcp --permanent centos6执行： 1iptables -I INPUT -p tcp --dport 10086 -j ACCEPT 同时按需修改selinux: 1semanage port -a -t ssh_port_t -p tcp 10086 重启ssh服务: 1systemctl restart sshd.service 测试ssh链接： 1ssh robert@ip_address -p 10086 参考链接 centos wiki add sudoer","categories":[{"name":"linux","slug":"linux","permalink":"bygeek.cn/categories/linux/"}],"tags":[{"name":"linux","slug":"linux","permalink":"bygeek.cn/tags/linux/"},{"name":"centos","slug":"centos","permalink":"bygeek.cn/tags/centos/"}]},{"title":"利用beyond compare自动生成patch包","slug":"利用beyond-compare自动生成patch包","date":"2018-03-12T02:33:40.000Z","updated":"2018-03-17T13:27:33.243Z","comments":true,"path":"2018/03/12/利用beyond-compare自动生成patch包/","link":"","permalink":"bygeek.cn/2018/03/12/利用beyond-compare自动生成patch包/","excerpt":"前言beyond compare对于程序员来说，可谓是一个不可多得的文件比较工具，试用过winMerge以及一些自带的diff工具之后，还是发现beyond compare界面最为友好，功能也比其他工具强大。 最近有一个需求是能否在每次release之后，可以比较方便的产生各个版本的升级patch包。持续集成的工具(类似jenkins，Travis CI)我没有了解过，不知道是否能有这个功能。但是仅仅对于这个小需求来说，利用beyond compare工具就可以做到。","text":"前言beyond compare对于程序员来说，可谓是一个不可多得的文件比较工具，试用过winMerge以及一些自带的diff工具之后，还是发现beyond compare界面最为友好，功能也比其他工具强大。 最近有一个需求是能否在每次release之后，可以比较方便的产生各个版本的升级patch包。持续集成的工具(类似jenkins，Travis CI)我没有了解过，不知道是否能有这个功能。但是仅仅对于这个小需求来说，利用beyond compare工具就可以做到。 利用BC GUI生成patch包 选中需要对比的两个文件夹，右键选择compare 在BC中选择diff，只显示有变化的文件 在BC菜单栏中Edit -&gt; Expand all, Edit -&gt; select all files 在选中的文件中右击，选择copy to folder 在打开的对话框中，选择要生成patch的文件(left/right side)，选择folder structure为base patch包生成完毕。 编写脚本自动化BC其实是支持脚本运行的，可移步与此。同时安装完BC之后，会在安装目录有CHM的帮助文件，具体的一些语法可参考该文件。 编写脚本，将脚本保存为bc_auto_script.txt 123456789log verbose \"c:\\bclog.txt\" #表示将脚本的log记录在bclog.txt中load \"d:\\testv1.0\" \"d:\\testv2.0\" #加载需要比较的文件夹filter \"-*.log;-lib\\\" #利用beyong compare中的filter：除去*.log文件以及lib子文件夹，即这些不参与比较expand all #展开文件，这个命令与beyond compare中的UI的expand all是对应的select right.diff.files right.orphan.files #只选取有差异的文件copyto right path:base \"D:\\diff.zip\" #将有差异的文件拷贝到d:\\diff中，注意copyto命令的参数 ##right: 对应上述load命令中的参数，即testv2.0，意思是将testv2.0的差异文件copy出来 ##path:base: 指保留目录结构 ##d:\\diff: 输出目录，也可以指明为zip文件：如\"d:\\diff.zip\"，这样最后会生成一个zip包 cmd下执行：&quot;C:\\Program Files (x86)\\Beyond Compare 4\\Bcompare.exe&quot; /silent &quot;@D:\\bc_auto_script.txt&quot;, BC安装路径， silent参数表示不启动GUI， 后面是在第一部中编写的脚本文件。 diff.zip即为生成的patch文件。如果要实现批量的生成patch包，可以编写一个批处理脚本。可参考这里。 参考链接 beyond compare sample script","categories":[{"name":"CI","slug":"CI","permalink":"bygeek.cn/categories/CI/"}],"tags":[{"name":"CI","slug":"CI","permalink":"bygeek.cn/tags/CI/"}]},{"title":"TCP报头的标志位","slug":"TCP报头的标志位","date":"2018-03-05T09:15:45.000Z","updated":"2018-03-11T12:58:33.428Z","comments":true,"path":"2018/03/05/TCP报头的标志位/","link":"","permalink":"bygeek.cn/2018/03/05/TCP报头的标志位/","excerpt":"上篇文章简单的摘录了TCP建立连接和释放连接的过程。TCP报头中的标志位于操控TCP的状态机。下面简单说说TCP报头中的标志位。","text":"上篇文章简单的摘录了TCP建立连接和释放连接的过程。TCP报头中的标志位于操控TCP的状态机。下面简单说说TCP报头中的标志位。 TCP 报头二图胜千言。 对比上述二图，可以看到TCP报文中定义了8个标志位。分别为SYN,ACK,FIN,PSH,RST,URG,CWR,ECE，其中最为常用的是前六个标志位。通过对这些标志位置位，可以控制TCP连接的建立和释放。 标志位标志位的功能摘录如下： SYN: for SYNchronize; marks packets that are part of the new-connection handshake ACK: indicates that the header Acknowledgment field is valid; that is, all but the first packet FIN: for FINish; marks packets involved in the connection closing PSH: for PuSH; marks “non-full” packets that should be delivered promptly at the far end RST: for ReSeT; indicates various error conditions URG: for URGent; part of a now-seldom-used mechanism for high-priority data CWR and ECE: part of the Explicit Congestion Notification mechanism URG：此标志表示TCP包的紧急指针域（后面马上就要说到）有效，用来保证TCP连接不被中断，并且督促中间层设备要尽快处理这些数据； ACK：此标志表示应答域有效，就是说前面所说的TCP应答号将会包含在TCP数据包中；有两个取值：0和1，为1的时候表示应答域有效，反之为0； PSH：这个标志位表示Push操作。所谓Push操作就是指在数据包到达接收端以后，立即传送给应用程序，而不是在缓冲区中排队； RST：这个标志表示连接复位请求。用来复位那些产生错误的连接，也被用来拒绝错误和非法的数据包； SYN：表示同步序号，用来建立连接。SYN标志位和ACK标志位搭配使用，当连接请求的时候，SYN=1，ACK=0；连接被响应的时候，SYN=1，ACK=1；这个标志的数据包经常被用来进行端口扫描。扫描者发送一个只有SYN的数据包，如果对方主机响应了一个数据包回来，就表明这台主机存在这个端口；但是由于这种扫描方式只是进行TCP三次握手的第一次握手，因此这种扫描的成功表示被扫描的机器不很安全，一台安全的主机将会强制要求一个连接严格的进行TCP的三次握手； FIN： 表示发送端已经达到数据末尾，也就是说双方的数据传送完成，没有数据可以传送了，发送FIN标志位的TCP数据包后，连接将被断开。这个标志的数据包也经常被用于进行端口扫描。 TCP过程结合下图来理解TCP连接的建立与释放和标志位的关系。 Wireshark抓包我们可以利用Wireshark抓包工具来对上述过程进行抓包。Wireshar本身不支持loopback address（即127.0.0.1）进行抓包测试，但是可以下载一个插件实现该功能：Npcap。 在本地建立一个socket 链接，详情可参考该博文。 打开wireshark，选择npcap虚拟网卡，开始抓包，并在filter中过滤TCP端口。 三次握手建立连接。SYN表示开始建立连接，PSH表示该包中有数据。 同时在wireshark的中间窗口中可以更清楚的看到标志位的置位情况。 四次挥手释放连接。FIN表示开始释放连接。client端发送带FIN标志的数据包，server端收到后给一个ACK确认包。然后server端确认自己也没有数据要发送，也给一个FIN包，最后client端回复ACK包，至此连接被释放。 netstat命令行工具在windows下，系统提供了一个netstat工具来查看连接的状态。 netstat -na | find &quot;55554&quot; 参考链接 TCP Transport TCP\\IP三次握手连接，四次握手断开分析","categories":[{"name":"网络通信","slug":"网络通信","permalink":"bygeek.cn/categories/网络通信/"}],"tags":[{"name":"TCP","slug":"TCP","permalink":"bygeek.cn/tags/TCP/"}]},{"title":"TCP中的三次握手和四次挥手","slug":"TCP中的三次握手和四次挥手","date":"2018-03-05T08:55:41.000Z","updated":"2018-03-11T12:58:33.426Z","comments":true,"path":"2018/03/05/TCP中的三次握手和四次挥手/","link":"","permalink":"bygeek.cn/2018/03/05/TCP中的三次握手和四次挥手/","excerpt":"TCP(Transmission Control Protocol)是一种面向连接的可靠的传输协议。TCP连接的建立和释放过程可由下图表示：","text":"TCP(Transmission Control Protocol)是一种面向连接的可靠的传输协议。TCP连接的建立和释放过程可由下图表示： 那么问题来了： 为什么建立连接协议是三次握手，而关闭连接却是四次握手呢？ 这是因为服务端的 LISTEN 状态下的 SOCKET 当收到 SYN 报文的建立连接请求后，它可以把 ACK 和 SYN （ ACK 起应答作用，而 SYN 起同步作用）放在一个报文里来发送。TCP是全双工通信，关闭连接时，当收到对方的 FIN 报文通知时，它仅仅表示对方没有数据发送给你了；但未必你所有的数据都全部发送给对方了，所以你可以未必会马上会关闭 SOCKET, 也即你可能还需要发送一些数据给对方之后，再发送 FIN 报文给对方来表示你同意现在可以关闭连接了，所以它这里的 ACK 报文和 FIN报文多数情况下都是分开发送的。 为什么 TIME_WAIT 状态还需要等 2MSL 后才能返回到 CLOSED 状态？ 这是因为虽然双方都同意关闭连接了，而且握手的 4 个报文也都协调和发送完毕，按理可以直接回到 CLOSED 状态（就好比从 SYN_SEND 状态到 ESTABLISH 状态那样）；但是因为我们必须要假想网络是不可靠的，你无法保证你最后发送的 ACK 报文会一定被对方收到，因此对方处于 LAST_ACK 状态下的 SOCKET 可能会因为超时未收到 ACK 报文，而重发 FIN 报文，所以这个 TIME_WAIT 状态的作用就是用来重发可能丢失的 ACK 报文。 本文摘录自 此","categories":[{"name":"网络通信","slug":"网络通信","permalink":"bygeek.cn/categories/网络通信/"}],"tags":[{"name":"TCP","slug":"TCP","permalink":"bygeek.cn/tags/TCP/"}]},{"title":"c#：关于socket.Receive是否阻塞的问题","slug":"c-：关于socket-Receive是否阻塞的问题","date":"2018-03-05T08:38:40.000Z","updated":"2018-03-11T12:58:33.437Z","comments":true,"path":"2018/03/05/c-：关于socket-Receive是否阻塞的问题/","link":"","permalink":"bygeek.cn/2018/03/05/c-：关于socket-Receive是否阻塞的问题/","excerpt":"最近socket调查一个bug的时候，发现一个“问题”。在c#中调用socket.Receive(buff)的时候，并没有阻塞当前线程，而是直接返回。","text":"最近socket调查一个bug的时候，发现一个“问题”。在c#中调用socket.Receive(buff)的时候，并没有阻塞当前线程，而是直接返回。 查看MSDN： The Receive method reads data into the buffer parameter and returns the number of bytes successfully read. You can call Receive from both connection-oriented and connectionless sockets. This overload only requires you to provide a receive buffer. The buffer offset defaults to 0, the size defaults to the length of the buffer parameter, and the SocketFlags value defaults to None. If you are using a connection-oriented protocol, you must either call Connect to establish a remote host connection, or Accept to accept an incoming connection prior to calling Receive. The Receive method will only read data that arrives from the remote host established in the Connect or Acceptmethod. If you are using a connectionless protocol, you can also use the ReceiveFrom method. ReceiveFrom will allow you to receive data arriving from any host. If no data is available for reading, the Receive method will block until data is available, unless a time-out value was set by using Socket.ReceiveTimeout. If the time-out value was exceeded, the Receive call will throw a SocketException. If you are in non-blocking mode, and there is no data available in the in the protocol stack buffer, the Receive method will complete immediately and throw a SocketException. You can use the Available property to determine if data is available for reading. When Available is non-zero, retry the receive operation. If you are using a connection-oriented Socket, the Receive method will read as much data as is available, up to the size of the buffer. If the remote host shuts down the Socket connection with the Shutdown method, and all available data has been received, the Receive method will complete immediately and return zero bytes. If you are using a connectionless Socket, Receive will read the first queued datagram from the destination address you specify in the Connectmethod. If the datagram you receive is larger than the size of the buffer parameter, buffer gets filled with the first part of the message, the excess data is lost and a SocketException is thrown. 加粗位置：当使用面向连接的socket（比如使用TCP协议），socket.Receive(buff)方法会获取尽可能多的数据来填充buff。但是如果remote端(可以是client，也可以是server)调用shutdown，而且所有的数据都收到了，则再次调用socket.Receive(buff)会立即返回。","categories":[{"name":"socket","slug":"socket","permalink":"bygeek.cn/categories/socket/"}],"tags":[{"name":"socket","slug":"socket","permalink":"bygeek.cn/tags/socket/"},{"name":"c#","slug":"c","permalink":"bygeek.cn/tags/c/"}]},{"title":"Socket通信浅析","slug":"Socket通信浅析","date":"2018-03-05T06:46:38.000Z","updated":"2018-03-11T12:58:33.420Z","comments":true,"path":"2018/03/05/Socket通信浅析/","link":"","permalink":"bygeek.cn/2018/03/05/Socket通信浅析/","excerpt":"定义Socket通信是计算机网络中一种重要的数据交换的方式。维基百科对socket定义如下： 在操作系统中，通常会为应用程序提供一组应用程序接口（API），称为套接字接口（英语：socket API）。应用程序可以通过套接字接口，来使用网络套接字，以进行数据交换。最早的套接字接口来自于4.2 BSD，因此现代常见的套接字接口大多源自Berkeley套接字（Berkeley sockets）标准。在套接字接口中，以IP地址及通信端口组成套接字地址（socket address）。远程的套接字地址，以及本地的套接字地址完成连接后，再加上使用的协议（protocol），这个五元组（five-element tuple)，作为套接字对（socket pairs），之后就可以彼此交换数据。例如，在同一台计算机上，TCP协议与UDP协议可以同时使用相同的port而互不干扰。 操作系统根据套接字地址，可以决定应该将数据送达特定的进程或线程。","text":"定义Socket通信是计算机网络中一种重要的数据交换的方式。维基百科对socket定义如下： 在操作系统中，通常会为应用程序提供一组应用程序接口（API），称为套接字接口（英语：socket API）。应用程序可以通过套接字接口，来使用网络套接字，以进行数据交换。最早的套接字接口来自于4.2 BSD，因此现代常见的套接字接口大多源自Berkeley套接字（Berkeley sockets）标准。在套接字接口中，以IP地址及通信端口组成套接字地址（socket address）。远程的套接字地址，以及本地的套接字地址完成连接后，再加上使用的协议（protocol），这个五元组（five-element tuple)，作为套接字对（socket pairs），之后就可以彼此交换数据。例如，在同一台计算机上，TCP协议与UDP协议可以同时使用相同的port而互不干扰。 操作系统根据套接字地址，可以决定应该将数据送达特定的进程或线程。 Socket本身并不是通信协议，只是定义的一个调用接口(API)，我们可以通过socket来使用TCP/UDP协议。socket只是对TCP等协议的抽象，方便应用层调用底层的通信协议。如下图： Socket 原语所谓的原语(primitive)是指定义的一些基本操作，跟具体的实现无关。TCP协议中socket定义的原语如下图： 其中包含两个方面，server side和client side。 Server side: Server startup executes SOCKET, BIND, LISTEN. LISTEN - allocate queue for multiple simultaneous clients. ACCEPT - suspend server until request. When client request arrives: ACCEPT returns.Start new socket (thread or process) with same properties as original, this handles the request,server goes on waiting on original socket.If new request arrives while spawning thread for this one, it is queued.If queue full it is refused. ​ Client side: SOCKET to create. Then CONNECT. When this returns the socket is open. Both sides can now SEND, RECEIVE. Connection not released until both sides do CLOSE. Typically client does it, server acks. 示例下面通过一个简单的示例，来展示c#中的socket编程的API，实现socket 多client连接。 server端代码：在while循环中接受client的连接，accept之后另起一个线程来handle这个request，并通过检查socket的状态来判断连接是否是active。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475static void Run() &#123; IPEndPoint server = new IPEndPoint(IPAddress.Parse(\"127.0.0.1\"), 55554); Socket listener = new Socket(AddressFamily.InterNetwork, SocketType.Stream, ProtocolType.Tcp); listener.Bind(server); listener.Listen(10); while (true) &#123; Log(\"waiting for connection...\"); Socket handler = listener.Accept(); Log(\"connection established.\"); try &#123; Thread thread = new Thread(new ParameterizedThreadStart(HandleSocket)); thread.Start(handler); &#125; catch (Exception e) &#123; Console.WriteLine(e.Message); &#125; &#125; &#125;static void HandleSocket(object socket) &#123; var handler = socket as Socket; byte[] data = new byte[1024]; try &#123; bool connected = SocketConnected(handler); while (connected) &#123; var cnt = 0; var recvStr = string.Empty; cnt = handler.Receive(data, SocketFlags.None); recvStr = Encoding.Default.GetString(data, 0, cnt); if (recvStr.IndexOf(\"\\n\") &gt; 0) &#123; //response Log(\"\\n \" + DateTime.Now.ToString() + \" received cmd: \" + recvStr); Log(\"send ok back.\\n\"); byte[] sendStr = Encoding.Default.GetBytes(\"ok\\n\"); handler.Send(sendStr); &#125; /* if (recvStr.IndexOf(\"&lt;EOF&gt;\") &gt;= 0) &#123; break; &#125; * */ connected = SocketConnected(handler); &#125; Log(\"close socket...\"); handler.Shutdown(SocketShutdown.Both); handler.Close(); &#125; catch (Exception ex) &#123; if (handler != null) &#123; handler.Shutdown(SocketShutdown.Both); handler.Close(); &#125; Log(ex.Message); &#125; &#125; client端代码：通过connect来建立连接，建立成功之后，即可发送数据，收发多次数据之后，将连接关闭。 1234567891011121314151617181920212223242526272829303132333435363738394041static void Communicate() &#123; Socket socket = new Socket(AddressFamily.InterNetwork, SocketType.Stream, ProtocolType.Tcp); byte[] buffer = new byte[1024]; IPEndPoint endpoint = new IPEndPoint(IPAddress.Parse(\"127.0.0.1\"), 55554); string recv = string.Empty; try &#123; socket.Connect(endpoint); byte[] data = Encoding.Default.GetBytes(\"connect\\n\"); for (int i = 0; i &lt; 10; i++) &#123; socket.Send(data); Console.WriteLine(\"&#123;0&#125; send: connect\\n\", DateTime.Now.ToString()); var cnt = socket.Receive(buffer); recv = Encoding.Default.GetString(buffer, 0, cnt); Console.WriteLine(\"&#123;0&#125; received: &#123;1&#125;\", DateTime.Now.ToString(), recv); if (!recv.Contains(\"ok\")) &#123; Console.WriteLine(\"not ok!\\n\"); break; &#125; &#125; //byte[] end = Encoding.Default.GetBytes(\"&lt;EOF&gt;\"); //socket.Send(end); //socket.Disconnect(false); socket.Shutdown(SocketShutdown.Both); socket.Close(); &#125; catch (Exception ex) &#123; Console.WriteLine(ex); &#125; 注意点： 在csharp中，socket等资源属于非托管资源，使用完毕之后，必须释放（client和server分别close），否则会导致内存泄漏。 server端close的释放时机一般是client端这边close之后，server也没有数据发送给client端。可以有以下方法来判断建立的连接是否已经close了： 通过client端发送定义好的字符，如&lt;EOF&gt;，当server端收到预定义好的字符串，则断开与client的连接并回收资源。 通过Socket.Poll方法。该方法可以用来判断socket的连接状态。MSDN文档如下： 1234public bool Poll( int microSeconds, SelectMode mode) Poll will block execution until the specified time period, measured in microseconds, elapses. Set the microSeconds parameter to a negative integer if you would like to wait indefinitely for a response. The Poll method will check the state of the Socket. Specify SelectMode.SelectRead for the selectMode parameter to determine if the Socket is readable. Specify SelectMode.SelectWrite to determine if the Socket is writable. Use SelectMode.SelectError to detect an error condition. TCP 浅析占位下篇博客链接占位。 参考链接 socket 原语 即时通讯系列之Socket简介 MSDN Socket.Poll Method 网络套接字 维基 Instantly detect client disconnection from server socket","categories":[{"name":"网络通信","slug":"网络通信","permalink":"bygeek.cn/categories/网络通信/"}],"tags":[{"name":"socket","slug":"socket","permalink":"bygeek.cn/tags/socket/"}]},{"title":"WPF自定义控件和依赖项属性浅析","slug":"WPF-自定义控件和依赖项属性浅析","date":"2018-02-28T00:18:35.000Z","updated":"2018-03-11T12:58:33.435Z","comments":true,"path":"2018/02/28/WPF-自定义控件和依赖项属性浅析/","link":"","permalink":"bygeek.cn/2018/02/28/WPF-自定义控件和依赖项属性浅析/","excerpt":"前言依赖项属性是WPF引入的一个新特性，它扩展了普通的CLR属性。同时依赖项属性有以下优点：减少内存占用，值继承，自动通知等。","text":"前言依赖项属性是WPF引入的一个新特性，它扩展了普通的CLR属性。同时依赖项属性有以下优点：减少内存占用，值继承，自动通知等。 依赖项属性与普通CLR属性区别和优点它与CLR属性的区别是： CLR属性是类中的一个成员，可以直接读取，而依赖项属性要通过GetValue() 方法动态取得 当你设置CLR属性时，CLR属性存储在对象的field中。依赖项属性必须声明为public static readonly，存储在基类DependencyObject中的Dictionary中。 依赖项属性带来的好处如下： 减少内存占用 It’s a huge dissipation to store a field for each property when you think that over 90% of the properties of a UI control typically stay at its initial values. Dependency properties solve these problems by only store modified properties in the instance. The default values are stored once within the dependency property. 值继承 When you access a dependency property the value is resolved by using a value resolution strategy. If no local value is set, the dependency property navigates up the logical tree until it finds a value. When you set the FontSize on the root element it applies to all textblocks below except you override the value. 变化通知 Dependency properties have a built-in change notification mechanism. By registering a callback in the property metadata you get notified, when the value of the property has been changed. This is also used by the databinding. 下面编写一个自定义控件，并给自定义控件加入几个依赖项属性。 例子在接下来的例子中，我们将自定义一个ChkButton控件，该控件左边是一个TextBlock，右边是一个Checkbox。并且定义两个依赖项属性：IsChecked，ChkVisibility。 创建自定义控件(Custom Control)。 创建成功后会在工程目录下多了一个theme的文件夹，同时在该文件夹内有Generic.xaml。该xaml是一个ResourceDictionary，在AssemblyInfo文件中会加载该xaml资源。 在Generic.xaml中，我们可以定义该Custom Control的ControlTemplate。 1234567891011121314151617181920212223242526272829303132333435&lt;Style TargetType=\"&#123;x:Type local:ChkButton&#125;\"&gt; &lt;Setter Property=\"Template\"&gt; &lt;Setter.Value&gt; &lt;ControlTemplate TargetType=\"&#123;x:Type local:ChkButton&#125;\"&gt; &lt;Border Background=\"&#123;TemplateBinding Background&#125;\" BorderBrush=\"&#123;TemplateBinding BorderBrush&#125;\" BorderThickness=\"&#123;TemplateBinding BorderThickness&#125;\"&gt; &lt;Grid&gt; &lt;Grid.ColumnDefinitions&gt; &lt;ColumnDefinition Width=\"*\" /&gt; &lt;ColumnDefinition Width=\"auto\" /&gt; &lt;/Grid.ColumnDefinitions&gt; &lt;TextBlock Name=\"PART_txt\" Margin=\"3,3\" HorizontalAlignment=\"Right\" VerticalAlignment=\"Center\" Text=\"&#123;TemplateBinding Content&#125;\" /&gt; &lt;CheckBox Name=\"PART_chk\" Grid.Column=\"1\" HorizontalAlignment=\"Center\" VerticalAlignment=\"Center\" IsChecked=\"&#123;Binding RelativeSource=&#123;RelativeSource TemplatedParent&#125;, Path=IsChecked, Mode=TwoWay&#125;\" Visibility=\"Collapsed\" /&gt; &lt;/Grid&gt; &lt;/Border&gt; &lt;/ControlTemplate&gt; &lt;/Setter.Value&gt; &lt;/Setter&gt; &lt;/Style&gt; ​ 先在该xaml中引入namespace，如xmlns:local=&quot;clr-namespace:ButtonTest1&quot; 该ControlTemplate中的Checkbox的IsChecked属性双向绑定与ChkButton的自定义的IsChecked依赖项属性，从而将内部的checkbox的checked属性开放出来。 定义ChkButton的依赖项属性：IsChecked, ChkVisibility。 1234567891011121314151617181920212223242526272829303132public static readonly DependencyProperty IsCheckedProperty = DependencyProperty.Register(\"IsChecked\", typeof(Boolean), typeof(ChkButton)); public bool IsChecked &#123; get &#123; return (bool)GetValue(IsCheckedProperty); &#125; set &#123; SetValue(IsCheckedProperty, value); &#125; &#125; public static readonly DependencyProperty ChkVisibilityProperty = DependencyProperty.Register(\"ChkVisibility\", typeof(Visibility), typeof(ChkButton), new PropertyMetadata(Visibility.Collapsed, new PropertyChangedCallback((obj, args) =&gt; &#123; var btn = (ChkButton)obj; btn.ApplyTemplate(); var textblock = (TextBlock)btn.GetTemplateChild(\"PART_txt\"); var checkbox = (CheckBox)btn.GetTemplateChild(\"PART_chk\"); checkbox.Visibility = (Visibility)args.NewValue; if (checkbox.Visibility == Visibility.Visible) &#123; textblock.HorizontalAlignment = HorizontalAlignment.Right; &#125; else &#123; textblock.HorizontalAlignment = HorizontalAlignment.Center; &#125; &#125;))); public Visibility ChkVisibility &#123; get &#123; return (Visibility)GetValue(ChkVisibilityProperty); &#125; set &#123; SetValue(ChkVisibilityProperty, value); &#125; &#125; 在ControlTemplate中给每一个Part定义一个名称，这样可以使用GetTemplateChild方法来获取到引用，注意在调用之前，必须先调用控件的ApplyTemplate方法。 我们希望在点击ChkButton的TextBlock部分时，响应Button的Click事件，在点击Checkbox部分时，不触发Click事件。但是由于WPF中event的冒泡特性，也会传递到ChkButton。我们可以在ChkButton的构造函数设置为该事件已处理。 1234567891011public ChkButton() &#123; this.Click += (sender, args) =&gt; &#123; if (args.OriginalSource is CheckBox) &#123; args.Handled = true; return; &#125; &#125;; &#125; ​ ChkButton已经创建好了。在xaml中可以使用。 123456789101112&lt;local:ChkButton x:Name=\"chkbtn1\" Width=\"100\" Height=\"100\" Margin=\"5\" Background=\"LightBlue\" ChkVisibility=\"Collapsed\" Click=\"ChkButton_Click\" Content=\"another text\" IsChecked=\"False\" /&gt; &lt;TextBlock Margin=\"5\" Text=\"&#123;Binding ElementName=chkbtn1, Path=IsChecked&#125;\" /&gt; ​ 参考链接 https://wpftutorial.net/DependencyProperties.html https://docs.microsoft.com/en-us/dotnet/framework/wpf/advanced/dependency-properties-overview","categories":[{"name":"WPF","slug":"WPF","permalink":"bygeek.cn/categories/WPF/"}],"tags":[{"name":"WPF","slug":"WPF","permalink":"bygeek.cn/tags/WPF/"}]},{"title":"博客迁移记录","slug":"博客迁移记录","date":"2018-02-26T03:01:51.000Z","updated":"2018-03-11T12:58:33.438Z","comments":true,"path":"2018/02/26/博客迁移记录/","link":"","permalink":"bygeek.cn/2018/02/26/博客迁移记录/","excerpt":"这几天将博客的主题换成了next。本来使用的是yilia主题，后来发现渲染有序列表会出现换行的问题，同时yilia已经放弃维护了，next主题也很不错，果断换之。使用hexo框架换个主题简直不要太简单，就不多说了。本文是简单记录下博客迁移的过程。","text":"这几天将博客的主题换成了next。本来使用的是yilia主题，后来发现渲染有序列表会出现换行的问题，同时yilia已经放弃维护了，next主题也很不错，果断换之。使用hexo框架换个主题简直不要太简单，就不多说了。本文是简单记录下博客迁移的过程。 关于如何使用hexo和github pages来搭建博客，网络上有很多教程。我主要是参考 此博文 。这篇博文详细记录了如何建立，部署，同时如何进行博客迁移。摘录部分内容如下： 4.2 我的博客搭建流程 创建仓库，CrazyMilk.github.io； 创建两个分支：master 与 hexo； 设置hexo为默认分支（因为我们只需要手动管理这个分支上的Hexo网站文件）； 使用git clone git@github.com:CrazyMilk/CrazyMilk.github.io.git拷贝仓库； 在本地CrazyMilk.github.io文件夹下通过Git bash依次执行npm install hexo、hexo init、npm install 和 npm install hexo-deployer-git（此时当前分支应显示为hexo）; 修改_config.yml中的deploy参数，分支应为master； 依次执行git add .、git commit -m “…”、git push origin hexo提交网站相关的文件； 执行hexo generate -d生成网站并部署到GitHub上。 这样一来，在GitHub上的CrazyMilk.github.io仓库就有两个分支，一个hexo分支用来存放网站的原始文件，一个master分支用来存放生成的静态网页。完美( •̀ ω •́ )y！ 4.3 我的博客管理流程4.3.1 日常修改在本地对博客进行修改（添加新博文、修改样式等等）后，通过下面的流程进行管理： 依次执行git add .、git commit -m “…”、git push origin hexo指令将改动推送到GitHub（此时当前分支应为hexo）； 然后才执行hexo generate -d发布网站到master分支上。 虽然两个过程顺序调转一般不会有问题，不过逻辑上这样的顺序是绝对没问题的（例如突然死机要重装了，悲催….的情况，调转顺序就有问题了）。 4.3.2 本地资料丢失当重装电脑之后，或者想在其他电脑上修改博客，可以使用下列步骤： 使用git clone git@github.com:CrazyMilk/CrazyMilk.github.io.git拷贝仓库（默认分支为hexo）； 在本地新拷贝的CrazyMilk.github.io文件夹下通过Git bash依次执行下列指令：npm install hexo、npm install、npm install hexo-deployer-git（记得，不需要hexo init这条指令）。 这样一来，hexo分支用于存放markdown等原文件，master分支用来存放生成之后的html等静态页面，可以方便的进行博客迁移和管理。","categories":[],"tags":[{"name":"博客","slug":"博客","permalink":"bygeek.cn/tags/博客/"},{"name":"hexo","slug":"hexo","permalink":"bygeek.cn/tags/hexo/"},{"name":"next","slug":"next","permalink":"bygeek.cn/tags/next/"}]},{"title":"如何删除github敏感文件","slug":"如何删除github敏感文件","date":"2018-02-24T08:35:47.000Z","updated":"2018-03-11T12:58:33.439Z","comments":true,"path":"2018/02/24/如何删除github敏感文件/","link":"","permalink":"bygeek.cn/2018/02/24/如何删除github敏感文件/","excerpt":"前言由于当初建立博客的失误，我将一些不可名状的东西上传到了github中，今天才发现，吓的我赶紧找方法如何删除。google了一番之后终于找到了一个repo-cleaner工具：BFG。 下面就简单记录下如何删除已经commit到服务器上的文件，同时删除commit记录。","text":"前言由于当初建立博客的失误，我将一些不可名状的东西上传到了github中，今天才发现，吓的我赶紧找方法如何删除。google了一番之后终于找到了一个repo-cleaner工具：BFG。 下面就简单记录下如何删除已经commit到服务器上的文件，同时删除commit记录。 步骤 在你的local working directory中将你要删除的文件删除，正常commit并push到remote，因为BFG工具会使用最新的一次commit。 The BFG treats you like a reformed alcoholic: you’ve made some mistakes in the past, but now you’ve cleaned up your act. Thus the BFG assumes that your latest commit is a good one, with none of the dirty files you want removing from your history still in it. This assumption by the BFG protects your work, and gives you peace of mind knowing that the BFG is only changing your repo history, not meddling with the current files of your project. 下载BFG工具jar包，链接 。（当然要先装java runtime）:) 下载git repo的bare repository：git clone --mirror git://example.com/some-repo.git bare repository并不能看到实际的repo文件，但是却包含了repo的全部数据。下载完之后，最好备份一下。 在目录下执行：java -jar bfg.jar --delete-files filename some-repo.git。 后面这个参数为刚刚下载到本地的repo目录，不是完整的git地址。 filename为要删除的文件，注意，该操作会将根目录下及根目录下的子目录的相同filename的文件都删除 如果想删除多个文件，filename参数可以写成{file1,file2}。 进入到刚下好的repo目录中，执行： git reflog expire --expire=now --all &amp;&amp; git gc --prune=now --aggressive 将修改的repo push到remote：git push。 push成功之后查看remote中是否文件已删除，并且与该文件相关的commit的历史记录也删除了。 参考链接 bfg-repo-cleaner Removing sensitive data from a repository 下篇博客预告，总结下博客迁移的步骤吧，今天又踩了以前踩过的坑:)","categories":[],"tags":[{"name":"github","slug":"github","permalink":"bygeek.cn/tags/github/"},{"name":"bfg","slug":"bfg","permalink":"bygeek.cn/tags/bfg/"}]},{"title":"onion architecture","slug":"onion-architecture","date":"2018-02-24T01:30:17.000Z","updated":"2018-03-11T12:58:33.438Z","comments":true,"path":"2018/02/24/onion-architecture/","link":"","permalink":"bygeek.cn/2018/02/24/onion-architecture/","excerpt":"传统的三层架构中数据位于最核心的地方，而洋葱模型将一些UI，DB这些最可能经常要变化的东西放在外圈，同时外圈的layer依赖于里圈的东西。","text":"传统的三层架构中数据位于最核心的地方，而洋葱模型将一些UI，DB这些最可能经常要变化的东西放在外圈，同时外圈的layer依赖于里圈的东西。 传统的三层架构一层只能调用下一层，不能跨层调用，比如UI只能调用Business Logic 层. 洋葱架构外圈的层可以调用内圈的层 洋葱架构要点 The application is built around an independent object model Inner layers define interfaces. Outer layers implement interfaces Direction of coupling is toward the center All application core code can be compiled and run separate from infrastructure 本文摘录地址","categories":[],"tags":[{"name":"architecture","slug":"architecture","permalink":"bygeek.cn/tags/architecture/"},{"name":"software","slug":"software","permalink":"bygeek.cn/tags/software/"}]},{"title":"blog plan","slug":"blog-plan","date":"2018-02-23T02:38:11.000Z","updated":"2018-02-25T09:43:32.543Z","comments":true,"path":"2018/02/23/blog-plan/","link":"","permalink":"bygeek.cn/2018/02/23/blog-plan/","excerpt":"","text":"最近打算将onenote上的一些笔记，整理整理上传到博客中，正好熟悉熟悉下markdown的语法。打算一周两篇的量吧。","categories":[],"tags":[]},{"title":"2018-new-year","slug":"2018-new-year","date":"2018-02-23T00:58:30.000Z","updated":"2018-03-11T12:58:33.419Z","comments":true,"path":"2018/02/23/2018-new-year/","link":"","permalink":"bygeek.cn/2018/02/23/2018-new-year/","excerpt":"2018年上班第一天。","text":"2018年上班第一天。 前些日子一直想做点开年计划，今天趁着不那么忙，把这些计划记录到自己的博客中。希望自己在这一年中能坚持做下来。 跑步减肥，目标是73KG。前几天搬家，越来越意识到自己真实越来越胖了 把博客运行起来。想来这个博客搭建好之后都快一年了，内容还只有first-blog-test。。。 看书，专业书和自己买的两本社科书。关于要看的书，再写一遍博文描述一下。 开发一个能上线的小程序/app，或者有自己的一个开源项目。 攒钱去一趟香港旅游。 2018/2/23 于公司","categories":[{"name":"notes","slug":"notes","permalink":"bygeek.cn/categories/notes/"}],"tags":[{"name":"plan","slug":"plan","permalink":"bygeek.cn/tags/plan/"}]},{"title":"blog migration test","slug":"blog-migration-test","date":"2017-11-08T02:31:35.000Z","updated":"2018-02-25T09:43:32.542Z","comments":true,"path":"2017/11/08/blog-migration-test/","link":"","permalink":"bygeek.cn/2017/11/08/blog-migration-test/","excerpt":"","text":"由于换了新电脑，博客内容一直没有迁移过来。（其实一直在忙着玩塞尔达） 本帖是迁移测试。","categories":[],"tags":[]},{"title":"image test","slug":"image-test","date":"2017-06-09T16:22:42.000Z","updated":"2018-02-25T09:43:32.543Z","comments":true,"path":"2017/06/10/image-test/","link":"","permalink":"bygeek.cn/2017/06/10/image-test/","excerpt":"使用七牛云作为图床，使用七牛云的图片处理功能，可以对图片进行预处理 不适用预处理的图片如下：","text":"使用七牛云作为图床，使用七牛云的图片处理功能，可以对图片进行预处理 不适用预处理的图片如下：","categories":[],"tags":[]},{"title":"my first blog","slug":"my-first-blog","date":"2017-05-31T15:37:54.000Z","updated":"2018-03-11T12:58:33.437Z","comments":true,"path":"2017/05/31/my-first-blog/","link":"","permalink":"bygeek.cn/2017/05/31/my-first-blog/","excerpt":"终于搞定了一些前几天困扰的问题了，一个是头像无法加载的问题，还有一个是点击所有文章提示模块缺失的问题。","text":"终于搞定了一些前几天困扰的问题了，一个是头像无法加载的问题，还有一个是点击所有文章提示模块缺失的问题。南京的夜晚，夏日炎炎，即使干坐了，也止不住的流汗。先占个坑，等有时间再详细说下问题怎么解决的吧。","categories":[{"name":"notes","slug":"notes","permalink":"bygeek.cn/categories/notes/"}],"tags":[]},{"title":"my fisrt post","slug":"my-fisrt-post","date":"2017-05-26T14:48:59.000Z","updated":"2018-02-25T09:43:32.543Z","comments":true,"path":"2017/05/26/my-fisrt-post/","link":"","permalink":"bygeek.cn/2017/05/26/my-fisrt-post/","excerpt":"","text":"this is my first post using hexo","categories":[],"tags":[]}]}