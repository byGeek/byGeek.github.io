<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>2018-new-year</title>
    <url>/2018/02/23/2018-new-year/</url>
    <content><![CDATA[<p>2018年上班第一天。</p>
<span id="more"></span>

<p>前些日子一直想做点开年计划，今天趁着不那么忙，把这些计划记录到自己的博客中。希望自己在这一年中能坚持做下来。</p>
<ul>
<li>跑步减肥，目标是73KG。前几天搬家，越来越意识到自己真实越来越胖了</li>
<li>把博客运行起来。想来这个博客搭建好之后都快一年了，内容还只有first-blog-test。。。</li>
<li>看书，专业书和自己买的两本社科书。关于要看的书，再写一遍博文描述一下。</li>
<li>开发一个能上线的小程序/app，或者有自己的一个开源项目。</li>
<li>攒钱去一趟香港旅游。</li>
</ul>
<p>2018/2/23 于公司</p>
]]></content>
      <categories>
        <category>notes</category>
      </categories>
      <tags>
        <tag>plan</tag>
      </tags>
  </entry>
  <entry>
    <title>2019-new-year</title>
    <url>/2019/02/11/2019-new-year/</url>
    <content><![CDATA[<p>今天初七，2019年上班第一天。</p>
<span id="more"></span>

<p>今年的计划如下：</p>
<h3 id="减脂"><a href="#减脂" class="headerlink" title="减脂"></a>减脂</h3><p>体重控制在69kg，全年跑量1000km。我知道这个目标其实很弱鸡，如果不出问题，应该可以很轻松的达成。但贵在坚持。坚持跑步，要对得起18年自己买的跑鞋。注意更加科学的跑步，加强自己的核心力量。</p>
<h3 id="书单"><a href="#书单" class="headerlink" title="书单"></a>书单</h3><p>专业书：</p>
<ul>
<li>Windows via C++</li>
<li>APUE</li>
<li>Inside the C++ Object Model</li>
<li>Effective STL</li>
<li>COM技术内幕-微软组件模型</li>
</ul>
<p>非专业书</p>
<ul>
<li>二战全史</li>
<li>尤瓦尔·赫拉利 三部曲：人类简史（看过了觉得还要重新看一遍），未来简史，今日简史</li>
<li>Kindle上ISIS的崛起</li>
<li>中央帝国的财政密码（去年未看完）</li>
</ul>
<h3 id="人生大事"><a href="#人生大事" class="headerlink" title="人生大事"></a>人生大事</h3><p>打算今年多关注一些房子的信息，多收集收集资料。</p>
<h3 id="旅游"><a href="#旅游" class="headerlink" title="旅游"></a>旅游</h3><p>暂定东南亚吧，泰国？或者重庆成都也可以，待西乡计划。</p>
<h3 id="工作"><a href="#工作" class="headerlink" title="工作"></a>工作</h3><p>希望可以通过慢慢参与到开源社区，贡献自己的力量。</p>
<h3 id="博客"><a href="#博客" class="headerlink" title="博客"></a>博客</h3><p>关于自己博客的内容，不一定是专业相关的文章，也可以是自己的见闻游记，思考等。</p>
<p>其他想到在补充吧。</p>
<p>2019/02/11 于南京</p>
]]></content>
      <categories>
        <category>notes</category>
      </categories>
      <tags>
        <tag>plan</tag>
      </tags>
  </entry>
  <entry>
    <title>2018年回顾</title>
    <url>/2019/01/07/2018-review/</url>
    <content><![CDATA[<p>2019年的元旦都过完好几天了，新年计划还一直没出来。迫于“新年新FLAG”，下面即是新年计划以及对过去一年的回顾。</p>
<span id="more"></span>

<p>一一对照下去年的计划吧。</p>
<blockquote>
<p>跑步减肥，目标是73KG</p>
</blockquote>
<p>今天早上上秤称了一下，正好达到目标。好悬！从8月底办了健身卡督促自己，一直到12月中旬，大概4个月，基本月跑量在130KM左右。自己的体重确实有下降。我也慢慢重新爱上了跑步，隔两天不跑感觉不舒服。单次距离从3K到5K到10K再到21K。10KM配速从6分半提高到5分，同时尝试了两次半马，一次2小时10分，一次1小时55分。总体来说对自己的成绩还是比较满意。但是后来右膝关节有点不舒服，跑步间隔也从一周4跑改成了一周2跑或3跑。</p>
<p>总的来说，下半年减重还是有效果的，也基本达到了预期，但是后面有所懈怠，当然有部分是膝关节的原因，但是个人主观上也有部分原因。</p>
<blockquote>
<p>把博客运行起来。 </p>
</blockquote>
<p>当初的计划是一周两篇博客，将自己积累的一些东西，或者遇到的一些问题，想法，记录下来，主要目的是方便自己以后查阅。开始的一两个月，确实保持这个频率更新，后来发现整理笔记成博客挺耗时间的，一般自己整理在onenote上的笔记，都是专业技术文章的剪贴，格式凌乱，自己看懂就行。一些文章要理出成自己的文字还是需要一定的时间。二来慢慢的以前的积累也慢慢消耗了。所以后来博文基本都已最近遇到问题或者看到的资料为基础。</p>
<p>本来博客是托管在Github上，后来趁着腾讯云搞活动，买了3年的云主机，就迁移到了腾讯云上。期间购买了域名并进行了网站备案。总的来说，这个Flag实现的还算合格吧。</p>
<blockquote>
<p>看书，专业书和自己买的两本社科书。</p>
</blockquote>
<p>这里先列下去年计划书单。</p>
<table>
<thead>
<tr>
<th>书名</th>
<th>完成情况</th>
<th>备注</th>
</tr>
</thead>
<tbody><tr>
<td>操作系统：精髓与设计原理</td>
<td>GOOD</td>
<td></td>
</tr>
<tr>
<td>深入理解操作系统（CSAPP）</td>
<td>NG</td>
<td>读完上一本书，发现CSAPP这本书受到推崇更多，于是又买了这本，但是没看了，估计以后这本书作为工具书查阅吧</td>
</tr>
<tr>
<td>程序员的自我修养–链接，装载与库</td>
<td>GOOD</td>
<td></td>
</tr>
<tr>
<td>C++ Primer</td>
<td>GOOD</td>
<td></td>
</tr>
<tr>
<td>Effective C++</td>
<td>GOOD</td>
<td>看的电子版，但是值得经常查阅，反复看</td>
</tr>
<tr>
<td>Effective Modern C++</td>
<td>ALMOST GOOD</td>
<td>看了大半部分，还未看完</td>
</tr>
<tr>
<td>COM技术内幕–微软组件对象模型</td>
<td>NG</td>
<td>未看完，看了开头</td>
</tr>
<tr>
<td>Inside the C++ Object Model</td>
<td>ALMOST GOOD</td>
<td>Lippman出的一本小册子，英文版，共180多页6个chapter，看了4个，算看完了大部分吧</td>
</tr>
<tr>
<td>深入理解Nginx</td>
<td>NG</td>
<td>看了部分，这本书当时还是跟前端的书一起买的，一直没看，后来为了折腾VPS的时候，以及阅读Nginx源码看了部分。</td>
</tr>
<tr>
<td>Docker入门实战</td>
<td>NG</td>
<td>看了部分</td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>GEB</td>
<td>NG</td>
<td>当初在StackOverflow看到很多人推荐这本书，就买了，看了一章就没咋看了</td>
</tr>
<tr>
<td>货币金融学</td>
<td>NG</td>
<td>看了部分，金融学确实比较难啊</td>
</tr>
</tbody></table>
<p>去年大概是下半年才开始看专业书的。因为项目的原因，阅读了几本C++方面以及操作系统相关的书籍。好多书都是看了部分，然后因为各种各样的原因没有完整阅读完毕。</p>
<blockquote>
<p>开发一个能上线的小程序/app，或者有自己的一个开源项目。</p>
</blockquote>
<p>这个算是做的比较失败了。小程序和APP没影，就是Github上有自己的几个Toy Project，都是简单的自己学习C++写的代码。发现这个还是比较难坚持下去，动力有点不足。</p>
<blockquote>
<p>去一趟香港</p>
</blockquote>
<p>在12月份的时候去了一趟。这个也是准备了好久的事，期间从办居住证，护照，通行证，拖了很长时间。整体去香港的感受一般，住宿，交通，吃饭都挺贵的。有时间写篇博文记录下吧。</p>
]]></content>
      <categories>
        <category>notes</category>
      </categories>
      <tags>
        <tag>plan</tag>
      </tags>
  </entry>
  <entry>
    <title>2020-new-year</title>
    <url>/2020/01/31/2020-new-year/</url>
    <content><![CDATA[<p>2019已经过去，2020已经来临，照例写点东西记录下吧。</p>
<span id="more"></span>

<p>看到19年当初定的一些计划，我都有点不太好意思，当初立的一些flag好多都没有做到，以至于今天我都不好再定2020的计划了。那就索性改变一下以前的形式吧。</p>
<h3 id="回望2019"><a href="#回望2019" class="headerlink" title="回望2019"></a>回望2019</h3><p>19年买了房子，开启了“百万负翁”的生活。以前想的是如何去周游世界，怎样去随性所欲，现在想着从每个月的工资扣掉房贷之后，平平凡凡的生活。这个算是好消息吧。虽然有时累的时候觉得不值，但是晚上睡在自己家的床上的时候，那种温暖还是跟以前不一样的。</p>
<p>19年8月换了份工作，结束了以前养老的工作。感谢现在的公司，在我换行业的时候，愿意给我一个学习的机会。也感谢上一家公司，可以让我有很多可以自我学习提高的机会。说到换工作的事情，跟买房子也有联系，当每个月的工资抵不上每个月的房贷时，让我不得不跳出自己的舒适圈。至于新的公司，到现在为止，有满意也有不满意的地方。经过几个月的工作，遇到了很多能力很强的同事，意识到了很多自己工作上问题，能力上的不足。我想我会努力的。</p>
<p>19年打脸最严重的就是跑步了。19年跑量不到500公里。在佳明上定的半马计划也搁置了。自从8月准备换工作到新公司上班之后，锻炼的少了，有那段时间忙碌的托辞，但是更重要的是是自己懒了。</p>
<p>19年倒是玩了好多游戏。看了下2019年play station的游戏游玩时间统计，花了259个小时在游戏上。</p>
<img src="/2020/01/31/2020-new-year/game_sumary.jpg" class="">

<img src="/2020/01/31/2020-new-year/game_time.jpg" class="">

<p>总的来说，可能因为上一份工作比较养老，所以花在游戏上的时间也比较多。而且正如PS有支广告说的，游戏是一种比较好的，花钱又比较少的娱乐活动了，哈哈。</p>
<h3 id="展望2020"><a href="#展望2020" class="headerlink" title="展望2020"></a>展望2020</h3><p>2020，我希望自己更加自信。在工作上，不仅仅是自己努力，需要多向同事学习，工作方式，沟通，如何解决问题，定时复盘。</p>
<p>我希望能报名一场半程马拉松比赛，半马应该不是问题，但是我想去赛场感受一下，和众多跑者一起奔跑。</p>
<p>我希望自己多看书，把自己买的书慢慢消化。</p>
<p>最重要的，希望自己，家人都身体健康，希望2020越来越好！</p>
]]></content>
      <categories>
        <category>notes</category>
      </categories>
  </entry>
  <entry>
    <title>最后生还者2的玩后感</title>
    <url>/2020/07/04/Reviews-of-TLUS2/</url>
    <content><![CDATA[<p>在端午节4天假期中打通了最后生还者2。现在已经过去一周了，闲来无事，写点感受。</p>
<span id="more"></span>

<h2 id="开篇"><a href="#开篇" class="headerlink" title="开篇"></a>开篇</h2><p>这是我唯一一款参与预售的游戏了。以前都是等等党。这次多多预售就百亿补贴，咱也不得不对生活低头，用上了多多==</p>
<p>没记错的话，应该是去年通的最后的生还者1（买PS4的时间比较晚），一代确实是一个不可多得的佳作，艾莉这个小蹄子，就爱她满嘴F word。历经千险万难，仿佛自己就是乔尔，艾莉就是自己的女儿一般。</p>
<p>三月份的跳票之后，当时网上就有剧透出来了，自己一直忍着没看。到19号发售，一直焦急的等待着卖家发货，到端午节当天下午，终于到货。连续肝了30多个小时，好久没有这么畅快的打游戏了。</p>
<h2 id="玩法"><a href="#玩法" class="headerlink" title="玩法"></a>玩法</h2><p>TLOUS2整个玩法跟1是差不太多的，包括游戏玩法，武器，狙击手剧情等。我印象深刻的就是两个部分，一个是WLF敌对势力中狗的加入。狗的加入确实令我蛋疼，基本每次遇到WLF，如果有狗的话，第一时间都是先把狗杀了，狗扑上来掉血太多。另外一个是疤脸帮中利用口哨来配合，一旦暗杀他们中的一个成员，其他人迅速寻找出事地点，手残如我，经常没有机动的变换位置，死了很多次。而且个人感觉与疤脸帮的战斗场景比一代中的火萤大很多。我个人在一中潜行居多，2的时候经常被发现，之后只能硬肝（技术菜，不是奖杯党）。</p>
<h2 id="剧情"><a href="#剧情" class="headerlink" title="剧情"></a>剧情</h2><p>剧情是大家喷的最多的地方，基本可以说是两点，一个是乔尔的死，死的太虐，太轻率。另外一个是结局最后艾莉在最后一刻放下太突然，玩家有点接受不能。</p>
<p>其实我通关下来，到没有这么强烈的感受。可能我不是太死忠粉。首先在玩到乔尔的死的时候，我也很惊异，一作中秒天秒地的乔尔尽然惨死在高尔夫下。但当时我更多想的是编剧在搞什么鬼，我很好奇艾比到底是个什么人，有什么不共戴天之仇。我很着急的想玩下去，看剧情如何发展。</p>
<p>艾莉线对于我来说，初了玩法上我上述说的两点外，其他对于我来说是乏善可陈的：在复仇的道路上，杀杀人，杀杀感染者，OVER。可能我是一个不太对开放世界感冒的低端玩家，在西雅图那张可以探索的地图上，我就拿了该拿的东西之后，就没有继续探索了。最后西雅图第三天，来到剧院，艾比拿着枪抵着艾莉的头。剧情切换到艾比线。</p>
<p>艾比线，我一开始是比较抵触的，一方面是艾比这个人物形象，与艾莉反差太大，强壮如牛，个人感觉丝毫没有美感，而且太残暴（虐杀乔尔）。后来才知道原来艾比是一代中火萤组织医生的女儿，心里慢慢理解的艾比。但是艾比反复冒着生命危险去就勒夫两人，感觉和前面艾比人设反差还是太大。到最后我真的想快点打完艾比的剧情，看在剧院和艾莉会发生什么。顺便说下，艾比在医院地下车库和鼠王的BOSS站，紧张刺激的氛围营造还是很成功的。</p>
<p>回到剧院那场戏，我以为艾比和艾莉对峙的时候，我会操纵艾莉。但是，竟然，我操作的尽然是艾比！操作艾比去狂揍艾莉！这太让我接受不能了。QTE的时候，默默的按键速度慢了下来。</p>
<p>第二点玩家喷的比价狠的是游戏最后没有给玩家选择，只能放走艾比。</p>
<p>先不说为何汤米为何在艾莉和蒂娜快乐的生活在小农场里，并育有一女的情况下神经质的要艾莉去复仇。剧情告诉我们的是艾莉在农场的生活并不那么快乐，一直在夜里梦到乔尔的惨死。所以最后又走上了复仇的道路。</p>
<p>这点其实对于当时正在玩游戏的我来说，似乎我已经潜意识的感觉艾莉怎么这么不懂事，艾比已经放走你两次，你还不能放下心中的仇恨吗？所以如果游戏最后让我选择是否放艾比一条生路，我还是会选择放的。毕竟作为一个玩家，在经历了艾比线之后，我可以知道艾比也是一个可怜人。</p>
<p>但是后面仔细想想，我作为玩家，是知道艾比的动机的，但是艾莉是不知道的呀。最后在网上看到了一个解释，我觉得给了我觉得艾莉放走艾比的合理性：艾莉在可以给艾比最后一击的时候，闪回她对乔尔说的，我觉得我这辈子都不会原谅你的，但是我仍然愿意试一试。在那一刻，艾莉想到也许现在的艾比就是当初保护她的乔尔，而勒夫就是当时的自己。</p>
<h2 id="最感动的地方"><a href="#最感动的地方" class="headerlink" title="最感动的地方"></a>最感动的地方</h2><p>游戏中最感动的地方是回忆的片段中乔尔给艾莉过生日，当他们躺在太空舱，艾莉听着乔尔给好不容易搞到的飞船发射的录音，脸上一脸满足，仿佛跟着飞船，最后畅游在太空。乔尔老父亲和天真可爱的艾莉，彷佛又回到了一作的那种温馨，温馨到让人泪目。</p>
<p>乔尔真的是以一己之力，对艾莉的爱，对抗着全世界。</p>
<h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>最后生还者2远远不是网络上那些谩骂说的那样低劣。剧情是可以喷，但是也要看到顽皮狗在叙事手法上的创新，比如西雅图三天平行世界的叙事手法等等。同时期待下一部好作品。</p>
]]></content>
      <categories>
        <category>note</category>
      </categories>
      <tags>
        <tag>game</tag>
      </tags>
  </entry>
  <entry>
    <title>记一次修改联通光猫为桥接模式的经历</title>
    <url>/2019/08/18/Change-Optical-modem-to-bridge-mode/</url>
    <content><![CDATA[<p>自从搬家换了宽带移机之后，本来群晖的外网访问就失效了。因为前段时间一直都比较忙，一直没好好解决这个问题。今天终于得闲，把这个问题整好了。以下是我的折腾记录。</p>
<span id="more"></span>

<h3 id="公网IP被取消？"><a href="#公网IP被取消？" class="headerlink" title="公网IP被取消？"></a>公网IP被取消？</h3><p>黑裙无法外网访问，首先想到的可能是联通这边不给公网IP了。打开ip138查看出口IP地址，是公网IP。当然这个并不能说明问题，因为这个检测到的只是出口IP，可能家里还是内网IP。</p>
<p>登录路由器管理界面，在远程管理看到路由器的IP地址为192.168的内网地址。内网IP无疑了。于是联系联通客服，质问为何移机之后的宽带取消了公网IP。一个工作日客服人员答复家里的宽带公网IP并未取消。</p>
<h3 id="无法ping通"><a href="#无法ping通" class="headerlink" title="无法ping通"></a>无法ping通</h3><p>其实确认有公网IP之后，路由器获取的又是内网地址，如果对网络拓扑和组网有简单的了解之后，已经可以确定可能是光猫的问题了，但是好久不搞这些东西，我已经把计算机网络的一些东西忘了差不多了。真是惭愧。</p>
<p>言归正传，当时我的想法是，既然我还是有公网IP，那么我试着ping下试试。使用我在腾讯云和GCP上的VPS对家里公网IP进行ping操作，无法ping通，100% package loss。有可能是封禁了ICMP response？</p>
<p>我又想到可以使用端口扫描工具，对该IP进行端口扫描，看是不是端口被封禁的问题。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">nmap -Pn ip_addr</span><br></pre></td></tr></table></figure>

<p>找不到open的端口。端口都被封了？</p>
<h3 id="在群晖设置router-端口转发找到问题"><a href="#在群晖设置router-端口转发找到问题" class="headerlink" title="在群晖设置router 端口转发找到问题"></a>在群晖设置router 端口转发找到问题</h3><p>走投无路的情况下，通过内网，我打开群晖的external access的问题。在重新配置router 端口转发的时候，群晖自检网络时抛出了一个warning：网络里存在多个路由，需要将接入设置为桥接模式。</p>
<img src="/2019/08/18/Change-Optical-modem-to-bridge-mode/set_up_router.png" class="">

<p>感觉找到了一个突破口。我马上找到光猫，开启无线功能，然后连上光猫的无线网之后，登录到web界面。但是发现由于是user用户，找不到修改光猫工作为桥接模式的设置。于是，在google上搜索“光猫 桥接”，找到了简书上的一篇文章： <a href="https://www.jianshu.com/p/0211c56c4945">电信光猫桥接模式的设置</a>。这篇文章也是碰到了外网访问的问题。修改光猫为桥接模式，必须要拿到管理员账户。那怎么搞到光猫的控制台密码呢？</p>
<h3 id="要到光猫管理员密码"><a href="#要到光猫管理员密码" class="headerlink" title="要到光猫管理员密码"></a>要到光猫管理员密码</h3><p>我直接在google上搜索的光猫的型号：吉比特TEWA 800G。找到一个知乎相关的问题：<a href="https://www.zhihu.com/question/316754462">吉比特TEWA 800G的管理员登录地址是什么？</a>。这个问题虽然没有人回答，但是在问题的描述中我知道了管理员登录的网址。这个光猫的登录界面还做的一个鸡贼的处理：当直接输入光猫的登录地址192.168.1.1时，只能看到普通用户登录的选项，没有管理员账户的登录选项。正好这个知乎问题上说明管理员的登录地址时: <code>192.168.1.1/cu.html</code>。</p>
<p>接下来就差密码了，我倒是想搜索相关的“破解”方法，不过本着试一试的想法，我直接打电话给装宽带小哥，询问他光猫的管理员的密码之后，没想到宽带小哥直接告诉了我！</p>
<p>使用管理员密码登录之后，我直接在光猫的快速设置向导中，将路由模式修改为桥接模式。然后在自己的路由器上使用PPPoE拨号。但是无法成功，提示没有连接到互联网。怎么回事呢？</p>
<h3 id="要到vlan-id"><a href="#要到vlan-id" class="headerlink" title="要到vlan id"></a>要到vlan id</h3><p>我重新看了简书上的<a href="https://www.jianshu.com/p/0211c56c4945">这篇文章</a>，里面说道改成桥接模式之后，需要修改VLAN ID，这个VLAN ID是原来路由模式的VLAN ID。再确认了一下我自家光猫的配合，没有问题，但是就是无法成功拨号。</p>
<p>无奈之下我再次拨打了宽带小哥的电话。小哥说让我加钱，他上门服务。我说别了吧，我自己弄就好了，不用上门，我请教你几个问题。没想到小哥也同意了。我加了小哥微信，把光猫的VLAN配置发他看了。他询问了我光猫上的一个参数之后，告诉我VLAN ID（这个VLAN ID并不是路由模式的VLAN ID），同时他说需要他在那边“操作一下”。</p>
<p>看来这个VLAN ID并不是像简书上的文章说的那样，而且需要宽带人员的操作（好像是要解绑什么东西？）。所以遇到问题需要按照实际情况进行分析。</p>
<p>我填入小哥说的VLAN ID之后，拨号成功！</p>
<h3 id="外网成功访问"><a href="#外网成功访问" class="headerlink" title="外网成功访问"></a>外网成功访问</h3><p>打开路由器的管理界面，在远程访问中可以看到路由器的IP不再是192.168了，而是公网IP。</p>
<p>然后在群晖上执行下DDNS脚本，终于搞定了外网访问的问题！</p>
<h3 id="桥接与VLAN"><a href="#桥接与VLAN" class="headerlink" title="桥接与VLAN"></a>桥接与VLAN</h3><p>其实这件事情很小，而且起初确认公网IP没有取消，路由器获取的是内网IP的时候，当时就应该可以判断是光猫的问题，但是由于还是一些组网知识都忘了，所以走了一些弯路。</p>
<p>下面在这里贴一下这期间碰到的知识点。</p>
<blockquote>
<p>Q: [What’s the difference between a bridge and a switch?(<a href="https://serverfault.com/questions/78184/whats-the-difference-between-a-bridge-and-a-switch">https://serverfault.com/questions/78184/whats-the-difference-between-a-bridge-and-a-switch</a>)</p>
<p>An ethernet switch is a multiport ethernet bridge. A bridge is a device that splits collision domains but not broadcast domains. A switch is simply a bridge with lots of ports. Other examples of bridges are wireless access points and dual speed hubs. </p>
</blockquote>
<blockquote>
<p>A <strong>virtual LAN</strong> (<strong>VLAN</strong>) is any <a href="https://en.wikipedia.org/wiki/Broadcast_domain">broadcast domain</a> that is <a href="https://en.wikipedia.org/wiki/Network_segmentation">partitioned</a> and isolated in a <a href="https://en.wikipedia.org/wiki/Computer_network">computer network</a> at the <a href="https://en.wikipedia.org/wiki/Data_link_layer">data link layer</a> (<a href="https://en.wikipedia.org/wiki/OSI_model#Layer_2:_Data_Link_Layer">OSI layer 2</a>).[<a href="https://en.wikipedia.org/wiki/Virtual_LAN#cite_note-1">1]</a>[<a href="https://en.wikipedia.org/wiki/Virtual_LAN#cite_note-802.1Q_1.4-2">2]</a> <em>LAN</em> is the abbreviation for <em>local area network</em> and in this context <em>virtual</em> refers to a physical object recreated and altered by additional logic. VLANs work by applying tags to network frames and handling these tags in networking systems – creating the appearance and functionality of <a href="https://en.wikipedia.org/wiki/Network_traffic">network traffic</a> that is physically on a single network but acts as if it is split between separate networks. In this way, VLANs can keep network applications separate despite being connected to the same physical network, and without requiring multiple sets of cabling and networking devices to be deployed.</p>
</blockquote>
]]></content>
      <categories>
        <category>notes</category>
      </categories>
      <tags>
        <tag>geek</tag>
      </tags>
  </entry>
  <entry>
    <title>TCP中的三次握手和四次挥手</title>
    <url>/2018/03/05/TCP%E4%B8%AD%E7%9A%84%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%E5%92%8C%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B/</url>
    <content><![CDATA[<p>TCP(Transmission Control Protocol)是一种面向连接的可靠的传输协议。TCP连接的建立和释放过程可由下图表示：</p>
<span id="more"></span>

<p><img src="/2018/03/05/TCP%E4%B8%AD%E7%9A%84%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%E5%92%8C%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B/TCP_process.jpg" alt="TCP_process"></p>
<p>那么问题来了：</p>
<ol>
<li><p>为什么建立连接协议是三次握手，而关闭连接却是四次握手呢？</p>
<p>这是因为服务端的 LISTEN 状态下的 SOCKET 当收<br>到 SYN 报文的建立连接请求后，它可以把 ACK 和 SYN （ ACK 起应答作用，而 SYN 起同步作用）放在一个报文里来发送。TCP是全双工通信，关闭连接时，<br>当收到对方的 FIN 报文通知时，它仅仅表示对方没有数据发送给你了；但未必你所有的数据都全部发送给对方了，所以你可以未必会马上会关闭 SOCKET, 也即你可能还需要发送一些数据给对方之后，再发送 FIN 报文给对方来表示你同意现在可以关闭连接了，所以它这里的 ACK 报文<br>和 FIN报文多数情况下都是分开发送的。 </p>
</li>
<li><p>为什么 TIME_WAIT 状态还需要等 2MSL 后才能返回到 CLOSED 状态？</p>
<p>这是因为虽然双方都同意关闭连接了，而且握手的 4 个报文也都协调和发送完毕，按理可以直接回到 CLOSED 状态（就好比从 SYN_SEND 状态<br>到 ESTABLISH 状态那样）；但是因为我们必须要假想网络是不可靠的，你无法保证你最后发送的 ACK 报文会一定被对方收到，因此对方处<br>于 LAST_ACK 状态下的 SOCKET 可能会因为超时未收到 ACK 报文，而重发 FIN 报文，所以这个 TIME_WAIT 状态的作用<br>就是用来重发可能丢失的 ACK 报文。</p>
</li>
</ol>
<p>本文摘录自 <a href="http://www.cnblogs.com/kesal/p/3285415.html">此</a></p>
]]></content>
      <categories>
        <category>learning</category>
      </categories>
      <tags>
        <tag>TCP</tag>
      </tags>
  </entry>
  <entry>
    <title>Socket通信浅析</title>
    <url>/2018/03/05/Socket%E9%80%9A%E4%BF%A1%E6%B5%85%E6%9E%90/</url>
    <content><![CDATA[<h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>Socket通信是计算机网络中一种重要的数据交换的方式。维基百科对socket定义如下：</p>
<blockquote>
<p>在操作系统中，通常会为应用程序提供一组应用程序接口（API），称为套接字接口（英语：socket API）。应用程序可以通过套接字接口，来使用网络套接字，以进行数据交换。最早的套接字接口来自于4.2 BSD，因此现代常见的套接字接口大多源自Berkeley套接字（Berkeley sockets）标准。在套接字接口中，以<strong>IP地址</strong>及<strong>通信端口</strong>组成套接字地址（socket address）。远程的套接字地址，以及本地的套接字地址完成连接后，再加上<strong>使用的协议</strong>（protocol），这个<strong>五元组</strong>（five-element tuple)，作为<strong>套接字对</strong>（socket pairs），之后就可以彼此交换数据。例如，在同一台计算机上，TCP协议与UDP协议可以同时使用相同的port而互不干扰。 操作系统根据套接字地址，可以决定应该将数据送达特定的进程或线程。</p>
</blockquote>
<span id="more"></span>

<p>Socket本身并不是通信协议，只是定义的一个调用接口(API)，我们可以通过socket来使用TCP/UDP协议。socket只是对TCP等协议的抽象，方便应用层调用底层的通信协议。如下图：</p>
<p><img src="/2018/03/05/Socket%E9%80%9A%E4%BF%A1%E6%B5%85%E6%9E%90/01_socket_layer.png" alt="socket_position"></p>
<h2 id="Socket-原语"><a href="#Socket-原语" class="headerlink" title="Socket 原语"></a>Socket 原语</h2><p>所谓的原语(primitive)是指定义的一些基本操作，跟具体的实现无关。TCP协议中socket定义的原语如下图：</p>
<p><img src="/2018/03/05/Socket%E9%80%9A%E4%BF%A1%E6%B5%85%E6%9E%90/02_socket_primitives.png" alt="socket_primitives"></p>
<p>其中包含两个方面，server side和client side。</p>
<blockquote>
<ol>
<li><p>Server side: Server startup executes <strong>SOCKET</strong>, <strong>BIND</strong>, <strong>LISTEN</strong>.</p>
<p><strong>LISTEN</strong> - allocate queue for multiple simultaneous clients.</p>
<p><strong>ACCEPT</strong> - suspend server until request. When client request arrives: ACCEPT returns.<br>Start new socket (<a href="http://computing.dcu.ie/~humphrys/Notes/OS/processes.html#threads">thread</a> or process) with same properties as original, this handles the request,<br>server goes on waiting on original socket.<br>If new request arrives while spawning thread for this one, it is queued.<br>If queue full it is refused.</p>
<p>​</p>
</li>
<li><p>Client side: <strong>SOCKET</strong> to create. Then <strong>CONNECT</strong>. When this returns the socket is open.</p>
<p>Both sides can now <strong>SEND</strong>, <strong>RECEIVE</strong>.</p>
<p>Connection not released until both sides do <strong>CLOSE</strong>. Typically client does it, server acks.</p>
</li>
</ol>
</blockquote>
<p>用下图来表示：</p>
<img src="/2018/03/05/Socket%E9%80%9A%E4%BF%A1%E6%B5%85%E6%9E%90/04_socket_process.jpg" class="">



<h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><p>下面通过一个简单的示例，来展示c#中的socket编程的API，实现socket 多client连接。</p>
<ol>
<li><p>server端代码：在while循环中接受client的连接，accept之后另起一个线程来handle这个request，并通过检查socket的状态来判断连接是否是active。</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Run</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>        &#123;</span><br><span class="line">            IPEndPoint server = <span class="keyword">new</span> IPEndPoint(IPAddress.Parse(<span class="string">&quot;127.0.0.1&quot;</span>), <span class="number">55554</span>);</span><br><span class="line">            Socket listener = <span class="keyword">new</span> Socket(AddressFamily.InterNetwork, SocketType.Stream, ProtocolType.Tcp);</span><br><span class="line"></span><br><span class="line">            listener.Bind(server);</span><br><span class="line">            listener.Listen(<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span> (<span class="literal">true</span>)</span><br><span class="line">            &#123;</span><br><span class="line"></span><br><span class="line">                Log(<span class="string">&quot;waiting for connection...&quot;</span>);</span><br><span class="line">                Socket handler = listener.Accept();</span><br><span class="line">                Log(<span class="string">&quot;connection established.&quot;</span>);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">try</span></span><br><span class="line">                &#123;</span><br><span class="line">                    Thread thread = <span class="keyword">new</span> Thread(<span class="keyword">new</span> ParameterizedThreadStart(HandleSocket));</span><br><span class="line">                    thread.Start(handler);</span><br><span class="line">                &#125;</span><br><span class="line">                catch (Exception e)</span><br><span class="line">                &#123;</span><br><span class="line">                    Console.WriteLine(e.Message);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">HandleSocket</span>(<span class="params"><span class="built_in">object</span> socket</span>)</span></span><br><span class="line"><span class="function"></span>        &#123;</span><br><span class="line">            <span class="keyword">var</span> handler = socket <span class="keyword">as</span> Socket;</span><br><span class="line"></span><br><span class="line">            <span class="built_in">byte</span>[] data = <span class="keyword">new</span> <span class="built_in">byte</span>[<span class="number">1024</span>];</span><br><span class="line">            <span class="keyword">try</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">bool</span> connected = SocketConnected(handler);</span><br><span class="line">                <span class="keyword">while</span> (connected)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">var</span> cnt = <span class="number">0</span>;</span><br><span class="line">                    <span class="keyword">var</span> recvStr = <span class="built_in">string</span>.Empty;</span><br><span class="line">                    cnt = handler.Receive(data, SocketFlags.None);</span><br><span class="line">                    recvStr = Encoding.Default.GetString(data, <span class="number">0</span>, cnt);</span><br><span class="line">                    <span class="keyword">if</span> (recvStr.IndexOf(<span class="string">&quot;\n&quot;</span>) &gt; <span class="number">0</span>)</span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="comment">//response</span></span><br><span class="line">                        Log(<span class="string">&quot;\n &quot;</span> + DateTime.Now.ToString() + <span class="string">&quot; received cmd: &quot;</span> + recvStr);</span><br><span class="line">                        Log(<span class="string">&quot;send ok back.\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">                        <span class="built_in">byte</span>[] sendStr = Encoding.Default.GetBytes(<span class="string">&quot;ok\n&quot;</span>);</span><br><span class="line">                        handler.Send(sendStr);</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="comment">/*</span></span><br><span class="line"><span class="comment">                    if (recvStr.IndexOf(&quot;&lt;EOF&gt;&quot;) &gt;= 0)</span></span><br><span class="line"><span class="comment">                    &#123;</span></span><br><span class="line"><span class="comment">                        break;</span></span><br><span class="line"><span class="comment">                    &#125;</span></span><br><span class="line"><span class="comment">                     * */</span></span><br><span class="line"></span><br><span class="line">                    connected = SocketConnected(handler);</span><br><span class="line"></span><br><span class="line">                &#125;</span><br><span class="line">                Log(<span class="string">&quot;close socket...&quot;</span>);</span><br><span class="line">                handler.Shutdown(SocketShutdown.Both);</span><br><span class="line">                handler.Close();</span><br><span class="line">            &#125;</span><br><span class="line">            catch (Exception ex)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (handler != <span class="literal">null</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    handler.Shutdown(SocketShutdown.Both);</span><br><span class="line">                    handler.Close();</span><br><span class="line">                &#125;</span><br><span class="line">                Log(ex.Message);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure></li>
<li><p>client端代码：通过connect来建立连接，建立成功之后，即可发送数据，收发多次数据之后，将连接关闭。</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Communicate</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>        &#123;</span><br><span class="line">            Socket socket = <span class="keyword">new</span> Socket(AddressFamily.InterNetwork, SocketType.Stream, ProtocolType.Tcp);</span><br><span class="line"></span><br><span class="line">            <span class="built_in">byte</span>[] buffer = <span class="keyword">new</span> <span class="built_in">byte</span>[<span class="number">1024</span>];</span><br><span class="line"></span><br><span class="line">            IPEndPoint endpoint = <span class="keyword">new</span> IPEndPoint(IPAddress.Parse(<span class="string">&quot;127.0.0.1&quot;</span>), <span class="number">55554</span>);</span><br><span class="line"></span><br><span class="line">            <span class="built_in">string</span> recv = <span class="built_in">string</span>.Empty;</span><br><span class="line">            <span class="keyword">try</span></span><br><span class="line">            &#123;</span><br><span class="line">                socket.Connect(endpoint);</span><br><span class="line"></span><br><span class="line">                <span class="built_in">byte</span>[] data = Encoding.Default.GetBytes(<span class="string">&quot;connect\n&quot;</span>);</span><br><span class="line">                <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">                &#123;</span><br><span class="line">                    socket.Send(data);</span><br><span class="line">                    Console.WriteLine(<span class="string">&quot;&#123;0&#125; send: connect\n&quot;</span>, DateTime.Now.ToString());</span><br><span class="line">                    <span class="keyword">var</span> cnt = socket.Receive(buffer);</span><br><span class="line"></span><br><span class="line">                    recv = Encoding.Default.GetString(buffer, <span class="number">0</span>, cnt);</span><br><span class="line">                    Console.WriteLine(<span class="string">&quot;&#123;0&#125; received: &#123;1&#125;&quot;</span>, DateTime.Now.ToString(), recv);</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">if</span> (!recv.Contains(<span class="string">&quot;ok&quot;</span>))</span><br><span class="line">                    &#123;</span><br><span class="line">                        Console.WriteLine(<span class="string">&quot;not ok!\n&quot;</span>);</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//byte[] end = Encoding.Default.GetBytes(&quot;&lt;EOF&gt;&quot;);</span></span><br><span class="line">                <span class="comment">//socket.Send(end);</span></span><br><span class="line"></span><br><span class="line">                <span class="comment">//socket.Disconnect(false);</span></span><br><span class="line">                socket.Shutdown(SocketShutdown.Both);</span><br><span class="line">                socket.Close();</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">            catch (Exception ex)</span><br><span class="line">            &#123;</span><br><span class="line">                Console.WriteLine(ex);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
<li><p>注意点：</p>
<ul>
<li><p>在csharp中，socket等资源属于非托管资源，使用完毕之后，必须释放（client和server分别close），否则会导致内存泄漏。</p>
</li>
<li><p>server端close的释放时机一般是client端这边close之后，server也没有数据发送给client端。可以有以下方法来判断建立的连接是否已经close了：</p>
<ul>
<li><p>通过client端发送定义好的字符，如<code>&lt;EOF&gt;</code>，当server端收到预定义好的字符串，则断开与client的连接并回收资源。</p>
</li>
<li><p>通过<code>Socket.Poll</code>方法。该方法可以用来判断socket的连接状态。MSDN文档如下：</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="built_in">bool</span> <span class="title">Poll</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">	<span class="built_in">int</span> microSeconds,</span></span></span><br><span class="line"><span class="function"><span class="params">	SelectMode mode</span></span></span><br><span class="line"><span class="function"><span class="params"></span>)</span></span><br></pre></td></tr></table></figure>

<blockquote>
<ul>
<li>Poll will block execution until the specified time period, measured in <em>microseconds</em>, elapses. Set the <em>microSeconds</em> parameter to a negative integer if you would like to wait indefinitely for a response.</li>
<li>The Poll method will check the state of the <a href="https://msdn.microsoft.com/en-us/library/system.net.sockets.socket.aspx">Socket</a>. Specify <a href="https://msdn.microsoft.com/en-us/library/y9x13hh4.aspx">SelectMode.SelectRead</a> for the <em>selectMode</em> parameter to determine if the <a href="https://msdn.microsoft.com/en-us/library/system.net.sockets.socket.aspx">Socket</a> is readable. Specify <a href="https://msdn.microsoft.com/en-us/library/y9x13hh4.aspx">SelectMode.SelectWrite</a> to determine if the <a href="https://msdn.microsoft.com/en-us/library/system.net.sockets.socket.aspx">Socket</a> is writable. Use <a href="https://msdn.microsoft.com/en-us/library/y9x13hh4.aspx">SelectMode.SelectError</a> to detect an error condition.</li>
</ul>
</blockquote>
<blockquote>
<p><img src="/2018/03/05/Socket%E9%80%9A%E4%BF%A1%E6%B5%85%E6%9E%90/03_select_mode.png" alt="select_mode"></p>
</blockquote>
</li>
</ul>
</li>
</ul>
</li>
</ol>
<h2 id="TCP-浅析占位"><a href="#TCP-浅析占位" class="headerlink" title="TCP 浅析占位"></a>TCP 浅析占位</h2><p>下篇博客链接占位。</p>
<h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ul>
<li><a href="http://computing.dcu.ie/~humphrys/Notes/Networks/sockets.html">socket 原语</a></li>
<li><a href="https://www.jianshu.com/p/94b138362173">即时通讯系列之Socket简介</a></li>
<li><a href="https://msdn.microsoft.com/en-us/library/system.net.sockets.socket.poll.aspx">MSDN Socket.Poll Method</a></li>
<li><a href="https://zh.wikipedia.org/wiki/%E7%B6%B2%E8%B7%AF%E6%8F%92%E5%BA%A7">网络套接字 维基</a></li>
<li><a href="https://stackoverflow.com/questions/722240/instantly-detect-client-disconnection-from-server-socket">Instantly detect client disconnection from server socket</a></li>
<li><a href="https://www.geeksforgeeks.org/socket-programming-cc/">Socket Programming in C/C++</a></li>
</ul>
]]></content>
      <categories>
        <category>learning</category>
      </categories>
      <tags>
        <tag>socket</tag>
      </tags>
  </entry>
  <entry>
    <title>TCP报头的标志位</title>
    <url>/2018/03/05/TCP%E6%8A%A5%E5%A4%B4%E7%9A%84%E6%A0%87%E5%BF%97%E4%BD%8D/</url>
    <content><![CDATA[<p><a href="">上篇文章</a>简单的摘录了TCP建立连接和释放连接的过程。TCP报头中的标志位于操控TCP的状态机。下面简单说说TCP报头中的标志位。</p>
<span id="more"></span>

<h2 id="TCP-报头"><a href="#TCP-报头" class="headerlink" title="TCP 报头"></a>TCP 报头</h2><p>二图胜千言。</p>
<p><img src="/2018/03/05/TCP%E6%8A%A5%E5%A4%B4%E7%9A%84%E6%A0%87%E5%BF%97%E4%BD%8D/tcp_header.svg" alt="tcp_header1"></p>
<p><img src="/2018/03/05/TCP%E6%8A%A5%E5%A4%B4%E7%9A%84%E6%A0%87%E5%BF%97%E4%BD%8D/tcp_header1.png" alt="tcp_header1"></p>
<p>对比上述二图，可以看到TCP报文中定义了8个标志位。分别为<code>SYN,ACK,FIN,PSH,RST,URG,CWR,ECE</code>，其中最为常用的是前六个标志位。通过对这些标志位置位，可以控制TCP连接的建立和释放。</p>
<h2 id="标志位"><a href="#标志位" class="headerlink" title="标志位"></a>标志位</h2><p>标志位的功能摘录如下：</p>
<blockquote>
<ul>
<li><strong>SYN</strong>: for SYNchronize; marks packets that are part of the new-connection handshake</li>
<li><strong>ACK</strong>: indicates that the header Acknowledgment field is valid; that is, all but the first packet</li>
<li><strong>FIN</strong>: for FINish; marks packets involved in the connection closing</li>
<li><strong>PSH</strong>: for PuSH; marks “non-full” packets that should be delivered promptly at the far end</li>
<li><strong>RST</strong>: for ReSeT; indicates various error conditions</li>
<li><strong>URG</strong>: for URGent; part of a now-seldom-used mechanism for high-priority data</li>
<li><strong>CWR</strong> and <strong>ECE</strong>: part of the Explicit Congestion Notification mechanism</li>
</ul>
</blockquote>
<blockquote>
<p>URG：此标志表示TCP包的紧急指针域（后面马上就要说到）有效，用来保证TCP连接不被中断，并且督促中间层设备要尽快处理这些数据； </p>
<p>ACK：此标志表示应答域有效，就是说前面所说的TCP应答号将会包含在TCP数据包中；有两个取值：0和1，为1的时候表示应答域有效，反之为0； </p>
<p>PSH：这个标志位表示Push操作。所谓Push操作就是指在数据包到达接收端以后，立即传送给应用程序，而不是在缓冲区中排队； </p>
<p>RST：这个标志表示连接复位请求。用来复位那些产生错误的连接，也被用来拒绝错误和非法的数据包； </p>
<p>SYN：表示同步序号，用来建立连接。SYN标志位和ACK标志位搭配使用，当连接请求的时候，SYN=1，ACK=0；连接被响应的时候，SYN=1，ACK=1；这个标志的数据包经常被用来进行端口扫描。扫描者发送一个只有SYN的数据包，如果对方主机响应了一个数据包回来，就表明这台主机存在这个端口；但是由于这种扫描方式只是进行TCP三次握手的第一次握手，因此这种扫描的成功表示被扫描的机器不很安全，一台安全的主机将会强制要求一个连接严格的进行TCP的三次握手； </p>
<p>FIN： 表示发送端已经达到数据末尾，也就是说双方的数据传送完成，没有数据可以传送了，发送FIN标志位的TCP数据包后，连接将被断开。这个标志的数据包也经常被用于进行端口扫描。</p>
</blockquote>
<h2 id="TCP过程"><a href="#TCP过程" class="headerlink" title="TCP过程"></a>TCP过程</h2><p>结合下图来理解TCP连接的建立与释放和标志位的关系。</p>
<p><img src="/2018/03/05/TCP%E6%8A%A5%E5%A4%B4%E7%9A%84%E6%A0%87%E5%BF%97%E4%BD%8D/TCP_process.jpg" alt="tcp_process"></p>
<h2 id="Wireshark抓包"><a href="#Wireshark抓包" class="headerlink" title="Wireshark抓包"></a>Wireshark抓包</h2><p>我们可以利用Wireshark抓包工具来对上述过程进行抓包。Wireshar本身不支持loopback address（即127.0.0.1）进行抓包测试，但是可以下载一个插件实现该功能：<a href="https://nmap.org/npcap/">Npcap</a>。</p>
<ol>
<li><p>在本地建立一个socket 链接，详情可参考<a href="https://bygeek.github.io/2018/03/05/Socket%E9%80%9A%E4%BF%A1%E6%B5%85%E6%9E%90/#more">该博文</a>。</p>
</li>
<li><p>打开wireshark，选择npcap虚拟网卡，开始抓包，并在filter中过滤TCP端口。</p>
</li>
<li><p>三次握手建立连接。SYN表示开始建立连接，PSH表示该包中有数据。</p>
<p><img src="/TCP_SYN.png" alt="TCP_SYN"></p>
<p>同时在wireshark的中间窗口中可以更清楚的看到标志位的置位情况。</p>
<p><img src="/2018/03/05/TCP%E6%8A%A5%E5%A4%B4%E7%9A%84%E6%A0%87%E5%BF%97%E4%BD%8D/tcp_flags.png" alt="tcp_flags"></p>
</li>
<li><p>四次挥手释放连接。FIN表示开始释放连接。client端发送带FIN标志的数据包，server端收到后给一个ACK确认包。然后server端确认自己也没有数据要发送，也给一个FIN包，最后client端回复ACK包，至此连接被释放。</p>
<p><img src="/2018/03/05/TCP%E6%8A%A5%E5%A4%B4%E7%9A%84%E6%A0%87%E5%BF%97%E4%BD%8D/tcp_fin.png" alt="tcp_fin"></p>
</li>
</ol>
<h2 id="netstat命令行工具"><a href="#netstat命令行工具" class="headerlink" title="netstat命令行工具"></a>netstat命令行工具</h2><p>在windows下，系统提供了一个netstat工具来查看连接的状态。</p>
<p><code>netstat -na | find &quot;55554&quot;</code></p>
<p><img src="/2018/03/05/TCP%E6%8A%A5%E5%A4%B4%E7%9A%84%E6%A0%87%E5%BF%97%E4%BD%8D/netstat.png" alt="netstat"></p>
<h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ul>
<li><a href="https://intronetworks.cs.luc.edu/current/html/tcp.html">TCP Transport</a></li>
<li><a href="http://www.cnblogs.com/kesal/p/3285415.html">TCP\IP三次握手连接，四次握手断开分析</a></li>
</ul>
]]></content>
      <categories>
        <category>learning</category>
      </categories>
      <tags>
        <tag>TCP</tag>
      </tags>
  </entry>
  <entry>
    <title>WPF自定义控件和依赖项属性浅析</title>
    <url>/2018/02/28/WPF-%E8%87%AA%E5%AE%9A%E4%B9%89%E6%8E%A7%E4%BB%B6%E5%92%8C%E4%BE%9D%E8%B5%96%E9%A1%B9%E5%B1%9E%E6%80%A7%E6%B5%85%E6%9E%90/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>依赖项属性是WPF引入的一个新特性，它扩展了普通的CLR属性。同时依赖项属性有以下优点：减少内存占用，值继承，自动通知等。</p>
<span id="more"></span>

<h2 id="依赖项属性与普通CLR属性区别和优点"><a href="#依赖项属性与普通CLR属性区别和优点" class="headerlink" title="依赖项属性与普通CLR属性区别和优点"></a>依赖项属性与普通CLR属性区别和优点</h2><p>它与CLR属性的区别是：</p>
<ul>
<li>CLR属性是类中的一个成员，可以直接读取，而依赖项属性要通过GetValue() 方法动态取得</li>
<li>当你设置CLR属性时，CLR属性存储在对象的field中。依赖项属性必须声明为public static readonly，存储在基类DependencyObject中的Dictionary中。</li>
</ul>
<p>依赖项属性带来的好处如下：</p>
<ul>
<li><p>减少内存占用</p>
<blockquote>
<p>It’s a huge dissipation to store a field for each property when you think that over 90% of the properties of a UI control typically stay at its initial values. Dependency properties solve these problems by only store modified properties in the instance. The default values are stored once within the dependency property.</p>
</blockquote>
</li>
<li><p>值继承</p>
<blockquote>
<p>When you access a dependency property the value is resolved by using a value resolution strategy. If no local value is set, the dependency property navigates up the logical tree until it finds a value. When you set the FontSize on the root element it applies to all textblocks below except you override the value. </p>
</blockquote>
</li>
<li><p>变化通知</p>
<blockquote>
<p>Dependency properties have a built-in change notification mechanism. By registering a callback in the property metadata you get notified, when the value of the property has been changed. This is also used by the databinding.</p>
</blockquote>
</li>
</ul>
<p>下面编写一个自定义控件，并给自定义控件加入几个依赖项属性。</p>
<h2 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h2><p>在接下来的例子中，我们将自定义一个ChkButton控件，该控件左边是一个TextBlock，右边是一个Checkbox。并且定义两个依赖项属性：IsChecked，ChkVisibility。</p>
<ol>
<li><p>创建自定义控件(Custom Control)。</p>
<p><img src="/2018/02/28/WPF-%E8%87%AA%E5%AE%9A%E4%B9%89%E6%8E%A7%E4%BB%B6%E5%92%8C%E4%BE%9D%E8%B5%96%E9%A1%B9%E5%B1%9E%E6%80%A7%E6%B5%85%E6%9E%90/01_new_custom_control.png" alt="new_custom_control"></p>
<p>创建成功后会在工程目录下多了一个theme的文件夹，同时在该文件夹内有Generic.xaml。该xaml是一个ResourceDictionary，在AssemblyInfo文件中会加载该xaml资源。</p>
<p><img src="/2018/02/28/WPF-%E8%87%AA%E5%AE%9A%E4%B9%89%E6%8E%A7%E4%BB%B6%E5%92%8C%E4%BE%9D%E8%B5%96%E9%A1%B9%E5%B1%9E%E6%80%A7%E6%B5%85%E6%9E%90/02_generic_xaml.png" alt="02_theme"></p>
</li>
<li><p>在Generic.xaml中，我们可以定义该Custom Control的ControlTemplate。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">Style</span> <span class="attr">TargetType</span>=<span class="string">&quot;&#123;x:Type local:ChkButton&#125;&quot;</span>&gt;</span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;<span class="name">Setter</span> <span class="attr">Property</span>=<span class="string">&quot;Template&quot;</span>&gt;</span></span></span><br><span class="line"><span class="css">            &lt;<span class="selector-tag">Setter</span><span class="selector-class">.Value</span>&gt;</span></span><br><span class="line"><span class="xml">                <span class="tag">&lt;<span class="name">ControlTemplate</span> <span class="attr">TargetType</span>=<span class="string">&quot;&#123;x:Type local:ChkButton&#125;&quot;</span>&gt;</span></span></span><br><span class="line">                    &lt;Border</span><br><span class="line">                        Background=&quot;&#123;TemplateBinding Background&#125;&quot;</span><br><span class="line">                        BorderBrush=&quot;&#123;TemplateBinding BorderBrush&#125;&quot;</span><br><span class="line">                        BorderThickness=&quot;&#123;TemplateBinding BorderThickness&#125;&quot;&gt;</span><br><span class="line"></span><br><span class="line"><span class="xml">                        <span class="tag">&lt;<span class="name">Grid</span>&gt;</span></span></span><br><span class="line"><span class="css">                            &lt;<span class="selector-tag">Grid</span><span class="selector-class">.ColumnDefinitions</span>&gt;</span></span><br><span class="line"><span class="xml">                                <span class="tag">&lt;<span class="name">ColumnDefinition</span> <span class="attr">Width</span>=<span class="string">&quot;*&quot;</span> /&gt;</span></span></span><br><span class="line"><span class="xml">                                <span class="tag">&lt;<span class="name">ColumnDefinition</span> <span class="attr">Width</span>=<span class="string">&quot;auto&quot;</span> /&gt;</span></span></span><br><span class="line"><span class="css">                            &lt;/<span class="selector-tag">Grid</span><span class="selector-class">.ColumnDefinitions</span>&gt;</span></span><br><span class="line"></span><br><span class="line">                            &lt;TextBlock</span><br><span class="line">                                Name=&quot;PART_txt&quot;</span><br><span class="line">                                Margin=&quot;3,3&quot;</span><br><span class="line">                                HorizontalAlignment=&quot;Right&quot;</span><br><span class="line">                                VerticalAlignment=&quot;Center&quot;</span><br><span class="line">                                Text=&quot;&#123;TemplateBinding Content&#125;&quot; /&gt;</span><br><span class="line"></span><br><span class="line">                                &lt;CheckBox</span><br><span class="line">                                    Name=&quot;PART_chk&quot;</span><br><span class="line">                                    Grid.Column=&quot;1&quot;</span><br><span class="line">                                    HorizontalAlignment=&quot;Center&quot;</span><br><span class="line">                                    VerticalAlignment=&quot;Center&quot;</span><br><span class="line">                                    IsChecked=&quot;&#123;Binding RelativeSource=&#123;RelativeSource TemplatedParent&#125;, Path=IsChecked, Mode=TwoWay&#125;&quot;</span><br><span class="line">                                    Visibility=&quot;Collapsed&quot; /&gt;</span><br><span class="line"><span class="xml">                        <span class="tag">&lt;/<span class="name">Grid</span>&gt;</span></span></span><br><span class="line"><span class="xml">                    <span class="tag">&lt;/<span class="name">Border</span>&gt;</span></span></span><br><span class="line"><span class="xml">                <span class="tag">&lt;/<span class="name">ControlTemplate</span>&gt;</span></span></span><br><span class="line"><span class="css">            &lt;/<span class="selector-tag">Setter</span><span class="selector-class">.Value</span>&gt;</span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;/<span class="name">Setter</span>&gt;</span></span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">Style</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>​</p>
<ul>
<li>先在该xaml中引入namespace，如<code>xmlns:local=&quot;clr-namespace:ButtonTest1&quot;</code></li>
<li>该ControlTemplate中的Checkbox的IsChecked属性双向绑定与ChkButton的自定义的IsChecked依赖项属性，从而将内部的checkbox的checked属性开放出来。</li>
</ul>
<p>注意，在这里在IsChecked进行Binding时没有使用TemplateBinding，即没有使用下面的写法：</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line">IsChecked=<span class="string">&quot;&#123;TemplateBinding IsChecked&#125;&quot;</span></span><br></pre></td></tr></table></figure>

<p>因为TemplateBind只支持单向绑定，而我们要实现双向绑定，只能通过Binding表达式。参见stackoverflow的这个<a href="https://stackoverflow.com/questions/5913176/in-wpf-why-doesnt-templatebinding-work-where-binding-does">问题</a>。</p>
</li>
<li><p>定义ChkButton的依赖项属性：IsChecked, ChkVisibility。 </p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">readonly</span> DependencyProperty IsCheckedProperty = DependencyProperty.Register(<span class="string">&quot;IsChecked&quot;</span>, <span class="keyword">typeof</span>(Boolean), <span class="keyword">typeof</span>(ChkButton));</span><br><span class="line">        <span class="keyword">public</span> <span class="built_in">bool</span> IsChecked</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">get</span> &#123; <span class="keyword">return</span> (<span class="built_in">bool</span>)GetValue(IsCheckedProperty); &#125;</span><br><span class="line">            <span class="keyword">set</span> &#123; SetValue(IsCheckedProperty, <span class="keyword">value</span>); &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">readonly</span> DependencyProperty ChkVisibilityProperty = DependencyProperty.Register(<span class="string">&quot;ChkVisibility&quot;</span>, <span class="keyword">typeof</span>(Visibility), <span class="keyword">typeof</span>(ChkButton),</span><br><span class="line">            <span class="keyword">new</span> PropertyMetadata(Visibility.Collapsed, <span class="keyword">new</span> PropertyChangedCallback((obj, args) =&gt;</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">var</span> btn = (ChkButton)obj;</span><br><span class="line">                btn.ApplyTemplate();</span><br><span class="line"></span><br><span class="line">                <span class="keyword">var</span> textblock = (TextBlock)btn.GetTemplateChild(<span class="string">&quot;PART_txt&quot;</span>);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">var</span> checkbox = (CheckBox)btn.GetTemplateChild(<span class="string">&quot;PART_chk&quot;</span>);</span><br><span class="line">                checkbox.Visibility = (Visibility)args.NewValue;</span><br><span class="line">                <span class="keyword">if</span> (checkbox.Visibility == Visibility.Visible)</span><br><span class="line">                &#123;</span><br><span class="line">                    textblock.HorizontalAlignment = HorizontalAlignment.Right;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    textblock.HorizontalAlignment = HorizontalAlignment.Center;</span><br><span class="line"></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;)));</span><br><span class="line">        <span class="keyword">public</span> Visibility ChkVisibility</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">get</span> &#123; <span class="keyword">return</span> (Visibility)GetValue(ChkVisibilityProperty); &#125;</span><br><span class="line">            <span class="keyword">set</span> &#123; SetValue(ChkVisibilityProperty, <span class="keyword">value</span>); &#125;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>在ControlTemplate中给每一个Part定义一个名称，这样可以使用GetTemplateChild方法来获取到引用，注意在调用之前，必须先调用控件的ApplyTemplate方法。</li>
</ul>
</li>
<li><p>我们希望在点击ChkButton的TextBlock部分时，响应Button的Click事件，在点击Checkbox部分时，不触发Click事件。但是由于WPF中event的冒泡特性，也会传递到ChkButton。我们可以在ChkButton的构造函数设置为该事件已处理。</p>
   <figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ChkButton</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>        &#123;</span><br><span class="line">            <span class="keyword">this</span>.Click += (sender, args) =&gt;</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (args.OriginalSource <span class="keyword">is</span> CheckBox)</span><br><span class="line">                &#123;</span><br><span class="line">                    args.Handled = <span class="literal">true</span>;</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure></li>
<li><p>ChkButton已经创建好了。在xaml中可以使用。</p>
   <figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">&lt;local:ChkButton</span><br><span class="line">            x:Name=&quot;chkbtn1&quot;</span><br><span class="line">            Width=&quot;100&quot;</span><br><span class="line">            Height=&quot;100&quot;</span><br><span class="line">            Margin=&quot;5&quot;</span><br><span class="line">            Background=&quot;LightBlue&quot;</span><br><span class="line">            ChkVisibility=&quot;Collapsed&quot;</span><br><span class="line">            Click=&quot;ChkButton_Click&quot;</span><br><span class="line">            Content=&quot;another text&quot;</span><br><span class="line">            IsChecked=&quot;False&quot; /&gt;</span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">TextBlock</span> <span class="attr">Margin</span>=<span class="string">&quot;5&quot;</span> <span class="attr">Text</span>=<span class="string">&quot;&#123;Binding ElementName=chkbtn1, Path=IsChecked&#125;&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="改善"><a href="#改善" class="headerlink" title="改善"></a>改善</h2><h3 id="使用BooleanToVisibilityConverter"><a href="#使用BooleanToVisibilityConverter" class="headerlink" title="使用BooleanToVisibilityConverter"></a>使用<code>BooleanToVisibilityConverter</code></h3><p>在上面的代码中，是通过创建一个ChkVisibility的依赖属性来控制是否显示Checkbox的，在PropertyChangedCallback中通过代码来控制Checkbox是否显示。其实我们可以直接通过绑定来实现这个功能。为了更直接的实现这个功能，我们使用一个ValueConvertor来将bool类型转化为Visibility类型。在framework中有一个现成的类：<code>BooleanToVisibilityConverter</code>。将其加入到对应的Style的Resource中。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;Style TargetType&#x3D;&quot;&#123;x:Type local:ChkButton&#125;&quot;&gt;</span><br><span class="line">&lt;Style.Resources&gt;</span><br><span class="line">            &lt;BooleanToVisibilityConverter x:Key&#x3D;&quot;boolToVi&quot; &#x2F;&gt;</span><br><span class="line">&lt;&#x2F;Style.Resources&gt;</span><br><span class="line">    ...</span><br><span class="line">    &lt;CheckBox</span><br><span class="line">    x:Name&#x3D;&quot;PART_chk&quot;</span><br><span class="line">    Grid.Column&#x3D;&quot;1&quot;</span><br><span class="line">    VerticalAlignment&#x3D;&quot;Center&quot;</span><br><span class="line">    Visibility&#x3D;&quot;&#123;TemplateBinding ShowCheckbox,</span><br><span class="line">                                 Converter&#x3D;&#123;StaticResource boolToVi&#125;&#125;&quot; </span><br><span class="line">    IsChecked&#x3D;&quot;&#123;Binding RelativeSource&#x3D;&#123;RelativeSource TemplatedParent&#125;, Mode&#x3D;TwoWay, Path&#x3D;IsChecked&#125;&quot;&#x2F;&gt;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">&lt;&#x2F;Style&gt;</span><br></pre></td></tr></table></figure>

<p>增加一个ShowCheckBox依赖属性：</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> DependencyProperty ShowCheckboxProperty = DependencyProperty.Register(</span><br><span class="line">            <span class="string">&quot;ShowCheckbox&quot;</span>, <span class="keyword">typeof</span>(<span class="built_in">bool</span>), <span class="keyword">typeof</span>(CustomControl1), <span class="keyword">new</span> FrameworkPropertyMetadata(<span class="literal">true</span>));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="built_in">bool</span> ShowCheckbox</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">get</span> &#123; <span class="keyword">return</span> (<span class="built_in">bool</span>)GetValue(ShowCheckboxProperty); &#125;</span><br><span class="line">            <span class="keyword">set</span> &#123; SetValue(ShowCheckboxProperty, <span class="keyword">value</span>); &#125;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>



<h3 id="使用TempatePartAttribute"><a href="#使用TempatePartAttribute" class="headerlink" title="使用TempatePartAttribute"></a>使用TempatePartAttribute</h3><p>在建立CustomControl时，经常会使用TemplatePart特性来标识类。这可以算是一种design pattern。</p>
<blockquote>
<p>Control authors apply this attribute to the class definition to inform template authors the types of the parts to use for styling the class. These parts are usually required in the template and have a specific predefined name. There can only be one element with a given name in any template.</p>
</blockquote>
<p>在上述的ChkButton中定义了两个PART: PART_btn, PART_chk。按照惯例，part name一般使用<code>PART_</code>开头，并并使用const string保存在类中。</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line">[<span class="meta">TemplatePart(Name=PART_BTN, Type=typeof(Button))</span>]</span><br><span class="line">[<span class="meta">TemplatePart(Name=PART_CHK, Type=typeof(CheckBox))</span>]</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">ChkButton</span> : <span class="title">Control</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">const</span> <span class="built_in">string</span> PART_BTN = <span class="string">&quot;PART_btn&quot;</span>;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">const</span> <span class="built_in">string</span> PART_CHK = <span class="string">&quot;PART_chk&quot;</span>;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">static</span> <span class="title">CustomControl1</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>        &#123;</span><br><span class="line">            DefaultStyleKeyProperty.OverrideMetadata(<span class="keyword">typeof</span>(ChkButton), <span class="keyword">new</span> FrameworkPropertyMetadata(<span class="keyword">typeof</span>(ChkButton)));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> Button _btnPart;</span><br><span class="line">        <span class="keyword">private</span> CheckBox _chkPart;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">OnApplyTemplate</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>        &#123;</span><br><span class="line">            <span class="keyword">base</span>.OnApplyTemplate();</span><br><span class="line">            </span><br><span class="line">            <span class="comment">//alway detach event handlers first</span></span><br><span class="line">            <span class="keyword">if</span> (_btnPart != <span class="literal">null</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                _btnPart.Click -= OnButtonClick;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            _btnPart = GetTemplateChild(PART_BTN) <span class="keyword">as</span> Button;</span><br><span class="line">            _chkPart = GetTemplateChild(PART_CHK) <span class="keyword">as</span> CheckBox; </span><br><span class="line"></span><br><span class="line">            <span class="comment">//alway check _btnPart/_chkPart is null or not</span></span><br><span class="line">            <span class="keyword">if</span> (_btnPart != <span class="literal">null</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                _btnPart.Click += OnButtonClick;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (_chkPart != <span class="literal">null</span>)</span><br><span class="line">            &#123;</span><br><span class="line">            	<span class="comment">//do something here</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>如果在类中要访问PART，则定义private 变量将PART 保存起来，同时重写<code>OnApplayTemplate</code>方法。同时在使用PART的时候需要判断是否为null，因为每次在给control ApplyTemplate的时候<code>OnApplayTemplate</code>会调用一次。同时注意先注销可能已经绑定的事件。</p>
<h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ul>
<li><a href="https://wpftutorial.net/DependencyProperties.html">https://wpftutorial.net/DependencyProperties.html</a></li>
<li><a href="https://docs.microsoft.com/en-us/dotnet/framework/wpf/advanced/dependency-properties-overview">https://docs.microsoft.com/en-us/dotnet/framework/wpf/advanced/dependency-properties-overview</a></li>
<li><a href="https://www.jeff.wilcox.name/2010/04/template-part-tips/">https://www.jeff.wilcox.name/2010/04/template-part-tips/</a></li>
<li>系列文章<ul>
<li><a href="https://www.kunal-chowdhury.com/2011/04/how-to-create-custom-control-in.html">https://www.kunal-chowdhury.com/2011/04/how-to-create-custom-control-in.html</a></li>
<li><a href="https://www.kunal-chowdhury.com/2011/04/how-to-design-custom-control-by-editing.html">https://www.kunal-chowdhury.com/2011/04/how-to-design-custom-control-by-editing.html</a></li>
<li><a href="https://www.kunal-chowdhury.com/2011/04/how-to-implement-template-binding-in.html">https://www.kunal-chowdhury.com/2011/04/how-to-implement-template-binding-in.html</a></li>
<li><a href="https://www.codeproject.com/articles/179105/how-to-access-control-template-parts-from-code-beh">https://www.codeproject.com/articles/179105/how-to-access-control-template-parts-from-code-beh</a></li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>coding</category>
      </categories>
      <tags>
        <tag>WPF</tag>
      </tags>
  </entry>
  <entry>
    <title>What are TCHAR, WCHAR, LPSTR, LPWSTR, LPCTSTR</title>
    <url>/2018/06/19/What-are-TCHAR-WCHAR-LPSTR-LPWSTR-LPCTSTR/</url>
    <content><![CDATA[<p>前段时间看到一篇关于C++中TCHAR，LPSTR的基础知识的文章，写的非常清晰易懂，看完之后觉得解决了以前一直郁结在心中的一些问题。推荐去看下原文：<a href="https://www.codeproject.com/Articles/76252/What-are-TCHAR-WCHAR-LPSTR-LPWSTR-LPCTSTR-etc">What are TCHAR, WCHAR, LPSTR, LPWSTR, LPCTSTR </a>。本文简单归纳总结下。</p>
<span id="more"></span>

<h2 id="缘由"><a href="#缘由" class="headerlink" title="缘由"></a>缘由</h2><p>字符可以使用一个byte或2个byte来表示。传统的ANSI字符是由一个byte表示，但是一个byte只能编码256个字符，显然无法满足所有的字符（比如说中文字符等）。所以后来创造出来unicode编码，可以用来表示任何字符。（Unicode编码只是一个统称，UTF-8，UTF-16，UTF-32都属于Unicode编码。）</p>
<h2 id="TCHAR宏"><a href="#TCHAR宏" class="headerlink" title="TCHAR宏"></a>TCHAR宏</h2><p>在visual c++ 编译器中原生支持char(8 bits)和wchar_t(16 bits)类型。在代码中，我们应该使用更通用的类型来表示字符和字符串，已获得更好的移植性和健壮性。TCHAR类型就是这样定义出来的。查看TCHAR.h头文件，可以看到：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> _UNICODE</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">wchar_t</span> TCHAR;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">char</span> TCHAR;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<p>通过条件编译，TCHAR只是wchar_t或char的别名。在visual studio中，当将character set 设置为”Use Unicode Character Set “时，会自动定义<code>_UNICODE</code>这个symbol，所以TCHAR类型就会被翻译成wchar_t。当设置为”Use Multi-Byte Character Set”，TCHAR类型会被翻译为char。</p>
<img src="/2018/06/19/What-are-TCHAR-WCHAR-LPSTR-LPWSTR-LPCTSTR/TCHAR.png" class="">

<p>同样的，避免直接使用string的一些库函数如<code>strlen,strcpy,strcat</code>或者<code>wcslen, wcscpy, wcscat</code>，而应该使用<code>tcslen,_tcscpy,_tcscat</code>。原有的函数原型和TCHAR.H头文件中的声明:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">size_t</span> <span class="title">strlen</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>*)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">size_t</span> <span class="title">wcslen</span><span class="params">(<span class="keyword">const</span> <span class="keyword">wchar_t</span>* )</span></span>;  <span class="comment">//wide character string length</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//tchar.h中的声明</span></span><br><span class="line"><span class="keyword">size_t</span> _tcslen(<span class="keyword">const</span> TCHAR* );</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> _UNICODE</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _tcslen wcslen </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _tcslen strlen</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure>



<h2 id="SetWindowTextW-vs-SetWindowTextA"><a href="#SetWindowTextW-vs-SetWindowTextA" class="headerlink" title="SetWindowTextW vs SetWindowTextA"></a>SetWindowTextW vs SetWindowTextA</h2><p>在查阅msdn中，经常可以看到windows的API分为两个版本，其实就是char与wchar_t的区别导致的。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// WinUser.H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> UNICODE</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SetWindowText  SetWindowTextW</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SetWindowText  SetWindowTextA</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">// !UNICODE</span></span></span><br></pre></td></tr></table></figure>

<p>通过宏定义，将这些区别隐藏起来，客户端只需要直接调用SetWindowText。注意SetWindowText只是一个宏定义，在dll中并不存在真正的SetWindowText函数入口！</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">HMODULE hDLLHandle;</span><br><span class="line">FARPROC pFuncPtr;</span><br><span class="line"></span><br><span class="line">hDLLHandle = LoadLibrary(<span class="string">L&quot;user32.dll&quot;</span>);</span><br><span class="line"></span><br><span class="line">pFuncPtr = GetProcAddress(hDLLHandle, <span class="string">&quot;SetWindowText&quot;</span>);</span><br><span class="line"><span class="comment">//pFuncPtr will be null, since there doesn&#x27;t exist any function with name SetWindowText !</span></span><br></pre></td></tr></table></figure>

<p>在user32.dll中导出的是``SetWindowTextA<code>和</code>SetWindowTextW<code>，所以去获取</code>SetWindowText`函数的入口地址返回为NULL。</p>
<h2 id="T宏-TEXT宏"><a href="#T宏-TEXT宏" class="headerlink" title="_T宏, _TEXT宏"></a>_T宏, _TEXT宏</h2><p>我们经常使用直接使用双引号标记一个string。但是这种方式定义的字符串是ANSI-string，意味着每个字符用一个byte来表示。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="string">&quot;This is ANSI String. Each letter takes 1 byte.&quot;</span></span><br></pre></td></tr></table></figure>

<p>如果要表示Unicode-string，需要在字符串前加入<code>L</code>前缀。如：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="string">L&quot;This is Unicode string. Each letter would take 2 bytes, including spaces.&quot;</span></span><br></pre></td></tr></table></figure>

<p>这样表示的所有字符都将使用两个byte来表示。</p>
<p>事实上，在TCHAR.h头文件中定义了两个宏来隐藏硬编码string导致的不同。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// SIMPLIFIED</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> _UNICODE </span></span><br><span class="line"> <span class="meta">#<span class="meta-keyword">define</span> _T(c) L##c</span></span><br><span class="line"> <span class="meta">#<span class="meta-keyword">define</span> TEXT(c) L##c</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span> </span></span><br><span class="line"> <span class="meta">#<span class="meta-keyword">define</span> _T(c) c</span></span><br><span class="line"> <span class="meta">#<span class="meta-keyword">define</span> TEXT(c) c</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<p>##符号是<a href="https://docs.microsoft.com/en-us/cpp/preprocessor/token-pasting-operator-hash-hash">token pasting operator</a>，用来宏定义参数中作为连接符号，将两个token连接在一起。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="string">&quot;ANSI String&quot;</span>; <span class="comment">// ANSI</span></span><br><span class="line"><span class="string">L&quot;Unicode String&quot;</span>; <span class="comment">// Unicode</span></span><br><span class="line"></span><br><span class="line">_T(<span class="string">&quot;Either string, depending on compilation&quot;</span>); <span class="comment">// ANSI or Unicode</span></span><br><span class="line"><span class="comment">// or use TEXT macro, if you need more readability</span></span><br></pre></td></tr></table></figure>



<h2 id="WCHAR-LPSTR-LPWSTR-LPCSTR-LPCWSTR-LPTSTR-LPCTSTR"><a href="#WCHAR-LPSTR-LPWSTR-LPCSTR-LPCWSTR-LPTSTR-LPCTSTR" class="headerlink" title="WCHAR, LPSTR, LPWSTR, LPCSTR, LPCWSTR, LPTSTR, LPCTSTR"></a>WCHAR, LPSTR, LPWSTR, LPCSTR, LPCWSTR, LPTSTR, LPCTSTR</h2><p>这些宏定义在winnt.h文件中定义。在MSDN中<a href="https://msdn.microsoft.com/en-us/library/windows/desktop/aa383751%28v=vs.85%29.aspx">data type</a>中有详细说明。通常来说：</p>
<ul>
<li><strong>LP</strong> - Long Pointer</li>
<li><strong>C</strong> - Const</li>
<li><strong>STR</strong> - String</li>
<li><strong>WSTR</strong> - Wide character String</li>
<li><strong>T</strong>- TCHAR</li>
</ul>
<h3 id="WCHAR"><a href="#WCHAR" class="headerlink" title="WCHAR"></a>WCHAR</h3><p><code>typedef wchar_t WCHAR;    // wc,   16-bit UNICODE character</code></p>
<h3 id="LPSTR"><a href="#LPSTR" class="headerlink" title="LPSTR"></a>LPSTR</h3><p><code>typedef char *LPSTR;  //A pointer to a null-terminated string of 8-bit Windows (ANSI) characters.</code></p>
<h3 id="LPWSTR"><a href="#LPWSTR" class="headerlink" title="LPWSTR"></a>LPWSTR</h3><p><code>typedef wchat_t *LPWSTR;  //A pointer to a null-terminated string of 16-bit Unicode characters. </code></p>
<h3 id="LPCSTR"><a href="#LPCSTR" class="headerlink" title="LPCSTR"></a>LPCSTR</h3><p><code>typedef const char *LPCSTR; //A pointer to a constant null-terminated string of 8-bit Windows (ANSI) characters.</code></p>
<h3 id="LPCWSTR"><a href="#LPCWSTR" class="headerlink" title="LPCWSTR"></a>LPCWSTR</h3><p><code>typedef const wchat_t *LPCWSTR; //A pointer to a constant null-terminated string of 16-bit Unicode characters. </code></p>
<h3 id="LPTSTR"><a href="#LPTSTR" class="headerlink" title="LPTSTR"></a>LPTSTR</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> UNICODE</span></span><br><span class="line"> <span class="keyword">typedef</span> LPWSTR LPTSTR;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line"> <span class="keyword">typedef</span> LPSTR LPTSTR;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<h3 id="LPCTSTR"><a href="#LPCTSTR" class="headerlink" title="LPCTSTR"></a>LPCTSTR</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> UNICODE</span></span><br><span class="line"> <span class="keyword">typedef</span> LPCWSTR LPCTSTR; </span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line"> <span class="keyword">typedef</span> LPCSTR LPCTSTR;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure>



<h2 id="Example"><a href="#Example" class="headerlink" title="Example"></a>Example</h2><p>经过上面一番讨论，在TCHAR，LPSTR, LPWSTR，LPTSTR的使用过程中，需要注意不要混用，否则容易出现一些“莫名其妙的错误”。如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    TCHAR name[] = <span class="string">&quot;Saturn&quot;</span>;</span><br><span class="line">    <span class="keyword">int</span> nLen; <span class="comment">// Or size_t</span></span><br><span class="line"></span><br><span class="line">    lLen = <span class="built_in">strlen</span>(name);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用ANSI char set编译通过，但是使用charset为unicode编译出错。</p>
<p>修改后的code：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">TCHAR name[] = _T(<span class="string">&quot;Saturn&quot;</span>);</span><br><span class="line"><span class="keyword">size_t</span> len;</span><br><span class="line">len = _tclen(name);</span><br></pre></td></tr></table></figure>

<p>同时在申请内存的时候也要注意sizeof的类型。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">LPTSTR pBuffer;</span><br><span class="line">pBuffer = <span class="keyword">new</span> TCHAR[<span class="number">128</span>];  <span class="comment">//申请一个128字符的空间，实际大小可能是128bytes或者256bytes</span></span><br><span class="line">pBuffer = (TCHAR *)<span class="built_in">malloc</span>(<span class="number">128</span> *<span class="keyword">sizeof</span>(TCHAR));</span><br></pre></td></tr></table></figure>





]]></content>
      <categories>
        <category>learning</category>
      </categories>
      <tags>
        <tag>c++</tag>
      </tags>
  </entry>
  <entry>
    <title>从BackgroundWorker说起</title>
    <url>/2018/08/13/async-operation-about-backgroundworker/</url>
    <content><![CDATA[<p>BackgroundWorker用于在另一个线程里执行一些操作。以前经常在UI thread启动一个workder对象，去完成一个耗时操作。然后在其ProgressChanged事件的EventHandler中去更新UI. 在.net 中，创建UI control和access的线程必须是同一个线程，否则操作是非法的。在文档中可以查到在ProgressChanged的EventHandler中是可以安全的更新UI的。那么在BackgroundWorker中是如何做的呢？</p>
<span id="more"></span>

<p>首先，BackgroundWorker的DoWork的EventHandler肯定需要在另外的线程中运行，而要想在安全的更新UI，必须要Invoke到UI thread。所以一开始我觉得应该是在BackgroundWorker中调用了Invoke操作。查看其reference code:</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">readonly</span> WorkerThreadStartDelegate  threadStart;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">readonly</span> SendOrPostCallback operationCompleted;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">readonly</span> SendOrPostCallback progressReporter;</span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">BackgroundWorker</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>        &#123;</span><br><span class="line">            threadStart        = <span class="keyword">new</span> WorkerThreadStartDelegate(WorkerThreadStart);</span><br><span class="line">            operationCompleted = <span class="keyword">new</span> SendOrPostCallback(AsyncOperationCompleted);</span><br><span class="line">            progressReporter   = <span class="keyword">new</span> SendOrPostCallback(ProgressReporter);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">RunWorkerAsync</span>(<span class="params"><span class="built_in">object</span> argument</span>)</span></span><br><span class="line"><span class="function"></span>        &#123;</span><br><span class="line">            <span class="keyword">if</span> (isRunning)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> InvalidOperationException(SR.GetString(SR.BackgroundWorker_WorkerAlreadyRunning));</span><br><span class="line">            &#125;</span><br><span class="line"> </span><br><span class="line">            isRunning = <span class="literal">true</span>;</span><br><span class="line">            cancellationPending = <span class="literal">false</span>;</span><br><span class="line">            </span><br><span class="line">            asyncOperation = AsyncOperationManager.CreateOperation(<span class="literal">null</span>);</span><br><span class="line">            threadStart.BeginInvoke(argument,</span><br><span class="line">                                    <span class="literal">null</span>,</span><br><span class="line">                                    <span class="literal">null</span>);</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>



<p>可以看到在BackgroundWorker中是通过delegate的BeginInvoke来实现异步操作的。所以Backgroundworker适用于执行一些轻量级的小任务。</p>
<p>上面代码中创建了一个<code>AsyncOperation</code>对象，在BackgroundWorker中ReportProgress就是使用该对象调用Post方法将progressReporter传递出去。progressReprorter会触发ProgressChanged事件。</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">ReportProgress</span>(<span class="params"><span class="built_in">int</span> percentProgress, <span class="built_in">object</span> userState</span>)</span></span><br><span class="line"><span class="function"></span>        &#123;</span><br><span class="line">            <span class="keyword">if</span> (!WorkerReportsProgress)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> InvalidOperationException(SR.GetString(SR.BackgroundWorker_WorkerDoesntReportProgress));</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            ProgressChangedEventArgs args = <span class="keyword">new</span> ProgressChangedEventArgs(percentProgress, userState);</span><br><span class="line"> </span><br><span class="line">            <span class="keyword">if</span> (asyncOperation != <span class="literal">null</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                asyncOperation.Post(progressReporter, args);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                progressReporter(args);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>



<p>进入到<code>AsyncOperationManager</code>源代码中：</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> AsyncOperation <span class="title">CreateOperation</span>(<span class="params"><span class="built_in">object</span> userSuppliedState</span>)</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> AsyncOperation.CreateOperation(userSuppliedState, SynchronizationContext);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> SynchronizationContext SynchronizationContext &#123;</span><br><span class="line">            <span class="keyword">get</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (SynchronizationContext.Current == <span class="literal">null</span>) &#123;</span><br><span class="line">                    SynchronizationContext.SetSynchronizationContext(<span class="keyword">new</span> SynchronizationContext());</span><br><span class="line">                &#125;</span><br><span class="line"> </span><br><span class="line">                <span class="keyword">return</span> SynchronizationContext.Current;</span><br><span class="line">            &#125;</span><br></pre></td></tr></table></figure>

<p>这里面使用到了一个对象<code>SynchronizationContext</code>, 同步上下文对象。看起来上面的调用的Post方法就是调用<code>SynchronizationContext</code>对象的Post方法:</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Post</span>(<span class="params">SendOrPostCallback d, Object state</span>)</span></span><br><span class="line"><span class="function"></span>        &#123;</span><br><span class="line">            ThreadPool.QueueUserWorkItem(<span class="keyword">new</span> WaitCallback(d), state);</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>

<p>是直接利用线程池来执行progressReporter 这个callback。但是我们注意到这个方法是一个virtual方法，而且在<code>AsyncOperation</code>中获取<code>SynchronizationContext</code>对象先判断<code>SynchronizationContext.Current</code>是否为null，如果是则新建一个<code>SynchronizationContext</code>对象，这种情况下是直接调用virtual方法的，也即使用线程池来执行callback。否则使用<code>SynchronizationContext.Current</code>对象来执行Post。那么这个Current对象又是什么呢？</p>
<p>查阅了一些资料，特别是MSDN上的这篇<a href="https://blogs.msdn.microsoft.com/pfxteam/2012/06/15/executioncontext-vs-synchronizationcontext/">博客</a>.</p>
<blockquote>
<p>SynchronizationContext is just an abstraction, one that represents a particular environment you want to do some work in.  As an example of such an environment, Windows Forms apps have a UI thread (while it’s possible for there to be multiple, for the purposes of this discussion it doesn’t matter), which is where any work that needs to use UI controls needs to happen.  For cases where you’re running code on a ThreadPool thread and you need to marshal work back to the UI so that this work can muck with UI controls, Windows Forms provides the Control.BeginInvoke method.  You give a delegate to a Control’s BeginInvoke method, and that delegate will be invoked back on the thread with which that control is associated. </p>
</blockquote>
<p><code>SynchoronizationContext</code>提供了具体上下文的抽象，提供了Post和Send方法接口，比如在一个worker thread里，你想update UI，则必须marshel到UI thread。</p>
<p>在windows form中我们使用control.BeginInvoke<br>在wpf中我们使用Dispatcher.BeginInvoke</p>
<p>那么SynchronizationContext就是对这个操作做了统一的封装。<br>提供了一个virtual的Post方法。</p>
<p>当实现类为WindowsFormSynchronizationContext （即在windowsfrom中）使用control.BeginInvoke</p>
<p>当实现类为DispatcherSynchronizationContext（即在wpf中）使用Dispatcher.BeginInvoke</p>
<p>SynchronizationContext还提供一个同步的Send方法。<br>在windows form中具体实现是： control.Invoke<br>在wpf中具体实现是： Dispatcher.Invoke</p>
<p>我们找到<code>WindowsFormSynchronizationContext</code>的源代码中的Post方法：</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">Post</span>(<span class="params">SendOrPostCallback d, Object state</span>)</span> &#123;</span><br><span class="line">            Debug.Assert(controlToSendTo != <span class="literal">null</span>, <span class="string">&quot;Should always have the marshaling control by this point&quot;</span>);</span><br><span class="line"> </span><br><span class="line">            <span class="keyword">if</span> (controlToSendTo != <span class="literal">null</span>) &#123;</span><br><span class="line">                controlToSendTo.BeginInvoke(d, <span class="keyword">new</span> <span class="built_in">object</span>[] &#123; state &#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>

<p>可以看到确实使用control.BeginInvoke来将操作marshel到UI thread。</p>
<p>关于<code>SynchronizationContext</code>，还可以参考这篇文章:  <a href="https://msdn.microsoft.com/magazine/gg598924.aspx">It’s All About the SynchronizationContext</a></p>
]]></content>
      <categories>
        <category>coding</category>
      </categories>
      <tags>
        <tag>csharp</tag>
      </tags>
  </entry>
  <entry>
    <title>在VS C++工程中使用Auto versionning</title>
    <url>/2018/12/17/auto-versioning-in-cpp-project/</url>
    <content><![CDATA[<p><a href="https://bygeek.cn/2018/04/04/automatic-versionning-in-visual-studio/">前面</a>我已经总结了在csharp中如何auto versionning来管理Assembly的版本号。本文总结一下在C++下如何方便的管理DLL的版本号。</p>
<span id="more"></span>

<h3 id="遇到的问题"><a href="#遇到的问题" class="headerlink" title="遇到的问题"></a>遇到的问题</h3><p>首先明确一下本文要解决的问题：</p>
<blockquote>
<p>在一个C++ solution中实现DLL或者EXE共享同一个版本号。</p>
</blockquote>
<p>既然要共享同一个版本号，那么最简单的类似csharp中的共享同一个AssemblyInfo文件了。csharp工程可以通过Add as Link方式将一个文件共享给其他project。在C++ project中自然也可以通过Add Existing File来实现这个目的。不过在VS2015之后Visual Studio支持了Shared Project Template。那么可以将version的信息放在Shared Project中，这样修改起来也方便。</p>
<h3 id="解决办法"><a href="#解决办法" class="headerlink" title="解决办法"></a>解决办法</h3><p>在C++ project中version信息是放在Resource.rc中的。</p>
<p>假设现在我们的代码结构是这样的：</p>
<blockquote>
<p>solution</p>
<p>+– project1</p>
<p>+– project2</p>
<p>+– sharedproject</p>
</blockquote>
<p>首先我们给project1和project2工程建立Resource文件。</p>
<blockquote>
<p>Project-&gt; Add-&gt;Resource-&gt;Version-&gt;New</p>
</blockquote>
<p>右击生成的Resource.rc文件, 选择View Code，滑动到Version部分。可以看到Version信息。</p>
<p>接下来在sharedproject中建立一个头文件verson.h</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> STRINGIZE2(s) #s   <span class="comment">//stringizing operator</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> STRINGIZE(s) STRINGIZE2(s)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> VERSION_MAJOR               1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> VERSION_MINOR               0</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> VERSION_REVISION            0</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> VERSION_BUILD               0</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//#define VER_FILE_DESCRIPTION_STR    &quot;Description&quot;  //decription和productionname各自独立，需要单独定义</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> VER_FILE_VERSION            VERSION_MAJOR, VERSION_MINOR, VERSION_REVISION, VERSION_BUILD</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> VER_FILE_VERSION_STR        STRINGIZE(VERSION_MAJOR)        \</span></span><br><span class="line">                                    <span class="string">&quot;.&quot;</span> STRINGIZE(VERSION_MINOR)    \</span><br><span class="line">                                    <span class="string">&quot;.&quot;</span> STRINGIZE(VERSION_REVISION) \</span><br><span class="line">                                    <span class="string">&quot;.&quot;</span> STRINGIZE(VERSION_BUILD)    \</span><br><span class="line"></span><br><span class="line"><span class="comment">//#define VER_PRODUCTNAME_STR         &quot;c_version_binary&quot;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> VER_PRODUCT_VERSION         VER_FILE_VERSION</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> VER_PRODUCT_VERSION_STR     VER_FILE_VERSION_STR</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> VER_ORIGINAL_FILENAME_STR   VER_PRODUCTNAME_STR <span class="meta-string">&quot;.exe&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> VER_INTERNAL_NAME_STR       VER_ORIGINAL_FILENAME_STR</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> VER_COPYRIGHT_STR           <span class="meta-string">&quot;Copyright (C) 2011&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> _DEBUG</span></span><br><span class="line">  <span class="meta">#<span class="meta-keyword">define</span> VER_VER_DEBUG             VS_FF_DEBUG</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">  <span class="meta">#<span class="meta-keyword">define</span> VER_VER_DEBUG             0</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> VER_FILEOS                  VOS_NT_WINDOWS32</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> VER_FILEFLAGS               VER_VER_DEBUG</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> VER_FILETYPE                VFT_APP</span></span><br><span class="line"><span class="comment">//注意，这里需要有一个空行，否则在resource中include这个头文件会报&quot;unexpected end of file&quot;错误</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>然后分别在project1和project2的Resource 属性中将Additional Include Directory将version.h的路径加进去。</p>
<blockquote>
<p>Project Property -&gt;Resource -&gt; General -&gt; Additional Include Directories</p>
</blockquote>
<p>注意是Resource选项卡，不是C++选项卡中的设置。</p>
<p>然后分别对project1和project2的Resource文件做如下操作：</p>
<ul>
<li><p>include version.h，定义description和product name</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Microsoft Visual C++ generated resource script.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;resource.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> VER_PRODUCTNAME_STR         <span class="meta-string">&quot;product_name_here&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> VER_FILE_DESCRIPTION_STR    <span class="meta-string">&quot;description_here&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;version.h&quot;</span></span></span><br></pre></td></tr></table></figure></li>
<li><p>替换version section</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/////////////////////////////////////////////////////////////////////////////</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Version</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line">VS_VERSION_INFO VERSIONINFO</span><br><span class="line"> FILEVERSION        VER_FILE_VERSION</span><br><span class="line"> PRODUCTVERSION     VER_PRODUCT_VERSION</span><br><span class="line"> FILEFLAGSMASK      <span class="number">0x3f</span>L</span><br><span class="line"> FILEFLAGS          VER_FILEFLAGS</span><br><span class="line"> FILEOS             VER_FILEOS</span><br><span class="line"> FILETYPE           VER_FILETYPE</span><br><span class="line"> FILESUBTYPE        <span class="number">0x0</span>L</span><br><span class="line">BEGIN</span><br><span class="line">    BLOCK <span class="string">&quot;StringFileInfo&quot;</span></span><br><span class="line">    BEGIN</span><br><span class="line">        BLOCK <span class="string">&quot;040904b0&quot;</span></span><br><span class="line">        BEGIN</span><br><span class="line">            VALUE <span class="string">&quot;FileDescription&quot;</span>,  VER_FILE_DESCRIPTION_STR <span class="string">&quot;\0&quot;</span></span><br><span class="line">            VALUE <span class="string">&quot;FileVersion&quot;</span>,      VER_FILE_VERSION_STR <span class="string">&quot;\0&quot;</span></span><br><span class="line">            VALUE <span class="string">&quot;InternalName&quot;</span>,     VER_INTERNAL_NAME_STR <span class="string">&quot;\0&quot;</span></span><br><span class="line">            VALUE <span class="string">&quot;LegalCopyright&quot;</span>,   VER_COPYRIGHT_STR <span class="string">&quot;\0&quot;</span></span><br><span class="line">            VALUE <span class="string">&quot;OriginalFilename&quot;</span>, VER_ORIGINAL_FILENAME_STR <span class="string">&quot;\0&quot;</span></span><br><span class="line">            VALUE <span class="string">&quot;ProductName&quot;</span>,      VER_PRODUCTNAME_STR</span><br><span class="line">            VALUE <span class="string">&quot;ProductVersion&quot;</span>,   VER_PRODUCT_VERSION_STR <span class="string">&quot;\0&quot;</span></span><br><span class="line">        END</span><br><span class="line">    END</span><br><span class="line">    BLOCK <span class="string">&quot;VarFileInfo&quot;</span></span><br><span class="line">    BEGIN</span><br><span class="line">        VALUE <span class="string">&quot;Translation&quot;</span>, <span class="number">0x409</span>, <span class="number">1200</span></span><br><span class="line">    END</span><br><span class="line">END</span><br></pre></td></tr></table></figure></li>
</ul>
<p>Build一下工程，并修改version.h头文件，看project1和project2的版本号是否是version里设置的版本号。</p>
<p>下次如果要修改版本号，就不用一个个去改每个工程的resource.rc文件了，直接修改version.h即可。</p>
<h3 id="进阶"><a href="#进阶" class="headerlink" title="进阶"></a>进阶</h3><p>上面的方法需要每次都手动修改version信息，可以利用visual studio中的Build Event自动将version.h信息更新。Share Project Template不支持VS project Build Event，可以将其换正常的Project类型。</p>
<p>具体请参考Code Project的一篇文章：<a href="https://www.codeproject.com/Articles/10313/Automatic-Build-Versioning-in-Visual-Studio">Automatic Build Versioning in Visual Studio</a>.</p>
<h3 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h3><ul>
<li><a href="https://www.zachburlingame.com/2011/02/versioning-a-native-cc-binary-with-visual-studio/">Versioning a Native C/C++ Binary with Visual Studio</a></li>
<li><a href="http://www.cplusplus.com/forum/windows/64819/">unexpected end of file found</a></li>
</ul>
]]></content>
      <categories>
        <category>coding</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>同步与锁</title>
    <url>/2018/11/15/about-synchronization/</url>
    <content><![CDATA[<p>本文摘录自《程序员的自我修养》第一章。</p>
<span id="more"></span>

<h2 id="二元信号量-Binary-Semaphore"><a href="#二元信号量-Binary-Semaphore" class="headerlink" title="二元信号量(Binary Semaphore):"></a>二元信号量(Binary Semaphore):</h2><p>最简单的一种锁, 只有两种状态: 占用与非占用.</p>
<p>它适合只能被唯一一个线程独占访问的资源.    </p>
<h2 id="信号量-Semaphore"><a href="#信号量-Semaphore" class="headerlink" title="信号量(Semaphore):"></a>信号量(Semaphore):</h2><p>允许多个线程并发访问的资源.  </p>
<h2 id="互斥量-Mutex"><a href="#互斥量-Mutex" class="headerlink" title="互斥量(Mutex):"></a>互斥量(Mutex):</h2><p>资源仅同时允许一个线程访问.</p>
<p> 但和信号量不同的是, 信号量在整个系统可以被任意线程获取并释放, 也就是说, 同一个信号量可以被系统中的一个线程获取之后由另一个线程释放. 而互斥量则要求哪个线程获取了互斥量, 哪个线程就要负责释放这个锁, 其他线程越俎代庖去释放互斥量是无效的.  </p>
<h2 id="临界锁-Critical-Section"><a href="#临界锁-Critical-Section" class="headerlink" title="临界锁(Critical Section):"></a>临界锁(Critical Section):</h2><p>是比互斥量更加严格的同步手段.</p>
<p>临界区和互斥量与信号量的区别在于, 互斥量和信号量在系统的任何进程里都是可见的, 也就是说, 一个进程创建了一个互斥量或信号量, 另一个进程试图去获取该锁是合法的. 然而, 临界区的作用范围仅限于本进程, 其他的进程无法获取该锁. 除此之外, 临界区具有和互斥量相同的性质.  </p>
<h2 id="读写锁-Read-Write-Lock"><a href="#读写锁-Read-Write-Lock" class="headerlink" title="读写锁(Read-Write Lock):"></a>读写锁(Read-Write Lock):</h2><p>致力于一种更加特定的场合的同步.</p>
<p>读写锁的状态如下:  </p>
<table>
<thead>
<tr>
<th>读写锁状态</th>
<th>以共享方式获取</th>
<th>以独占方式获取</th>
</tr>
</thead>
<tbody><tr>
<td>自由</td>
<td>成功</td>
<td>成功</td>
</tr>
<tr>
<td>共享</td>
<td>成功</td>
<td>等待</td>
</tr>
<tr>
<td>独占</td>
<td>成功</td>
<td>等待</td>
</tr>
</tbody></table>
]]></content>
      <categories>
        <category>coding</category>
      </categories>
      <tags>
        <tag>lock</tag>
        <tag>synchronization</tag>
      </tags>
  </entry>
  <entry>
    <title>awesome-bits</title>
    <url>/2018/09/28/awesome-bits/</url>
    <content><![CDATA[<p>转载自<a href="https://github.com/keon/awesome-bits/blob/master/README.md">github</a></p>
<span id="more"></span>

<h1 id="awesome-bits"><a href="#awesome-bits" class="headerlink" title="awesome-bits "></a>awesome-bits <a href="https://github.com/sindresorhus/awesome"><img src="https://cdn.rawgit.com/sindresorhus/awesome/d7305f38d29fed78fa85652e3a63e154dd8e8829/media/badge.svg" alt="Awesome"></a></h1><blockquote>
<p>A curated list of awesome bitwise operations and tricks</p>
<p>Maintainer - <a href="https://github.com/keonkim">Keon Kim</a><br>Please feel free to <a href="https://github.com/keonkim/awesome-bits/pulls">pull requests</a></p>
</blockquote>
<h2 id="Integers"><a href="#Integers" class="headerlink" title="Integers"></a>Integers</h2><p><strong>Set n<sup>th</sup> bit</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">x | (1&lt;&lt;n)</span><br></pre></td></tr></table></figure>
<p><strong>Unset n<sup>th</sup> bit</strong><br> <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">x &amp; ~(1&lt;&lt;n)</span><br></pre></td></tr></table></figure><br><strong>Toggle n<sup>th</sup> bit</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">x ^ (1&lt;&lt;n)</span><br></pre></td></tr></table></figure>
<p><strong>Round up to the next power of two</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">unsigned int v; &#x2F;&#x2F;only works if v is 32 bit</span><br><span class="line">v--;</span><br><span class="line">v |&#x3D; v &gt;&gt; 1;</span><br><span class="line">v |&#x3D; v &gt;&gt; 2;</span><br><span class="line">v |&#x3D; v &gt;&gt; 4;</span><br><span class="line">v |&#x3D; v &gt;&gt; 8;</span><br><span class="line">v |&#x3D; v &gt;&gt; 16;</span><br><span class="line">v++;</span><br></pre></td></tr></table></figure>
<p><strong>Get the maximum integer</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int maxInt &#x3D; ~(1 &lt;&lt; 31);</span><br><span class="line">int maxInt &#x3D; (1 &lt;&lt; 31) - 1;</span><br><span class="line">int maxInt &#x3D; (1 &lt;&lt; -1) - 1;</span><br><span class="line">int maxInt &#x3D; -1u &gt;&gt; 1;</span><br></pre></td></tr></table></figure>
<p><strong>Get the minimum integer</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int minInt &#x3D; 1 &lt;&lt; 31;</span><br><span class="line">int minInt &#x3D; 1 &lt;&lt; -1;</span><br></pre></td></tr></table></figure>
<p><strong>Get the maximum long</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">long maxLong &#x3D; ((long)1 &lt;&lt; 127) - 1;</span><br></pre></td></tr></table></figure>
<p><strong>Multiply by 2</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">n &lt;&lt; 1; &#x2F;&#x2F; n*2</span><br></pre></td></tr></table></figure>
<p><strong>Divide by 2</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">n &gt;&gt; 1; &#x2F;&#x2F; n&#x2F;2</span><br></pre></td></tr></table></figure>
<p><strong>Multiply by the m<sup>th</sup> power of 2</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">n &lt;&lt; m;</span><br></pre></td></tr></table></figure>
<p><strong>Divide by the m<sup>th</sup> power of 2</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">n &gt;&gt; m;</span><br></pre></td></tr></table></figure>
<p><strong>Check Equality</strong></p>
<p><sub><em>This is 35% faster in Javascript</em></sub></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">(a^b) &#x3D;&#x3D; 0; &#x2F;&#x2F; a &#x3D;&#x3D; b</span><br><span class="line">!(a^b) &#x2F;&#x2F; use in an if</span><br></pre></td></tr></table></figure>
<p><strong>Check if a number is odd</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">(n &amp; 1) &#x3D;&#x3D; 1;</span><br></pre></td></tr></table></figure>
<p><strong>Exchange (swap) two values</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;version 1</span><br><span class="line">a ^&#x3D; b;</span><br><span class="line">b ^&#x3D; a;</span><br><span class="line">a ^&#x3D; b;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;version 2</span><br><span class="line">a &#x3D; a ^ b ^ (b &#x3D; a)</span><br></pre></td></tr></table></figure>
<p><strong>Get the absolute value</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;version 1</span><br><span class="line">x &lt; 0 ? -x : x;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;version 2</span><br><span class="line">(x ^ (x &gt;&gt; 31)) - (x &gt;&gt; 31);</span><br></pre></td></tr></table></figure>
<p><strong>Get the max of two values</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">b &amp; ((a-b) &gt;&gt; 31) | a &amp; (~(a-b) &gt;&gt; 31);</span><br></pre></td></tr></table></figure>
<p><strong>Get the min of two values</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">a &amp; ((a-b) &gt;&gt; 31) | b &amp; (~(a-b) &gt;&gt; 31);</span><br></pre></td></tr></table></figure>
<p><strong>Check whether both numbers have the same sign</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">(x ^ y) &gt;&#x3D; 0;</span><br></pre></td></tr></table></figure>
<p><strong>Flip the sign</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">i &#x3D; ~i + 1; &#x2F;&#x2F; or</span><br><span class="line">i &#x3D; (i ^ -1) + 1; &#x2F;&#x2F; i &#x3D; -i</span><br></pre></td></tr></table></figure>
<p><strong>Calculate 2<sup>n</sup></strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1 &lt;&lt; n;</span><br></pre></td></tr></table></figure>
<p><strong>Whether a number is power of 2</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">n &gt; 0 &amp;&amp; (n &amp; (n - 1)) &#x3D;&#x3D; 0;</span><br></pre></td></tr></table></figure>
<p><strong>Modulo 2<sup>n</sup> against m</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">m &amp; ((1 &lt;&lt; n) - 1);</span><br></pre></td></tr></table></figure>
<p><strong>Get the average</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">(x + y) &gt;&gt; 1;</span><br><span class="line">((x ^ y) &gt;&gt; 1) + (x &amp; y);</span><br></pre></td></tr></table></figure>
<p><strong>Get the m<sup>th</sup> bit of n (from low to high)</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">(n &gt;&gt; (m-1)) &amp; 1;</span><br></pre></td></tr></table></figure>
<p><strong>Set the m<sup>th</sup> bit of n to 0 (from low to high)</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">n &amp; ~(1 &lt;&lt; (m-1));</span><br></pre></td></tr></table></figure>
<p><strong>Check if n<sup>th</sup> bit is set</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">if (x &amp; (1&lt;&lt;n)) &#123;</span><br><span class="line">  n-th bit is set</span><br><span class="line">&#125; else &#123;</span><br><span class="line">  n-th bit is not set</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>Isolate (extract) the right-most 1 bit</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">x &amp; (-x)</span><br></pre></td></tr></table></figure>
<p><strong>Isolate (extract) the right-most 0 bit</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">~x &amp; (x+1)</span><br></pre></td></tr></table></figure>

<p><strong>Set the right-most 0 bit to 1</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">x | (x+1)</span><br></pre></td></tr></table></figure>

<p><strong>Set the right-most 1 bit to 0</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">x &amp; (x-1)</span><br></pre></td></tr></table></figure>

<p><strong>n + 1</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-~n</span><br></pre></td></tr></table></figure>
<p><strong>n - 1</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">~-n</span><br></pre></td></tr></table></figure>
<p><strong>Get the negative value of a number</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">~n + 1;</span><br><span class="line">(n ^ -1) + 1;</span><br></pre></td></tr></table></figure>
<p><strong><code>if (x == a) x = b; if (x == b) x = a;</code></strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">x &#x3D; a ^ b ^ x;</span><br></pre></td></tr></table></figure>
<p><strong>Swap Adjacent bits</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">((n &amp; 10101010) &gt;&gt; 1) | ((n &amp; 01010101) &lt;&lt; 1)</span><br></pre></td></tr></table></figure>
<p><strong>Different rightmost bit of numbers m &amp; n</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">(n^m)&amp;-(n^m) &#x2F;&#x2F; returns 2^x where x is the position of the different bit (0 based)</span><br></pre></td></tr></table></figure>
<p><strong>Common rightmost bit of numbers m &amp; n</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">~(n^m)&amp;(n^m)+1 &#x2F;&#x2F; returns 2^x where x is the position of the common bit (0 based)</span><br></pre></td></tr></table></figure>
<h2 id="Floats"><a href="#Floats" class="headerlink" title="Floats"></a>Floats</h2><p>These are techniques inspired by the <a href="https://en.wikipedia.org/wiki/Fast_inverse_square_root">fast inverse square root method.</a> Most of these<br>are original.</p>
<p><strong>Turn a float into a bit-array (unsigned uint32_t)</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdint.h&gt;</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">union</span> &#123;</span><span class="keyword">float</span> flt; <span class="keyword">uint32_t</span> bits&#125; <span class="keyword">lens_t</span>;</span><br><span class="line"><span class="function"><span class="keyword">uint32_t</span> <span class="title">f2i</span><span class="params">(<span class="keyword">float</span> x)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> ((<span class="keyword">lens_t</span>) &#123;.flt = x&#125;).bits;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><sub><em>Caveat: Type pruning via unions is undefined in C++; use <code>std::memcpy</code> instead.</em></sub></p>
<p><strong>Turn a bit-array back into a float</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">float</span> <span class="title">i2f</span><span class="params">(<span class="keyword">uint32_t</span> x)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> ((<span class="keyword">lens_t</span>) &#123;.bits = x&#125;).flt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>Approximate the bit-array of a <em>positive</em> float using <code>frexp</code></strong></p>
<p><em><code>frexp</code> gives the 2<sup>n</sup> decomposition of a number, so that <code>man, exp = frexp(x)</code> means that man * 2<sup>exp</sup> = x and 0.5 &lt;= man &lt; 1.</em></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">man, <span class="built_in">exp</span> = <span class="built_in">frexp</span>(x);</span><br><span class="line"><span class="keyword">return</span> (<span class="keyword">uint32_t</span>)((<span class="number">2</span> * man + <span class="built_in">exp</span> + <span class="number">125</span>) * <span class="number">0x800000</span>);</span><br></pre></td></tr></table></figure>
<p><sub><em>Caveat: This will have at most 2<sup>-16</sup> relative error, since man + 125 clobbers the last 8 bits, saving the first 16 bits of your mantissa.</em></sub></p>
<p><strong>Fast Inverse Square Root</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">return</span> i2f(<span class="number">0x5f3759df</span> - f2i(x) / <span class="number">2</span>);</span><br></pre></td></tr></table></figure>
<p><sub><em>Caveat: We’re using the <code>i2f</code> and the <code>f2i</code> functions from above instead.</em></sub></p>
<p>See <a href="https://en.wikipedia.org/wiki/Fast_inverse_square_root#A_worked_example">this Wikipedia article</a> for reference.</p>
<p><strong>Fast n<sup>th</sup> Root of positive numbers via Infinite Series</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">float</span> <span class="title">root</span><span class="params">(<span class="keyword">float</span> x, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">#DEFINE MAN_MASK <span class="number">0x7fffff</span></span><br><span class="line">#DEFINE EXP_MASK <span class="number">0x7f800000</span></span><br><span class="line">#DEFINE EXP_BIAS <span class="number">0x3f800000</span></span><br><span class="line">  <span class="keyword">uint32_t</span> bits = f2i(x);</span><br><span class="line">  <span class="keyword">uint32_t</span> man = bits &amp; MAN_MASK;</span><br><span class="line">  <span class="keyword">uint32_t</span> <span class="built_in">exp</span> = (bits &amp; EXP_MASK) - EXP_BIAS;</span><br><span class="line">  <span class="keyword">return</span> i2f((man + man / n) | ((EXP_BIAS + <span class="built_in">exp</span> / n) &amp; EXP_MASK));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>See <a href="http://www.phailed.me/2012/08/somewhat-fast-square-root/">this blog post</a> regarding the derivation.</p>
<p><strong>Fast Arbitrary Power</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">return</span> i2f((<span class="number">1</span> - <span class="built_in">exp</span>) * (<span class="number">0x3f800000</span> - <span class="number">0x5c416</span>) + f2i(x) * <span class="built_in">exp</span>)</span><br></pre></td></tr></table></figure>

<p><sub><em>Caveat: The <code>0x5c416</code> bias is given to center the method. If you plug in exp = -0.5, this gives the <code>0x5f3759df</code> magic constant of the fast inverse root method.</em></sub></p>
<p>See <a href="http://www.bullshitmath.lol/FastRoot.slides.html">these set of slides</a> for a derivation of this method.</p>
<p><strong>Fast Geometric Mean</strong></p>
<p>The geometric mean of a set of <code>n</code> numbers is the n<sup>th</sup> root of their<br>product.</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stddef.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">float</span> <span class="title">geometric_mean</span><span class="params">(<span class="keyword">float</span>* <span class="built_in">list</span>, <span class="keyword">size_t</span> length)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// Effectively, find the average of map(f2i, list)</span></span><br><span class="line">  <span class="keyword">uint32_t</span> accumulator = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; length; i++) &#123;</span><br><span class="line">    accumulator += f2i(<span class="built_in">list</span>[i]);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> i2f(accumulator / n);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>See <a href="https://github.com/leegao/float-hacks#geometric-mean-1">here</a> for its derivation.</p>
<p><strong>Fast Natural Logarithm</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">#DEFINE EPSILON <span class="number">1.1920928955078125e-07</span></span><br><span class="line">#DEFINE LOG2 <span class="number">0.6931471805599453</span></span><br><span class="line"><span class="keyword">return</span> (f2i(x) - (<span class="number">0x3f800000</span> - <span class="number">0x66774</span>)) * EPSILON * LOG2</span><br></pre></td></tr></table></figure>

<p><sub><em>Caveat: The bias term of <code>0x66774</code> is meant to center the method. We multiply by <code>ln(2)</code> at the end because the rest of the method computes the <code>log2(x)</code> function.</em></sub></p>
<p>See <a href="https://github.com/leegao/float-hacks#log-1">here</a> for its derivation.</p>
<p><strong>Fast Natural Exp</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">return</span> i2f(<span class="number">0x3f800000</span> + (<span class="keyword">uint32_t</span>)(x * (<span class="number">0x800000</span> + <span class="number">0x38aa22</span>)))</span><br></pre></td></tr></table></figure>

<p><sub><em>Caveat: The bias term of <code>0x38aa22</code> here corresponds to a multiplicative scaling of the base. In particular, it<br>corresponds to <code>z</code> such that 2<sup>z</sup> = e</em></sub></p>
<p>See <a href="https://github.com/leegao/float-hacks#exp-1">here</a> for its derivation.</p>
<h2 id="Strings"><a href="#Strings" class="headerlink" title="Strings"></a>Strings</h2><p><strong>Convert letter to lowercase:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">OR by space &#x3D;&gt; (x | &#39; &#39;)</span><br><span class="line">Result is always lowercase even if letter is already lowercase</span><br><span class="line">eg. (&#39;a&#39; | &#39; &#39;) &#x3D;&gt; &#39;a&#39; ; (&#39;A&#39; | &#39; &#39;) &#x3D;&gt; &#39;a&#39;</span><br></pre></td></tr></table></figure>

<p><strong>Convert letter to uppercase:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">AND by underline &#x3D;&gt; (x &amp; &#39;_&#39;)</span><br><span class="line">Result is always uppercase even if letter is already uppercase</span><br><span class="line">eg. (&#39;a&#39; &amp; &#39;_&#39;) &#x3D;&gt; &#39;A&#39; ; (&#39;A&#39; &amp; &#39;_&#39;) &#x3D;&gt; &#39;A&#39;</span><br></pre></td></tr></table></figure>
<p><strong>Invert letter’s case:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">XOR by space &#x3D;&gt; (x ^ &#39; &#39;)</span><br><span class="line">eg. (&#39;a&#39; ^ &#39; &#39;) &#x3D;&gt; &#39;A&#39; ; (&#39;A&#39; ^ &#39; &#39;) &#x3D;&gt; &#39;a&#39;</span><br></pre></td></tr></table></figure>
<p><strong>Letter’s position in alphabet:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">AND by chr(31)&#x2F;binary(&#39;11111&#39;)&#x2F;(hex(&#39;1F&#39;) &#x3D;&gt; (x &amp; &quot;\x1F&quot;)</span><br><span class="line">Result is in 1..26 range, letter case is not important</span><br><span class="line">eg. (&#39;a&#39; &amp; &quot;\x1F&quot;) &#x3D;&gt; 1 ; (&#39;B&#39; &amp; &quot;\x1F&quot;) &#x3D;&gt; 2</span><br></pre></td></tr></table></figure>
<p><strong>Get letter’s position in alphabet (for Uppercase letters only):</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">AND by ? &#x3D;&gt; (x &amp; &#39;?&#39;) or XOR by @ &#x3D;&gt; (x ^ &#39;@&#39;)</span><br><span class="line">eg. (&#39;C&#39; &amp; &#39;?&#39;) &#x3D;&gt; 3 ; (&#39;Z&#39; ^ &#39;@&#39;) &#x3D;&gt; 26</span><br></pre></td></tr></table></figure>
<p><strong>Get letter’s position in alphabet (for lowercase letters only):</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">XOR by backtick&#x2F;chr(96)&#x2F;binary(&#39;1100000&#39;)&#x2F;hex(&#39;60&#39;) &#x3D;&gt; (x ^ &#39;&#96;&#39;)</span><br><span class="line">eg. (&#39;d&#39; ^ &#39;&#96;&#39;) &#x3D;&gt; 4 ; (&#39;x&#39; ^ &#39;&#96;&#39;) &#x3D;&gt; 24</span><br></pre></td></tr></table></figure>

<h2 id="Miscellaneous"><a href="#Miscellaneous" class="headerlink" title="Miscellaneous"></a>Miscellaneous</h2><p><strong>Fast color conversion from R5G5B5 to R8G8B8 pixel format using shifts</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">R8 &#x3D; (R5 &lt;&lt; 3) | (R5 &gt;&gt; 2)</span><br><span class="line">G8 &#x3D; (R5 &lt;&lt; 3) | (R5 &gt;&gt; 2)</span><br><span class="line">B8 &#x3D; (R5 &lt;&lt; 3) | (R5 &gt;&gt; 2)</span><br></pre></td></tr></table></figure>
<p>Note: using anything other than the English letters will produce garbage results</p>
<h2 id="Additional-Resources"><a href="#Additional-Resources" class="headerlink" title="Additional Resources"></a>Additional Resources</h2><ul>
<li><a href="https://graphics.stanford.edu/~seander/bithacks.html">Bit Twiddling Hacks</a></li>
<li><a href="https://github.com/leegao/float-hacks">Floating Point Hacks</a></li>
<li><a href="http://www.hackersdelight.org/">Hacker’s Delight</a></li>
<li><a href="http://bits.stephan-brumme.com/">The Bit Twiddler</a></li>
</ul>
]]></content>
      <categories>
        <category>coding</category>
      </categories>
      <tags>
        <tag>c/c++</tag>
      </tags>
  </entry>
  <entry>
    <title>another normal weekend</title>
    <url>/2020/07/11/another-normal-day/</url>
    <content><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">
  <script id="hbeData" type="hbeData" data-hmacdigest="c311b2ccefbaabd4b33495fe3b1e79bdaba8e07786ebfee428f02cb1c7c20176">59fd7a6a1f42c434984d9088bceb757958dcfc7bd45b1cf0001644c858799d569eafd51d5093c5ea0d82e358c7a299c009ae74705592c26c030da6eabbcaeb6fe99bc168592f24b35c3f3d5e28572af7644791f2f2c82d166fc1ec3b085aaa2a95af757de6031d258a5f4fda17ab375b78fdb5b87b82d1216dc268fd3aa027c2ee6a2a28725d248aa826b5dc3157650edf3d7b585843af84c3e8afe15f128655392e9edf9acd335e1ea887ba72550881071e24b6540c7194c2bd02a242c6330855f8561569dad891c1aadce4616eb4fcc93f09f8e87f2e6dfe0f95ceaf4b330bece15e559434833e8440ffab0ac334691142c9c264519cfaf54f9d90f9184625548ef26b5e5f01b1b190a1b622a646d1b39e1614faf43e618baac22addba4b7b5b6697ff66a26beb2dbf3fec789d49bd9bfa220bd4d79c6365ec307c6ca2a727fae2fc8803eb75feb60f328d147927a0f76a53adfed64452445a4bd3f30987b0ad23966cf4bef75b2bf91a6412e8900822072a9750f99dd11475d995e0aa3f03f1ea1604e0b00a9f5a50764c50e82ebd50e4121b565e0cc41f162ccffc232580caa02deb4da2b1e9ae99049715dc72b55bfa80702620a3df98899b775fa0f6509411da23b29db671b54cd9dc82d11228cce22bea368ea7dab17b4f7833122c8eaea9c152fdcdd8f3e5ca8f49157422f041f13799a3efcbfe821a0970fb249963fd3c8ccdb040b544d1a2ff30bb2c6fd82c350e42f56c0e22bdaa3e236511808f422e7bc1996616e2d00fe2f93c09057083a8819be6ec1e234264d923399561d540a3758d51775afd339475c53b1af174ae40827460cb38846ce03c6dc0a7c674806d03e73be2f0a49da3d3391f6d4b4d0138b117b1d9bbe79a7ed711509860e6818a3c1d6b30b053eba978fa7d7b24339cc5384c92b9b100681a37910b9d6a4efa07f65cfe9d30a5291a67199603d3a34501314f3a753ed9d3937667347765cbcfb0e42dec6235cc50b1665b776f29d178cd340f64564e55250e8e82323e317e126b10d0089a8ca1b8eee517315714b697a3638ccc1f531e6cd5fba3240cab099ac408296f97556738f6a31010122243885b8b84645ee3ce56325050834751001c83cfa34b926d2396c423384b95a55e651f813c53d285d271ae62f6d6e38f85c62c8d3e32868c9994fda2353ffabd4043eadc3a926136207eeb755b7a2b2f13cdca541849730c96d77a93ff8988af057a975801ca921e623fd06874f4cbd4a41ee2228b1e152d49c6a326788d850bdc7b8b4b2d906f12b8f6bbb0e5c3deeb236b36a263164748e15cdd0ea2319b0f476fdd6b525d660972d572cb268700efbd0f68bc0c5f1c3b880a0be3898dce1244314ac39ada241616338fd057d2c85b28a76d91b056ff2c04d4853dffc7ee8e3517305c4a10a47f104281a5c6ac3d92a6b31d9b9bfd4ec21b6e2948f6d1a9035d406d4cca3ff1a3ccaf6916c8af5b88874b215300f0e757b05b230b04cedaf81e7dc7b155eda64908df298a313bbfd84195d48b810fa7563a745f549a29a2615269f33ef837ec55a865a2ae607aaa2597a9a6f84c7d2dac9ef60eed3790dda4309a59f585b4e9477f4f4d5ac8e4e6ec04ce01417e218914ac5fa4392ec67d3542c2b8ab53d7aad16a4e38644d67bf31d7955c7492c83e735a0a032c793833fae9e0912f98b5686bd452df0025edea2f8dbd523c237088419f0c7f07b00604c744c42994a90154864cd47f61329778046021e33174187884956706f4626a299306e393383d9b1d035896cdf7817a3075212b45843c0042908a6190303a5d4db7115483102bd0493f87b776fce0a74e43a2494c8bc4b7c16de3d22d84bfdd2b1eb0ea2675bc2731eb4cad69ab5e0ad32f7d119bbb2ce8615697d4b348a45675e47929f7db86b3495bcb7fe4cf4e15b53c7473736eddefd16ebe2f75717536e54c3c9cc83663b402dd9281fb3ae9d7f80e93f28d44d833a3a3a9b5427ed42c2adf2e64de913fdfbce0d71bfe1f10cd63a71e5ff7301db54b330b13059b26b739a6e034f21ea2c855a495dabe1a3b3e25595fe2e09b4a5dcbae3b8387498e5b112014b61146979bfef43e7c003e25cb7eafc7cf68e98e32e717d89f074e7f0936fc5d9ec096dada0b5fb3df73efe58cd4b94b47e16a587570746739c8c9d01eb7a9efd5b7fc51583e62dd0acf9b10c6d09e6362dc7686ce49c65ce17e3f29c43e4c830c4ac84f5928c9068891644b1dcf3cb13e7de72594fa3b76daeb8b5bbee5f8f5759893ee1974ac773fab0aaa0f7348a1249449b7df24a44535212b348bea63cab59fa158cfe706b87b1bfaa0be3b270d2ad73e32f87520e811b77b637fe0931dc839d7789b6432c704f429760da63b2c30743926a24c8816f4f3dae0645e60afdafc3d9e9ab53a30eb1b850d73d388b2941f0ea833a11203274e7a5f453fd18373a04bbc062d14cbfbbe7d5ac6964e4c</script>
  <div class="hbe hbe-content">
    <div class="hbe hbe-input hbe-input-default">
      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">
      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">
        <span class="hbe hbe-input-label-content hbe-input-label-content-default">Hey, password is required here.</span>
      </label>
    </div>
  </div>
</div>
<script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
      <categories>
        <category>notes</category>
      </categories>
  </entry>
  <entry>
    <title>visual studio中版本号自动管理</title>
    <url>/2018/04/04/automatic-versionning-in-visual-studio/</url>
    <content><![CDATA[<p>在开发中，对版本号进行管理是一个很重要的事情。特别在visual studio中有多个project的时候，每一个project都有自己的version。下面介绍三种方式来实现版本号自动化管理。</p>
<span id="more"></span>

<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>先简单介绍下在visual studio中的三个version。</p>
<ul>
<li><p>Assembly Version</p>
<blockquote>
<p>.net CLR加载DLL的时候使用的版本号，如果加载强签名的dll，需要指定dll的版本号，就是这个Assembly Version</p>
</blockquote>
</li>
<li><p>Assembly File Version</p>
<blockquote>
<p>在windows 资源管理器中显示的文件版本号</p>
</blockquote>
</li>
<li><p>Assembly Info Version</p>
<blockquote>
<p>在windows 资源管理器中显示的产品版本号</p>
</blockquote>
</li>
</ul>
<img src="/2018/04/04/automatic-versionning-in-visual-studio/strong_named_assembly.png" class="">

<img src="/2018/04/04/automatic-versionning-in-visual-studio/version.png" class="">

<h2 id="利用VS自带的版本号递增"><a href="#利用VS自带的版本号递增" class="headerlink" title="利用VS自带的版本号递增"></a>利用VS自带的版本号递增</h2><p>在project的AssemblyInfo.cs文件中，可以使用通配符来使得版本号自动变化。</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Version information for an assembly consists of the following four values:</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//      Major Version</span></span><br><span class="line"><span class="comment">//      Minor Version </span></span><br><span class="line"><span class="comment">//      Build Number</span></span><br><span class="line"><span class="comment">//      Revision</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// You can specify all the values or you can default the Build and Revision Numbers </span></span><br><span class="line"><span class="comment">// by using the &#x27;*&#x27; as shown below:</span></span><br><span class="line"><span class="comment">// [assembly: AssemblyVersion(&quot;1.0.*&quot;)]</span></span><br><span class="line">[<span class="meta">assembly: AssemblyVersion(<span class="meta-string">&quot;1.0.*&quot;</span>)</span>]</span><br><span class="line"><span class="comment">//[assembly: AssemblyFileVersion(&quot;1.0.0.0&quot;)]  注释掉该行</span></span><br></pre></td></tr></table></figure>

<p>这样每次成功build之后，assembly version ，File version都会变化，其中build number和revision是以某个时间节点为起点，到build时计算出来的值。</p>
<p>在vs中，每个project都有一个AssemblyInfo.cs文件，在多个project之间，可以通过共享文件来共享同一个版本号。</p>
<ul>
<li><p>首先将所有project的AssemblyInfo.cs文件中的AssemblyVersion和AssemblyFileVersion注释掉</p>
</li>
<li><p>在你的启动工程中创建一个SharedInfo.cs，加入以下内容:</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> System.Reflection;</span><br><span class="line"></span><br><span class="line">[<span class="meta">assembly: AssemblyVersion(<span class="meta-string">&quot;1.0.*&quot;</span>)</span>]</span><br></pre></td></tr></table></figure></li>
<li><p>在其他project中将上一步创建的文件通过add as link方式add进来。</p>
<img src="/2018/04/04/automatic-versionning-in-visual-studio/add_as_link.png" class=""></li>
</ul>
<p>这样所有project都会共享SharedInfo文件。</p>
<h2 id="使用T4模板生成版本号"><a href="#使用T4模板生成版本号" class="headerlink" title="使用T4模板生成版本号"></a>使用T4模板生成版本号</h2><p>在AssemblyVersion属性中使用通配符生成的版本号并不是那么“友好”。有的时候仅仅是想让版本号加一而已。使用T4(<strong>Text Template Transformation Toolkit</strong>)模板自动生成代码可以做到这一点。</p>
<blockquote>
<p>In Visual Studio, a <em>T4 text template</em> is a mixture of text blocks and control logic that can generate a text file.</p>
</blockquote>
<blockquote>
<p>T4 is used by developers as part of an application or tool framework to automate the creation of text files with a variety of parameters. These text files can ultimately be any text format, such as code (for example C#), XML, HTML or XAML.</p>
</blockquote>
<p>在vs中创建一个SharedInfo.tt文件(new -&gt;item -&gt; text template)，加入以下内容:</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line">&lt;<span class="meta">#@ template debug=&quot;false&quot; hostspecific=&quot;true&quot; language=&quot;C#&quot; #&gt;</span></span><br><span class="line">&lt;<span class="meta">#@ import namespace=&quot;System.IO&quot; #&gt;</span></span><br><span class="line">&lt;<span class="meta">#@ output extension=&quot;.cs&quot; #&gt;</span></span><br><span class="line">&lt;<span class="meta">#</span></span><br><span class="line">     <span class="built_in">int</span> major = <span class="number">0</span>; </span><br><span class="line">     <span class="built_in">int</span> minor = <span class="number">0</span>; </span><br><span class="line">     <span class="built_in">int</span> build = <span class="number">0</span>; </span><br><span class="line">     <span class="built_in">int</span> revision = <span class="number">0</span>; </span><br><span class="line">  </span><br><span class="line">     <span class="keyword">try</span></span><br><span class="line">     &#123;</span><br><span class="line">         <span class="keyword">using</span>(<span class="keyword">var</span> f = File.OpenText(Host.ResolvePath(<span class="string">&quot;SharedInfo.cs&quot;</span>)))</span><br><span class="line">         &#123;</span><br><span class="line">             <span class="built_in">string</span> maj = f.ReadLine().Replace(<span class="string">&quot;//&quot;</span>,<span class="string">&quot;&quot;</span>);</span><br><span class="line">             <span class="built_in">string</span> min = f.ReadLine().Replace(<span class="string">&quot;//&quot;</span>,<span class="string">&quot;&quot;</span>);</span><br><span class="line">             <span class="built_in">string</span> b = f.ReadLine().Replace(<span class="string">&quot;//&quot;</span>,<span class="string">&quot;&quot;</span>);</span><br><span class="line">             <span class="built_in">string</span> r = f.ReadLine().Replace(<span class="string">&quot;//&quot;</span>,<span class="string">&quot;&quot;</span>);</span><br><span class="line">  </span><br><span class="line">             major = <span class="built_in">int</span>.Parse(maj); </span><br><span class="line">             minor = <span class="built_in">int</span>.Parse(min); </span><br><span class="line">             build = <span class="built_in">int</span>.Parse(b); </span><br><span class="line">             revision = <span class="built_in">int</span>.Parse(r) + <span class="number">1</span>; </span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line">     catch</span><br><span class="line">     &#123;</span><br><span class="line">         major = <span class="number">1</span>; </span><br><span class="line">         minor = <span class="number">0</span>; </span><br><span class="line">         build = <span class="number">0</span>; </span><br><span class="line">         revision = <span class="number">0</span>; </span><br><span class="line">     &#125;</span><br><span class="line"> <span class="meta">#&gt;</span></span><br><span class="line"> <span class="comment">//&lt;#= major #&gt;</span></span><br><span class="line"> <span class="comment">//&lt;#= minor #&gt;</span></span><br><span class="line"> <span class="comment">//&lt;#= build #&gt;</span></span><br><span class="line"> <span class="comment">//&lt;#= revision #&gt;</span></span><br><span class="line"> <span class="comment">// </span></span><br><span class="line"> <span class="comment">// This code was generated by a tool. Any changes made manually will be lost</span></span><br><span class="line"> <span class="comment">// the next time this code is regenerated.</span></span><br><span class="line"> <span class="comment">// </span></span><br><span class="line">  </span><br><span class="line"> <span class="keyword">using</span> System.Reflection;</span><br><span class="line">  </span><br><span class="line"> [<span class="meta">assembly: AssemblyFileVersion(<span class="meta-string">&quot;&lt;#= major #&gt;.&lt;#= minor #&gt;.&lt;#= build #&gt;.&lt;#= revision #&gt;&quot;</span>)</span>]</span><br></pre></td></tr></table></figure>

<p>保存之后，会在SharedInfo.tt文件下面生成SharedInfo.cs文件。然后将该文件通过add as link 加入到其他project中。这样每次要生成一个新的版本号之后，需要在SharedInfo.tt文件的右键菜单中<code>Run Custom tool</code>，重新生成SharedInfo.cs文件。</p>
<p>当然也可以在使用pre-build事件，自动化这一过程。在project的pre-build事件中加入以下内容：</p>
<figure class="highlight bat"><table><tr><td class="code"><pre><span class="line"><span class="built_in">set</span> textTemplatingPath=&quot;<span class="variable">%CommonProgramFiles(x86)%</span>\Microsoft Shared\TextTemplating\$(VisualStudioVersion)\texttransform.exe&quot;</span><br><span class="line"><span class="keyword">if</span> <span class="variable">%textTemplatingPath%</span>==&quot;\Microsoft Shared\TextTemplating\$(VisualStudioVersion)\texttransform.exe&quot; <span class="built_in">set</span> textTemplatingPath=&quot;<span class="variable">%CommonProgramFiles%</span>\Microsoft Shared\TextTemplating\$(VisualStudioVersion)\texttransform.exe&quot;</span><br><span class="line"><span class="variable">%textTemplatingPath%</span> &quot;$(ProjectDir)SharedInfo.tt&quot;</span><br></pre></td></tr></table></figure>

<img src="/2018/04/04/automatic-versionning-in-visual-studio/pre_build.png" class="">

<h2 id="使用VS插件Automatic-Versions-1"><a href="#使用VS插件Automatic-Versions-1" class="headerlink" title="使用VS插件Automatic Versions 1"></a>使用VS插件Automatic Versions 1</h2><p>最简单也是最强大的莫过于直接使用<a href="https://marketplace.visualstudio.com/items?itemName=PrecisionInfinity.AutomaticVersions">Automatic Versions</a>插件了。该VS插件提供了多种策略来实现版本号自动递增，可以支持整个solution和单个project的versioning继承。即可以为整个solution设置versionning的规则，也可以为单个project设置不继承solution的规则，自己按自己的规则。</p>
<p>安装好之后，在vs菜单栏tools -&gt; automatic versions settings，打开设置面板。</p>


<p>设置选项参考官方的文档：</p>
<blockquote>
<p>CustomSystem.Version Options</p>
<p>Major, Minor, Build, andRevision can be individually configured to the incrementation type desired:</p>
<img src="/2018/04/04/automatic-versionning-in-visual-studio/clip_image001.png" class="">

<p>In these examples, we usethe date July 29th 2024, 1:30pm</p>
<ul>
<li>None -     Do not increment this value.</li>
<li>Increment (Always) - Always Increments this value by 1*</li>
<li>Increment w/AutoReset - Increments this value by     1, unless a more significant number increases, in which case it will reset     to 0.</li>
<li>On Demand (Build New     Version) - Increment this value     by 1 only when a build is initiated using the Build New Version command (on the     context menu of each project). You can set this value on both the Major     and the Minor numbers and use the context menu (see usage below) to     control which one is incremented.</li>
<li>On Demand w/Reset (Obsolete) - Use Increment w/AutoReset instead.     This feature may not be supported in future versions of the product.     (Legacy functionality: Increment this value by 1 only when a build is     initiated using the Build New Version command (on the context menu of each     project). Resets all Increment sub-values.)</li>
<li>Day Of Year (ddd) - Set this value to DateTime.UtcNow.DayOfYear:     211.</li>
<li>Day (dd) -     Set this value to the current day of the month: 29.</li>
<li>Month (MM) - Set this value to the current month of the year:     7.</li>
<li>Year (yyyy) - Set this value to the current year: 2024.</li>
<li>Short Year (yy) - Set this value to 2 digit     current year: 24.</li>
<li>Date (yyddd) - Set this value to the current date (yyddd format     - where ddd is the day of year)**: 24211.</li>
<li>Date (MMdd) - Set this value to the     current date (MMdd) where MM is a 2-digit month and dd is a 2-digit day of     month: 0729.</li>
<li>UTC Time (HHmm) - Set this value to the current time (HHmm     format): 1330.</li>
<li>Delta Days (since 1/1/2000) - Set this value to the number of days that have     occurred since January 1, 2000: 8976.</li>
<li>UTC Seconds Since Midnight/2 - If you are using a custom     unique time based stamp for your version number, this gives you the most     granularity to a single day. The number has to be divided by 2 so it     doesn’t overflow the max value.</li>
</ul>
<p>*There is an exception to this rule whenIncrement On Demand w/Reset (Obsolete) is used it will reset this value if youchoose Build New Version</p>
<p>**This value will overflow in 2065. Since itis very useful and there are limited alternatives that work as well as thisone, we are continuing to use it and even recommend using it, however, we maychange it’s functionality at some point such that it does not overflow in 2065.The overflow itself is not a security issue, however. It will only cause abuild error.</p>
<p>CustomSemantic Version (BETA/PRO)</p>
<p>Semantic Versioning istypically used for ‘packaging’ the results of a build for use in a manifestfile or as a ‘published package’ of your product. Therefore Semantic Versioningleverages the other version attributes by letting you choose which of those youwant to use for your Major/Minor numbers, and independently does it’s ownincrementation on the Patch and Pre-Release numbers.</p>
<img src="/2018/04/04/automatic-versionning-in-visual-studio/clip_image002.png" class="">

<ul>
<li>Major/Minor settings - Set to use     AssemblyVersion, AssemblyFileVersion, or Set Manually. To set manually,     open the AssemblyInfo file (for Full .Net) or the project properties (for     .Net Standard/Core) and manually set the major and minor values.</li>
<li>Patch settings - This will increment the     Patch number based on the incrementation settings. Increment Once is     available for when you switch to a ‘pre-release’ version of the product,     you will typically want the Patch number to Increment Once for the start     of your pre-release cycle. After incrementing once, this setting will     automatically update to None (whereby Pre-Release will be doing the     incrementation).</li>
<li>Pre-Release (optional) - Set to alpha, beta,     preview, rc, or N/A (release). If you set a pre-release, then Patch will     automatically change to “increment once” for you and the     prerelease will increment instead starting with alpha, then alpha-01,     alpha-02, etc. When you set this to (N/A release) then Patch will be     automatically changed to Increment w/AutoReset for you.</li>
</ul>
</blockquote>
<p>注意一点：</p>
<p>OnDemand 表示在工程的右键菜单中手动选择build</p>
<img src="/2018/04/04/automatic-versionning-in-visual-studio/on_demand.png" class="">



<h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ul>
<li><a href="https://jonthysell.com/2017/01/10/automatically-generating-version-numbers-in-visual-studio/">https://jonthysell.com/2017/01/10/automatically-generating-version-numbers-in-visual-studio/</a></li>
<li><a href="https://marketplace.visualstudio.com/items?itemName=PrecisionInfinity.AutomaticVersions">https://marketplace.visualstudio.com/items?itemName=PrecisionInfinity.AutomaticVersions</a></li>
<li><a href="https://weblogs.asp.net/kon/assembly-file-version-auto-increment-magic">https://weblogs.asp.net/kon/assembly-file-version-auto-increment-magic</a></li>
<li><a href="https://docs.microsoft.com/en-us/visualstudio/modeling/code-generation-and-t4-text-templates">https://docs.microsoft.com/en-us/visualstudio/modeling/code-generation-and-t4-text-templates</a></li>
</ul>
]]></content>
      <categories>
        <category>coding</category>
      </categories>
      <tags>
        <tag>visual studio</tag>
      </tags>
  </entry>
  <entry>
    <title>bitwise copy vs memberwise copy</title>
    <url>/2018/11/23/bitwise-copy-vs-memberwise-copy/</url>
    <content><![CDATA[<p>本文转自<a href="https://stackoverflow.com/questions/42749439/what-is-the-difference-between-memberwise-copy-bitwise-copy-shallow-copy-and-d">Stack Overflow</a>，对几种copy的概念将的通熟易懂。</p>
<span id="more"></span>

<p><strong>Member-wise Copy</strong></p>
<p>Is when you visit each member and explicitly copy it, invoking its copy constructor. It is usually tantamount to deep-copy. It is the right and proper way of copying things. The opposite is bit-wise copy, which is a hack, see below.</p>
<p><strong>Bit-wise Copy</strong></p>
<p>Is a specific form of shallow copy. It is when you simply copy the bits of the source class to the target class, using <code>memcpy()</code> or something similar. Constructors are not invoked, so you tend to get a class which <em>appears</em> to be all right but things start breaking in horrible ways as soon as you start using it. This is the opposite of member-wise copy, and is a quick and dirty hack that can sometimes be used when we know that there are no constructors to be invoked and no internal structures to be duplicated. For a discussion of what may go wrong with this, see this Q&amp;A: <a href="https://stackoverflow.com/questions/15123516/c-bitwise-vs-memberwise-copying">C++ bitwise vs memberwise copying?</a></p>
<p><strong>Shallow Copy</strong></p>
<p>Refers to copying just the immediate members of an object, without duplicating whatever structures are pointed by them. It is what you get when you do a bit-wise copy.</p>
<p>(Note that there is no such thing as “shadow copy”. I mean, there is such a thing, in file systems, but that’s probably <em>not</em> what you had in mind.)</p>
<p><strong>Deep Copy</strong></p>
<p>Refers to not only copying the immediate members of an object, but also duplicating whatever structures are pointed by them. It is what you normally get when you do member-wise copy.</p>
<p><strong>To summarize:</strong></p>
<p>There are two categories:</p>
<ul>
<li>Shallow Copy</li>
<li>Deep Copy</li>
</ul>
<p>Then, there are two widely used techniques:</p>
<ul>
<li>Bit-wise Copy (a form of Shallow Copy)</li>
<li>Member-wise Copy (a form of Deep Copy)</li>
</ul>
<p>As for the hear-say about someone who said something and someone who said something else: bit-wise copy is definitely always shallow copy. Member-wise copy is usually deep copy, but you may of course foul it up, so you may be thinking that you are making a deep copy while in fact you are not. Proper member-wise copy relies on having proper copy constructors.</p>
<p>Finally:</p>
<p>The default copy constructor will do a bit-wise copy if the object is known to be trivially copyable, or a member-wise copy if not. However, the compiler does not always have enough information to perform a proper copy of each member. For example, a pointer is copied by making a copy of the pointer, not by making a copy of the pointed object. That’s why you should generally not rely on the compiler providing you with a default copy constructor when your object is not trivially copyable.</p>
<p>A user-supplied constructor may do whatever type of copy the user likes. Hopefully, the user will choose wisely and do a member-wise copy.</p>
]]></content>
      <categories>
        <category>coding</category>
      </categories>
      <tags>
        <tag>copy</tag>
      </tags>
  </entry>
  <entry>
    <title>blog migration test</title>
    <url>/2017/11/08/blog-migration-test/</url>
    <content><![CDATA[<p>由于换了新电脑，博客内容一直没有迁移过来。<br>（其实一直在忙着玩塞尔达）</p>
<p>本帖是迁移测试。</p>
]]></content>
      <categories>
        <category>notes</category>
      </categories>
  </entry>
  <entry>
    <title>blog plan</title>
    <url>/2018/02/23/blog-plan/</url>
    <content><![CDATA[<p>最近打算将onenote上的一些笔记，整理整理上传到博客中，正好熟悉熟悉下markdown的语法。打算一周两篇的量吧。</p>
]]></content>
      <categories>
        <category>notes</category>
      </categories>
  </entry>
  <entry>
    <title>build c/c++ extension for python</title>
    <url>/2018/11/08/build-c-c-extension-for-python/</url>
    <content><![CDATA[<p>本文记录下如何在python中调用C/C++中函数。本文主要参考MSDN 中<a href="https://docs.microsoft.com/en-us/visualstudio/python/working-with-c-cpp-python-in-visual-studio?view=vs-2017">Create a C++ extension for Python</a> 一文。</p>
<span id="more"></span>

<h2 id="搭建python环境"><a href="#搭建python环境" class="headerlink" title="搭建python环境"></a>搭建python环境</h2><p>由于我是直接参考的MSDN上的教程，所以没有直接下载python安装包，而是直接通过Visual Studio 2017来安装的python。所以按照MSDN上的步骤，通过Visual Studio Installer来安装Python模块。建议同时安装32bit和64bit。</p>
<p>安装好之后，默认安装的路径是<code>C:\Program Files (x86)\Microsoft Visual Studio\Shared</code>。可以建立一个文件夹快捷方式放在C盘根目录，方便以后导航。</p>
<p>接下来设置一下系统的环境变量，首先建立PATHHOME环境变量为Python安装目录：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">C:\Program Files (x86)\Microsoft Visual Studio\Shared\Python36_86\</span><br></pre></td></tr></table></figure>

<p>然后修改PATH环境变量，加入以下路径：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">;%PYTHONHOME%;%PYTHONHOME%\Scripts;%PYTHONHOME%\DLLS;</span><br></pre></td></tr></table></figure>

<p>以后如果想使用Python 64位的，直接修改PYTHONHOME环境变量为Python 64目录即可。</p>
<h2 id="验证环境"><a href="#验证环境" class="headerlink" title="验证环境"></a>验证环境</h2><p>按照MSDN上，建立一个Python工程，直接run一下试试，验证Python环境是否成功。</p>
<p>按照MSDN上，建立一个c++ 工程，然后设置下project property，<strong>具体设置项按照MSDN上的设置项</strong>。然后编写c++ function。build以下，验证C++工程无问题。</p>
<p>注意:</p>
<ul>
<li>根据MSDN，需要将在Project Property中C/C++ Code Generation -&gt; Runtime Library 设置为Multi-threaded DLL(/MD)</li>
<li>工程设置中将<code>$(PYTHONHOME)\include</code>加入到Additional Include directory中。<code>$(PYTHONHOME)</code>即是我们在上一步中设置的环境变量。</li>
<li>在Linker -&gt; General -&gt; Additional Library Directories 中加入<code>$(PYTHONHOME)\libs</code></li>
<li>将Project platform设置为win32 平台。</li>
</ul>
<h2 id="编写代码"><a href="#编写代码" class="headerlink" title="编写代码"></a>编写代码</h2><p>在原有的c++工程中新建一个cpp文件，然后加入以下代码</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//always put Python header first, if not found this header, </span></span><br><span class="line"><span class="comment">//check c++ Additional library include setting ：$(PYTHONHOME)\include</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;Python.h&gt;  </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;Windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;math.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function">PyObject* <span class="title">test_mul</span><span class="params">(PyObject *self, PyObject* args)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> a, b;</span><br><span class="line">	PyArg_ParseTuple(args, <span class="string">&quot;ii&quot;</span>, &amp;a, &amp;b);  <span class="comment">//format string ref: https://docs.python.org/3.7/c-api/arg.html</span></span><br><span class="line">	<span class="comment">//return PyLong_FromLong(a*b);</span></span><br><span class="line">	<span class="keyword">int</span> result = mul(a, b);</span><br><span class="line">	<span class="keyword">return</span> PyLong_FromLong(result);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">PyObject* <span class="title">test_sub</span><span class="params">(PyObject* self, PyObject* args)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> a, b;</span><br><span class="line">	PyArg_ParseTuple(args, <span class="string">&quot;ii&quot;</span>, &amp;a, &amp;b);</span><br><span class="line">	<span class="keyword">int</span> result = sub(a, b);</span><br><span class="line">	<span class="keyword">return</span> PyLong_FromLong(result);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> PyMethodDef superfastcode_methods[] = &#123;</span><br><span class="line">	<span class="comment">// The first property is the name exposed to Python, fast_tanh, the second is the C++</span></span><br><span class="line">	<span class="comment">// function name that contains the implementation.</span></span><br><span class="line">	<span class="comment">//&#123; &quot;fast_tanh&quot;, (PyCFunction)tanh_impl, METH_O, nullptr &#125;,  //METH_O means only passing one argument</span></span><br><span class="line">	&#123;<span class="string">&quot;test_mul&quot;</span>, (PyCFunction)test_mul, METH_VARARGS, <span class="literal">nullptr</span>&#125;,  <span class="comment">//METH_VARARGS ref: https://docs.python.org/3/c-api/structures.html</span></span><br><span class="line">	&#123;<span class="string">&quot;test_sub&quot;</span>, (PyCFunction)test_sub, METH_VARARGS, <span class="literal">nullptr</span>&#125;,</span><br><span class="line">	<span class="comment">// Terminate the array with an object containing nulls.</span></span><br><span class="line">	&#123; <span class="literal">nullptr</span>, <span class="literal">nullptr</span>, <span class="number">0</span>, <span class="literal">nullptr</span> &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> PyModuleDef superfastcode_module = &#123;</span><br><span class="line">	PyModuleDef_HEAD_INIT,</span><br><span class="line">	<span class="string">&quot;superfastcode&quot;</span>,                        <span class="comment">// Module name to use with Python import statements</span></span><br><span class="line">	<span class="string">&quot;Provides some functions, but faster&quot;</span>,  <span class="comment">// Module description</span></span><br><span class="line">	<span class="number">0</span>,</span><br><span class="line">	superfastcode_methods                   <span class="comment">// Structure that defines the methods of the module</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">PyMODINIT_FUNC <span class="title">PyInit_superfastcode</span><span class="params">()</span> </span>&#123;  <span class="comment">//PyInit_&lt;module_name&gt;  module_name must be your module name</span></span><br><span class="line">	<span class="keyword">return</span> PyModule_Create(&amp;superfastcode_module);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>build工程查看是否成功。下面是对其几点说明。</p>
<ol>
<li><p>必须要有一个<code>PyInit_&lt;model_name&gt;</code>导出函数，Python会通过这个函数来初始化模块。</p>
</li>
<li><p>给C++函数写一个对应的wrapper 函数，比如上述中的<code>test_mul</code>函数，wrapper函数的签名是<code>Pyobject* (Pyobject* self, Pyobject* args)</code>。在Python中所有的type都是“继承”自Pyobject（之所以打引号，是因为python是用C写的，并没有继承的概念）。</p>
</li>
<li><p>在wrapper函数中的第二个参数是args表示从Python脚本中传递过来的参数包。可以使用PyArg_ParseTuple来取得。</p>
<blockquote>
<p>int <code>PyArg_ParseTuple</code>(<a href="https://docs.python.org/3/c-api/structures.html#c.PyObject">PyObject</a> *<em>args</em>, const char *<em>format</em>, …)</p>
<p>Parse the parameters of a function that takes only positional parameters into local variables. Returns true on success; on failure, it returns false and raises the appropriate exception.</p>
</blockquote>
<p>其中第二个参数format表示如何解析传递的参数包，”ii”表示两个integer，”s”表示字符串，具体请参考<a href="https://docs.python.org/3/c-api/arg.html">Parsing arguments and building values</a></p>
</li>
<li><p>定义一个数组，并枚举需要导出的C++函数，如上面的<code>superfastcode_methods</code>，数组中每个元素都是一个<code>PyMethodDef</code>结构体。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">PyMethodDef</span> &#123;</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span>  *ml_name;   <span class="comment">/* The name of the built-in function/method */</span></span><br><span class="line">    PyCFunction ml_meth;    <span class="comment">/* The C function that implements it */</span></span><br><span class="line">    <span class="keyword">int</span>         ml_flags;   <span class="comment">/* Combination of METH_xxx flags, which mostly</span></span><br><span class="line"><span class="comment">                               describe the args expected by the C func */</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span>  *ml_doc;    <span class="comment">/* The __doc__ attribute, or NULL */</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">PyMethodDef</span> <span class="title">PyMethodDef</span>;</span></span><br></pre></td></tr></table></figure>

<p>其中ml_flags中METH_O表示只有一个参数，METH_VARARGS表示可以有多个参数。在wrapper class中会使用这些”声明”来取得参数。</p>
</li>
<li><p>定义一个<code>PyModuleDef</code>结构体，如上面的<code>superfastcode_module</code>。表示module名称等信息。</p>
</li>
</ol>
<h2 id="使用定义好的Module"><a href="#使用定义好的Module" class="headerlink" title="使用定义好的Module"></a>使用定义好的Module</h2><p>Module定义好之后，可以有两种方式导入到python中。</p>
<p>如果跟Python工程属于同一个Solution，可以直接在Python Project中直接Reference过来。具体做法是在Python工程-&gt; References -&gt; Add References。</p>
<p>另外一种方式，可以通过<code>distutils</code>来编译成Python的一个模块。<code>distutils</code>通过setup.py 脚本来编译C/C++ 源文件。一个简单的setup.py如下。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> distutils.core <span class="keyword">import</span> setup, Extension, DEBUG</span><br><span class="line"></span><br><span class="line"><span class="comment">#more info about setup.py, please ref: https://docs.python.org/3/extending/building.html</span></span><br><span class="line"></span><br><span class="line">sfc_module = Extension(<span class="string">&#x27;superfastcode&#x27;</span>, </span><br><span class="line">                       libraries=[<span class="string">&#x27;StaticLib1&#x27;</span>],  <span class="comment">#dependency</span></span><br><span class="line">                       sources = [<span class="string">&#x27;source.cpp&#x27;</span>])</span><br><span class="line"></span><br><span class="line">setup(name = <span class="string">&#x27;superfastcode&#x27;</span>, version = <span class="string">&#x27;1.0&#x27;</span>,</span><br><span class="line">    description = <span class="string">&#x27;Python Package with superfastcode C++ extension&#x27;</span>,</span><br><span class="line">    ext_modules = [sfc_module]</span><br><span class="line">    )</span><br></pre></td></tr></table></figure>

<p>上面source.cpp中依赖了一个StaticLib1中的函数，所以加入了libraries 供链接用。</p>
<p>目前文件结构如下图：</p>
<img src="/2018/11/08/build-c-c-extension-for-python/file_structure.png" class="">

<p>其中math.h 是StaticLib1的头文件。PythonApplication1.py是测试用的脚本。</p>
<p>我们首先需要编译source.cpp。在该目录下打开cmder(cmder一款统一命令行工具，也可以用cmd命令行)，执行</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">pip install .</span><br></pre></td></tr></table></figure>

<p>此操作会将module安装到Python的site-package中。然后我们就可以在python脚本中使用了</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#demo test</span></span><br><span class="line"><span class="comment">#import function from module</span></span><br><span class="line"><span class="keyword">from</span> superfastcode <span class="keyword">import</span> test_mul, test_sub</span><br><span class="line"></span><br><span class="line">result = test_mul(<span class="number">2</span>,<span class="number">2</span>)</span><br><span class="line">print(result);</span><br><span class="line"></span><br><span class="line">result = test_sub(<span class="number">5</span>,<span class="number">1</span>);</span><br><span class="line">print(result);</span><br></pre></td></tr></table></figure>

<p>在Visual Studio中F5运行或者在命令行执行<code>python PythonApplication1.py</code>，验证是否成功。</p>
<h2 id="卸载已安装的包"><a href="#卸载已安装的包" class="headerlink" title="卸载已安装的包"></a>卸载已安装的包</h2><p>如果在上一步执行<code>pip install .</code>的时候提示已经该包已经安装过，无法卸载。执行<code>pip uninstall your_module_name</code>也无法卸载。可以通过删除Python安装目录下的site-packages来卸载该包。</p>
<img src="/2018/11/08/build-c-c-extension-for-python/site-package.png" class="">

<p>注意采用这种卸载方式是因为我们使用的distutils来安装package的，Python下可以使用其他包管理来管理，如<a href="http://peak.telecommunity.com/DevCenter/EasyInstall">easy_install</a></p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li><a href="https://docs.python.org/3/c-api/arg.html">https://docs.python.org/3/c-api/arg.html</a></li>
<li><a href="https://docs.python.org/3/extending/building.html">https://docs.python.org/3/extending/building.html</a></li>
<li><a href="https://docs.python.org/3/c-api/structures.html">https://docs.python.org/3/c-api/structures.html</a></li>
<li><a href="https://stackoverflow.com/questions/402359/how-do-you-uninstall-a-python-package-that-was-installed-using-distutils">https://stackoverflow.com/questions/402359/how-do-you-uninstall-a-python-package-that-was-installed-using-distutils</a></li>
<li><a href="https://docs.python.org/3.7/c-api/arg.html">https://docs.python.org/3.7/c-api/arg.html</a></li>
<li><a href="https://docs.microsoft.com/en-us/visualstudio/python/working-with-c-cpp-python-in-visual-studio?view=vs-2017">https://docs.microsoft.com/en-us/visualstudio/python/working-with-c-cpp-python-in-visual-studio?view=vs-2017</a></li>
</ul>
]]></content>
      <categories>
        <category>coding</category>
      </categories>
      <tags>
        <tag>c++</tag>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>家庭影院折腾入门</title>
    <url>/2021/05/27/build-your-own-media-server/</url>
    <content><![CDATA[<p>以前旧笔记本装的黑裙基本上只当下载机和文件共享中心。“斥巨资”组了黑裙之后，总想着多多利用起来。群晖上的套件一路折腾过来，踩了一些坑，也有了一些经验，此博文是为记。</p>
<span id="more"></span>

<h2 id="过往历程"><a href="#过往历程" class="headerlink" title="过往历程"></a>过往历程</h2><p>其实我的原始需求很简单：在电视上方便的观看下载的视频。在我的旧笔记本的黑裙基本已经可以满足这个需求了。</p>
<blockquote>
<p>trasmission BT下载 -&gt; NAS 共享文件夹 -&gt; 电视NPlayer播放视频</p>
</blockquote>
<p>这个方案基本不需要额外投入。直到一次黑五，购入了一个14T的硬盘，由于3.5寸盘无法直接用在笔记本上，只能外挂作为移动硬盘，用当然是可以用，但是旧笔记本USB2.0的速度在局域网动辄百兆千兆来说，简直有点侮辱了这块盘。于是有了装机的打算。</p>
<p>说到装机，还有一段插曲。当时公司正好有一批淘汰的机架式服务器，50块的价格感觉不要太香！抢购之后发现有两个致命缺点：1) 大，奈何家里小  2)噪音大，开机之后直接芜湖起飞。无奈出掉。又看了蜗牛星际和暴风几款矿渣主机，当时价格已经涨上来了，蜗牛星际黄鱼上基本400左右一套可以拿下，暴风主机大概贵一倍的价格。翻来覆去，最终选择了暴风二期，J3145比J1900还是强一些，而且网上对暴风二期的做工评价也不错。</p>
<p>于是在不想再次斥巨资的情况下，把14T的硬盘置换为了8T硬盘 + 暴风二期。（后来由于硬盘挖矿兴起，大容量硬盘价格被炒的翻倍，14T盘被我卖飞在涨价前夕，这是后话，含泪不表）</p>
<p>机器到手自然直接上了黑裙，这里踩了一个大坑。黑裙的版本分两个版本，一个是918版本，一个是3617版本。参考网上的教程，开始直接上918版本，因为据说918版本照片人脸识别功能做的更好。但是引导之后出现主机无法获取IP的情况，折腾两个晚上，无法解决，最终只能换3617，3617版本一切顺利。</p>
<p>后来才发现918版本的固件对暴风二期机子的螃蟹网卡驱动支持不是很完美，会导致机器IP获取慢的问题（需要3~5分钟才能分配到IP）。后来又发现只有918版本的黑裙才支持GPU硬件解码，当然这又是后话，暂且不表。</p>
<h2 id="我的需求"><a href="#我的需求" class="headerlink" title="我的需求"></a>我的需求</h2><p>群晖上的影音套件有很多，自带的Video Station，Emby， Jellifin， Plex等等。网上看了一些相关的文章，基本上比较推荐Emby和Plex。</p>
<p>下面是Emby和Plex两个方案试用下来的对比。</p>
<table>
<thead>
<tr>
<th>需求</th>
<th>Emby</th>
<th>Plex</th>
</tr>
</thead>
<tbody><tr>
<td>可以外挂字幕</td>
<td>可以自动挂载字幕</td>
<td>Plex集成自动搜索字幕</td>
</tr>
<tr>
<td>电视客户端，简单好用</td>
<td>有相应的Emby Android TV客户端</td>
<td>无TV客户端，但是可以作为KODI的插件，但是KODI反人类的操作界面…</td>
</tr>
<tr>
<td>自动刮削，生成海报墙</td>
<td>由于墙的原因，MovieDatabase等一些电影元素据的网站需要科学上网访问，但是Emby有相应的开心版docker镜像集成了代理服务器，但是海报墙效果差强人意，优点是nfo数据和海报数据直接保存在本地文件夹</td>
<td>Plex真正自动刮削，海报墙效果比Emby强不少</td>
</tr>
<tr>
<td>比较方便的外网访问</td>
<td>反向代理可解决</td>
<td>同样反向代理可解决，同时Plex登陆时使用HTTPS登录Plex账号，授权成功之后，自动跳转到自建的Plex服务，也就是说自建Plex服务开启HTTP即可，省去HTTPS申请证书等一套繁琐的操作。</td>
</tr>
<tr>
<td>最好免费</td>
<td>基本功能免费，Premium功能收费，当然有开心版本可白嫖</td>
<td>Premium功能收费</td>
</tr>
<tr>
<td>转码可有可无，有最好，不是强需求</td>
<td>有，需Premium会员</td>
<td>有且不收费</td>
</tr>
</tbody></table>
<p>这里多吐槽下KODI，不知道是不是电视的原因，KODI电视客户端无法安装插件，在路由器全局下科学上网下也无法work，使我不得不放弃KODI作为电视客户端。</p>
<p>Emby和Plex使用下来，最终我选择两个方案共存。因为Emby的电视客户端使用体验还不错，所以电视上，我使用Emby 来播放视频。在需要使用电脑的情况下，使用浏览器来访问Plex服务。话不多说，上图！</p>
<p><img src="/2021/05/27/build-your-own-media-server/plex_movie.png"></p>
<p><img src="/2021/05/27/build-your-own-media-server/plex_tvshow.png"></p>
<p><img src="/2021/05/27/build-your-own-media-server/plex_movie_intro.png"></p>
<p><img src="/2021/05/27/build-your-own-media-server/plex_intro.png"></p>
<h2 id="外网访问"><a href="#外网访问" class="headerlink" title="外网访问"></a>外网访问</h2><p>这里记录下Plex外网访问的方法。说白了就是内网穿透，这里也有两种方法。</p>
<ol>
<li>家里宽带有公网IP。这种情况只需要有一个域名即可。甚至不需要自己的域名，借助一些第三方的服务实现DDNS。比如TP路由器直接就提供了TPLINK的DDNS服务。</li>
<li>没有公网IP。需要有一台云主机，借助FRP来实现内网穿透。但是由于视频需要对VPS的带宽有一定的要求，国内VPS 带宽一般都比较贵，建议直接上国外的VPS，同样价格下带宽大且可以有“其他用途”。</li>
</ol>
<p>家里宽带有公网IP，但是由于公网IP一般都封禁了80,443,8080端口，同时公司出口又只放通了80,443,8080端口，所以我无法直接使用方案1。无奈只能通过nginx+frp方案来实现从公司访问到家里的Plex服务。</p>
<h3 id="DNS"><a href="#DNS" class="headerlink" title="DNS"></a>DNS</h3><p>在自己域名增加一个A记录，指向VPS IP地址，比如</p>
<p><code>media.bygeek.cn  -&gt; 123.123.123.123</code></p>
<h3 id="VPS端"><a href="#VPS端" class="headerlink" title="VPS端"></a>VPS端</h3><ol>
<li>安装frp，可以直接使用docker image</li>
</ol>
<p><code>docker pull snowdreamtech/frpc</code></p>
<p>通过volume挂载配置文件</p>
<p><code>docker run --restart=always --network host -d -v /etc/frp/frps.ini:/etc/frp/frps.ini --name frps snowdreamtech/frps</code></p>
<p>本地的frps.ini 配置示例</p>
<figure class="highlight ini"><table><tr><td class="code"><pre><span class="line"><span class="section">[common]</span></span><br><span class="line"><span class="attr">bind_addr</span> = <span class="number">0.0</span>.<span class="number">0.0</span></span><br><span class="line"><span class="attr">bind_port</span> = <span class="number">7024</span></span><br><span class="line"><span class="attr">vhost_http_port</span> = <span class="number">18080</span></span><br><span class="line"><span class="comment">#vhost_https_port = 443</span></span><br><span class="line"><span class="attr">dashboard_port</span> = <span class="number">7025</span></span><br><span class="line"><span class="attr">privilege_mode</span> = <span class="literal">true</span></span><br><span class="line"><span class="attr">privilege_token</span> = your_password_here</span><br></pre></td></tr></table></figure>

<p>vhost_http_port即为frp server监听并进行http转发的端口</p>
<ol start="2">
<li><p>安装nginx</p>
<p>nginx的/etc/nginx/nginx.conf示例配置</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">        listen       80 default_server;</span><br><span class="line">        listen       [::]:80 default_server;</span><br><span class="line">        server_name  media.bygeek.cn;</span><br><span class="line">        <span class="comment">#root         /usr/share/nginx/html;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># Load configuration files for the default server block.</span></span><br><span class="line">        include /etc/nginx/default.d/*.conf;</span><br><span class="line"></span><br><span class="line">        location / &#123;</span><br><span class="line">          proxy_set_header Host $host;</span><br><span class="line">          proxy_set_header X-Real-IP $remote_addr;</span><br><span class="line">          proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;</span><br><span class="line">          proxy_set_header X-Forwarded-Scheme  $scheme;</span><br><span class="line">          proxy_redirect off;</span><br><span class="line">          proxy_pass http://localhost:18080;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        error_page 404 /404.html;</span><br><span class="line">        <span class="attr">location</span> = /<span class="number">404</span>.html &#123;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        error_page 500 502 503 504 /50x.html;</span><br><span class="line">        <span class="attr">location</span> = /<span class="number">50</span>x.html &#123;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>nginx会在将访问media.bygeek.cn的80端口的服务proxy到本地的18080端口http服务上去。也就是上文的frps。</p>
<p>注意location block里面的的proxy_set_header 字段，会将media.bygeek.cn这个host 设置为header送给frps。这个很重要，因为frps会根据custom domain来转发。</p>
</li>
</ol>
<h3 id="NAS端"><a href="#NAS端" class="headerlink" title="NAS端"></a>NAS端</h3><p>同样安装docker 版frp，可以ssh到nas上或者直接在群晖docker 套件中搜索<code>snowdreamtech/frpc</code></p>
<p>frpc的配置文件示例</p>
<figure class="highlight ini"><table><tr><td class="code"><pre><span class="line"><span class="section">[common]</span></span><br><span class="line"><span class="attr">server_addr</span> = <span class="number">123.123</span>.<span class="number">123.123</span></span><br><span class="line"><span class="attr">server_port</span> = <span class="number">7024</span></span><br><span class="line"><span class="attr">log_level</span> = info</span><br><span class="line"><span class="attr">authenticate_new_work_conns</span> = <span class="literal">true</span></span><br><span class="line"><span class="attr">authenticate_heartbeats</span> = <span class="literal">true</span></span><br><span class="line"><span class="attr">token</span> = your_password_here</span><br><span class="line"></span><br><span class="line"><span class="section">[media]</span></span><br><span class="line"><span class="attr">type</span> = http</span><br><span class="line"><span class="attr">local_ip</span> = <span class="number">127.0</span>.<span class="number">0.1</span></span><br><span class="line"><span class="attr">local_port</span> = <span class="number">32400</span></span><br><span class="line"><span class="attr">custom_domains</span> = media.bygeek.cn</span><br></pre></td></tr></table></figure>

<p>server_addr是安装frps的服务器的地址，也即你的VPS地址</p>
<p>token跟frps的privilege_token一致</p>
<p>custom_domains即是上文DNS增加的记录</p>
<p>local_port是你nas上Plex服务器的端口</p>
<h3 id="效果"><a href="#效果" class="headerlink" title="效果"></a>效果</h3><p>配置完成之后，即可在外网通过80端口访问内网的Plex服务了，且登录时通过跳转Plex域名完成授权，无需担心安全问题。</p>
<p><img src="/2021/05/27/build-your-own-media-server/plex_login.png"></p>
<p>经过实测，VPS的带宽可以满足自动转码下720p的外网流畅播放。</p>
<h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>由于黑裙3617版本不支持硬件解码，在需要转码的情况下CPU的暂用率很高，如果需要充分发挥暴风二期J3145 的GPU 硬解4K的能力，需要安装918固件。而这，是下一次折腾的故事了。</p>
]]></content>
      <categories>
        <category>tutorial</category>
      </categories>
      <tags>
        <tag>nas</tag>
        <tag>HTPC</tag>
      </tags>
  </entry>
  <entry>
    <title>c#：关于socket.Receive是否阻塞的问题</title>
    <url>/2018/03/05/c-%EF%BC%9A%E5%85%B3%E4%BA%8Esocket-Receive%E6%98%AF%E5%90%A6%E9%98%BB%E5%A1%9E%E7%9A%84%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<p>最近socket调查一个bug的时候，发现一个“问题”。在c#中调用<code>socket.Receive(buff)</code>的时候，并没有阻塞当前线程，而是直接返回。</p>
<span id="more"></span>

<p>查看MSDN：</p>
<blockquote>
<p>The Receive method reads data into the buffer parameter and returns the number of bytes successfully read. You can call Receive from both connection-oriented and connectionless sockets.</p>
<p>This overload only requires you to provide a receive buffer. The buffer offset defaults to 0, the size defaults to the length of the buffer parameter, and the SocketFlags value defaults to None.</p>
<p>If you are using a connection-oriented protocol, you must either call Connect to establish a remote host connection, or Accept to accept an incoming connection prior to calling Receive. The Receive method will only read data that arrives from the remote host established in the Connect or Acceptmethod. If you are using a connectionless protocol, you can also use the ReceiveFrom method. ReceiveFrom will allow you to receive data arriving from any host.</p>
<p>If no data is available for reading, the Receive method will block until data is available, unless a time-out value was set by using Socket.ReceiveTimeout. If the time-out value was exceeded, the Receive call will throw a SocketException. If you are in non-blocking mode, and there is no data available in the in the protocol stack buffer, the Receive method will complete immediately and throw a SocketException. You can use the Available property to determine if data is available for reading. When Available is non-zero, retry the receive operation.</p>
<p><strong>If you are using a connection-oriented Socket, the Receive method will read as much data as is available, up to the size of the buffer. If the remote host shuts down the Socket connection with the Shutdown method, and all available data has been received, the Receive method will complete immediately and return zero bytes.</strong></p>
<p>If you are using a connectionless Socket, Receive will read the first queued datagram from the destination address you specify in the Connectmethod. If the datagram you receive is larger than the size of the buffer parameter, buffer gets filled with the first part of the message, the excess data is lost and a SocketException is thrown.</p>
</blockquote>
<p>加粗位置：当使用面向连接的socket（比如使用TCP协议），<code>socket.Receive(buff)</code>方法会获取尽可能多的数据来填充<code>buff</code>。但是如果remote端(可以是client，也可以是server)调用<code>shutdown</code>，而且所有的数据都收到了，则再次调用<code>socket.Receive(buff)</code>会立即返回。</p>
]]></content>
      <categories>
        <category>coding</category>
      </categories>
      <tags>
        <tag>socket</tag>
        <tag>c#</tag>
      </tags>
  </entry>
  <entry>
    <title>centos 初始化简单配置</title>
    <url>/2018/03/12/centos-%E5%88%9D%E5%A7%8B%E5%8C%96%E7%AE%80%E5%8D%95%E9%85%8D%E7%BD%AE/</url>
    <content><![CDATA[<p>centos简单折腾记录。</p>
<h2 id="新建用户"><a href="#新建用户" class="headerlink" title="新建用户"></a>新建用户</h2><ol>
<li>使用root用户登录到server端。</li>
<li>新建用户账号：<code>adduser robert</code></li>
<li>设置密码: <code>passwd robert</code></li>
</ol>
<h2 id="增加用户到sudoer中"><a href="#增加用户到sudoer中" class="headerlink" title="增加用户到sudoer中"></a>增加用户到sudoer中</h2><p>root用户拥有系统的最高权限，但是为了系统的安全性，一般不会直接使用root用户。相反我们会使用sudo命令来暂时提高当前用户的权限。下一步我们将新建的用户robert加入到sudoer中。在centos中，在<code>wheel</code>用户组的用户具有sudo权限。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">usermod -aG wheel robert</span><br></pre></td></tr></table></figure>

<p>注：在debian系统中sudoer所在的用户组是sudo。<code>usermod -aG sudo robert</code></p>
<p>测试是否成功。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">su robert</span><br><span class="line">sudo ls -al /root</span><br></pre></td></tr></table></figure>

<p>如果还是提示用户不再sudoer中。那么还需要修改<code>/etc/sudoers</code>文件。sudo命令是由该文件来配置哪个用户及用户组可以执行。注意该文件不要随便修改，因为错误的语法错误可能会导致用户无法通过sudo来提升权限。需要通过<code>visudo</code>命令来修改。<code>visudo</code>命令默认使用vi来打开文件，但是在保存文件的时候会检查配置是否有语法错误。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">visudo -f /etc/sudoers</span><br></pre></td></tr></table></figure>

<p>找到wheel（可以使用vi中进行搜索字符）。如下面所示，去掉前面的#号，取消该行注释。%wheel表示的是wheel 用户组。参考<a href="https://www.digitalocean.com/community/tutorials/how-to-edit-the-sudoers-file-on-ubuntu-and-centos#what-is-visudo">链接</a></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">...</span><br><span class="line"><span class="meta">%</span><span class="bash">wheel ALL=(ALL) ALL</span></span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>然后再测试是否切换到创建的用户，是否能够执行sudo命令。</p>
<h2 id="修改SSH默认端口"><a href="#修改SSH默认端口" class="headerlink" title="修改SSH默认端口"></a>修改SSH默认端口</h2><p>ssh是一个安全的加密协议，用于主机之间的通信。为了加强系统的安全性，修改默认的ssh的22端口。</p>
<ol>
<li><p>修改ssh_config文件中的默认端口号</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">vim /etc/ssh/sshd_config</span><br></pre></td></tr></table></figure>

<p>找到<code>#Port 22</code>这一行，去掉#，取消注释，修改为你想要该的端口号，如10086。</p>
</li>
<li><p>按需修改修改防火墙规则和更新selinux规则。</p>
<p>centos7执行：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">firewall-cmd --add-port 10086</span><br><span class="line">firewall-cmd --add-port 2345/tcp --permanent</span><br></pre></td></tr></table></figure>

<p>centos6执行：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">iptables -I INPUT -p tcp --dport 10086 -j ACCEPT</span><br></pre></td></tr></table></figure>

<p>同时按需修改selinux:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">semanage port -a -t ssh_port_t -p tcp 10086</span><br></pre></td></tr></table></figure></li>
<li><p>重启ssh服务: </p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">systemctl restart sshd.service</span><br></pre></td></tr></table></figure>

<p>注：在centos 6以下中可能无法使用<code>systemctl</code>，需使用<code>service ssh restart</code>.</p>
</li>
<li><p>测试ssh链接：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ssh robert@ip_address -p 10086</span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="配置公钥登录"><a href="#配置公钥登录" class="headerlink" title="配置公钥登录"></a>配置公钥登录</h2><p>在windows上一般使用putty或xshell来作为ssh客户端。这里以xshell为例。在xshell中<code>Tools-&gt;User key Manager-&gt;Generate</code>生成公钥/私钥对。将私钥保存好，同时将公钥复制到剪贴板。</p>
<p>使用xshell ssh连接到远程主机，在当前用户HOME目录下执行如下命令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> ~</span><br><span class="line">mkdir .ssh &amp;&amp; chmod 700 .ssh</span><br><span class="line">touch .ssh/authorized_keys &amp;&amp; chmod 600 .ssh/authorized_keys</span><br></pre></td></tr></table></figure>

<p>ssh服务默认使用用户.ssh目录下的authorized_keys中的公钥来进行验证。将上一部复制的公钥复制到authorized_keys文件中。</p>
<p>如果想配置root也使用公钥登录，需要在root目录下也建立.ssh文件夹和authorized_keys文件。注意，需要更改文件夹和文件权限！</p>
<h2 id="禁止root远程密码登录"><a href="#禁止root远程密码登录" class="headerlink" title="禁止root远程密码登录"></a>禁止root远程密码登录</h2><p>修改ssd的配置文件</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo vim /etc/ssh/sshd_config</span><br></pre></td></tr></table></figure>

<p>将<code>#PermitRootLogin yes</code>修改为<code>PermitRootLogin without-password</code>。注意是修改为without-password，如果直接修改为no，则root公钥也不能登录了。</p>
<h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ul>
<li><a href="https://wiki.centos.org/HowTos/Network/SecuringSSH">centos wiki</a></li>
<li><a href="https://www.digitalocean.com/community/tutorials/how-to-create-a-sudo-user-on-centos-quickstart">add sudoer</a></li>
<li><a href="https://www.digitalocean.com/community/tutorials/how-to-edit-the-sudoers-file-on-ubuntu-and-centos#what-is-visudo">add sudoer 2</a></li>
</ul>
]]></content>
      <categories>
        <category>tutorial</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>centos</tag>
      </tags>
  </entry>
  <entry>
    <title>call c function in lua</title>
    <url>/2018/09/11/call-c-function-in-lua/</url>
    <content><![CDATA[<p>Code in <a href="https://github.com/byGeek/CallCFunctionInLua">here</a>.</p>
<span id="more"></span>

<p>This project use Lua5.2.4, visual studio 2017.  You can find the lua binary file located in <code>TestLua/lua</code>folder.</p>
<p>To create a C library and export function to lua. Follow this steps:</p>
<ul>
<li><p>Define your function with following signature</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">int</span> <span class="params">(*lua_CFunction)</span><span class="params">(lua_State* L)</span></span></span><br></pre></td></tr></table></figure>

<p>example</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">myadd</span><span class="params">(lua_State* L)</span></span>;</span><br></pre></td></tr></table></figure></li>
<li><p>Construct a <code>luaL_Reg</code> array</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">luaL_Reg</span> <span class="title">mylib</span>[] =</span>&#123;</span><br><span class="line">    &#123;<span class="string">&quot;myadd&quot;</span>, myadd&#125;,</span><br><span class="line">    &#123;<span class="literal">NULL</span>, <span class="literal">NULL</span>&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>and <code>luaL_Reg</code> is defined in <code>lauxlib.h</code></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">luaL_Reg</span> &#123;</span></span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">char</span> *name;</span><br><span class="line">  lua_CFunction func;</span><br><span class="line">&#125; luaL_Reg;</span><br></pre></td></tr></table></figure></li>
</ul>
<p>So the first is the function name which will be used in lua, and the second is the function address in c library. Note that the last element in this array must be <code>&#123;NULL, NULL&#125;</code>.</p>
<ul>
<li><p>Define a <code>luaopen_DLLName</code> function</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">luaopen_TestLua</span><span class="params">(lua_State *L)</span></span>&#123;</span><br><span class="line">    luaL_newlib(L, mylib);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>This function name should be match pattern <code>luaopen_dllname</code>, dllname is your dll’s name</p>
</li>
<li><p>Final step, Use this c library in your lua code.</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- test.lua</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">local</span> t = <span class="built_in">require</span> <span class="string">&quot;TestLua&quot;</span></span><br><span class="line"><span class="built_in">print</span>(t.myadd(<span class="number">1</span>, <span class="number">2</span>))</span><br></pre></td></tr></table></figure>

<p>when you run this <code>test.lua</code> script in lua environment, it should output correct answer. Remerber to use <strong>same lua exe version</strong> to run this script.</p>
<p>Note that the module name is <strong>case sensitive</strong> because internally lua interpreter will call <code>luaopen_Modulename</code> function which exported by your c library.</p>
</li>
</ul>
<p>Another note, you should export <code>luaopen_Modulename</code> method  and use <code>extern &quot;C&quot; </code>to modifier all function to make it follow the C standard if you are using c++.</p>
]]></content>
      <categories>
        <category>coding</category>
      </categories>
      <tags>
        <tag>lua</tag>
      </tags>
  </entry>
  <entry>
    <title>c++中的const总结</title>
    <url>/2018/06/27/const-in-cpp/</url>
    <content><![CDATA[<p>最近在看《c++ primer》，里面涉及到很多关于const相关的一些概念，比如顶层const，底层const，const函数重载等，以下是自己的一些总结，作为备忘。</p>
<span id="more"></span>

<h2 id="const变量"><a href="#const变量" class="headerlink" title="const变量"></a>const变量</h2><p>最简单的一个用法，可以用const来定义一个常量，如</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> val=<span class="number">1024</span>;</span><br></pre></td></tr></table></figure>



<p>val是一个常量，定义之后不能被改变。有点类似与使用宏定义，如</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> VAL 1024</span></span><br></pre></td></tr></table></figure>



<p>常量与宏定义的区别在于：</p>
<ul>
<li>宏定义是被预处理器（preprocessor）处理的，预处理器并不知道类型信息，只是将VAL出现过的地方替换为1024</li>
<li>const定义的变量是被编译器（compiler）处理的，编译器理解变量的定义，类型。</li>
</ul>
<h2 id="常量指针与指向常量的指针"><a href="#常量指针与指向常量的指针" class="headerlink" title="常量指针与指向常量的指针"></a>常量指针与指向常量的指针</h2><p>常量指针表示指针本身是一个常量，意味着不能修改该指针。</p>
<p>指向常量的指针表示指针指向的对象是一个常量，该对象不能够被修改。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> j = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> *<span class="keyword">const</span> p = &amp;i;  <span class="comment">//p指针本身是一个常量，不允许改变p的值，顶层const</span></span><br><span class="line"><span class="keyword">int</span> <span class="keyword">const</span> *q = &amp;i;  <span class="comment">//q指针指向的内容是一个常量，不允许改变*q的值，底层const</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> *q = &amp;i;  <span class="comment">//等价与int const *q = &amp;i</span></span><br><span class="line">	</span><br><span class="line">p = &amp;j;  <span class="comment">//报错，编译无法通过</span></span><br><span class="line">*q = <span class="number">2</span>;  <span class="comment">//报错，编译无法通过</span></span><br></pre></td></tr></table></figure>

<p>可以通过“从右往左”的结合方式，来判断是属于常量指针还是指向常量的指针。</p>
<ul>
<li>顶层const（top-level const）: 表示该指针本身就是一个const常量</li>
<li>底层const（low-level const）:表示该指针指向的内容是一个const常量 </li>
</ul>
<p>这里还涉及到左值(lvalue)，右值(rvalue)的概念。</p>
<ul>
<li><strong>左值</strong>：能放在赋值语句的左侧，当一个对象被用作左值，用的是对象的身份（在内存中的位置）</li>
<li><strong>右值</strong>：不能放在赋值语句的左侧，当一个对象被用作右值，用的是对象的值（内容）</li>
</ul>
<h2 id="const修饰函数返回值"><a href="#const修饰函数返回值" class="headerlink" title="const修饰函数返回值"></a>const修饰函数返回值</h2><p>看下面一个例子：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">char</span> *<span class="title">foo</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;hello, world&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">foo()[<span class="number">1</span>] = <span class="string">&#x27;a&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p>编译无问题，但是在运行的时候会报错，因为试图修改字符串字面量导致未定义行为。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">const</span> <span class="keyword">char</span> *<span class="title">foo</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;hello, world&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">foo()[<span class="number">1</span>] = <span class="string">&quot;a&quot;</span>;  <span class="comment">//无法通过编译</span></span><br></pre></td></tr></table></figure>

<p>使用const修饰函数的返回值，可以在编译的时候发现问题。</p>
<h2 id="const修饰函数形参"><a href="#const修饰函数形参" class="headerlink" title="const修饰函数形参"></a>const修饰函数形参</h2><p>先看下面一个例子：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">foo</span><span class="params">(<span class="keyword">int</span> val)</span></span>&#123;</span><br><span class="line">    val = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bar</span><span class="params">(<span class="keyword">int</span> &amp;val)</span></span>&#123;</span><br><span class="line">    val = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> val = <span class="number">0</span>;</span><br><span class="line">foo(val);</span><br><span class="line">bar(val);</span><br></pre></td></tr></table></figure>

<p>我们知道调用foo时，会将实参拷贝一份赋值给形参，在函数内部修改val的值并不会影响外部的val。而调用bar时，由于传递的是引用，所以外部的val会受到影响。这里存在一种情况，就是如果实参是一个很大的数据结构，在参数传递时，希望避免不需要的拷贝，我们可以传递引用。但是传递引用可能会改变实参的值。这个时候可以使用const来修饰参数。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">foo</span><span class="params">(<span class="keyword">const</span> big_type &amp;val)</span></span>&#123;</span><br><span class="line">    <span class="comment">//todo</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用const可以保证传参时不被拷贝，同时不被函数内部修改。</p>
<h2 id="const成员函数"><a href="#const成员函数" class="headerlink" title="const成员函数"></a>const成员函数</h2><p>先看例子：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">foo</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">bar</span><span class="params">()</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> val;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">foo::bar</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ++val;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">foo ifoo;</span><br><span class="line">ifoo.bar();</span><br></pre></td></tr></table></figure>

<p>例子很简单，调用bar之后会将ifoo对象中的val值加1。如果bar函数本身并不想去修改val的值，这可以将其定义为const成员函数。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">...</span><br><span class="line">void bar() const;</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>在const成员函数中，无法对对象的数据成员进行修改。</p>
<h2 id="const函数重载"><a href="#const函数重载" class="headerlink" title="const函数重载"></a>const函数重载</h2><p>函数重载是指函数名称一样，但是函数签名不一样。需要const函数重载的原因是<strong>常量对象无法调用非const成员函数</strong>。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">foo</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">get_val</span><span class="params">()</span></span>&#123; <span class="keyword">return</span> val; &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="keyword">int</span> val = <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">foo f1;</span><br><span class="line">f1.get_val();  <span class="comment">//正确</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> foo f2;</span><br><span class="line">f2.get_val();  <span class="comment">//报错，f2只能调用const成员函数</span></span><br></pre></td></tr></table></figure>

<p>f2无法调用get_val函数，因为f2为常量对象，只能调用const成员函数。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">foo</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">get_val</span><span class="params">()</span></span>&#123; <span class="keyword">return</span> do_get_val(); &#125;</span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">get_val</span><span class="params">()</span> <span class="keyword">const</span></span>&#123; <span class="keyword">return</span> do_get_val(); &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="keyword">int</span> val = <span class="number">0</span>;</span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">do_get_val</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> val; &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>我们再添加一个get_val的const重载函数。注意，这个额外定义了一个do_get_val函数来返回val值，在这个简单的例子中可能显得很多余，但是如果需要做一些比较复杂的操作，单独成一个函数可以防止代码冗余，同时如果以后修改也比较方便。</p>
<h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ul>
<li><a href="http://duramecho.com/ComputerInformation/WhyHowCppConst.html">The C++ ‘const’ Declaration: Why &amp; How</a></li>
<li>《C++ primer》</li>
</ul>
]]></content>
      <categories>
        <category>coding</category>
      </categories>
      <tags>
        <tag>c++</tag>
        <tag>const</tag>
      </tags>
  </entry>
  <entry>
    <title>关于网站改名</title>
    <url>/2020/02/25/change-website-title/</url>
    <content><![CDATA[<p>今天收到通知，被告知网站title和备案不一致，需要更改，于是在未将服务迁出之前，本网站改名为”萝卜头的日志”…</p>
<span id="more"></span>

<img src="/2020/02/25/change-website-title/Big-Brother-1984.jpg" class="">

]]></content>
  </entry>
  <entry>
    <title>WPF中遇到的一个关于RadioButton的数据绑定问题</title>
    <url>/2018/10/11/data-binding-problem-with-radiobutton-in-wpf/</url>
    <content><![CDATA[<p>最近在重构代码的时候遇到一个WPF相关的问题，在使用MVVM pattern时，给WPF RadioButton建立绑定数据源时，理所当然的想到使用boolean类型。但是发生了一个奇怪的现象。废话不多说，直接上sample 代码。</p>
<span id="more"></span>

<h2 id="问题代码"><a href="#问题代码" class="headerlink" title="问题代码"></a>问题代码</h2><p>完整sample代码在<a href="https://github.com/byGeek/WPF_RadioButton/tree/master/src/RadioButtonTest2">github</a>上。</p>
<ul>
<li><p>TestClass.cs</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="built_in">enum</span> RW</span><br><span class="line">&#123;</span><br><span class="line">    Read, Write</span><br><span class="line">&#125;</span><br><span class="line">  </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">TestClass</span></span><br><span class="line">&#123;</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">public</span> RW ReadOrWrite &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>TestViewModel.cs</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">TestViewModel</span> : <span class="title">ViewModelBase</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">readonly</span> TestClass testclass;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">TestViewModel</span>(<span class="params">TestClass tc</span>)</span></span><br><span class="line"><span class="function"></span>        &#123;</span><br><span class="line">            testclass = tc;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="built_in">bool</span> IsRead</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">get</span> &#123; <span class="keyword">return</span> testclass.ReadOrWrite == RW.Read; &#125;</span><br><span class="line">            <span class="keyword">set</span></span><br><span class="line">            &#123;</span><br><span class="line">                testclass.ReadOrWrite = <span class="keyword">value</span> ? RW.Read : RW.Write;</span><br><span class="line">                OnPropertyChanged(<span class="string">&quot;IsRead&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="built_in">bool</span> IsWrite</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">get</span> &#123; <span class="keyword">return</span> testclass.ReadOrWrite == RW.Write; &#125;</span><br><span class="line">            <span class="keyword">set</span></span><br><span class="line">            &#123;</span><br><span class="line">                testclass.ReadOrWrite = <span class="keyword">value</span> ? RW.Write : RW.Read;</span><br><span class="line">                OnPropertyChanged(<span class="string">&quot;IsWrite&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li>
<li><p>TestWindow.xaml</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;StackPanel &gt;</span><br><span class="line">    &lt;RadioButton GroupName&#x3D;&quot;test&quot; Content&#x3D;&quot;read&quot; IsChecked&#x3D;&quot;&#123;Binding IsRead, Mode&#x3D;TwoWay&#125;&quot;&#x2F;&gt;</span><br><span class="line">    &lt;RadioButton GroupName&#x3D;&quot;test&quot; Content&#x3D;&quot;write&quot; IsChecked&#x3D;&quot;&#123;Binding IsWrite, Mode&#x3D;TwoWay&#125;&quot;&#x2F;&gt;</span><br><span class="line">&lt;&#x2F;StackPanel&gt;</span><br></pre></td></tr></table></figure></li>
</ul>
<p>代码很简单，有两个window: MainWindowViewModel, TestWindow。TestWindow有两个RadioButton，分别建立双向绑定TestViewModel中的两个属性。在MainWindow中传递TestViewModel给TestWindow，作为其DataContext。同时在MainWindow有一个button，点击打开TestWindow。当点击button，然后关闭TestWindow，重复几遍，发现TestWindow中的RadioButton 来回<strong>自动</strong>切换状态！</p>
<p>第一次点击：</p>
<ul>
<li><input checked="" disabled="" type="checkbox"> read</li>
<li><input disabled="" type="checkbox"> write</li>
</ul>
<p>第二次点击：</p>
<ul>
<li><input disabled="" type="checkbox"> read</li>
<li><input checked="" disabled="" type="checkbox"> write</li>
</ul>
<p>第三次点击：</p>
<ul>
<li><input disabled="" type="checkbox"> read</li>
<li><input disabled="" type="checkbox"> write</li>
</ul>
<p>第四次点击:</p>
<ul>
<li><input checked="" disabled="" type="checkbox"> read</li>
<li><input disabled="" type="checkbox"> write</li>
</ul>
<p>如此反复…</p>
<h2 id="问题分析"><a href="#问题分析" class="headerlink" title="问题分析"></a>问题分析</h2><p>为什么在“数据源不变”的情况下，RadioButton的状态会变化呢？这是一个很简单的数据绑定而已! 在TestViewModel中属性的getter和setting中打上断点发现：程序会”自动”调用两个属性的setter。在代码中没有直接给属性赋值，所以setter的调用肯定是WPF搞的鬼了。</p>
<p>会不会是因为两个RadioButton属于同一个Group，所以在选择一个的时候，WPF会自动将Group内的置为Uncheck状态？在xaml中去掉GroupName之后，果然没有出现这个问题了。</p>
<p>查看<a href="https://referencesource.microsoft.com/#PresentationFramework/src/Framework/System/Windows/Controls/RadioButton.cs,0582ad78f5047101">Reference code</a>:</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//file RadioButton.cs</span></span><br><span class="line">[<span class="meta">ThreadStatic</span>] <span class="keyword">private</span> <span class="keyword">static</span> Hashtable _groupNameToElements;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">OnChecked</span>(<span class="params">RoutedEventArgs e</span>)</span></span><br><span class="line"><span class="function"></span>        &#123;</span><br><span class="line">            <span class="comment">// If RadioButton is checked we should uncheck the others in the same group</span></span><br><span class="line">            UpdateRadioButtonGroup();</span><br><span class="line">            <span class="keyword">base</span>.OnChecked(e);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">UpdateRadioButtonGroup</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>        &#123;</span><br><span class="line">            <span class="built_in">string</span> groupName = GroupName;</span><br><span class="line">            <span class="keyword">if</span> (!<span class="built_in">string</span>.IsNullOrEmpty(groupName))</span><br><span class="line">            &#123;</span><br><span class="line">                Visual rootScope = KeyboardNavigation.GetVisualRoot(<span class="keyword">this</span>);</span><br><span class="line">                <span class="keyword">if</span> (_groupNameToElements == <span class="literal">null</span>)</span><br><span class="line">                    _groupNameToElements = <span class="keyword">new</span> Hashtable(<span class="number">1</span>);</span><br><span class="line">                <span class="keyword">lock</span> (_groupNameToElements)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="comment">// Get all elements bound to this key and remove this element</span></span><br><span class="line">                    ArrayList elements = (ArrayList)_groupNameToElements[groupName];</span><br><span class="line">                    <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; elements.Count; )</span><br><span class="line">                    &#123;</span><br><span class="line">                        WeakReference weakReference = (WeakReference)elements[i];</span><br><span class="line">                        RadioButton rb = weakReference.Target <span class="keyword">as</span> RadioButton;</span><br><span class="line">                        <span class="keyword">if</span> (rb == <span class="literal">null</span>)</span><br><span class="line">                        &#123;</span><br><span class="line">                            <span class="comment">// Remove dead instances</span></span><br><span class="line">                            elements.RemoveAt(i);</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">else</span></span><br><span class="line">                        &#123;</span><br><span class="line">                            <span class="comment">// Uncheck all checked RadioButtons different from the current one</span></span><br><span class="line">                            <span class="keyword">if</span> (rb != <span class="keyword">this</span> &amp;&amp; (rb.IsChecked == <span class="literal">true</span>) &amp;&amp; rootScope == KeyboardNavigation.GetVisualRoot(rb))</span><br><span class="line">                                rb.UncheckRadioButton();</span><br><span class="line">                            i++;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="comment">// Logical parent should be the group</span></span><br><span class="line">            &#123;</span><br><span class="line">                DependencyObject parent = <span class="keyword">this</span>.Parent;</span><br><span class="line">                <span class="keyword">if</span> (parent != <span class="literal">null</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="comment">// Traverse logical children</span></span><br><span class="line">                    IEnumerable children = LogicalTreeHelper.GetChildren(parent);</span><br><span class="line">                    IEnumerator itor = children.GetEnumerator();</span><br><span class="line">                    <span class="keyword">while</span> (itor.MoveNext())</span><br><span class="line">                    &#123;</span><br><span class="line">                        RadioButton rb = itor.Current <span class="keyword">as</span> RadioButton;</span><br><span class="line">                        <span class="keyword">if</span> (rb != <span class="literal">null</span> &amp;&amp; rb != <span class="keyword">this</span> &amp;&amp; <span class="built_in">string</span>.IsNullOrEmpty(rb.GroupName) &amp;&amp; (rb.IsChecked == <span class="literal">true</span>))</span><br><span class="line">                            rb.UncheckRadioButton();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>

<p>看代码可知，RadioButton内部有一个static变量<code>_groupNameToElements</code>, 用来存储GroupName与RadioButton示例的对应关系。在RadioButton的状态改变时，会调用<code>UpdateRadioButtonGroup</code>函数。</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (rb != <span class="literal">null</span> &amp;&amp; rb != <span class="keyword">this</span> &amp;&amp; <span class="built_in">string</span>.IsNullOrEmpty(rb.GroupName) &amp;&amp; (rb.IsChecked == <span class="literal">true</span>))</span><br><span class="line">                            rb.UncheckRadioButton();</span><br></pre></td></tr></table></figure>

<p>料想应该是这段代码设置RadioButton的状态，然后通过binding调用了属性的setter。在TestWindow ShowDialog前后打断点，查看变量<code>_groupNameToElements</code>. </p>
<p>第一次点击：</p>
<img src="/2018/10/11/data-binding-problem-with-radiobutton-in-wpf/1.1.png" class="">

<img src="/2018/10/11/data-binding-problem-with-radiobutton-in-wpf/1.2.png" class="">

<p>第二次点击：</p>
<img src="/2018/10/11/data-binding-problem-with-radiobutton-in-wpf/2.1.png" class="">

<img src="/2018/10/11/data-binding-problem-with-radiobutton-in-wpf/2.2.png" class="">

<p>第三次点击：</p>
<img src="/2018/10/11/data-binding-problem-with-radiobutton-in-wpf/3.1.png" class="">

<img src="/2018/10/11/data-binding-problem-with-radiobutton-in-wpf/3.2.png" class="">

<p>可以看到由于创建的RadioButton并没有马上被垃圾回收，还是残留在同一个Group中。所以在<code>UpdateRadioButtonGroup</code>函数中迭代<code>elements</code>时，执行</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line">rb.UncheckRadioButton();</span><br></pre></td></tr></table></figure>

<p>同时由于在这几个RadioButton中TestViewModel是共享的(即DataContext为同一个对象)，所以通过setter会改变TestViewModel中的属性。而因为是双向绑定，又反过来作用与RadioButton的IsChecked状态。所以出现了上述的问题。</p>
<h2 id="问题解决"><a href="#问题解决" class="headerlink" title="问题解决"></a>问题解决</h2><p>至此应该很明了了，在RadioButton中使用绑定时，应该留个心眼，如果给每个RadioButton分别绑定一个属性的时候，需要注意这种情况。这种情况在xaml中直接给RadioButton去掉GroupName这个属性即可。我觉得更好的方法应该是使用其他的数据绑定方式。如stackoverflow中的一个问题，使用ListBox来模拟RadioButton.</p>
<p>[<a href="https://stackoverflow.com/questions/1317891/simple-wpf-radiobutton-binding">Simple WPF RadioButton Binding?</a>]</p>
<h2 id="延伸阅读"><a href="#延伸阅读" class="headerlink" title="延伸阅读"></a>延伸阅读</h2><ul>
<li>[<a href="https://stackoverflow.com/questions/20528909/how-is-xaml-interpreted-and-executed-at-runtime">How is XAML interpreted and executed at runtime?</a>]</li>
</ul>
]]></content>
      <categories>
        <category>coding</category>
      </categories>
      <tags>
        <tag>wpf</tag>
      </tags>
  </entry>
  <entry>
    <title>ios 13 beta降级到ios 12.3</title>
    <url>/2019/07/13/downgrade-ios-13-to-ios-12-3/</url>
    <content><![CDATA[<p>今天手贱把手机的IPhone 6s升级到ios public beta3。谁想到发热严重，app时不时闪退，必须重启才有效。不得已要要降级。本文就当自己今天的作死记录做个小记吧。</p>
<span id="more"></span>

<h3 id="起因"><a href="#起因" class="headerlink" title="起因"></a>起因</h3><p>我一直时不想当苹果的小白鼠的。Beta在软件上的含义不言而喻。但是实在是不能忍受在IOS 12.3.1短信拦截失效bug又一次复现！国内的垃圾短信太猖獗，我一直是用的“短信拦截”这个APP来拦截垃圾短信，好像是花了6块钱买的吧。我在IOS上使用的收费软件不多。但是升级到IOS 12.3.1版本之后，短信拦截失效了。我还以为是APP出现了问题，后来下载了另一款“熊猫吃短信”发现也无法拦截垃圾短信。在该APP的描述中才知道是IOS系统的bug导致短信无法拦截。</p>
<p>这个问题以前也出现过，本来拦截正常使用的情况下，在升级某个小版本的正式包之后，出现问题。现在果真BUG OS也越来越坐实了。后来在V2EX论坛上了解到在IOS13以及修正了这个BUG。于是乎，我在使用Itunes备份了数据之后，开启了升级之路。</p>
<h3 id="IOS-13-PB-BETA-2"><a href="#IOS-13-PB-BETA-2" class="headerlink" title="IOS 13 PB BETA 2"></a>IOS 13 PB BETA 2</h3><p>升级IOS 13 公测版2之后，系统发热严重，我想这可能是刚升级完系统，可能是正常现象，可能多重启几次就能“放凉”。没想到一重启之后，打开应用全部闪退。不得不再次重启，才恢复正常。</p>
<p>简单体验了下IOS 13，特别是Apple提到的Dark mode，有点新鲜感。Photos界面也重新设计了。短信界面好像变的更拟物化设计了。短信拦截也恢复正常了。但是发热严重。随便打开哪个APP，一会时间，手机就变的好烫，掉电量惊人。上午9点出门，下午3点就没电了，而且中间还开启了省电模式。</p>
<p>掉电这个还能忍，就是异常发热和APP偶尔闪退忍不了。没办法，只好选择降级。但是，数据咋办？</p>
<h3 id="降级"><a href="#降级" class="headerlink" title="降级"></a>降级</h3><p>降级一般都是要刷机，而刷机一般都是要抹除数据。幸好在油管上找到降级无损数据的方法。谢天谢地，否则折腾到明天也折腾不完了。</p>
<p>油管视频：<a href="https://www.youtube.com/watch?v=Ph5MGBeClv8">How to Downgrade iOS 13 to iOS 12! (Without Losing Data)</a></p>
<p>看视频应该很简单：</p>
<ol>
<li>在<a href="https://ipsw.me/">ipsw.me</a>上下载对应的固件，我是下载的IOS 12.3版本，因为12.3.1有短信无法拦截的版本，索性直接降级到12.3版本。幸好苹果还没有关闭12.3的激活通道。</li>
<li>使用Itunes备份数据。注意请先升级到itunes的最新版本再备份。</li>
<li>恢复数据。在恢复过程中出现一次白苹果。卡在苹果logo，无进度条显示。以为变砖了，在苹果官网找到进recovery方法，但是幸好在插上数据线之后，iTunes提示升级新版本即可。但是就是这个升级操作，导致后面“虚惊一场”！</li>
</ol>
<p>一开始itunes自动升级失败，所以我没在意，直接使用的老版本的itunes做backup，然后再restore的时候itunes提示要升级到最新版才可以restore到12.3。但是在我升级完itunes之后，发现新版的itunes无法找到我的backup记录了！当时感觉心都凉了，数据都没了。后来在查看info.plist文件，在文件结尾有itunes的版本号，怀疑是不是iTunes的版本差异，导致新版的iTunes无法识别使用旧版iTunes backup的文件。所以我在卸载新版itunes，并安装对应的旧版本的时候，终于恢复数据成功。</p>
<p>在卸载新版iTunes的时候，现在微软也慢慢使用Microsoft store作统一的软件分发平台了。新版的itunes就是在MS Store上下载。在卸载的时候没有在control panel中的卸载中找到itunes，后来是直接在windows上搜索iTunes，右键直接uninstall。</p>
<p>安装完旧版本的iTunes时，启动会发现提示一个文件由新版本的iTunes创建，导致无法启动成功。解决方法时直接将该文件删除即可。启动iTunes时，会自动创建该文件。安装成功之后，可以找到先前备份的数据。10G的恢复文件大概花了半个小时才恢复成功。</p>
<h3 id="降级之后"><a href="#降级之后" class="headerlink" title="降级之后"></a>降级之后</h3><p>降级之后，别完了卸载旧的iTunes，重新安装新版iTunes。并且充分备份下数据。最后在iCloud中也备份一份数据。</p>
<p>最重要的是，千万不要再手贱升级啦！</p>
]]></content>
      <categories>
        <category>notes</category>
      </categories>
      <tags>
        <tag>apple</tag>
      </tags>
  </entry>
  <entry>
    <title>配置git使用socks5代理</title>
    <url>/2018/08/08/git-over-proxy/</url>
    <content><![CDATA[<p>最近github网站经常抽风（当然是你懂的的原因），网页上通过配置科学上网之后有所改善。但是在使用git clone时还是经常性失败。在网上找了一波解决方案，发现配置下git代理，很简单，效果立竿见影。</p>
<span id="more"></span>

<p>以下环境为windows 7，console是cmder，直接使用git bash也可以。首先你需要一个代理地址，建议bangwagong自己购买一个云主机，自建服务。本地使用ss做转发。以下<code>127.0.0.1:1080</code>即为本地1080监听地址。</p>
<h2 id="配置HTTP-proxy"><a href="#配置HTTP-proxy" class="headerlink" title="配置HTTP proxy"></a>配置HTTP proxy</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git config --global http.https://github.com.proxy socks5://127.0.0.1:1080</span><br></pre></td></tr></table></figure>

<p>配置之后可以查看下是否成功</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git config --global --get http.https://github.com.proxy</span><br><span class="line">socks5://127.0.0.1:1080</span><br></pre></td></tr></table></figure>

<p>或者在编辑器中查看</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git config --global -e</span><br></pre></td></tr></table></figure>

<img src="/2018/08/08/git-over-proxy/gitconfig.png" class="">



<h2 id="配置SSH-proxy"><a href="#配置SSH-proxy" class="headerlink" title="配置SSH proxy"></a>配置SSH proxy</h2><p>上面配置了http的代理之后，我们使用http/https协议来clone repo的时候已经有效了，但是如果想在ssh也走代理的话，还需要以下配置。</p>
<p>在windows users 用户目录下生成config文件，如在<code>C:\Users\your_user_name\.ssh</code> 目录下，找到config文件，如果没有新建一个，写入如下内容：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Host github.com</span><br><span class="line">ProxyCommand connect -H 127.0.0.1:1080 %h 22</span><br></pre></td></tr></table></figure>



<p>配置完毕之后，在clone一个repo试试，效果拔群啊。</p>
<h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ul>
<li><a href="https://gist.github.com/laispace/666dd7b27e9116faece6">from github</a></li>
</ul>
]]></content>
      <categories>
        <category>tutorial</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title>hexo添加第三方功能支持</title>
    <url>/2018/03/20/hexo-add-more-setting/</url>
    <content><![CDATA[<p>hexo添加第三方插件，可以实现很多功能，如seo优化，生成feed等。</p>
<span id="more"></span>



<h2 id="SEO优化"><a href="#SEO优化" class="headerlink" title="SEO优化"></a>SEO优化</h2><p>seo优化简单的说如何让搜索引擎收录你的网站。参考<a href="https://segmentfault.com/a/1190000009254968">此博文</a>。</p>
<p>需注意一点的是，因为网站未备案的原因，直接使用http无法访问自己的博客。而hexo中自动生成的sitemap都是默认以http来访问，导致提交sitemap到谷歌的时候，会无法抓取。所以我手动修改了一下sitemap的模板文件。</p>
<ul>
<li><p>hexo-generator-sitemap</p>
<p>在<code>node_modules\hexo-generator-sitemap\sitemap.xml</code>中，手动加入<code>https://</code></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">loc</span>&gt;</span>https://&#123;&#123; post.permalink | uriencode &#125;&#125;<span class="tag">&lt;/<span class="name">loc</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
<li><p>hexo-generator-baidu-sitemap</p>
<p>在<code>node_modules\hexo-generator-baidu-sitemap\baidusitemap.ejs</code>中，手动加入<code>https://</code></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">loc</span>&gt;</span>https://&lt;%- encodeURI(url + post.path) %&gt;<span class="tag">&lt;/<span class="name">loc</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="添加feed"><a href="#添加feed" class="headerlink" title="添加feed"></a>添加feed</h2><p>安装feed插件</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm install hexo-generator-feed --save</span><br></pre></td></tr></table></figure>

<p>在站点_config.yml文件中添加</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">feed:</span><br><span class="line">  type: atom</span><br><span class="line">  path: atom.xml</span><br><span class="line">  limit: 20</span><br><span class="line">  hub:</span><br><span class="line">  content: true</span><br><span class="line">  content_limit: 140</span><br><span class="line">  content_limit_delim: &#x27; &#x27;</span><br></pre></td></tr></table></figure>





<h2 id="添加评论系统"><a href="#添加评论系统" class="headerlink" title="添加评论系统"></a>添加评论系统</h2><p>Valine是一款极简的评论系统，基于leancloud。具体参考<a href="https://ioliu.cn/2017/add-valine-comments-to-your-blog/">此博文</a>。</p>
<h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ul>
<li><a href="https://segmentfault.com/a/1190000009254968">SEO</a></li>
<li><a href="https://github.com/hexojs/hexo-generator-feed">Feed github</a></li>
</ul>
]]></content>
      <categories>
        <category>tutorial</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>image test</title>
    <url>/2017/06/10/image-test/</url>
    <content><![CDATA[<p>Update 2018/11/09</p>
<p>由于最近七牛云测试域名回收，图片需要绑定自定义域名，外链才正常。参考<a href="https://developer.qiniu.com/fusion/manual/1367/custom-domain-name-binding-process">绑定加速域名和域名解析流程</a>已经绑定了本站点域名。</p>
<p>使用七牛云作为图床，使用七牛云的图片处理功能，可以对图片进行预处理，使用hexo-qiniu-sync插件可以在_config.yml文件中配置处理默认效果。比如</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">?imageView2&#x2F;0&#x2F;w&#x2F;800&#x2F;q&#x2F;75|watermark&#x2F;2&#x2F;text&#x2F;YnlHZWVr&#x2F;font&#x2F;YXJpYWw&#x3D;&#x2F;fontsize&#x2F;360&#x2F;fill&#x2F;I0ZGRkZGRg&#x3D;&#x3D;&#x2F;dissolve&#x2F;100&#x2F;gravity&#x2F;SouthEast&#x2F;dx&#x2F;10&#x2F;dy&#x2F;10|imageslim</span><br></pre></td></tr></table></figure>

<p>控制图片width=800，等比缩放，加上bygeek水印等。只需在_config.yml文件中配置好默认效果之后，在markdown文件中使用一下标记语法即可对图片加上默认处理效果。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;% qnimg demo.jpg %&#125;</span><br></pre></td></tr></table></figure>

<img src="http://img.bygeek.cn/images/demo.jpg?imageView2/0/w/800/q/75|watermark/2/text/YnlHZWVr/font/YXJpYWw=/fontsize/360/fill/I0ZGRkZGRg==/dissolve/100/gravity/SouthEast/dx/10/dy/10|imageslim">

<span id="more"></span>

<p>如果想显示原图效果，markdown中标记如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;% qnimg demo.jpg normal:yes %&#125;</span><br></pre></td></tr></table></figure>

<p>效果即是原图效果，如下：</p>
<img src="http://img.bygeek.cn/images/demo.jpg">

<p>Hexo-qiniu-sync插件自动扫描_config.yml配置的目录local_dir，在执行<code>hexo s</code>的时候会自动将local_dir目录下的资源上传同步到七牛云。然后在markdown中直接使用图片名称即可。</p>
<p>更多的图片预处理语法请参考<a href="https://developer.qiniu.com/dora/manual/1279/basic-processing-images-imageview2">七牛云图片处理</a>。</p>
<p>关于Hexo-qiniu-sync的配置等请参考<a href="https://github.com/gyk001/hexo-qiniu-sync">官方Github</a>以及<a href="https://juejin.im/post/5a689d93f265da3e283a2fc1">Hexo七牛插件安装与使用</a>。</p>
]]></content>
  </entry>
  <entry>
    <title>大山</title>
    <url>/2021/01/10/in-memory-of-dashan/</url>
    <content><![CDATA[<p>大山是我捡到的一只泰迪。准确的说，是卷子注意到的。</p>
<span id="more"></span>

<h2 id="偶遇"><a href="#偶遇" class="headerlink" title="偶遇"></a>偶遇</h2><p>清明假期，在沿山大道骑车，我在前面，拉开距离后没看到卷子跟上来，回去找的时候她正蹲着注视着蜷在一米一外的狗子。狗子浑身沾满了叶子，明显在外面流浪好几天了，累的都走不动了。看着腿还有点瘸。犹豫了一会，我们把狗子放在自行车篮筐里，取消了接下来的行程，准备去宠物医院给狗子做个检查。</p>
<p>“既然在沿山达到捡到的，就叫他沿山吧”</p>
<p>“沿山太正式， 就叫大山吧”</p>
<h2 id="傻狗"><a href="#傻狗" class="headerlink" title="傻狗"></a>傻狗</h2><p>接大山回家之后，没来得及买狗窝，当时把一件旧衣服铺在框里，刚放下，大山就心领神会的爬上去窝着了。一开始大山与我不熟，天天要赖着卷子，娟子躺沙发，大山必要窝在她腿上。看着它尝试着跳上沙发却不得，眼巴巴的望着你，很难不把它抱在怀里。</p>
<p><img src="/2021/01/10/in-memory-of-dashan/dashan1.JPG"></p>
<p>大山睡觉的时候老是咧着嘴，让人觉得滑稽的很，“这傻狗”，让你忍不住去抱他。狗确实是一个忠实的伙伴，当你取得它的信任之后，它便会无条件的相信你，有你的地方，便可以睡的安详。</p>
<p><img src="/2021/01/10/in-memory-of-dashan/dashan2.JPG"></p>
<p>养狗之后，自己的生活作息也跟着变了。每天至少要遛狗两次，早上一次，晚上一次。早上啥时候出门取决于大山啥时候叫我。哦，对了，忘了说，由于卷子上门早，没时间遛狗，所以我开始照顾大山，大山也和我熟络了起来。大山粘人，晚上睡觉也想在卧室睡，但是我们还是决定让它在狗窝呆着。于是每天早上大山都会不定时的挠门，并可怜的哼唧吸引我们的注意。有的时候半夜三四点被吵醒，开门的一瞬间，它就顺势钻了进来，趴在床下面。我以为它只是要离我们近点，但是等你在床上躺下之后，它出来趴在床沿上跃跃欲试，你这时如果不制止他，它便像是得到了许可一样，一跃上床。</p>
<p><img src="/2021/01/10/in-memory-of-dashan/dashan6.JPG"></p>
<p>“欸呀呀，大山昨天还在小区草丛里钻来钻去的…”</p>
<p>我只得下床，做出怒目圆睁的样子，小声喝斥它，指着狗窝，让它退去。大山也不得趣，只能乖乖回到客厅，脑袋趴在狗窝沿上，用可怜的眼光瞟着我。我得赶紧多睡一会，等待它早上再一次叫我起床。有的时候，大山实在在磨人，我只能当“陪睡”了。</p>
<p><img src="/2021/01/10/in-memory-of-dashan/dashan7.JPG"></p>
<p>每次回家，刚从电梯口出来，就听到大山从次卧飞奔到门口的声音。我家的次卧是靠着连廊的，不知道大山在我们出门的时候，是不是都呆在次卧，以便能第一时间收到我们回家的信号。开门的一瞬间，大山便哇哇的边窜边叫，彷佛在哭诉自己独自在家，无人陪伴的苦水。大山太娇小了，腿又不好，它跳起来才勉强碰到我的膝盖，又被弹回摔到地板上，但是它还是执意再次跳着迎接我回家。我心疼它，顾不上吃晚饭，抱着大山出门遛去了。一出单元楼，大山开心极了，跑跳嗅尿，拽着我往前走。想起刚才的那一幕，也不知道它是想我们了，还是想它的自由了。</p>
<h2 id="冲突"><a href="#冲突" class="headerlink" title="冲突"></a>冲突</h2><p>后来工作渐渐忙了起来，卷子也是，大山晚上的吵闹，有点顶不住了。同时由于大山跟我越来越熟，慢慢对卷子充满了敌意。它要守护我和它的地盘。而这个地盘，卷子是不能插足的。有一次卷子从旁边经过，要拿个东西，大山呸了一声，作势要咬人的样子，把卷子给吓坏了。难道大山已经只认我为主人，却忘记了当时是卷子把它捡回来的么？</p>
<p>不得已，我们考虑将大山送养。开始小区沿街店铺的一个老板表示要收养大山，老板看起来不错，就是可能生意比较忙，担心会没多长时间照顾大山，有点犹豫。后来同小区有个人家也表示的收养的意愿，那人上门来看望大山时，没想到大山很快就跟那边男主人熟悉了起来。我也觉得有些宽慰，大山也算是喜欢那个男主人吧。但是好景不长，那家女主人说有点怕狗，后面又将大山送回来了。后面的事情一波三折，我们送给了那个商铺的老板，有几次远远的在商铺门口经过的时候，看到大山被栓在门口，一动不动，彷佛是等着我接它回家。后面我就不敢从商铺前走过了。</p>
<p>有一次晚上十点多，我听过有只狗子在外面叫了很久。下楼循声而去，果然是大山，它是自己跑到小区里来了，狗绳子被灌木丛给缠住了。当它看到我来救它，彷佛看到了希望一般，拼命想要挣脱绳子的束缚。当晚我把大山抱回家了。后面我就联系老板说自己养了。大山晚上还是太吵了，跟卷子吵了一架，我知道我可能还要继续给大山寻找一个好主人。</p>
<p>大山最后被隔壁的M市的一个妹子抱走了，她开车过来接的大山。大山被接走的时候，我给他接上狗绳，可能它还觉得是陪它出去玩吧，还是很兴奋。走到上车的时候，我把它抱给了那个妹子，它好像知道了什么，明白了过来，着急的叫我。我不敢看它，只希望车窗赶紧摇上去…</p>
<h2 id="后来"><a href="#后来" class="headerlink" title="后来"></a>后来</h2><p>后来有一天，在电梯里遇到一个小女孩。</p>
<p>“你就是住在X楼的吧？”</p>
<p>“是啊”</p>
<p>“上次你家的小狗，还是我给你送回去的哩。那小狗上电梯到了我家门口，一直叫，开门之后它又对着电梯一直叫，闹着要做电梯下去呢，那小狗真聪明。”</p>
<p>“是吗？哈哈，是啊…”</p>
]]></content>
      <tags>
        <tag>notes</tag>
      </tags>
  </entry>
  <entry>
    <title>centos 配置Shadowsocks备忘</title>
    <url>/2018/08/28/install-shadowsocks-on-centos-and-enable-bbr/</url>
    <content><![CDATA[<p>本文作为一个centos配置shadowsocks的备忘。</p>
<span id="more"></span>

<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>一年前买的vps快到期了，临到续费的时候想起来能否开启bbr，试过google cloud之后，开启bbr之前与之后的效果提升了十倍。按照网上的教程操作了一波，在开启bbr的时候，由于centos的glibc版本太低，需要升级，无奈在centos 6上升级不成功。本来是通过KCPTun工具的来加速，对比了bbr的加速效果，觉得开启bbr的效果更开启KCP效果差不多。索性直接将vps的系统重装了一遍。本文是在<strong>centos 7 64位</strong>版本的实验的。</p>
<h2 id="一键安装脚本"><a href="#一键安装脚本" class="headerlink" title="一键安装脚本"></a>一键安装脚本</h2><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><p>使用root登录，运行以下命令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">wget --no-check-certificate -O shadowsocks-all.sh https://raw.githubusercontent.com/teddysun/shadowsocks_install/master/shadowsocks-all.sh</span><br><span class="line">chmod +x shadowsocks-all.sh</span><br><span class="line">./shadowsocks-all.sh 2&gt;&amp;1 | tee shadowsocks-all.log</span><br></pre></td></tr></table></figure>

<p>安装过程会提示输入密码，端口等信息。</p>
<p>安装完毕之后，如果想修改参数，可以使用vim打开配置文件:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">vim /etc/shadowsocks/config.json</span><br></pre></td></tr></table></figure>

<p>会看到刚才的配置信息:</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">&quot;server&quot;</span>:<span class="string">&quot;0.0.0.0&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;server_port&quot;</span>: your_port,</span><br><span class="line">    <span class="attr">&quot;local_port&quot;</span>:<span class="number">1080</span>,</span><br><span class="line">    <span class="attr">&quot;password&quot;</span>:<span class="string">&quot;your_passwd&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;method&quot;</span>:<span class="string">&quot;rc4-md5&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;timeout&quot;</span>:<span class="number">300</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对应修改即可。</p>
<h3 id="卸载"><a href="#卸载" class="headerlink" title="卸载"></a>卸载</h3><p>找到上一步安装的脚本路径：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">./shadowsocks-all.sh uninstall</span><br></pre></td></tr></table></figure>

<h3 id="启动脚本"><a href="#启动脚本" class="headerlink" title="启动脚本"></a>启动脚本</h3><p>启动脚本后面的参数含义，从左至右依次为：启动，停止，重启，查看状态。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">/etc/init.d/shadowsocks start | stop | restart | status</span><br></pre></td></tr></table></figure>



<h2 id="开启bbr"><a href="#开启bbr" class="headerlink" title="开启bbr"></a>开启bbr</h2><p>对于不同虚拟架构的vps，脚本不一样。因此首先需要知道vps是基于什么架构的。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">yum install virt-what</span><br><span class="line">virt-what</span><br></pre></td></tr></table></figure>

<p>如果输出是KVM，则是KVM架构，如果是openvz，则是openvz架构。</p>
<p>去年貌似openvz还不支持开启bbr，正好今天搜到一篇文章，openvz架构的vps也可以开启bbr了。由于我的vps是openvz架构的，所以KVM的未作测试。</p>
<h3 id="KVM"><a href="#KVM" class="headerlink" title="KVM"></a>KVM</h3><p>安装</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">wget --no-check-certificate https://github.com/teddysun/across/raw/master/bbr.sh</span><br><span class="line">chmod +x bbr.sh</span><br><span class="line">./bbr.sh</span><br></pre></td></tr></table></figure>

<p>验证</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">uname -r</span><br><span class="line">sysctl net.ipv4.tcp_available_congestion_control</span><br><span class="line">sysctl net.ipv4.tcp_congestion_control</span><br><span class="line">sysctl net.core.default_qdisc</span><br><span class="line">lsmod | grep bbr</span><br></pre></td></tr></table></figure>

<h3 id="OpenVZ"><a href="#OpenVZ" class="headerlink" title="OpenVZ"></a>OpenVZ</h3><p>安装</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">wget https://raw.githubusercontent.com/kuoruan/shell-scripts/master/ovz-bbr/ovz-bbr-installer.sh </span><br><span class="line">chmod +x ovz-bbr-installer.sh </span><br><span class="line">./ovz-bbr-installer.sh</span><br></pre></td></tr></table></figure>

<p>实测脚本执行完毕，bbr开启成功。如果你的vps是centos 6版本，会出现执行脚本提示glibc版本过低，可以升级glibc版本，但是我升级失败，建议vps安装centos 7版本。</p>
<p>验证方法跟上面一致。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sysctl net.ipv4.tcp_available_congestion_control</span><br></pre></td></tr></table></figure>

<p>返回值一般为：<br>net.ipv4.tcp_available_congestion_control = bbr cubic reno</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sysctl net.ipv4.tcp_congestion_control</span><br></pre></td></tr></table></figure>

<p>返回值一般为：<br>net.ipv4.tcp_congestion_control = bbr</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sysctl net.core.default_qdisc</span><br></pre></td></tr></table></figure>

<p>返回值一般为：<br>net.core.default_qdisc = fq</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">lsmod | grep bbr</span><br></pre></td></tr></table></figure>

<p>返回值有 tcp_bbr 模块即说明bbr已启动。</p>
<h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ul>
<li>[How to determine Linux guest VM virtualization technology](How to determine Linux guest VM virtualization technology)</li>
<li><a href="https://teddysun.com/486.html">Install Shadowsocks</a></li>
<li><a href="https://www.bandwagonhost.net/268.html">Enable Google BBR</a></li>
</ul>
<p>ok</p>
]]></content>
      <categories>
        <category>tutorial</category>
      </categories>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>黑群晖的安装以及设置外网访问</title>
    <url>/2018/03/31/install-synology-on-pc/</url>
    <content><![CDATA[<p>最近把家里闲置的一台笔记本装了群晖，并且利用上次再良心云买的域名，添加了外网访问。此博文为记。</p>
<h2 id="安装群晖"><a href="#安装群晖" class="headerlink" title="安装群晖"></a>安装群晖</h2><p>总体来说用笔记本来安装黑群晖还是比较简单的。具体参考张大妈上的<a href="https://post.smzdm.com/p/377290/">这篇文章</a>。</p>
<p>需要注意的是，本来笔记本是ssd和机械硬盘组的双硬盘，安装好群晖之后，发现只能识别到ssd，无法识别机械硬盘。想着ssd用来做硬盘有点浪费，所以我将笔记本的ssd拆下来，又重新安装了一遍，这才识别了机械硬盘。</p>
<span id="more"></span>



<p>安装完之后出现登录界面还是有点小激动的。</p>
<p><img src="/2018/03/31/install-synology-on-pc/synology_login.png" alt="synology_login"></p>
<h2 id="建立外网访问"><a href="#建立外网访问" class="headerlink" title="建立外网访问"></a>建立外网访问</h2><p>安装完之后，建立外网访问。建立外网访问需要具备几个条件。</p>
<ul>
<li>拥有外网IP，家里办的联通的宽带，是有公网IP的</li>
<li>拥有自有域名，这个可以购买，我是再腾讯云买的域名</li>
<li>DNSPOD账号，免费注册，现在已经被腾讯收购了。腾讯云买的域名默认DNS服务器就是DNSPOD免费服务器。</li>
</ul>
<h3 id="添加DNS解析记录"><a href="#添加DNS解析记录" class="headerlink" title="添加DNS解析记录"></a>添加DNS解析记录</h3><p>登录到DNSPOD，再域名下添加一条解析记录。主机记录填上你想要的二级域名，记录值可以随便填一个IP地址(后面会通过脚本来自动修改该值)</p>
<p><img src="/2018/03/31/install-synology-on-pc/domain.png" alt="domain"></p>
<p>然后需要获取这条记录的ID值，按F12打开浏览器开发者工具，选择记录前面的勾选框，然后再html源码中找到value值，即为这条记录的ID值，后续我们需要通过这个ID值来定期修改IP地址。</p>
<p><img src="/2018/03/31/install-synology-on-pc/find_id.png" alt="find_id"></p>
<h3 id="创建API-Token"><a href="#创建API-Token" class="headerlink" title="创建API Token"></a>创建API Token</h3><p>再DNSPOD左侧面板中选择安全设置，然后创建API Token，得到API Token ID和Token值。</p>
<p><img src="/2018/03/31/install-synology-on-pc/api_token.png" alt="api_token"></p>
<h3 id="建立计划任务"><a href="#建立计划任务" class="headerlink" title="建立计划任务"></a>建立计划任务</h3><p>将安装好群晖的笔记本通过千兆有线连接到路由器中。然后再主控机中打开Synology Assist。查找局域网内的群晖，可以看到DHCP后的IP地址。</p>
<img src="/2018/03/31/install-synology-on-pc/local_ip.png" class="">

<p>打开浏览器输入URL: <code>10.0.0.10:5000</code>，以默认的admin用户登陆。然后再控制面板中找到计划任务。新建计划任务，再用户自定义脚本中填入以下脚本（注意替换），并且设置15分钟执行一次：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">curl -X POST https://dnsapi.cn/Record.Ddns -d <span class="string">&#x27;login_token=ApiToken数字ID,ApiToken密钥&amp;format=json&amp;domain=你的域名&amp;record_id=记录的ID&amp;record_line=默认&amp;sub_domain=域名的前缀</span></span><br></pre></td></tr></table></figure>

<p><img src="/2018/03/31/install-synology-on-pc/task01.png" alt="task01"></p>
<p><img src="/2018/03/31/install-synology-on-pc/task02.png" alt="task02"></p>
<p>这个教程原理就是通过发POST请求给DNSPOD服务器，然后DNSPOD服务器就能知道你的公网地址，同时将得到的公网地址写入到我们新增的域名解析记录中，从而可以动态刷新IP地址。</p>
<p>现在我们先手动执行以下上面的脚本，linux可以直接再终端执行，window再git bash上执行。如果如果返回执行成功，说明已经成功将公网IP推送域名解析中。</p>
<h3 id="设置路由器转发"><a href="#设置路由器转发" class="headerlink" title="设置路由器转发"></a>设置路由器转发</h3><p>手动ping一下域名，看是否能得到你的公网ip。如果可以ping通，那么增加的域名解析记录已经成功。从修改DNS解析记录到该记录同步到DNS服务器，需要一定的同步时间。</p>
<p>再浏览器中登陆群晖，再控制面板中找到外部访问，路由器设置。群晖会启动检测你的路由器型号，并且验证是否具有端口转发的功能。我的路由器是网件的R6400，虽然不在检测中支持的列表里，但是可以兼容。</p>
<p>![set_up_router][set_up_router.png]</p>
<p>勾选要转发的端口，这个可以按需勾选，一般至少打开WEB UI 管理也即5000和5001端口。勾选之后，点击保存，注意这步就覆盖路由器中现有的端口映射规则。点击测试连接。如果配置成功，可以看到测试OK。</p>
<p><img src="/2018/03/31/install-synology-on-pc/test_connection.png" alt="test_connection"></p>
<p>至此，已大功告成。再浏览器中输入域名加端口看看能否访问。没有用过群晖官方的QuickConnect，但是一些朋友使用公网IP来访问之后，都说速度比官方的快不少。通过公网IP在群晖上下载，速度取决于宽带的上行带宽。</p>
<h2 id="安全设置"><a href="#安全设置" class="headerlink" title="安全设置"></a>安全设置</h2><p>由于现在已经将群晖暴露在公网之下，所以采取一定的安全措施必不可少。下面简单说一些安全的方法。</p>
<h3 id="https化"><a href="#https化" class="headerlink" title="https化"></a>https化</h3><p>默认是直接使用5000端口进行访问的，这种方式是直接使用HTTP连接来访问。在现在这个全站HTTPS化的时代，实现HTTPS访问必不可少。</p>
<p>首先去申请SSL证书，有很多的厂商都提供免费的DV SSL证书，如Let’s Encrypt，TrustAsia等。腾讯云与赛门铁克推出了免费的TrustAsia SSL证书。于是自然我去腾讯云申请SSL证书。同一域名下可以免费申请20个DV SSL证书，而且证书签发很快，从申请到审核通过几分钟就好了。</p>
<p><img src="/2018/03/31/install-synology-on-pc/apply_ssl.png" alt="apply_ssl"></p>
<p>审核通过之后，将证书下载下来解压缩。进入到群晖中的控制面板，安全，证书导入。我们使用Apache目录下的证书。如下图：</p>
<p><img src="/2018/03/31/install-synology-on-pc/import_ssl.png" alt="import_ssl"></p>
<p>导入之后</p>
<p><img src="/2018/03/31/install-synology-on-pc/import_success.png" alt="import_success"></p>
<p>然后再浏览器中使用域名打开。可以看到成功https访问。</p>
<p><img src="/2018/03/31/install-synology-on-pc/url.png" alt="url"></p>
<h3 id="关闭SSH连接"><a href="#关闭SSH连接" class="headerlink" title="关闭SSH连接"></a>关闭SSH连接</h3><p>安装好的群晖默认是没有启用SSH连接的。如果你不使用ssh来登陆的话，建议关闭SSH登陆。</p>
<p><img src="/2018/03/31/install-synology-on-pc/disable_ssh.png" alt="disable_ssh"></p>
<h3 id="设置独立用户，admin用户二部验证"><a href="#设置独立用户，admin用户二部验证" class="headerlink" title="设置独立用户，admin用户二部验证"></a>设置独立用户，admin用户二部验证</h3><p>给admin用户加上二步验证。这样如果使用admin用户登陆，需要输入验证码，提升安全性。同时设置用户组，严格管理每个用户的目录访问权限和读写权限。</p>
<p>初玩nas，必然还有很多的东西等我去发掘。nas作为一个私有云盘，可以方便的进行数据备份，数据管理等，希望以后好好利用。</p>
<h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ul>
<li><a href="https://www.chiphell.com/thread-1312291-1-1.html">ssl证书</a></li>
<li><a href="https://post.smzdm.com/p/377290/">nas 安装</a></li>
<li><a href="http://www.nasyun.com/forum.php?mod=viewthread&action=printable&tid=28977">nas外网访问</a></li>
</ul>
]]></content>
      <categories>
        <category>tutorial</category>
      </categories>
      <tags>
        <tag>nas</tag>
      </tags>
  </entry>
  <entry>
    <title>windows 开发遇到的一些权限问题</title>
    <url>/2019/05/15/it-is-all-about-security/</url>
    <content><![CDATA[<p>最近碰到一个问题，折腾了很久。因为troubleshooting的过程中沟通不畅（种种原因暂且不表），导致像个无头苍蝇一样debug。最后发现是个windows权限的问题。好了，直接说问题。</p>
<span id="more"></span>

<h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><p>问题简化为以下代码，是在windows下使用PIPE来进行进程间通信。首先看下server 端代码：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;Windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">message</span> &#123;</span></span><br><span class="line">	<span class="keyword">int</span> id;</span><br><span class="line">	<span class="keyword">char</span> data[<span class="number">8</span>];</span><br><span class="line">&#125; Message;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	HANDLE h = INVALID_HANDLE_VALUE;</span><br><span class="line">	<span class="keyword">const</span> <span class="keyword">char</span>* pipename = <span class="string">&quot;\\\\.\\pipe\\mypipe&quot;</span>;</span><br><span class="line">	<span class="keyword">const</span> <span class="keyword">int</span> BUFSIZE = <span class="number">1024</span>;</span><br><span class="line">	<span class="keyword">const</span> <span class="keyword">int</span> DEFAULT_TIMEOUT = <span class="number">100</span>;</span><br><span class="line">	<span class="keyword">char</span> buf[<span class="number">1024</span>];</span><br><span class="line"></span><br><span class="line">	h = CreateNamedPipe(</span><br><span class="line">		pipename,</span><br><span class="line">		PIPE_ACCESS_DUPLEX,<span class="comment">/*| FILE_FLAG_OVERLAPPED*/</span></span><br><span class="line">		PIPE_TYPE_MESSAGE | PIPE_READMODE_MESSAGE,</span><br><span class="line">		PIPE_UNLIMITED_INSTANCES,</span><br><span class="line">		BUFSIZE,</span><br><span class="line">		BUFSIZE,</span><br><span class="line">		DEFAULT_TIMEOUT,</span><br><span class="line">		<span class="literal">NULL</span></span><br><span class="line">	);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (h == INVALID_HANDLE_VALUE) &#123;</span><br><span class="line">		<span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (ConnectNamedPipe(h, <span class="literal">NULL</span>)) &#123;</span><br><span class="line">		DWORD read = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">if</span> (ReadFile(h, buf, <span class="keyword">sizeof</span>(Message), &amp;read, <span class="literal">NULL</span>)</span><br><span class="line">			&amp;&amp; read == <span class="keyword">sizeof</span>(Message)) &#123;</span><br><span class="line">			Message* msg = <span class="keyword">reinterpret_cast</span>&lt;Message*&gt;(buf);</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;get message from client: id: %d, data: %s\n&quot;</span>, msg-&gt;id, msg-&gt;data);</span><br><span class="line"></span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;ready to echo back!\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">			DWORD written = <span class="number">0</span>;</span><br><span class="line">			<span class="keyword">if</span> (WriteFile(h, msg, <span class="keyword">sizeof</span>(Message), &amp;written, <span class="literal">NULL</span>)</span><br><span class="line">				&amp;&amp; written == <span class="keyword">sizeof</span>(Message)) &#123;</span><br><span class="line">				<span class="built_in">printf</span>(<span class="string">&quot;echo back completed!\n&quot;</span>);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span> &#123;</span><br><span class="line">				<span class="built_in">printf</span>(<span class="string">&quot;WriteFile failed: %d\n&quot;</span>, GetLastError());</span><br><span class="line">				<span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;ReadFile failed: %d\n&quot;</span>, GetLastError());</span><br><span class="line">			<span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;ConnectNamedPipe failed: %d\n&quot;</span>, GetLastError());</span><br><span class="line">		<span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	CloseHandle(h);</span><br><span class="line"></span><br><span class="line">	getchar();</span><br><span class="line">	<span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>代码很简单，使用WIN32 API <code>CreateNamedPipe</code>创建一个命名管道，然后等待pipe client来建立连接。收到client的message之后再echo回去。</p>
<p>再看下client端代码：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">HANDLE h = INVALID_HANDLE_VALUE;</span><br><span class="line">	<span class="keyword">const</span> <span class="keyword">char</span>* pipename = <span class="string">&quot;\\\\.\\pipe\\mypipe&quot;</span>;</span><br><span class="line">	<span class="keyword">const</span> <span class="keyword">int</span> BUFSIZE = <span class="number">1024</span>;</span><br><span class="line">	<span class="keyword">const</span> <span class="keyword">int</span> DEFAULT_TIMEOUT = <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line">	h = CreateFile(pipename,</span><br><span class="line">		GENERIC_READ | GENERIC_WRITE,</span><br><span class="line">		<span class="number">0</span>,</span><br><span class="line">		<span class="literal">NULL</span>,</span><br><span class="line">		OPEN_EXISTING,</span><br><span class="line">		<span class="number">0</span>,</span><br><span class="line">		<span class="literal">NULL</span></span><br><span class="line">	);</span><br><span class="line">	<span class="keyword">if</span> (h == INVALID_HANDLE_VALUE) &#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;open pipe failed: %d\n&quot;</span>, GetLastError());</span><br><span class="line">		<span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	Message m = &#123; <span class="number">1</span>, <span class="string">&quot;hello&quot;</span> &#125;;</span><br><span class="line">	DWORD written = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">if</span> (WriteFile(h, &amp;m, <span class="keyword">sizeof</span>(Message), &amp;written, <span class="literal">NULL</span>)</span><br><span class="line">		&amp;&amp; written == <span class="keyword">sizeof</span>(Message)) &#123;</span><br><span class="line"></span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;client write pipe finished\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">		<span class="keyword">char</span> buf[<span class="number">1024</span>];</span><br><span class="line">		DWORD read = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">if</span> (ReadFile(h, buf, <span class="keyword">sizeof</span>(Message), &amp;read, <span class="literal">NULL</span>)</span><br><span class="line">			&amp;&amp; read == <span class="keyword">sizeof</span>(Message)) &#123;</span><br><span class="line">			Message* msg = <span class="keyword">reinterpret_cast</span>&lt;Message*&gt;(buf);</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;received message: id: %d, data: %s\n&quot;</span>, msg-&gt;id, msg-&gt;data);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;read pipe failed: %d\n&quot;</span>, GetLastError());</span><br><span class="line">			<span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;Write Pipe failed: %d\n&quot;</span>, GetLastError());</span><br><span class="line">		<span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	CloseHandle(h);</span><br><span class="line">	<span class="built_in">exit</span>(<span class="number">0</span>);</span><br></pre></td></tr></table></figure>

<p>client代码也很简单，发起pipe connect，之后发送一个简单的message，然后收到server回复后退出。</p>
<p>但是在实际的生产环境中，发现client端无法连接到server端。根据GetLastError返回值是5，对应的error message是“Access Deny”。那肯定是权限问题嘛。果然，server端是使用Administrator运行的，而client端只有standard user的权限，因为Windows vista中加入的<a href="https://en.wikipedia.org/wiki/Mandatory_Integrity_Control">Mandatory Integrity Control</a>(强制性完整性控制)，导致low integrity level的对象无法modify或者delete high integrity level的对象。</p>
<h3 id="什么是Integrity-Level"><a href="#什么是Integrity-Level" class="headerlink" title="什么是Integrity Level"></a>什么是Integrity Level</h3><p><a href="https://docs.microsoft.com/en-us/previous-versions/dotnet/articles/bb625957(v=msdn.10)">MSDN</a>上如是说：</p>
<blockquote>
<p>The integrity level is a representation of the trustworthiness of running application processes and objects, such as files created by the application. The integrity mechanism provides the ability for resource managers, such as the file system, to use pre-defined policies that block processes of lower integrity, or lower trustworthiness, from reading or modifying objects of higher integrity. The integrity mechanism allows the Windows security model to enforce new access control restrictions that cannot be defined by granting user or group permissions in access control lists (ACLs).</p>
</blockquote>
<p>抛开定义，首先先visualize一下Integrity level。我们使用<a href="https://docs.microsoft.com/en-us/sysinternals/downloads/process-explorer">process explorer</a>工具来查看，如果没有这一栏，可以在View-&gt;Select Columns-&gt;Process Image tab中勾选Integrity level。</p>
<img src="/2019/05/15/it-is-all-about-security/01_show_integrity_level.png" class="">

<p>我们可以看到Integrity level(以下简写为IL)分为几个等级：low, medium, high, system。根据<a href="https://docs.microsoft.com/en-us/windows/desktop/secauthz/mandatory-integrity-control">MSDN</a>:</p>
<blockquote>
<p>Windows defines four integrity levels: low, medium, high, and system. Standard users receive medium, elevated users receive high. Processes you start and objects you create receive your integrity level (medium or high) or low if the executable file’s level is low; system services receive system integrity. Objects that lack an integrity label are treated as medium by the operating system; this prevents low-integrity code from modifying unlabeled objects. Additionally, Windows ensures that processes running with a low integrity level cannot obtain access a process which is associated with an app container.</p>
</blockquote>
<p>标准用户得到meduim IL，这意味着标准用户启动的程序或创建的内核对象都拥有medium IL，除非在程序或对象中指定其为low IL。特权用户得到high IL。系统服务得到system IL。任何其他没有声明IL 标签的，系统默认其为medium IL。windows系统会保证低IL的对象无法读写/访问高IL的对象。</p>
<p>摘录一张《windows via c++》第四章最后一节的图：</p>
<img src="/2019/05/15/it-is-all-about-security/02_integrity_level_example.png" class="">

<blockquote>
<p>When a piece of code tries to access a kernel object, the system compares the integrity level of the<br>calling process with the integrity level associated to the kernel object. If the latter is higher than the<br>former, modify and delete actions are denied. Notice that this comparison is done before checking<br>ACLs. So, even though the process would have the right privileges to access the resource, the fact<br>that it runs with an integrity level lower than the one required by the resource denies the requested<br>access to the object.</p>
</blockquote>
<p>简单来说，就是当访问一个内核对象的时候，系统会比较调用进程的IL和与内核对象关联的IL，如果内核对象关联的IL更高，则无法对其进行修改或者删除操作。一般可以进行读操作。</p>
<p>所以在上面的demo中，由于pipe server使用的是管理员用户运行的，则其创建的PIPE 内核对象拥有high 级别的IL。pipe client 使用标准用户运行，去访问pipe 内核对象时，由于只有medium 级别的IL，所以发生access deny的错误。</p>
<p>除了在进程间访问内核对象提供保护之外，IL还用在windows 的用户界面中，用于防止low IL的进程去修改high IL的界面。我们知道，windows提供了SendMessage和PostMessage来在窗口之间发送消息。窗体可以根据收到的消息来更新UI等。当一个low IL的进程通过SendMessage、PostMessage、SendInput发送消息给high IL的窗体时，系统会屏幕掉这类消息， 这个时候SendInput会返回0，并且GetLastError也不会显示出异常。这种机制称为<strong>User Interface Privilege Isolation</strong>（UIPI）。</p>
<p>这里再多说一句，一些杀毒软件，如360安全卫士会主动拦截SendMessage发出的消息。曾经就遇到过bug排查一天，最后发现是这个问题。</p>
<p>关于详细内容，可以参考《windows via c++》中第四章的内容，中文书名为《windows 核心编程》。</p>
<h3 id="什么是UAC"><a href="#什么是UAC" class="headerlink" title="什么是UAC"></a>什么是UAC</h3><h3 id="什么事ACL"><a href="#什么事ACL" class="headerlink" title="什么事ACL"></a>什么事ACL</h3><h3 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h3><ul>
<li><p><a href="%5Bhttps://docs.microsoft.com/en-us/previous-versions/windows/it-pro/windows-server-2008-R2-and-2008/dd446675(v=ws.10)%5D(https://docs.microsoft.com/en-us/previous-versions/windows/it-pro/windows-server-2008-R2-and-2008/dd446675(v=ws.10))">What’s New in User Account Control</a></p>
</li>
<li><p><a href="https://social.technet.microsoft.com/wiki/contents/articles/2275.windows-security-survival-guide.aspx">Windows Security Survival Guide</a></p>
</li>
<li><p><a href="https://blogs.technet.microsoft.com/yuridiogenes/2011/04/13/exploring-the-windows-security-survival-guide-integrity/">Exploring the Windows Security Survival Guide – Integrity</a></p>
</li>
<li><p><a href="https://docs.microsoft.com/en-us/previous-versions/dotnet/articles/bb625957(v=msdn.10)">What is the Windows Integrity Mechanism?</a></p>
</li>
</ul>
]]></content>
      <categories>
        <category>coding</category>
      </categories>
      <tags>
        <tag>windows</tag>
      </tags>
  </entry>
  <entry>
    <title>lua: os.execute vs os.popen</title>
    <url>/2018/09/13/lua-os-execute-vs-os-popen/</url>
    <content><![CDATA[<p>最近遇到一个lua上问题：在一个c++工程中(进程A)，执行lua脚本，由该脚本去启动一个另外的进程B。在lua脚本执行完毕时，在C++工程中调用<code>lua_close</code>来退出lua环境时，线程stuck在该函数中。</p>
<span id="more"></span>

<h2 id="找到问题"><a href="#找到问题" class="headerlink" title="找到问题"></a>找到问题</h2><p>使用Process Explorer查看C++工程的进程，发现进程B属于进程A的子进程。所以问题很明显了，因为子进程B未退出，所以进程A无法退出，调用<code>lua_close</code>时lua 解析器等待子进程退出，造成stuck问题。</p>
<p>下面来看下lua reference(lua 5.1)中提供的启动外部程序的API</p>
<h2 id="查看API"><a href="#查看API" class="headerlink" title="查看API"></a>查看API</h2><h3 id="os-execute"><a href="#os-execute" class="headerlink" title="os.execute"></a>os.execute</h3><blockquote>
<p>This function is equivalent to the C function <code>system</code>. It passes <code>command</code> to be executed by an operating system shell. It returns a status code, which is system-dependent. If <code>command</code> is absent, then it returns nonzero if a shell is available and zero otherwise.</p>
</blockquote>
<p>os.execute只是将command传递给shell。查看lua源码(lua 5.2)</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">os_execute</span> <span class="params">(lua_State *L)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">char</span> *cmd = luaL_optstring(L, <span class="number">1</span>, <span class="literal">NULL</span>);</span><br><span class="line">  <span class="keyword">int</span> stat = system(cmd);</span><br><span class="line">  <span class="keyword">if</span> (cmd != <span class="literal">NULL</span>)</span><br><span class="line">    <span class="keyword">return</span> luaL_execresult(L, stat);</span><br><span class="line">  <span class="keyword">else</span> &#123;</span><br><span class="line">    lua_pushboolean(L, stat);  <span class="comment">/* true if there is a shell */</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到直接调用的c标准库中的<code>system</code>。</p>
<h3 id="io-popen"><a href="#io-popen" class="headerlink" title="io.popen"></a>io.popen</h3><blockquote>
<p>Starts program <code>prog</code> in a separated process and returns a file handle that you can use to read data from this program (if <code>mode</code> is <code>&quot;r&quot;</code>, the default) or to write data to this program (if <code>mode</code> is <code>&quot;w&quot;</code>).</p>
<p>This function is system dependent and is not available on all platforms.</p>
</blockquote>
<p>看功能说明可以知道，io.popen可以创建一个进程，并可以往该进程的IO读写数据。</p>
<p>io.popen源码如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">io_popen</span> <span class="params">(lua_State *L)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">char</span> *filename = luaL_checkstring(L, <span class="number">1</span>);</span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">char</span> *mode = luaL_optstring(L, <span class="number">2</span>, <span class="string">&quot;r&quot;</span>);</span><br><span class="line">  LStream *p = newprefile(L);</span><br><span class="line">  p-&gt;f = lua_popen(L, filename, mode);</span><br><span class="line">  p-&gt;closef = &amp;io_pclose;</span><br><span class="line">  <span class="keyword">return</span> (p-&gt;f == <span class="literal">NULL</span>) ? luaL_fileresult(L, <span class="number">0</span>, filename) : <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>lua_popen是一个宏定义，最终调用c标准库的popen函数，该函数用来创建一个calling program与command的pipe，说白了就是创建一个子进程。</p>
<h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h2><p>在lua脚本中将启用外部程序的的API由io.popen换成os.execute。</p>
]]></content>
  </entry>
  <entry>
    <title>博客迁移到腾讯云</title>
    <url>/2018/03/19/migration-to-tecent-cvm/</url>
    <content><![CDATA[<p>终于受不了Github的龟速，速度慢就罢了，在联通的宽带下还经常timeout。虽然腾讯云的带宽也就1Mbps，好歹也能跑满，速度稳定在120多kb。于是在周末把博客完全迁移到了腾讯云上。</p>
<span id="more"></span>

<h2 id="流程"><a href="#流程" class="headerlink" title="流程"></a>流程</h2><blockquote>
<p>先明确一下它的运作流程：本地有个 hexo 程序，里面包含了 public 文件夹，sources 文件夹，hexo 将 sources 里的<code>*.md</code>文件渲染为静态的 html 文件放到 public 下，然后我们用git推送到服务器的<code>repository</code>，服务器用<code>git hooks</code>把仓库里的文件同步到网站根目录，而 nginx 的作用就是反向代理。</p>
<ul>
<li>服务器环境：安装git、nginx、创建git用户</li>
<li>本地搭建Hexo环境：安装NodeJs、hexo-cli，生成本地静态网站</li>
<li>使用git自动化部署发布博客</li>
</ul>
</blockquote>
<h2 id="安装git，建立git用户"><a href="#安装git，建立git用户" class="headerlink" title="安装git，建立git用户"></a>安装git，建立git用户</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">yum install git</span><br><span class="line">adduser git</span><br></pre></td></tr></table></figure>

<h2 id="安装nginx"><a href="#安装nginx" class="headerlink" title="安装nginx"></a>安装nginx</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">yum install nginx</span><br><span class="line">systemctl start nginx</span><br><span class="line">systemctl enable nginx.service #设置为开机启动</span><br></pre></td></tr></table></figure>

<p>修改nginx的配置文件：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">vim /etc/nginx/nginx.conf</span><br></pre></td></tr></table></figure>

<p>server模块配置如下（包含https的配置）</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">        listen       80 default_server;</span><br><span class="line">        listen       [::]:80 default_server;</span><br><span class="line">        server_name  your_ip bygeek.cn www.bygeek.cn;</span><br><span class="line">        #root         /usr/share/nginx/html;</span><br><span class="line">        root         /usr/blog/www;</span><br><span class="line">        return 301 https://$host$request_uri;</span><br><span class="line">        # Load configuration files for the default server block.</span><br><span class="line">        include /etc/nginx/default.d/*.conf;</span><br><span class="line"></span><br><span class="line">        location / &#123;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        error_page 404 /404.html;</span><br><span class="line">            location = /40x.html &#123;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        error_page 500 502 503 504 /50x.html;</span><br><span class="line">            location = /50x.html &#123;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> Settings <span class="keyword">for</span> a TLS enabled server.</span></span><br><span class="line"><span class="meta">#</span></span><br><span class="line"><span class="bash">    server &#123;</span></span><br><span class="line">        listen       443 ssl http2 default_server;</span><br><span class="line">        listen       [::]:443 ssl http2 default_server;</span><br><span class="line">        server_name  your_ip www.bygeek.cn bygeek.cn;</span><br><span class="line">        ssl on;</span><br><span class="line">        # root         /usr/blog/www;</span><br><span class="line"></span><br><span class="line">        ssl_certificate &quot;/etc/nginx/ssl_folder/1_bygeek.cn_bundle.crt&quot;;</span><br><span class="line">        ssl_certificate_key &quot;/etc/nginx/ssl_folder/2_bygeek.cn.key&quot;;</span><br><span class="line">        ssl_session_cache shared:SSL:1m;</span><br><span class="line">        ssl_session_timeout  10m;</span><br><span class="line">        ssl_protocols TLSv1 TLSv1.1 TLSv1.2;</span><br><span class="line">        ssl_ciphers ECDHE-RSA-AES128-GCM-SHA256:HIGH:!aNULL:!MD5:!RC4:!DHE;</span><br><span class="line">        ssl_prefer_server_ciphers on;</span><br><span class="line"></span><br><span class="line">        # Load configuration files for the default server block.</span><br><span class="line">        include /etc/nginx/default.d/*.conf;</span><br><span class="line"></span><br><span class="line">        location / &#123;</span><br><span class="line">            root /usr/blog/www;</span><br><span class="line">            index index.html index.htm;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        error_page 404 /404.html;</span><br><span class="line">            location = /40x.html &#123;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        error_page 500 502 503 504 /50x.html;</span><br><span class="line">            location = /50x.html &#123;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>更改权限</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cd /usr/blog</span><br><span class="line">mkdir www</span><br><span class="line">chmod -R 777 /usr/blog/www #更改文件夹及子文件夹权限</span><br></pre></td></tr></table></figure>

<p>将<code>/usr/blog/www</code>作为网站的根目录。</p>
<h2 id="服务器新建仓库"><a href="#服务器新建仓库" class="headerlink" title="服务器新建仓库"></a>服务器新建仓库</h2><p>在服务器上新建裸仓库blog.git.</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">su git</span><br><span class="line">cd ~ #切换到git用户的根目录 /home/git</span><br><span class="line">mkdir blog.git</span><br><span class="line">cd blog.git</span><br><span class="line">git init --bare</span><br></pre></td></tr></table></figure>

<p>利用git hooks，当blog.git收到push之后，自动同步到站点中。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">vim ~/blog.git/hooks/post-receive</span><br></pre></td></tr></table></figure>

<p>写入以下内容：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!/bin/sh</span></span><br><span class="line">git --work-tree=/usr/blog/www --git-dir=/home/git/blog.git checkout -f</span><br></pre></td></tr></table></figure>

<p>赋予可执行权限：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">chmod +x ~/blog.git/hooks/post-receive</span><br></pre></td></tr></table></figure>



<h2 id="设置公钥登录"><a href="#设置公钥登录" class="headerlink" title="设置公钥登录"></a>设置公钥登录</h2><p>在服务器端创建.ssh文件夹记忆authorized_keys文件。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">su git</span><br><span class="line">cd ~</span><br><span class="line">mkdir .ssh &amp;&amp; chmod 700 .ssh</span><br><span class="line">touch .ssh/authorized_keys &amp;&amp; chmod 600 .ssh/authorized_keys</span><br></pre></td></tr></table></figure>

<p>在本地使用puttygen加载你的private key获取public key，复制之后粘贴到authrozied_keys文件中。如果使用的git bash，git bash使用ssh目录在<code>C:\Users\user_name\.ssh</code>中，id_rsa即为私钥文件。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">vim ~/.ssh/authorized_keys</span><br></pre></td></tr></table></figure>

<p>保存之后测试下是否能登录</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ssh git@your_server_ip -p your_ssh_port</span><br></pre></td></tr></table></figure>



<h2 id="本地设置hexo"><a href="#本地设置hexo" class="headerlink" title="本地设置hexo"></a>本地设置hexo</h2><p>由于以前设置过hexo环境，本来博客的源文件是托管在github上的，这次索性将源文件也迁移到腾讯云上。</p>
<p>在git bash中，从服务器clone到本地</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> /d/blog</span><br><span class="line">git <span class="built_in">clone</span> ssh://git@your_server_ip:your_ssh_port/home/git/blog.git</span><br></pre></td></tr></table></figure>

<p>注意：如果你的ssh端口不是默认的22端口，这需要指出ssh的端口号。blog.git 这个repo的地址是在上一步新建的目录。</p>
<p>新建一个hexo分支，用于保存markdown等博客源文件，master分支用于保存渲染好的html页面。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git branch hexo <span class="comment">#新建hexo分支</span></span><br><span class="line">git checkout hexo <span class="comment">#切换到hexo分支</span></span><br><span class="line">git push origin hexo <span class="comment">#push到remote，即remote也新建了一个hexo分支</span></span><br></pre></td></tr></table></figure>

<p>在git bash中</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> /d/blog</span><br><span class="line">npm install hexo -g</span><br><span class="line">mkdir blog_source</span><br><span class="line"><span class="built_in">cd</span> blog_source</span><br><span class="line">hexo init</span><br><span class="line">npm install</span><br><span class="line">npm install hexo-deployer-git</span><br></pre></td></tr></table></figure>

<p>本地的hexo环境搭建完毕，将以前的博客源文件覆盖过来。编辑站点_config.yml，在deploy中修改为腾讯云的repo地址</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">deploy:</span><br><span class="line">  type: git</span><br><span class="line">  repo: ssh:&#x2F;&#x2F;git@ip:port&#x2F;home&#x2F;git&#x2F;blog.git</span><br><span class="line">  branch: master</span><br></pre></td></tr></table></figure>

<p>安装next theme</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git <span class="built_in">clone</span> --branch v5.1.4 https://github.com/iissnan/hexo-theme-next themes/next</span><br></pre></td></tr></table></figure>

<p>将以前next theme的_config.yml文件覆盖。</p>
<p>由于使用了七牛云作为图床，安装七牛云插件</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npm install hexo-qiniu-sync --save</span><br></pre></td></tr></table></figure>

<p>next theme使用了第三方的local search：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npm install hexo-generator-searchdb --save</span><br></pre></td></tr></table></figure>



<p>最后，将文件push到服务器上</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git push origin hexo</span><br></pre></td></tr></table></figure>



<h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ul>
<li><a href="https://cloud.tencent.com/developer/article/1004839">腾讯云的1001种玩法</a></li>
<li><a href="https://git-scm.com/book/en/v2/Git-on-the-Server-Setting-Up-the-Server">git-scm</a></li>
<li><a href="https://blog.fundebug.com/2017/05/18/deploy-hexo-on-cloud/">将Hexo博客部署到云主机</a></li>
</ul>
]]></content>
      <categories>
        <category>tutorial</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>my first blog</title>
    <url>/2017/05/31/my-first-blog/</url>
    <content><![CDATA[<p>终于搞定了一些前几天困扰的问题了，一个是头像无法加载的问题，还有一个是点击所有文章提示模块缺失的问题。</p>
<span id="more"></span>
<p>南京的夜晚，夏日炎炎，即使干坐了，也止不住的流汗。<br>先占个坑，等有时间再详细说下问题怎么解决的吧。</p>
]]></content>
      <categories>
        <category>notes</category>
      </categories>
  </entry>
  <entry>
    <title>my fisrt post</title>
    <url>/2017/05/26/my-fisrt-post/</url>
    <content><![CDATA[<p>this is my first post using hexo</p>
]]></content>
  </entry>
  <entry>
    <title>My reviews about Red dead redemption 2</title>
    <url>/2020/01/30/my-review-on-rdr2/</url>
    <content><![CDATA[<p>前几天把荒野大镖客2通关了，今天专门找了下游戏中的原声带听了一下，很有感触，正好闲在家中，看看记录点东西吧。</p>
<span id="more"></span>

<p>大表哥这个游戏盘买了很久了，记得当时刚发售的时候，看到一些预告和别人试玩的视频片段，心里痒痒。上次去香港的时候本来打算买块盘，看了看新战神还没开坑，就作罢。后来是看到越来越多的报道，说R星七年磨一剑，于是果断买盘（想着以后还可出二手回血）。</p>
<p>其实大表哥这种题材的游戏还是蛮合我的胃口的。我个人更倾向于写实的游戏。比如一战，二战题材，以前玩的英雄连，COD二战等。我对一些比较科幻，武器很fancy的不是特别感冒。就玩法来说，我比较喜欢一本道的游戏，比如战神系列，神海系列，对开放世界比较无感，但是塞尔达荒野之息例外。当我玩完大表哥第一章的时候，还是很震撼的。但是到了第二章的时候，发现游戏节奏有点慢，大部分时间都是在骑马跑路，热情大减，于是弃坑了。</p>
<p>时隔一年，快到春节假期，游戏荒了，趁着周末，拿出大表哥盘，花了两个小时将光盘载入到PS4中。发现战斗系统都生疏了。依旧是骑马跑路，但是随着主线任务的推进，慢慢沉浸到了亚瑟摩根的西部世界中。下面说说在游戏中我印象比较深刻的人。</p>
<h3 id="亚瑟摩根"><a href="#亚瑟摩根" class="headerlink" title="亚瑟摩根"></a>亚瑟摩根</h3><p>亚瑟12岁被Dutch救了之后，跟随Dutch20多年，脏活苦活，出生入死。他对Dutch是很敬仰的，不管现在的情况多么穷困潦倒，坚定的相信Dutch可以work out a plan。中间被奥觉斯科帮派抓住，折磨，也丝毫没有透露出帮派的信息。每次Dutch计划失败，让大家深陷险境时，亚瑟都是去解决问题的那个人， 对Dutch无条件的信任。即使亚瑟最后发现Dutch是个不折不扣的利己主义者，对自己见死不救，还是希望Dutch可以回心转意。最终那一幕，亚瑟，麦卡，Dutch三人对质，此时的亚瑟已是濒死之人，”I did my best, I did”。不知道Dutch听到这些话是什么感受。</p>
<h3 id="沙迪艾德勒"><a href="#沙迪艾德勒" class="headerlink" title="沙迪艾德勒"></a>沙迪艾德勒</h3><p>沙迪是里面我最喜欢的一个女角色了。从被奥觉斯科帮派杀了丈夫，被Dutch就下，一直在皮尔逊的厨房打下手，但是她注定是个gunslinger！跟亚瑟出征，巾帼不让须眉。后期更是带领帮派藏身沼泽地，和亚瑟一起突破平克顿侦探的围剿。她应该是价值观最和亚瑟和的来的吧。有勇有谋，率性爽快。最后和马斯顿上雪山，杀迈卡，中枪之后，马斯顿说， “You are dying”, 沙迪果断说，“No, I ain’t! I ain’t‘”。最后反杀迈卡。沙迪是一个很要强的女性，最后成为一个赏金猎人我觉得是对她来说不失为一个很好的结局。</p>
]]></content>
      <categories>
        <category>notes</category>
      </categories>
      <tags>
        <tag>games</tag>
      </tags>
  </entry>
  <entry>
    <title>我与游戏的故事(一)</title>
    <url>/2019/06/03/my-story-with-video-games/</url>
    <content><![CDATA[<p>买了Play Station已经快两个月了。玩了几款PS4平台的第一方大作之后，是时候来写写自己的感受了。说起买PS4这个经历，其实有点阴差阳错。不过在这之前，我打算先说一下以前我跟游戏的前世今生。</p>
<span id="more"></span>

<h3 id="令人怀念的“小霸王”"><a href="#令人怀念的“小霸王”" class="headerlink" title="令人怀念的“小霸王”"></a>令人怀念的“小霸王”</h3><p>作为一枚90后，我小时候接触到的其实是“小霸王”之类的“学习机”，以前并没有红白机之类的概念。可能是中国特殊的国情所致，特别是一些农村的父母，对游戏可是讳莫如深，想正大光明的买游戏机，那几乎是不可能的事。估计也是这个原因，国内的一些厂商将红白机包装为学习机，正好让我有了买“小霸王”的理由。那个时候基本都对父母说是买来“学电脑的”。也确实，当时随机器附带的卡带都是带五笔打字的，我估计应该有很多人对这个场景有印象：一艘艘小船上面是五笔的偏旁部首，只要敲如相应的键就可以将小船击沉。说实话，当时自己还是花了一些时间在“小霸王”上练习五笔打字的，还背诵了偏旁部首的记忆口诀。只可惜，这些打字诀窍最终只停留在了那个学习机上，等我真正接触到电脑，五笔打字早就忘了一干二净了。</p>
<p>那个时候还是比较痴迷在“小霸王”上的，而且自己还耗费了不少资金在上面。我记得当时一盘“四合一”的卡带要卖8块。那个时候应该大概是2000年左右。要是没记错的话，当时在小学的商店一支雪糕只要5分钱。前前后后应该买了不下20盘卡带。那个时候成绩好，每次基本都是以这个为后盾再加上撒娇，母亲也就顺了我的意。</p>
<p>想起那段时间，真实觉得很美好。小学放学之后，先把作业写完（那个时候作业应该简单吧，记得每次半个小时就写完了）。然后将“小霸王”接上家里的黑白电视机，拿着卡带在嘴边吹下卡带金手指（似乎这样能防止死机），小心翼翼的摁上去，开机！一个简单的游戏能不亦乐乎的玩上很久。当然了，最后肯定是在母亲一遍遍的催促下最后关了机。</p>
<p>除了一个人在家里开黑，最大的乐趣就是和村里的小伙伴一起玩了。当时隔壁院子里的一个小伙伴，暂且称之为玲，经常一起玩。印象最深游戏是“热血系列”中的“热血格斗”。这个游戏并不是类似拳皇之类的格斗游戏，而是每局4个人物，你，队友，还有两位对手。你和队友需要在规定时间内击败对手。每一局都是不同的场景，场景还有不同的辅助道具，例如电网，地雷，瀑布等。最后挑战最终的boss——两个带着虎头的对手。首先这个游戏带有一定的随机性（也可能是当时玩的日文版本，看不明白吧），因为每次无法直接选择游戏人物的“招数”，而是通过为人物选择名字，血型，然后系统会分配一个人物给你。可能人物可以有“连环拳”，或者“连环腿”，或者“地雷滚”。其次“热血格斗”场景比较多，每一局的场景设计都很有意思。比如电网那关，当时经常干的伎俩就是讲击倒后的NPC直接扔到电网里，给其造成二次伤害，而且由于击倒后到再起来，有一定的时间差，把握好这个时间差可以无限扔到电网里。还有地雷那关，故意引诱NPC去踩雷，但有的时候被NPC背摔自己去中雷了，哈哈。游戏里还可以跟队友“合体”放大招，变成旋风。由于看不懂日文，我和玲经常要去试看那个人物最厉害，后来还总结出一个“规律”：O型血比较“欧”。“殴”在我的家乡话里是有点类似撒泼比较厉害的意思。我们都觉得很形象。于是默默都给人物选择O型血。但也不总是能选择有“连环拳”或者“连环腿”的人物。</p>
<p>“热血格斗”卡带是玲的，我没有，于是我经常趁着玲妈不在跟玲一起玩。那个时候基本每个放学的下午，都能在玲的房间里昏天黑地的玩一两个小时。有的时候被玲妈发现我们在房间里背着她玩游戏，我只能尬笑着回家，偷偷约定这明天来我家玩。</p>
<p>学习机我一共买过两台，一台是在一个打着雷的雨天关机之后就无法再开机了。后来仗着自己成绩好，又让我妈给我买了一台新的。这台新的还带了一把“枪”。可以用来玩一个叫“打鸭子”的游戏。只要指着黑白电视机里的鸭子开枪，就可以将其击落。不过终归没有见到支持这种玩法的游戏了，渐渐的这把“枪”也吃灰了。</p>
<h3 id="街机"><a href="#街机" class="headerlink" title="街机"></a>街机</h3><p>我记得这个“学习机”一直没坏，只是后来上中学之后，当时慢慢迷上了街机。虽然经常是一个币都不买，但是却可以站在旁边看别人玩一天。当时比较火的几款游戏是恐龙岛和三国战记。看着别人摇杆拍的左来右去，按键拍的啪啪响，感觉自己也浑身充满了”干劲“。没记错的话，一块钱4个币，对于一些老手来说，可以玩一天了。对于我来说，可能四个币也就撑过一两关吧。输了不续币是要重来的，但即使这样，也乐此不疲。因为街机始终玩的很少。一个是费钱，另外就是家人的反对了。可能是街机厅里环境不是很好，有人经常逃学去玩，而且街机厅在家长的眼里就是游戏厅，好歹小霸王还打个掩护叫学习机呢。我妈很反对我去街机厅。一开始是表哥带我去，有一次被我妈发现了，直接冲到街机厅，把我两拎回来了。”你去玩吧，我看你以后有什么出息。“然后也数落其表哥来，后来表哥再也没带我去了。</p>
<p>我觉得街机当时对我的吸引力主要有三点吧。第一，相比与再黑白电视机上接上小霸王玩，街机的大彩屏简直就是现在的iPhone对于比诺基亚的功能机带来的震撼一样多。第二，街机满足了一定的社交需求。在家还是一个人玩小霸王的时候居多，有的时候我宁愿再与伙伴再通几局魂斗罗或者沙罗曼蛇，也不愿去玩一些角色扮演的”大型游戏“。可能一些角色扮演的游戏剧情多，但是玩游戏嘛还是需要玩伴才玩的开心。街机就不一样的，为什么即使自己不玩也能再游戏厅里呆一天，就是因为有那个氛围在那。投了多少个币，重生多少次之后，终于干倒了别人没干倒的boss，在别人的围观下，next mission！第三点，街机操作的快感。街机加入的摇杆，带来了一种很爽快的体验。那个时候我经常看别人玩，摇杆拍来拍去，特别是玩拳皇这种特别讲究操作的游戏，结合大大的摇杆和大大的按键，更能体验到那种拳拳到肉的感觉，仿佛你按键用多大力气，就能直接传递到游戏人物的打击中一样。</p>
<p>上面我说的小霸王上的”大游戏“，不仅仅是价格比普通的4合1的游戏贵好几倍，而且卡带也要更大。我记得有两个游戏，一个是角色扮演游戏（当然当时我还不知道），游戏开始掉到山洞里，然后4个人物，到后期可以给每个人选择不同的职业，拥有不同的技能。遗憾的是后来在一个地方卡关了，一块巨石挡在了王宫，然后就过不去了。当时还能玲一起尝试，最后我们一致认为是游戏的bug，再后来就不了了之了。直到我买了PS4之后，才知道原来这个游戏叫最终幻想。</p>
<p>还有一个游戏是再我玩了塞尔达荒野之息后（这个游戏真是赞誉再多也不为过），再网上看一些游戏视频，发现了一个FC上的游戏，突然发现我玩过，最后也没通关，原因好像是迷宫太多。这个游戏叫塞尔达！</p>
<p>未完待续！</p>
]]></content>
      <categories>
        <category>notes</category>
      </categories>
      <tags>
        <tag>games</tag>
      </tags>
  </entry>
  <entry>
    <title>关于使用VMware安装ubuntu的几个注意点</title>
    <url>/2018/04/12/notes-about-installing-ubuntu-using-vmware/</url>
    <content><![CDATA[<p>最近打算读读开源项目的源码，正好一年前买的《深入理解Nginx》这本书还一直落灰，就准备读读Nginx的源码吧。在Github下载源码之后，干看代码不好理解，得像个办法Debug啊，于是乎有了用VMware折腾下Ubuntu，学学如何使用GCC和GDB。这就是本文的由来。</p>
<span id="more"></span>

<p>VMware傻瓜式的安装教程就不多说了。不过昨天折腾了一晚上竟然没有安装成功，使用的VMware pro 10.0版本，镜像为Ubuntu Desktop 16.04 LTS版本，一直提示<code>Internal Error</code>。后来换了VMware pro 12.5版本之后顺利安装。</p>
<p>系统安装好之后，安装VMWare tools。VMWare tools可以提供一系列强化功能，比如全屏化，和Host共享文件等。</p>
<p>在VMware菜单中 <code>VM -&gt; Install VMWare tools  </code>。VMware tool文件会挂载到CD-ROM中。将压缩包解压出来，打开Terminal</p>
<p><code>sudo ./vmware-install.pl</code></p>
<p>执行安装脚本即可。安装好之后重启一下。</p>
<h3 id="无法全屏问题"><a href="#无法全屏问题" class="headerlink" title="无法全屏问题"></a>无法全屏问题</h3><p><code>View -&gt; Autosize -&gt; AutoGuest</code>勾选之后，Logout一下即可</p>
<h3 id="共享文件夹"><a href="#共享文件夹" class="headerlink" title="共享文件夹"></a>共享文件夹</h3><p>在VMware中编辑虚拟机配置，在Option-&gt;Shared Folder选择宿主中要共享的文件夹。然后即可再Ubuntu的<code>/mnt/hgfs</code> 路径下看到共享的文件夹。</p>
<h3 id="科学上网问题"><a href="#科学上网问题" class="headerlink" title="科学上网问题"></a>科学上网问题</h3><p>有的时候还是需要再虚拟机中共享宿主的科学上网网络的。我们需要为虚拟机配置一个代理。具体参考<a href="https://www.ctolib.com/topics-114336.html">此文章</a>。</p>
]]></content>
      <categories>
        <category>tutorial</category>
      </categories>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>C++ 11带来的新特性</title>
    <url>/2018/12/04/new-features-in-cpp-11/</url>
    <content><![CDATA[<p>本文转载自Herb Sutter的<a href="https://herbsutter.com/elements-of-modern-c-style/">blog</a>。Herb Sutter是C++标准委员会的主席，他在本文中主要讲述了C++ 11 带来的新的一些feature，同时建议尽量使用Modern C++ style编程。</p>
<p>同时我建议阅读Scott Mayers的《Effective Modern C++》一书。</p>
<p>原文如下。</p>
<span id="more"></span>

<p>The C++11 standard offers <a href="http://www2.research.att.com/~bs/C++0xFAQ.html">many useful new features</a>. This page focuses specifically and only on those features that make C++11 really feel like a new language compared to C++98, because:</p>
<ul>
<li>They change the styles and idioms you’ll use when writing C++ code, often including the way you’ll design C++ libraries. For example, you’ll see more smart pointer parameters and return values, and functions that return big objects by value.</li>
<li>They will be used so pervasively that you’ll probably see them in most code examples. For example, virtually every five-line modern C++ code example will say “auto” somewhere.</li>
</ul>
<p>Use the other great C++11 features too. But get used to these ones first, because these are the pervasive ones that show why C++11 code is clean, safe, and fast – just as clean and safe as code written in any other modern mainstream language, and with C++’s traditional to-the-metal performance as strong as ever.</p>
<p>Notes:</p>
<ul>
<li>Like Strunk &amp; White, this page is deliberately focused on brief summary guidance. It is not intended to provide exhaustive rationale and pro/con analysis; that will go into other articles.</li>
<li>This is a living document. See the end for a list of the main changes and additions over time.</li>
</ul>
<h3 id="auto"><a href="#auto" class="headerlink" title="auto"></a>auto</h3><p>Use auto wherever possible. It is useful for two reasons. First, most obviously it’s a convenience that lets us avoid repeating a type name that we already stated and the compiler already knows.</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// C++98</span></span><br><span class="line"><span class="built_in">map</span>&lt;<span class="keyword">int</span>,<span class="built_in">string</span>&gt;::iterator i = m.begin();</span><br><span class="line"><span class="keyword">double</span> <span class="keyword">const</span> xlimit = config[<span class="string">&quot;xlimit&quot;</span>];</span><br><span class="line">singleton&amp; s = singleton::instance();</span><br><span class="line"> </span><br><span class="line"><span class="comment">// C++11</span></span><br><span class="line"><span class="keyword">auto</span> i = begin(m);</span><br><span class="line"><span class="keyword">auto</span> <span class="keyword">const</span> xlimit = config[<span class="string">&quot;xlimit&quot;</span>];</span><br><span class="line"><span class="keyword">auto</span>&amp; s = singleton::instance();</span><br></pre></td></tr></table></figure>

<p>Second, it’s more than just a convenience when a type has an unknown or unutterable name, such as the type of most lambda functions, that you couldn’t otherwise spell easily or at all.</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// C++98</span></span><br><span class="line">binder2nd&lt; greater &gt; x = bind2nd( greater(), <span class="number">42</span> );</span><br><span class="line"> </span><br><span class="line"><span class="comment">// C++11</span></span><br><span class="line"><span class="keyword">auto</span> x = [](<span class="keyword">int</span> i) &#123; <span class="keyword">return</span> i &gt; <span class="number">42</span>; &#125;;</span><br></pre></td></tr></table></figure>

<p>Note that using auto doesn’t change the code’s meaning. The code is still statically typed, and the type of every expression is already crisp and clear; the language just no longer forces us to redundantly restate the type’s name.</p>
<p>Some people are initially afraid of using auto here, because it may feel like not (re)stating the type we want could mean we’ll get a different type by accident. If you want to explicitly <em>enforce a type conversion</em>, that’s okay; state the target type. The vast majority of the time, however, just use auto; it will rarely be the case that you get a different type by mistake, and even in those cases the language’s strong static typing means the compiler will usually let you know because you’ll be trying to call a member function the variable doesn’t have or otherwise use it as something that it isn’t.</p>
<h3 id="Smart-pointers-No-delete"><a href="#Smart-pointers-No-delete" class="headerlink" title="Smart pointers: No delete"></a>Smart pointers: No delete</h3><p>Always use the standard smart pointers, and non-owning raw pointers. Never use owning raw pointers and delete, except in rare cases when implementing your own low-level data structure (and even then keep that well encapsulated inside a class boundary).</p>
<p>If you know you’re the only owner of another object, use unique_ptr to express unique ownership. A “new T” expression should immediately initialize another object that owns it, typically a unique_ptr. A classic example is the Pimpl Idiom (see <a href="https://herbsutter.com/gotw/_100/">GotW #100</a>):</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// C++11 Pimpl idiom: header file</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">widget</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    widget();</span><br><span class="line">    <span class="comment">// ... (see GotW #100) ...</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">impl</span>;</span></span><br><span class="line">    <span class="built_in">unique_ptr</span>&lt;impl&gt; pimpl;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// implementation file</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">widget</span>:</span>:impl &#123; <span class="comment">/*...*/</span> &#125;;</span><br><span class="line"> </span><br><span class="line">widget::widget() : pimpl&#123; <span class="keyword">new</span> impl&#123; <span class="comment">/*...*/</span> &#125; &#125; &#123; &#125;</span><br><span class="line"><span class="comment">// ...</span></span><br></pre></td></tr></table></figure>

<p>Use shared_ptr to express shared ownership. Prefer to use make_shared to create shared objects efficiently.</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; C++98</span><br><span class="line">widget* pw &#x3D; new widget();</span><br><span class="line">:::</span><br><span class="line">delete pw;</span><br><span class="line"> </span><br><span class="line">&#x2F;&#x2F; C++11</span><br><span class="line">auto pw &#x3D; make_shared&lt;widget&gt;();</span><br></pre></td></tr></table></figure>

<p>Use weak_ptr to break cycles and express optionality (e.g., implementing an object cache).</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// C++11</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">gadget</span>;</span></span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">widget</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">shared_ptr</span>&lt;gadget&gt; g; <span class="comment">// if shared ownership</span></span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">gadget</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    weak_ptr&lt;widget&gt; w;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br></pre></td></tr></table></figure>

<p>If you know another object is going to outlive you and you want to observe it, use a (non-owning) raw pointer.</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// C++11</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">node</span> &#123;</span></span><br><span class="line"> <span class="built_in">vector</span>&lt;<span class="built_in">unique_ptr</span>&lt;node&gt;&gt; children;</span><br><span class="line"> node* parent;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"> :::</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="nullptr"><a href="#nullptr" class="headerlink" title="nullptr"></a>nullptr</h3><p>Always use nullptr for a null pointer value, never the literal 0 or the macro NULL which are ambiguous because they could be either an integer or a pointer.</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// C++98</span></span><br><span class="line"><span class="keyword">int</span>* p = <span class="number">0</span>;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// C++11</span></span><br><span class="line"><span class="keyword">int</span>* p = <span class="literal">nullptr</span>;</span><br></pre></td></tr></table></figure>

<h3 id="Range-for"><a href="#Range-for" class="headerlink" title="Range for"></a>Range for</h3><p>The range-based for loop is a much more convenient way to visit every element of a range in order.</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// C++98</span></span><br><span class="line"><span class="keyword">for</span>( <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::iterator i = v.begin(); i != v.end(); ++i ) &#123;</span><br><span class="line">    total += *i;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// C++11</span></span><br><span class="line"><span class="keyword">for</span>( <span class="keyword">auto</span> d : v ) &#123;</span><br><span class="line">    total += d;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Nonmember-begin-and-end"><a href="#Nonmember-begin-and-end" class="headerlink" title="Nonmember begin and end"></a>Nonmember begin and end</h3><p>Always use nonmember begin(x) and end(x) (not x.begin() and x.end()), because begin(x) and end(x) are extensible and can be adapted to work with all container types – even arrays – not just containers that follow the STL style of providing x.begin() and x.end() member functions.</p>
<p>If you’re using a non-STL collection type that provides iteration but not STL-style x.begin() and x.end(), you can often write your own non-member begin(x) and end(x) overloads for that type and then you can traverse collections of that type using the same coding style above as for STL containers. The standard has set the example: C arrays are such a type, and the standard provides begin and end for arrays.</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v;</span><br><span class="line"><span class="keyword">int</span> a[<span class="number">100</span>];</span><br><span class="line"> </span><br><span class="line"><span class="comment">// C++98</span></span><br><span class="line">sort( v.begin(), v.end() );</span><br><span class="line">sort( &amp;a[<span class="number">0</span>], &amp;a[<span class="number">0</span>] + <span class="keyword">sizeof</span>(a)/<span class="keyword">sizeof</span>(a[<span class="number">0</span>]) );</span><br><span class="line"> </span><br><span class="line"><span class="comment">// C++11</span></span><br><span class="line">sort( begin(v), end(v) );</span><br><span class="line">sort( begin(a), end(a) );</span><br></pre></td></tr></table></figure>

<h3 id="Lambda-Functions-and-Algorithms"><a href="#Lambda-Functions-and-Algorithms" class="headerlink" title="Lambda Functions and Algorithms"></a>Lambda Functions and Algorithms</h3><p>Lambdas are a game-changer and will frequently change the way you write code to make it more elegant and faster. Lambdas make the existing STL algorithms roughly 100x more usable. Newer C++ libraries increasingly are designed assuming lambdas as available (e.g., PPL), and some even require you to write lambdas to use the library at all (e.g., C++ AMP).</p>
<p>Here’s one quick example: Find the first element in v that’s &gt;x and &lt;y. In C+11, the simplest and cleanest code is to use a standard algorithm.</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// C++98: write a naked loop (using std::find_if is impractically difficult)</span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::iterator i = v.begin(); <span class="comment">// because we need to use i later</span></span><br><span class="line"><span class="keyword">for</span>( ; i != v.end(); ++i ) &#123;</span><br><span class="line">    <span class="keyword">if</span>( *i &gt; x &amp;&amp; *i &lt; y ) <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// C++11: use std::find_if</span></span><br><span class="line"><span class="keyword">auto</span> i = find_if( begin(v), end(v), [=](<span class="keyword">int</span> i) &#123; <span class="keyword">return</span> i &gt; x &amp;&amp; i &lt; y; &#125; );</span><br></pre></td></tr></table></figure>

<p>Want a loop or similar language feature that’s not actually in the language? No sweat; just write it as a template function (library algorithm), and thanks to lambdas you can use it with <em>almost</em> the same convenience as if it were a language feature, but with more flexibility because it really is a library and not a hardwired language feature.</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// C#</span></span><br><span class="line">lock( mut_x ) &#123;</span><br><span class="line">    ... use x ...</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// C++11 without lambdas: already nice, and more flexible (e.g., can use timeouts, other options)</span></span><br><span class="line">&#123;</span><br><span class="line">    lock_guard&lt;mutex&gt; hold &#123; mut_x &#125;;</span><br><span class="line">    ... use x ...</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// C++11 with lambdas, and a helper algorithm: C# syntax in C++</span></span><br><span class="line"><span class="comment">// Algorithm: template&lt;typename T&gt; void lock( T&amp; t, F f ) &#123; lock_guard hold(t); f(); &#125;</span></span><br><span class="line">lock( mut_x, [&amp;]&#123;</span><br><span class="line">    ... use x ...</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>Get familiar with lambdas. You’ll use them a lot, and not just in C++ – they are already widely available and pervasively used in several popular mainstream languages. A good place to start is my talk <a href="https://herbsutter.com/2010/10/30/pdc-languages-panel-andshortened-lambdas-talk/">Lambdas, Lambdas Everywhere</a> at PDC 2010.</p>
<h3 id="Move-amp-amp"><a href="#Move-amp-amp" class="headerlink" title="Move / &amp;&amp;"></a>Move / &amp;&amp;</h3><p>Move is best thought of as an optimization of copy, though it also enables other things like perfect forwarding.</p>
<p>Move semantics change the way we design our APIs. We’ll be designing for return by value a lot more often.</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// C++98: alternatives to avoid copying</span></span><br><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;* <span class="title">make_big_vector</span><span class="params">()</span></span>; <span class="comment">// option 1: return by pointer: no copy, but don&#x27;t forget to delete</span></span><br><span class="line">:::</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;* result = make_big_vector();</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">make_big_vector</span><span class="params">( <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; out )</span></span>; <span class="comment">// option 2: pass out by reference: no copy, but caller needs a named object</span></span><br><span class="line">:::</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; result;</span><br><span class="line">make_big_vector( result );</span><br><span class="line"> </span><br><span class="line"><span class="comment">// C++11: move</span></span><br><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">make_big_vector</span><span class="params">()</span></span>; <span class="comment">// usually sufficient for &#x27;callee-allocated out&#x27; situations</span></span><br><span class="line">:::</span><br><span class="line"><span class="keyword">auto</span> result = make_big_vector(); <span class="comment">// guaranteed not to copy the vector</span></span><br></pre></td></tr></table></figure>

<p>Enable move semantics for your type when you can do something more efficient than copy.</p>
<h3 id="Uniform-Initialization-and-Initializer-Lists"><a href="#Uniform-Initialization-and-Initializer-Lists" class="headerlink" title="Uniform Initialization and Initializer Lists"></a>Uniform Initialization and Initializer Lists</h3><p>What hasn’t changed: When initializing a local variable whose type is non-POD or auto, continue using the familiar = syntax without extra { } braces.</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// C++98 or C++11</span></span><br><span class="line"><span class="keyword">int</span> a = <span class="number">42</span>;        <span class="comment">// still fine, as always</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">// C++ 11</span></span><br><span class="line"><span class="keyword">auto</span> x = begin(v); <span class="comment">// no narrowing or non-initialization is possible</span></span><br></pre></td></tr></table></figure>

<p>In other cases, including especially everywhere that you would have used ( ) parentheses when constructing an object, prefer using { } braces instead. Using braces avoids several potential problems: you can’t accidentally get narrowing conversions (e.g., float to int), you won’t occasionally accidentally have uninitialized POD member variables or arrays, and you’ll avoid the occasional C++98 surprise that your code compiles but actually declares a function rather than a variable because of a declaration ambiguity in C++’s grammar – what Scott Meyers famously calls “C++’s most vexing parse.” There’s nothing vexing about the new style.</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// C++98</span></span><br><span class="line"><span class="function">rectangle       <span class="title">w</span><span class="params">( origin(), extents() )</span></span>;   <span class="comment">// oops, declares a function, if origin and extents are types</span></span><br><span class="line"><span class="function"><span class="built_in">complex</span>&lt;<span class="keyword">double</span>&gt; <span class="title">c</span><span class="params">( <span class="number">2.71828</span>, <span class="number">3.14159</span> )</span></span>;</span><br><span class="line"><span class="keyword">int</span>             a[] = &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span> &#125;;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;     v;</span><br><span class="line"><span class="keyword">for</span>( <span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">4</span>; ++i ) v.push_back(i);</span><br><span class="line"> </span><br><span class="line"><span class="comment">// C++11</span></span><br><span class="line">rectangle       w   &#123; origin(), extents() &#125;;</span><br><span class="line"><span class="built_in">complex</span>&lt;<span class="keyword">double</span>&gt; c   &#123; <span class="number">2.71828</span>, <span class="number">3.14159</span> &#125;;</span><br><span class="line"><span class="keyword">int</span>             a[] &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span> &#125;;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;     v   &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span> &#125;;</span><br></pre></td></tr></table></figure>

<p>The new { } syntax works pretty much everywhere:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// C++98</span></span><br><span class="line">X::X( <span class="comment">/*...*/</span> ) : mem1(init1), mem2(init2, init3) &#123; <span class="comment">/*...*/</span> &#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// C++11</span></span><br><span class="line">X::X( <span class="comment">/*...*/</span> ) : mem1&#123;init1&#125;, mem2&#123;init2, init3&#125; &#123; <span class="comment">/*...*/</span> &#125;</span><br></pre></td></tr></table></figure>

<p>Finally, sometimes it’s just convenient to pass function arguments without a type-named temporary:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">draw_rect</span><span class="params">( rectangle )</span></span>;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// C++98</span></span><br><span class="line">draw_rect( rectangle( myobj.origin, selection.extents ) );</span><br><span class="line"> </span><br><span class="line"><span class="comment">// C++11</span></span><br><span class="line">draw_rect( &#123; myobj.origin, selection.extents &#125; );</span><br></pre></td></tr></table></figure>

<p>The only place where I prefer not to write the braces is on simple initialization of a non-POD variable, like <em>auto x = begin(v);</em> , where it would make the code needlessly ugly because I know it’s a class type, so I know I don’t need to worry about accidental narrowing conversions, and modern compilers already routinely perform the optimization to elide the extra copy (or the extra move, if the type is move-enabled).</p>
<h3 id="And-More"><a href="#And-More" class="headerlink" title="And More"></a>And More</h3><p>There’s more to modern C++. <a href="http://www2.research.att.com/~bs/C++0xFAQ.html">Much more.</a> And in the future I plan to write more in-depth pieces about these and other features of C++11 we’ll get to know and love.</p>
<p>But for now, this is the list of must-know features. These features form the core that defines modern C++ style, that make C++ code look and perform the way it does, that you’ll see used pervasively in nearly every piece of modern code you’ll see or write… and that make modern C++ the clean, and safe, and fast language that our industry will continue relying on heavily for years to come.</p>
<h3 id="Major-Change-History"><a href="#Major-Change-History" class="headerlink" title="Major Change History"></a>Major Change History</h3><p>2011-10-30: Added C# lock example to lambdas. Reordered smart pointers to introduce unique_ptr first.</p>
<p>2011-11-01: Added uniform initialization.</p>
]]></content>
      <categories>
        <category>coding</category>
        <category>repost</category>
      </categories>
      <tags>
        <tag>c++</tag>
      </tags>
  </entry>
  <entry>
    <title>onion architecture</title>
    <url>/2018/02/24/onion-architecture/</url>
    <content><![CDATA[<p>传统的三层架构中数据位于最核心的地方，而洋葱模型将一些UI，DB这些最可能经常要变化的东西放在外圈，同时外圈的layer依赖于里圈的东西。</p>
<span id="more"></span>

<h2 id="传统的三层架构"><a href="#传统的三层架构" class="headerlink" title="传统的三层架构"></a>传统的三层架构</h2><p>一层只能调用下一层，不能跨层调用，比如UI只能调用Business Logic 层.</p>
<img src="/2018/02/24/onion-architecture/traditional_layered_architecture.png" class="">



<h2 id="洋葱架构"><a href="#洋葱架构" class="headerlink" title="洋葱架构"></a>洋葱架构</h2><p>外圈的层可以调用内圈的层</p>
<img src="/2018/02/24/onion-architecture/onion_architecture.png" class="">

<h2 id="洋葱架构要点"><a href="#洋葱架构要点" class="headerlink" title="洋葱架构要点"></a>洋葱架构要点</h2><ul>
<li>The application is built around an independent object model</li>
<li>Inner layers define interfaces.  Outer layers implement interfaces</li>
<li>Direction of coupling is toward the center</li>
<li>All application core code can be compiled and run separate from infrastructure</li>
</ul>
<p>本文摘录<a href="http://jeffreypalermo.com/blog/the-onion-architecture-part-1/">地址</a></p>
]]></content>
      <categories>
        <category>coding</category>
      </categories>
      <tags>
        <tag>architecture</tag>
        <tag>software</tag>
      </tags>
  </entry>
  <entry>
    <title>操作系统基本概念</title>
    <url>/2018/05/25/operating-system-101/</url>
    <content><![CDATA[<p>作为一名非科班程序员，经常在碰到一些操作系统相关的概念时蒙逼。特别是看前段时间看nginx源码的时候，涉及到一些I/O多路复用的代码。碰到问题，碰到不懂的名词，去网上搜索，也就能了解个大概，一些系统性的东西还是很有必要去系统性的学习。于是购入了一本《操作系统：精髓与设计原理》，打算好好读一遍。至于为什么没有买传说中的龙书(深入理解计算机系统)。。。主要是当时不知道有龙书，买完才发现大多数都推崇龙书。</p>
<p>本文姑且作为学习《操作系统》这本书的学习大纲吧。下面先按着书的章节列一下大纲。以后分别出各个主题的博文。坚持！</p>
<span id="more"></span>

<h2 id="Operating-System-lesson-101"><a href="#Operating-System-lesson-101" class="headerlink" title="Operating System lesson 101"></a>Operating System lesson 101</h2><ul>
<li>操作系统概述<ul>
<li>什么是操作系统，作用是什么</li>
<li>基本组成</li>
<li>总线周期，指令周期</li>
</ul>
</li>
<li>进程<ul>
<li>什么是进程</li>
<li>在操作系统中如何表示进程</li>
<li>线程，进程区别</li>
</ul>
</li>
<li>并发<ul>
<li>互斥(Mutex)</li>
<li>信号量(Semaphone)</li>
<li>管程(Monitor)</li>
<li>管道(Pipes)</li>
<li>自旋锁与互斥锁，busy-waiting与sleep-waiting</li>
<li>原子操作</li>
<li>在c#中同步相关的API</li>
<li>死锁与饥饿</li>
</ul>
</li>
<li>内存管理<ul>
<li>为什么要分页，分段</li>
<li>实存(main memory/primary memory)</li>
<li>虚拟内存的设计原因等</li>
</ul>
</li>
<li>I/O管理<ul>
<li>同步I/O</li>
<li>异步I/O</li>
<li>LINUX下I/O多路复用</li>
</ul>
</li>
<li>文件系统</li>
</ul>
]]></content>
      <categories>
        <category>learning</category>
      </categories>
      <tags>
        <tag>operating system</tag>
      </tags>
  </entry>
  <entry>
    <title>使用Fiddler抓包遇到的几个问题</title>
    <url>/2018/04/16/package-filter-in-fiddler/</url>
    <content><![CDATA[<p>Fiddler是一款免费好用的web debugging工具，可用于网络抓包。下面简单介绍Fiddler再抓包过程中的过滤功能。</p>
<span id="more"></span>

<p>Fiddler支持解析HTTPS请求，不过首先需要再Fiddler设置，设置之后会自动安装Fiddler的根证书。</p>
<img src="/2018/04/16/package-filter-in-fiddler/decrypt_https_traffic.png" class="">

<p>在Filter页面，勾选<code>Use Filters</code>，对filter进行一定的配置，然后点击右上角的<code>Actions</code></p>
<img src="/2018/04/16/package-filter-in-fiddler/run_filter.png" class="">

<p>即可以按你配置的规则进行包过滤。</p>
<p>在使用过滤时，自己也踩了不少坑。想当然的以为这个功能不是“显而易见”嘛，然后就发现，咦，我的包哪去了？？下面简单说下遇到的“坑”。</p>
<h3 id="坑1：以为可以自动匹配三级域名"><a href="#坑1：以为可以自动匹配三级域名" class="headerlink" title="坑1：以为可以自动匹配三级域名"></a>坑1：以为可以自动匹配三级域名</h3><p>例如，如果你想只抓取instapaper.com站点的数据，需要在host下填入：<code>www.instapaper.com</code>，而不是直接填写<code>instapaper.com</code>。在不使用通配符的情况下，Fiddler默认是使用完全匹配的规则来进行过滤的，也就是说在host为<code>instapaper.com</code>的过滤条件下，是无法在结果中显示<code>www.instapaper.com</code>的数据包的。</p>
<p>对于这种情况，可以使用通配符来匹配Host名称，如<code>*.instapaper.com;*instapaper.com</code>。</p>
<h3 id="坑2：以为Chrome的Task-Manager中的Process-ID作为过滤条件"><a href="#坑2：以为Chrome的Task-Manager中的Process-ID作为过滤条件" class="headerlink" title="坑2：以为Chrome的Task Manager中的Process ID作为过滤条件"></a>坑2：以为Chrome的Task Manager中的Process ID作为过滤条件</h3><p>在Fiddler中过滤页面中，可以通过Process ID作为过滤条件，如下图：</p>
<img src="/2018/04/16/package-filter-in-fiddler/process_id.png" class="">

<p>在Chrome中的Task Manager中可以看到Tab的进程ID的，如下图：</p>
<img src="/2018/04/16/package-filter-in-fiddler/chrome_task_manager.png" class="">

<p>但是注意了（手动划重点！）：如果想要在Fiddler中使用Client Process ID作为chrome的Tab的数据包的过滤条件的话，<strong>这个process ID并不是在task manager中的Tab的process ID，而是Chrome 浏览器的Process ID，即在上图中<code>Browser</code>的Process ID。</strong></p>
<img src="/2018/04/16/package-filter-in-fiddler/fiddler_process_id_filter.png" class="">



<h3 id="打开TroubleShooting"><a href="#打开TroubleShooting" class="headerlink" title="打开TroubleShooting"></a>打开TroubleShooting</h3><p>如果发现在使用Fiddler的过滤时，无法正确的Filter到想要的包，可以在打开Fiddler的TroubleShooting，查看包时被什么过滤条件给“无视”了。</p>
<img src="/2018/04/16/package-filter-in-fiddler/help_troubleshooting.png" class="">

<p>勾选之后，Fiddler会将所有的包都已“被划掉”的形式显示出来，并在<code>Comments</code>一栏显示被”无视”的原因。</p>
<img src="/2018/04/16/package-filter-in-fiddler/troubleshooting_comments.png" class="">



<p>Happy Fiddlering!</p>
]]></content>
      <categories>
        <category>tutorial</category>
      </categories>
      <tags>
        <tag>fiddler</tag>
      </tags>
  </entry>
  <entry>
    <title>有关与最近的生活</title>
    <url>/2018/04/10/recent-review-2018-4/</url>
    <content><![CDATA[<p>一个月前，自己立了好多flag。这一个月以来，为了不打自己脸，行动了起来。</p>
<ol>
<li><p>关于博客。</p>
<p>现在坚持一个礼拜出两篇博客。目前为止，坚持的还算好。需要继续坚持。</p>
</li>
<li><p>关于跑步。</p>
<p>鉴于夏天是胖子的死期，没办法，最近开始夜跑了。准备隔一天跑个5公里。不过今天偷懒了。要坚持。</p>
</li>
<li><p>关于办理护照。</p>
<p>上周去办理了居住证，办理下来需要一段时间，这个先等等吧。</p>
</li>
<li><p>关于阅读。</p>
<p>一个月前买了两本书，一本《货币金融学》，一本《GEB》。也许是货币金融学太教科书了，当然这本书本身就是作为经济学教材，搬家之后没看了。可以挑选一些敢兴趣的章节看下。《GEB》上周末看了一点。要坚持。</p>
</li>
<li><p>关于工作。</p>
<p>最近工作比以前忙了起来，但是却不是我要的状态。关于在今年准备搞一搞开源项目，目前的打算是与博客中的技术分享结合起来，充实github。还有一点就是看一些优质的开源项目代码。前端时间看了一下MvvmLight的源码，不过就代码量来说，这个项目还算是少的。今天准备开始看Nginx的源码。要坚持。</p>
</li>
</ol>
<p>2018/04/10 于家中</p>
]]></content>
      <categories>
        <category>notes</category>
      </categories>
  </entry>
  <entry>
    <title>VMware虚拟机中设置网络代理</title>
    <url>/2018/10/24/set-network-proxy-in-vmware-virtual-machine/</url>
    <content><![CDATA[<p>本文是为vmware中安装的ubuntu设置代理的备忘。</p>
<span id="more"></span>

<h2 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h2><ul>
<li><p>在宿主机中安装好shadowsocks，并允许局域网连接。</p>
<img src="/2018/10/24/set-network-proxy-in-vmware-virtual-machine/shadowsocks_setting.png" class=""></li>
<li><p>在vmware中设置虚拟机的网络为NAT模式，这时虚拟机对外来说共享宿主的IP地址，对内于宿主是属于局域网</p>
<img src="/2018/10/24/set-network-proxy-in-vmware-virtual-machine/vmware_setting.png" class=""></li>
<li><p>在ubuntu中，system settings-&gt;network -&gt; network proxy 中勾选Manual（手动）,地址全部填宿主机IP（局域网网段），设置好代理端口（可在windows下的shadowsocks查看，一般为默认1080）</p>
<img src="/2018/10/24/set-network-proxy-in-vmware-virtual-machine/ubuntu_setting.png" class=""></li>
<li><p>访问下不可知的网站试试。</p>
</li>
</ul>
]]></content>
      <categories>
        <category>tutorial</category>
      </categories>
      <tags>
        <tag>shadowsocks</tag>
        <tag>vmware</tag>
      </tags>
  </entry>
  <entry>
    <title>关于正则表达式的简单总结</title>
    <url>/2018/12/18/personal-summary-on-regular-expression/</url>
    <content><![CDATA[<p>本文记录一下正则表达式的一些语法和常见用法。以备后查。</p>
<p>在线regex测试网站推荐<a href="https://regex101.com/">regex101</a>。</p>
<p>有关regex的资料推荐: </p>
<ul>
<li><a href="https://www.regular-expressions.info/quickstart.html">regular-expressions.info</a></li>
<li><a href="http://www.runoob.com/regexp/regexp-metachar.html">runoob.com</a></li>
</ul>
<span id="more"></span>

<h2 id="基础概念语法"><a href="#基础概念语法" class="headerlink" title="基础概念语法"></a>基础概念语法</h2><h3 id="Text-patterns-and-Matches"><a href="#Text-patterns-and-Matches" class="headerlink" title="Text patterns and Matches"></a>Text patterns and Matches</h3><p>pattern表示一个规则。在本文中将正则表达式的Text pattern使用<code>/</code>包裹起来。如<code>/cat/</code></p>
<h3 id="Literal-Characters"><a href="#Literal-Characters" class="headerlink" title="Literal Characters"></a>Literal Characters</h3><p>字面量字符，最普通的一种情况。比如<code>/cat/</code>, 输入字符串<code>he catch a catfish for his cat.</code> 在字符串的第4个位置找到匹配。</p>
<p>如果想继续匹配。则需要设置为全局模式。<code>/cat/g</code>，则会对输入字符串进行全局搜索。</p>
<p>在正则表达式中有12个字符有着特殊的含义，分别是：</p>
<blockquote>
<p>the backslash <code>\</code>, the caret <code>^</code>, the dollar sign <code>$</code>, the period or dot <code>.</code>, the vertical bar or pipe symbol <code>|</code>, the question mark <code>?</code>, the asterisk or star <code>*</code>, the plus sign <code>+</code>, the opening parenthesis <code>(</code>, the closing parenthesis <code>)</code>, the opening square bracket <code>[</code>, and the opening curly brace <code>&#123;</code></p>
</blockquote>
<p>它们也叫做<code>metacharacters</code>。这些字符如果想被当成普通字符使用，需要使用<code>\</code>进行转译。如如果你想匹配<code>1+1=2</code>，你需要的Text pattern是<code>/1\+1=2/</code></p>
<h3 id="Character-Classes-or-Character-Sets"><a href="#Character-Classes-or-Character-Sets" class="headerlink" title="Character Classes or Character Sets"></a>Character Classes or Character Sets</h3><p>Character Class 只能在几个字符中匹配到其中一个。比如<code>/gr[ae]y/</code>可以匹配<code>gray</code>, <code>grey</code>, 但不能匹配<code>graey</code>。可以使用hyphen（连字符-）来表示一个候选范围，如<code>/[0-9]/</code>可匹配一个数字。<code>/[a-zA-Z]/</code>可用来匹配<code>bH</code>, <code>cD</code>等。也可以单字符和连字符一起使用，如<code>/[x0-9]/</code>用来匹配字符<code>x</code>或<code>0-9</code>的数字。</p>
<p>在方括号里使用<code>^</code>用来表示取否。如<code>/[^abc]/</code>可匹配非a非b非c的字符，<code>/[^ ]/</code>可匹配非空格（blank space）的字符。</p>
<h3 id="Shorthand-Character-Classes"><a href="#Shorthand-Character-Classes" class="headerlink" title="Shorthand Character Classes"></a>Shorthand Character Classes</h3><p>正则表达式提供了一些更简便的方式（Shorthand）来匹配一些常用的字符串。注意，这些shorthand具体包含的字符跟不同的regex flavour有关。不同的flavour可能还有其他的一些shorthand。这里讲一些通用的shorhand放在下表中。</p>
<table>
<thead>
<tr>
<th>Shorthand</th>
<th>Equals</th>
<th>Match</th>
</tr>
</thead>
<tbody><tr>
<td>\d</td>
<td>[0-9]</td>
<td>digit: 0-9的数字</td>
</tr>
<tr>
<td>\w</td>
<td>[a-zA-Z0-9_]</td>
<td>Word character: 用于组成单词的字符，下划线和数字</td>
</tr>
<tr>
<td>\s</td>
<td>[ \t\r\n\f]</td>
<td>Whitespace ：空格，tab，换行符, form feed</td>
</tr>
</tbody></table>
<p>Shorthand也可以有shorthand。一般用大写字母来表示取否。</p>
<table>
<thead>
<tr>
<th>Negated Shorthand</th>
<th>Equals</th>
</tr>
</thead>
<tbody><tr>
<td>\D</td>
<td>[^\d]</td>
</tr>
<tr>
<td>\W</td>
<td>[^\w]</td>
</tr>
<tr>
<td>\S</td>
<td>[^\s]</td>
</tr>
</tbody></table>
<p>在中括号中使用Negated Shorthand需要注意。如<code>[\D\S]</code>与<code>[^\d\s]</code>表达的含义不一样。<code>[^\d\s]</code>用来匹配即不是White space又不是数字的字符，而<code>[\D\S]</code>两个条件（\D或\S）满足一个即可匹配，换句话说，<code>[\D\S]</code>可以匹配数字，whitespace或者其他字符。这里面涉及的是逻辑上与或非关系。</p>
<p>可以在<a href="https://regex101.com/">regex101</a>上进行在线测试每个shorthand代表的简写。</p>
<img src="/2018/12/18/personal-summary-on-regular-expression/regex101.png" class="">

<h3 id="Non-Printable-Characters"><a href="#Non-Printable-Characters" class="headerlink" title="Non-Printable Characters"></a>Non-Printable Characters</h3><p>在正则表达式中可以使用特殊字符来匹配不可打印字符。</p>
<table>
<thead>
<tr>
<th>pattern</th>
<th>match</th>
<th>pattern</th>
<th>match</th>
</tr>
</thead>
<tbody><tr>
<td>\t</td>
<td>tab字符（ASCII 0x09）</td>
<td>\r</td>
<td>carriage return(0x0D)</td>
</tr>
<tr>
<td>\n</td>
<td>line feed(0x0A)</td>
<td>\f</td>
<td>form feed(0x0C)</td>
</tr>
</tbody></table>
<p>需要注意的是，在windows上使用<code>\r\n</code>来用作line break, 而unix上是<code>\n</code>.</p>
<h3 id="The-Dot-matches-Almost-any-character"><a href="#The-Dot-matches-Almost-any-character" class="headerlink" title="The Dot matches (Almost) any character"></a>The Dot matches (Almost) any character</h3><p><code>.</code>可以匹配除了line break之外的所有字符。如<code>/gr.y/</code>可以匹配<code>gray</code>, <code>grey</code>, <code>/gr%y</code>. 谨慎的使用dot 字符。因为使用Character class匹配的速度回更快也更精确.</p>
<h3 id="Anchors"><a href="#Anchors" class="headerlink" title="Anchors"></a>Anchors</h3><blockquote>
<p>Anchors do not match any characters. They match a position.</p>
</blockquote>
<p>Anchors（锚）用来匹配一个位置。<code>^</code>用于匹配输入字符串的开始位置，<code>$</code>用于匹配输入字符串的结束位置。在<code>multi-line</code>模式下，<code>^</code>用来匹配每一行的开始位置，<code>$</code>用来匹配每一行的结束位置。如<code>/^a/</code>可以匹配<code>abc</code>中的a，但是再<code>bca</code>中找不到匹配。</p>
<p><code>\b</code>用来匹配word boundary。</p>
<blockquote>
<p>A word boundary is a position between a character that can be matched by <code>\w</code> and a character that cannot be matched by <code>\w</code></p>
</blockquote>
<p><code>\B</code>正好相反，用来匹配<code>\b</code>无法匹配的地方。</p>
<p>更多的内容相关请参考: <a href="https://www.regular-expressions.info/anchors.html">Learn more about anchors</a>.</p>
<h3 id="Alternation"><a href="#Alternation" class="headerlink" title="Alternation"></a>Alternation</h3><p>Alternation相当于正则表达式中的”或”。如<code>/cat|dog/</code>匹配<code>cat and dogs</code>中的<code>cat</code>,如果再次匹配（如使用global模式），才会再次匹配到<code>dog</code>.</p>
<p>Alternation在正则表达式中的操作符中优先级最低。如<code>cat|dog food</code>可以用来匹配<code>cat</code>或者<code>dog food</code>。如果想要匹配<code>cat food</code>或者<code>dog food</code>，需要使用捕获组<code>(cat|dog)food</code>.</p>
<h3 id="Repetition"><a href="#Repetition" class="headerlink" title="Repetition"></a>Repetition</h3><ul>
<li><p>quantifier <code>?</code>用来使得前面的token最多可以出现一次（0次或一次）。如<code>colou?r</code>匹配<code>colour</code>或<code>color</code> .</p>
</li>
<li><p>quantifier <code>*</code>用来使得前面的token出现0次，一次，或多次。</p>
</li>
<li><p>quentifier <code>+</code>用来使得前面的token至少出现一次（一次或多次）。</p>
</li>
<li><p>使用大括号<code>&#123;&#125;</code>用来表示前面的token出现特定次数。如<code>/\b[1-9][0-9]&#123;3&#125;\b/</code>匹配<code>1000-9999</code>的数字.</p>
</li>
</ul>
<p><code>/\b[1-9][0-9]&#123;2,4&#125;\b/</code>匹配100-9999.</p>
<h3 id="Greedy-and-Lazy-Repetition"><a href="#Greedy-and-Lazy-Repetition" class="headerlink" title="Greedy and Lazy Repetition"></a>Greedy and Lazy Repetition</h3><p>Repetition的匹配符都是“贪婪”的，他们会尽可能多的匹配，返回尽可能长的匹配字符串。如<code>/&lt;.+&gt;/</code>在输入字符串为<code>This is a &lt;EM&gt;first&lt;/EM&gt; test</code>中返回的匹配字符串为<code>&lt;EM&gt;first&lt;/EM&gt;</code>。</p>
<p>在<code>+</code>之后使用<code>?</code>使得匹配变为lazy. 使用<code>/&lt;.+?&gt;/</code>来匹配上面的字符串，则返回的是<code>&lt;EM&gt;</code>.</p>
<p>更好的方式是使用dot 运算符。</p>
<blockquote>
<p>Use <code>&lt;[^&lt;&gt;]+&gt;</code> to quickly match an HTML tag without regard to attributes. The negated character class is more specific than the dot, which helps the regex engine find matches quickly.</p>
</blockquote>
<h3 id="Grouping-and-Capturing"><a href="#Grouping-and-Capturing" class="headerlink" title="Grouping and Capturing"></a>Grouping and Capturing</h3><p>使用<code>()</code>来对多个字符进行分组，可以使用repetition运算符来修饰分组。如<code>/set(value)?/ 可以匹配</code>set<code>或</code>setvalue`.</p>
<p>使用小括号分组即创建了一个捕获组。上面的例子有一个分组，如果匹配set，则group1什么都没有，如果匹配setvalue，则group1是<code>value</code>。group0总是整个匹配的字符串。至于如何访问group，这个跟你使用的编程语言有关。</p>
<p>创建捕获组之后，可以使用backreference来引用捕获组。backreference即使用backslash和group number来表示捕获组的内容。</p>
<p>如<code>/([abc])=\1/</code>可以匹配<code>a=a</code>,或<code>b=b</code>，或<code>c=c</code></p>
<p>如果你只想分组不想创建捕获组可以使用<code>(？:)?</code>。如上面的例子，<code>set(?:value)?</code>, 这样只会创建分组，但不会创建捕获组。这样做的目的可以使得正则表达式匹配更快，性能更高。</p>
]]></content>
      <categories>
        <category>coding</category>
      </categories>
      <tags>
        <tag>regex</tag>
      </tags>
  </entry>
  <entry>
    <title>c#中使用RegisterNotification来接收特定GUID的设备消息</title>
    <url>/2018/04/20/register-notification-using-device-interface-guid/</url>
    <content><![CDATA[<p>在WIN32 API中提供了一个<a href="https://msdn.microsoft.com/en-us/library/windows/desktop/aa363431%28v=vs.85%29.aspx">RegisterNotification</a>函数来接收系统发过来的message。本文介绍一下在csharp中调用该接口来监听特定GUID的设备消息。</p>
<span id="more"></span>

<p>在MSDN中，RegisterDeviceNotification的原型为</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">HDEVNOTIFY WINAPI <span class="title">RegisterDeviceNotification</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">  _In_ HANDLE hRecipient,</span></span></span><br><span class="line"><span class="function"><span class="params">  _In_ LPVOID NotificationFilter,</span></span></span><br><span class="line"><span class="function"><span class="params">  _In_ DWORD  Flags</span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>;</span><br></pre></td></tr></table></figure>

<p>其中NotificationFilter起到消息过滤的作用，也就是说如果我们只想收到特定的消息，可以传递特定的NotificationFilter参数。</p>
<blockquote>
<p><em>NotificationFilter</em> [in]</p>
<p>A pointer to a block of data that specifies the type of device for which notifications should be sent. This block always begins with the <a href="https://msdn.microsoft.com/en-us/library/windows/desktop/aa363246%28v=vs.85%29.aspx"><strong>DEV_BROADCAST_HDR</strong></a> structure. The data following this header is dependent on the value of the <strong>dbch_devicetype</strong> member, which can be <strong>DBT_DEVTYP_DEVICEINTERFACE</strong> or <strong>DBT_DEVTYP_HANDLE</strong>. For more information, see Remarks.</p>
</blockquote>
<p>需要注意的是，对于PORT设备，arrival和removal消息会自动广播给顶层窗口。所以如果你的设备不是PORT设备，又想收到arrival和removal消息，需要手动注册消息监听。</p>
<blockquote>
<p>The <a href="https://msdn.microsoft.com/en-us/library/windows/desktop/aa363205%28v=vs.85%29.aspx">DBT_DEVICEARRIVAL</a> and <a href="https://msdn.microsoft.com/en-us/library/windows/desktop/aa363208%28v=vs.85%29.aspx">DBT_DEVICEREMOVECOMPLETE</a> events are automatically broadcast to all top-level windows for port devices. Therefore, it is not necessary to call <strong>RegisterDeviceNotification</strong> for ports, and the function fails if the <strong>dbch_devicetype</strong>member is <strong>DBT_DEVTYP_PORT</strong>. Volume notifications are also broadcast to top-level windows, so the function fails if <strong>dbch_devicetype</strong>is <strong>DBT_DEVTYP_VOLUME</strong>. OEM-defined devices are not used directly by the system, so the function fails if <strong>dbch_devicetype</strong> is <strong>DBT_DEVTYP_OEM</strong>.</p>
</blockquote>
<p>关于设备类型，猜测这个应该跟设备的驱动有关，在设备驱动中会指明设备的类型，然后在设备插入到系统中，会有一个枚举过程，这样系统就知道了该设备类型。上述的DBT_DEVICEARRIVAL和DBT_DEVICEREMOVECOMPLETE是<a href="https://msdn.microsoft.com/en-us/library/windows/desktop/aa363480%28v=vs.85%29.aspx">WM_DEVICECHANGE</a>消息中的参数。</p>
<p>如果设备类型为<a href="https://msdn.microsoft.com/en-us/library/windows/desktop/aa363244%28v=vs.85%29.aspx"><strong>DBT_DEVTYP_DEVICEINTERFACE</strong> </a>，查看MSDN可知，该结构体中有一个guid的参数，正是我们需要的通过GUID来判断是否是特定设备的参数。我们在接受windows消息的函数中，判断是否是需要监测的设备即可。</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">ProcessWinMessage</span>(<span class="params"><span class="built_in">int</span> msg, IntPtr wParam, IntPtr lParam</span>)</span></span><br><span class="line"><span class="function"></span>        &#123;</span><br><span class="line">            <span class="keyword">if</span> (msg == Native.WM_DEVICECHANGE)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">switch</span> (wParam.ToInt32())</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">case</span> (<span class="built_in">int</span>)Native.WM_DEVICECHANGE_WPPARAMS.DBT_DEVICEARRIVAL:</span><br><span class="line"></span><br><span class="line">                        <span class="keyword">if</span> (IsDesiredDevice(lParam))</span><br><span class="line">                        &#123;</span><br><span class="line">                            <span class="keyword">if</span> (StateChanged != <span class="literal">null</span>)</span><br><span class="line">                            &#123;</span><br><span class="line">                                StateChanged(<span class="literal">true</span>);</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line"></span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">case</span> (<span class="built_in">int</span>)Native.WM_DEVICECHANGE_WPPARAMS.DBT_DEVICEREMOVECOMPLETE:</span><br><span class="line"></span><br><span class="line">                        <span class="keyword">if</span> (IsDesiredDevice(lParam))</span><br><span class="line">                        &#123;</span><br><span class="line">                            <span class="keyword">if</span> (StateChanged != <span class="literal">null</span>)</span><br><span class="line">                            &#123;</span><br><span class="line">                                StateChanged(<span class="literal">false</span>);</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    <span class="comment">/*</span></span><br><span class="line"><span class="comment">                     * this event will be fired when device been added and removed</span></span><br><span class="line"><span class="comment">                case Native.DBT_DEVNODES_CHANGED:</span></span><br><span class="line"><span class="comment">                        </span></span><br><span class="line"><span class="comment">                    if (StateChanged != null)</span></span><br><span class="line"><span class="comment">                    &#123;</span></span><br><span class="line"><span class="comment">                        StateChanged(false);</span></span><br><span class="line"><span class="comment">                    &#125;</span></span><br><span class="line"><span class="comment">                    break;</span></span><br><span class="line"><span class="comment">                     * */</span></span><br><span class="line">                    <span class="literal">default</span>:</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>

<p><code>IsDesignedDevice</code>定义如下</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="built_in">bool</span> <span class="title">IsDesiredDevice</span>(<span class="params">IntPtr lParam</span>)</span></span><br><span class="line"><span class="function"></span>        &#123;</span><br><span class="line">            <span class="keyword">var</span> hdr = (Native.DEV_BROADCAST_HDR)Marshal.PtrToStructure(lParam, <span class="keyword">typeof</span>(Native.DEV_BROADCAST_HDR));</span><br><span class="line">            <span class="keyword">if</span> (hdr.dbcc_devicetype == (uint)_deviceType)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (_deviceType == Native.DeviceType.DBT_DEVTYP_DEVICEINTERFACE)</span><br><span class="line">                &#123;</span><br><span class="line">                    Native.DEV_BROADCAST_DEVICEINTERFACE deviceInterface =</span><br><span class="line">                        (Native.DEV_BROADCAST_DEVICEINTERFACE)Marshal.PtrToStructure(lParam, <span class="keyword">typeof</span>(Native.DEV_BROADCAST_DEVICEINTERFACE));</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">var</span> str = Encoding.Default.GetString(deviceInterface.dbcc_classguid);</span><br><span class="line">                    <span class="keyword">var</span> guid = <span class="keyword">new</span> Guid(deviceInterface.dbcc_classguid);</span><br><span class="line">                    <span class="keyword">if</span> (guid.ToString() == DEVICE_INTERFACE_GUID)</span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="comment">//<span class="doctag">TODO:</span> other device type</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>

<p><a href="https://msdn.microsoft.com/en-us/library/windows/desktop/aa363246%28v=vs.85%29.aspx">DEV_BROADCAST_HDR</a>结构体中的三个字段包含在所有设备类型结构体中，所以可以先将WM_DEVICECHANGE中的lParam转化为DEV_BROADCAST_HDR类型，然后根据其<code>dbch_devicetype</code>来转化为特定设备类型结构体类型，如<code>DBT_DEVTYP_DEVICEINTERFACE</code>。</p>
<p>完整的例子请参考：<a href="https://github.com/byGeek/UsbDetector">UsbDetector</a></p>
]]></content>
      <categories>
        <category>coding</category>
      </categories>
      <tags>
        <tag>csharp</tag>
      </tags>
  </entry>
  <entry>
    <title>搭建nginx调试环境</title>
    <url>/2018/04/18/set-up-debugging-envirronment-about-nginx/</url>
    <content><![CDATA[<p>本文简单记录一下搭建nginx源码调试环境的过程。</p>
<span id="more"></span>

<h2 id="Windows"><a href="#Windows" class="headerlink" title="Windows"></a>Windows</h2><p>在windows下使用宇宙最强IDE进行调试，可谓事半功倍。但是nginx的源码并没有提供visual studio的solution工程文件，所幸在github上找到了一个repo，别人已经将其他一些messup的东西都给你搞好了，直接F5就能run起来，简单省事。</p>
<p>Repo地址:  <a href="https://github.com/tumtumtum/nginx-visualstudio">https://github.com/tumtumtum/nginx-visualstudio</a></p>
<h2 id="Linux"><a href="#Linux" class="headerlink" title="Linux"></a>Linux</h2><p>好在微软发布了一个跨平台的VS Code，在linux下可以使用它作为集成开发环境。下面以ubuntu为例。</p>
<h3 id="安装VS-Code"><a href="#安装VS-Code" class="headerlink" title="安装VS Code"></a>安装VS Code</h3><p>在官网下载vs code deb包，安装好，再安装C/C++插件</p>
<h3 id="安装GCC-GDB"><a href="#安装GCC-GDB" class="headerlink" title="安装GCC/GDB"></a>安装GCC/GDB</h3><p>安装GCC编辑器和GDB调试器，我使用的ubuntu desktop 16.04版本自带这些，所以就没有额外安装，如果系统没有带，需要额外安装。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo apt install build-essential -y</span><br></pre></td></tr></table></figure>

<h3 id="下载Nginx源码与依赖库"><a href="#下载Nginx源码与依赖库" class="headerlink" title="下载Nginx源码与依赖库"></a>下载Nginx源码与依赖库</h3><p>使用git 将repo clone下来。如果没有安装git，需要先安装git。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> ~</span><br><span class="line">git <span class="built_in">clone</span> https://github.com/nginx/nginx.git</span><br></pre></td></tr></table></figure>

<p>注意，如果你是在虚拟机使用git，记得使用https方式，而不是ssh方式来下载代码。因为你可能没有为虚拟机生成公钥。</p>
<blockquote>
<p>NGINX depends on 3 libraries: <a href="http://www.pcre.org/">PCRE</a>, <a href="https://www.zlib.net/">zlib</a> and <a href="https://www.openssl.org/">OpenSSL</a>:</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># PCRE version 4.4 - 8.40</span></span><br><span class="line">wget https://ftp.pcre.org/pub/pcre/pcre-8.40.tar.gz &amp;&amp; tar xzvf pcre-8.40.tar.gz</span><br><span class="line"></span><br><span class="line"><span class="comment"># zlib version 1.1.3 - 1.2.11</span></span><br><span class="line">wget http://www.zlib.net/zlib-1.2.11.tar.gz &amp;&amp; tar xzvf zlib-1.2.11.tar.gz</span><br><span class="line"></span><br><span class="line"><span class="comment"># OpenSSL version 1.0.2 - 1.1.0</span></span><br><span class="line">wget https://www.openssl.org/<span class="built_in">source</span>/openssl-1.1.0f.tar.gz &amp;&amp; tar xzvf openssl-1.1.0f.tar.gz</span><br></pre></td></tr></table></figure>

<h3 id="编译源码"><a href="#编译源码" class="headerlink" title="编译源码"></a>编译源码</h3><p>执行configure shell脚本，编译代码。注意，configure脚本在 <code>auto</code>目录下，我们需要拷贝到代码根目录</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> nginx</span><br><span class="line">cp auto/configure configure</span><br><span class="line">./configure --with-pcre=<span class="string">&quot;./pcre-8.40&quot;</span>	\</span><br><span class="line">	    --with-zlib=<span class="string">&quot;./zlib-1.2.11&quot;</span>	\</span><br><span class="line">	    --with-openssl=<span class="string">&quot;./openssl-1.1.0f&quot;</span>	\</span><br><span class="line">	    --with-debug</span><br></pre></td></tr></table></figure>

<p>上述configure指出的参数为依赖库的目录地址。</p>
<p>执行成功之后在根目录生成obj目录和Makefile。正式进行编译。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">make -f Makefile</span><br></pre></td></tr></table></figure>

<h3 id="使用VS-Code进行debug"><a href="#使用VS-Code进行debug" class="headerlink" title="使用VS Code进行debug"></a>使用VS Code进行debug</h3><p>使用VS Code 打开nginx 代码根目录，F5开始调试，如果是第一次进行调试，会打开launch.json文件。修改可执行程序目录。</p>
<img src="/2018/04/18/set-up-debugging-envirronment-about-nginx/launch_json.png" class="">

<p>打上断点即可开始调试，效果如下图。</p>
<img src="/2018/04/18/set-up-debugging-envirronment-about-nginx/vs_code_debug_nginx.png" class="">



<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>由于自己以前没哟在linux下的开发经验，导致搭建调试环境的时候遇到了一些问题。比如makefile是怎么一回事等等。希望自己能好好看看nginx的源码，打算在接下来的博文中出一个nginx源码解读系列。</p>
<h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><p><a href="https://www.vultr.com/docs/how-to-compile-nginx-from-source-on-ubuntu-16-04">Debug Nginx source code</a></p>
]]></content>
      <categories>
        <category>coding</category>
        <category>nginx</category>
      </categories>
      <tags>
        <tag>nginx</tag>
      </tags>
  </entry>
  <entry>
    <title>spy++简单教程</title>
    <url>/2018/04/05/simple-spy-tutorial/</url>
    <content><![CDATA[<p>Spy++是一款随着Visual studio自带的工具，可以用来分析windows上的应用程序的windows 消息。Windows上的GUI程序都是靠windows message来响应用户，来与用户交互。</p>
<p>Spy++有两个版本，32bit版本(spyxx.exe)和64bit版本(spyxx_amd64.exe)，分别用来spy对应bit的进程。所以如果你在使用spy++的时候发现无法收到消息，可以试着使用另外版本。</p>
<span id="more"></span>

<p>在这里同时推荐一款windows小而美的软件：<a href="http://www.listary.com/"><strong>Listary</strong></a>。双击left control两次即可呼出检索框。</p>
<img src="/2018/04/05/simple-spy-tutorial/listary.png" class="">

<p>在这里以spyxx 32bit版本为例。启动spyxx.exe。</p>
<img src="/2018/04/05/simple-spy-tutorial/spy++_startup.png" class="">

<p>Spy++可以查看window，Process和Thread的状态。以查看Window为例。contrl + F呼出Find window窗口。然后用鼠标拖拽中间的圆形标志到你要spy的windows上，即可在window tree上找到。然后右键message可以看到该窗体的消息。</p>
<img src="/2018/04/05/simple-spy-tutorial/window_message.png" class="" title="all message">

<p>默认是会将该window收到的所有的消息都显示在spy++界面中，可以通过filter只显示你想要显示的消息。点击菜单栏中的<code>Logging Option</code>按钮。勾选需要监听的window message，比如Mouse message</p>
<img src="/2018/04/05/simple-spy-tutorial/window_message_option.png" class="">

<img src="/2018/04/05/simple-spy-tutorial/window_message_filter.png" class="" title="mouse message">

<p>Window message的种类可以参考MSDN：<a href="https://msdn.microsoft.com/en-us/library/windows/desktop/ms644927%28v=vs.85%29.aspx#types">Message Types</a>。</p>
]]></content>
      <categories>
        <category>tutorial</category>
      </categories>
      <tags>
        <tag>windows</tag>
      </tags>
  </entry>
  <entry>
    <title>Dependency walker的简单介绍</title>
    <url>/2018/07/05/simple-user-guide-to-dependency-walker/</url>
    <content><![CDATA[<p>在c++中可以使用LoadLibrary来动态加载dll，最近遇到了一个跟发布有关的问题。在自己的电脑上运行没问题，但是在客户机上却LoadLibrary失败，返回126的错误。使用Dependency walker分析之后，发现是要动态加载的类库依赖另外一个类库，客户机找不到该类库，所以失败。下面简单介绍一下Dependency walker的使用方法。</p>
<p>Dependency walker是一个可以用来查看windows上可执行文件依赖库的工具。可以用来分析库的装载相关的错误。</p>
<blockquote>
<p>Dependency Walker is a free utility that scans any 32-bit or 64-bit Windows module (exe, dll, ocx, sys, etc.) and builds a hierarchical tree diagram of all dependent modules. For each module found, it lists all the functions that are exported by that module, and which of those functions are actually being called by other modules. Another view displays the minimum set of required files, along with detailed information about each file including a full path to the file, base address, version numbers, machine type, debug information, and more. </p>
</blockquote>
<span id="more"></span>

<p>Dependency walker主界面如下：</p>
<img src="/2018/07/05/simple-user-guide-to-dependency-walker/dp.png" class="">

<p>通过File-&gt;open来加载一个module，module可以是dll，exe文件。左侧是加载的module的依赖的dll列表，显示了树状的依赖层级。可以在菜单栏中选择显示绝对路径。</p>
<p>右边上方是在左侧选中的dll中，实际上被父模块调用的函数。在该示例图中，表示fmaud_mn.dll中调用了MSVCR110.DLL中的_onexit, _unlock等等函数。其中左侧的PI列图例介绍如下：</p>
<img src="/2018/07/05/simple-user-guide-to-dependency-walker/legend1.png" class="">



<p>右下方的是左侧选中的dll中，export function列表，如果导出的是c++ function，可以右键选择undecoreated c++ function，这样显示的人类可读的没有被编译器处理的函数名。，其中左侧的E列图例介绍如下：</p>
<img src="/2018/07/05/simple-user-guide-to-dependency-walker/legend2.png" class="">

<p>我们也可以使用dumpbin命令行工具(linux中使用objdump或readelf)来显示dll中导出的函数。</p>
<p><a href="http://www.dependencywalker.com/">Dependency walker下载地址</a></p>
<p>详细使用指南可以参考下载文件夹内的的帮助文件。</p>
<p>关于可执行文件，目标文件的格式，可以参考《程序员的自我修养—链接，装载与库》一书。</p>
]]></content>
      <categories>
        <category>tutorial</category>
      </categories>
      <tags>
        <tag>c++</tag>
      </tags>
  </entry>
  <entry>
    <title>由sizeof引起的问题</title>
    <url>/2018/11/06/sizeof-question-in-cpp/</url>
    <content><![CDATA[<p>最近在看Lippman的《Inside the c++ object model》，书中Lippman说有人发邮件问了他一个问题。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">X</span> &#123;</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Y</span> :</span> <span class="keyword">public</span> <span class="keyword">virtual</span> X&#123;&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Z</span>:</span> <span class="keyword">public</span> <span class="keyword">virtual</span> X&#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>:</span><span class="keyword">public</span> Y, <span class="keyword">public</span> Z&#123;&#125;;</span><br></pre></td></tr></table></figure>

<p>根据以上定义，使用sizeof运算符分别计算类X,Y,Z,A的所占大小。</p>
<span id="more"></span>

<p>答案公布：</p>
<p>在msvc140和gcc 5.4环境下测试：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">size_t</span> temp = <span class="keyword">sizeof</span>(X); <span class="comment">//1</span></span><br><span class="line">temp = <span class="keyword">sizeof</span>(Y);  <span class="comment">//4</span></span><br><span class="line">temp = <span class="keyword">sizeof</span>(Z);  <span class="comment">//4</span></span><br><span class="line">temp = <span class="keyword">sizeof</span>(A);  <span class="comment">//8</span></span><br></pre></td></tr></table></figure>

<h2 id="为什么sizeof-X-为1？"><a href="#为什么sizeof-X-为1？" class="headerlink" title="为什么sizeof(X)为1？"></a>为什么sizeof(X)为1？</h2><p>X是一个”空类”，按理来说sizeof(X)应该是0，因为没有数据需要存储。为何sizeof(X)为1呢？</p>
<p>Lippman给出的解释是，如果空类所占空间为0，则类的两个不同的实例地址就相同，这样的结果显然不是我们想要的。编译器自动给空类插入占用一字节的char数据成员，这样可以保证不同的对象会分配唯一的地址空间。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">X a, b;</span><br><span class="line"><span class="keyword">if</span>(&amp;a == &amp;b) <span class="built_in">cerr</span> &lt;&lt; <span class="string">&quot;yipes&quot;</span> &lt;&lt;<span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure>

<p>在《Effective c++》中item 39中，作者提到：freestanding objects必须有Non-zero size，对于大多数编译器，sizeof(X)是1，是因为编译器插入一个char完成的。</p>
<p>在<a href="https://en.cppreference.com/w/cpp/language/ebo">cppreference</a>可以找到相关的标准规定:</p>
<blockquote>
<p>The size of any <a href="https://en.cppreference.com/w/cpp/language/object">object</a> or member subobject (unless [[no_unique_address]] – see below) (since C++20) is required to be at least 1 even if the type is an empty <a href="https://en.cppreference.com/w/cpp/language/class">class type</a> (that is, a class or struct that has no non-static data members), in order to be able to guarantee that the addresses of distinct objects of the same type are always distinct.</p>
</blockquote>
<h2 id="为什么sizeof-Y-sizeof-Z-为4？"><a href="#为什么sizeof-Y-sizeof-Z-为4？" class="headerlink" title="为什么sizeof(Y), sizeof(Z)为4？"></a>为什么sizeof(Y), sizeof(Z)为4？</h2><p>先来考虑另外一个问题</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">X</span>&#123;</span>&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Q</span>:</span> <span class="keyword">public</span> X&#123;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">    	<span class="keyword">int</span> data;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Q继承自空类X，考虑到sizeof(X) = 1, 那么Q类的所占空间是sizeof(int)还是sizeof(int) + 1?</p>
<p>答案是根据Empty base optimization原则，Q所占空间为sizeof(int)。也就是说base class所占空间被“优化”掉了。但是这里我们class Y， Z并没有数据成员，sizeof(Y) == sizeof(Z)  == 4。</p>
<p>这是因为使用了virtual inheritance。一旦跟<strong>virtual</strong>扯上关系，编译器又在背后偷偷的做了一些事情。</p>
<p>为了实现面向对象中的多态特性，大多数编译器都会将一个vptr插入到the most base class中，vptr指向vtable。关于vtable的相关知识，请参考我的这篇<a href="https://bygeek.cn/2018/10/22/vtable-and-object-memory-layout-in-cpp-language/">博文</a>。正是因为vptr指针占用4个字节，并且基于empty base optimization原则，所以sizeof(Y) = 4。</p>
<h2 id="为什么sizeof-A-为8？"><a href="#为什么sizeof-A-为8？" class="headerlink" title="为什么sizeof(A)为8？"></a>为什么sizeof(A)为8？</h2><p>因为virtual继承关系，编译器会在Y，Z的memory layout中加入一个vptr指针。在多重继承下，X的memory layout会包含Y,Z的vptr，所以sizeof(A)为8。</p>
<h2 id="如看查看memory-layout"><a href="#如看查看memory-layout" class="headerlink" title="如看查看memory layout"></a>如看查看memory layout</h2><h3 id="MSVC"><a href="#MSVC" class="headerlink" title="MSVC"></a>MSVC</h3><p>在msvc下我们可以使用编译器选项<code>/d1reportSingleClassLayout&lt;classname&gt;</code>， <code>/d1reportAllClassLayout</code>来查看memory layout。打开visual studio 开发者prompt</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cl.exe your_source_file_path.cpp &#x2F;d1reportAllClassLayout</span><br></pre></td></tr></table></figure>

<p>如果包含的类比较多，可以将输出信息重定向到文件中，方便查看。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cl.exe your_source_file_path.cpp &#x2F;d1reportAllClassLayout &gt; &quot;d:\out.txt&quot;</span><br></pre></td></tr></table></figure>

<p>在MSVC140下dump出来的memory layout如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class X	size(1):</span><br><span class="line">	+---</span><br><span class="line">	+---</span><br><span class="line"></span><br><span class="line">class Y	size(4):</span><br><span class="line">	+---</span><br><span class="line"> 0	| &#123;vbptr&#125;</span><br><span class="line">	+---</span><br><span class="line">	+--- (virtual base X)</span><br><span class="line">	+---</span><br><span class="line"></span><br><span class="line">Y::$vbtable@:</span><br><span class="line"> 0	| 0</span><br><span class="line"> 1	| 4 (Yd(Y+0)X)</span><br><span class="line">vbi:	   class  offset o.vbptr  o.vbte fVtorDisp</span><br><span class="line">               X       4       0       4 0</span><br><span class="line"></span><br><span class="line">class Z	size(4):</span><br><span class="line">	+---</span><br><span class="line"> 0	| &#123;vbptr&#125;</span><br><span class="line">	+---</span><br><span class="line">	+--- (virtual base X)</span><br><span class="line">	+---</span><br><span class="line"></span><br><span class="line">Z::$vbtable@:</span><br><span class="line"> 0	| 0</span><br><span class="line"> 1	| 4 (Zd(Z+0)X)</span><br><span class="line">vbi:	   class  offset o.vbptr  o.vbte fVtorDisp</span><br><span class="line">               X       4       0       4 0</span><br><span class="line"></span><br><span class="line">class A	size(8):</span><br><span class="line">	+---</span><br><span class="line"> 0	| +--- (base class Y)</span><br><span class="line"> 0	| | &#123;vbptr&#125;</span><br><span class="line">	| +---</span><br><span class="line"> 4	| +--- (base class Z)</span><br><span class="line"> 4	| | &#123;vbptr&#125;</span><br><span class="line">	| +---</span><br><span class="line">	+---</span><br><span class="line">	+--- (virtual base X)</span><br><span class="line">	+---</span><br><span class="line"></span><br><span class="line">A::$vbtable@Y@:</span><br><span class="line"> 0	| 0</span><br><span class="line"> 1	| 8 (Ad(Y+0)X)</span><br><span class="line"></span><br><span class="line">A::$vbtable@Z@:</span><br><span class="line"> 0	| 0</span><br><span class="line"> 1	| 4 (Ad(Z+0)X)</span><br><span class="line">vbi:	   class  offset o.vbptr  o.vbte fVtorDisp</span><br><span class="line">               X       8       0       4 0</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="GCC"><a href="#GCC" class="headerlink" title="GCC"></a>GCC</h3><p>在gcc中可以通过编译选项<code>-fdump-class-hierarchy</code>来查看。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">g++ main.cpp -fdump-class-hierarchy</span><br></pre></td></tr></table></figure>

<p>编程成功后，会生成一个main.cpp.002t.class的文件，搜索想要查看的类的memory layout即可。</p>
<p>载g++ 5.4 ubuntu下dump出来的main.cpp.002t.class文件如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Class X</span><br><span class="line">   size&#x3D;1 align&#x3D;1</span><br><span class="line">   base size&#x3D;0 base align&#x3D;1</span><br><span class="line">X (0x0x7f34c09cf5a0) 0 empty</span><br><span class="line"></span><br><span class="line">Vtable for Y</span><br><span class="line">Y::_ZTV1Y: 3u entries</span><br><span class="line">0     0u</span><br><span class="line">8     (int (*)(...))0</span><br><span class="line">16    (int (*)(...))(&amp; _ZTI1Y)</span><br><span class="line"></span><br><span class="line">VTT for Y</span><br><span class="line">Y::_ZTT1Y: 1u entries</span><br><span class="line">0     ((&amp; Y::_ZTV1Y) + 24u)</span><br><span class="line"></span><br><span class="line">Class Y</span><br><span class="line">   size&#x3D;8 align&#x3D;8</span><br><span class="line">   base size&#x3D;8 base align&#x3D;8</span><br><span class="line">Y (0x0x7f34c08661a0) 0 nearly-empty</span><br><span class="line">    vptridx&#x3D;0u vptr&#x3D;((&amp; Y::_ZTV1Y) + 24u)</span><br><span class="line">  X (0x0x7f34c09cf600) 0 empty virtual</span><br><span class="line">      vbaseoffset&#x3D;-24</span><br><span class="line"></span><br><span class="line">Vtable for Z</span><br><span class="line">Z::_ZTV1Z: 3u entries</span><br><span class="line">0     0u</span><br><span class="line">8     (int (*)(...))0</span><br><span class="line">16    (int (*)(...))(&amp; _ZTI1Z)</span><br><span class="line"></span><br><span class="line">VTT for Z</span><br><span class="line">Z::_ZTT1Z: 1u entries</span><br><span class="line">0     ((&amp; Z::_ZTV1Z) + 24u)</span><br><span class="line"></span><br><span class="line">Class Z</span><br><span class="line">   size&#x3D;8 align&#x3D;8</span><br><span class="line">   base size&#x3D;8 base align&#x3D;8</span><br><span class="line">Z (0x0x7f34c0866208) 0 nearly-empty</span><br><span class="line">    vptridx&#x3D;0u vptr&#x3D;((&amp; Z::_ZTV1Z) + 24u)</span><br><span class="line">  X (0x0x7f34c09cf660) 0 empty virtual</span><br><span class="line">      vbaseoffset&#x3D;-24</span><br><span class="line"></span><br><span class="line">Vtable for A</span><br><span class="line">A::_ZTV1A: 6u entries</span><br><span class="line">0     0u</span><br><span class="line">8     (int (*)(...))0</span><br><span class="line">16    (int (*)(...))(&amp; _ZTI1A)</span><br><span class="line">24    18446744073709551608u</span><br><span class="line">32    (int (*)(...))-8</span><br><span class="line">40    (int (*)(...))(&amp; _ZTI1A)</span><br><span class="line"></span><br><span class="line">Construction vtable for Y (0x0x7f34c0866270 instance) in A</span><br><span class="line">A::_ZTC1A0_1Y: 3u entries</span><br><span class="line">0     0u</span><br><span class="line">8     (int (*)(...))0</span><br><span class="line">16    (int (*)(...))(&amp; _ZTI1Y)</span><br><span class="line"></span><br><span class="line">Construction vtable for Z (0x0x7f34c08662d8 instance) in A</span><br><span class="line">A::_ZTC1A8_1Z: 3u entries</span><br><span class="line">0     18446744073709551608u</span><br><span class="line">8     (int (*)(...))0</span><br><span class="line">16    (int (*)(...))(&amp; _ZTI1Z)</span><br><span class="line"></span><br><span class="line">VTT for A</span><br><span class="line">A::_ZTT1A: 4u entries</span><br><span class="line">0     ((&amp; A::_ZTV1A) + 24u)</span><br><span class="line">8     ((&amp; A::_ZTC1A0_1Y) + 24u)</span><br><span class="line">16    ((&amp; A::_ZTC1A8_1Z) + 24u)</span><br><span class="line">24    ((&amp; A::_ZTV1A) + 48u)</span><br><span class="line"></span><br><span class="line">Class A</span><br><span class="line">   size&#x3D;16 align&#x3D;8</span><br><span class="line">   base size&#x3D;16 base align&#x3D;8</span><br><span class="line">A (0x0x7f34c0878310) 0</span><br><span class="line">    vptridx&#x3D;0u vptr&#x3D;((&amp; A::_ZTV1A) + 24u)</span><br><span class="line">  Y (0x0x7f34c0866270) 0 nearly-empty</span><br><span class="line">      primary-for A (0x0x7f34c0878310)</span><br><span class="line">      subvttidx&#x3D;8u</span><br><span class="line">    X (0x0x7f34c09cf6c0) 0 empty virtual</span><br><span class="line">        vbaseoffset&#x3D;-24</span><br><span class="line">  Z (0x0x7f34c08662d8) 8 nearly-empty</span><br><span class="line">      subvttidx&#x3D;16u vptridx&#x3D;24u vptr&#x3D;((&amp; A::_ZTV1A) + 48u)</span><br><span class="line">    X (0x0x7f34c09cf6c0) alternative-path</span><br></pre></td></tr></table></figure>

<p>在调试的时候还可以通过GDB命令<code>info vtbl</code>来查看vtable，下面是在vscode中调试示例。</p>
<img src="/2018/11/06/sizeof-question-in-cpp/vtable1.png" class="">





<p>如果想更多了解C++背后的故事，推荐阅读Lippman的《Inside the C++ Object Model》一书。</p>
<h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ul>
<li><p><a href="https://ofekshilon.com/2010/11/07/d1reportallclasslayout-dumping-object-memory-layout/">https://ofekshilon.com/2010/11/07/d1reportallclasslayout-dumping-object-memory-layout/</a></p>
</li>
<li><p><a href="http://visualgdb.com/gdbreference/commands/info_vtbl">http://visualgdb.com/gdbreference/commands/info_vtbl</a></p>
</li>
<li><p><a href="https://www.gonwan.com/2010/09/20/c-class-layout-using-msvc/">https://www.gonwan.com/2010/09/20/c-class-layout-using-msvc/</a></p>
</li>
<li><p><a href="https://stackoverflow.com/questions/99297/how-are-virtual-functions-and-vtable-implemented">https://stackoverflow.com/questions/99297/how-are-virtual-functions-and-vtable-implemented</a></p>
</li>
<li><p><a href="https://www.v2ex.com/t/500682#reply10">https://www.v2ex.com/t/500682#reply10</a></p>
</li>
<li><p><a href="https://isocpp.org/wiki/faq/pointers-to-members">https://isocpp.org/wiki/faq/pointers-to-members</a></p>
</li>
</ul>
]]></content>
      <categories>
        <category>coding</category>
      </categories>
      <tags>
        <tag>c++</tag>
      </tags>
  </entry>
  <entry>
    <title>关于神秘海域系列的玩后感</title>
    <url>/2019/01/31/thoughts-on-Sony-s-Uncharted-series/</url>
    <content><![CDATA[<p>拖延症害死人啊，这篇文章写于一个月之前吧。如今已通关神海3和资料片失落遗产。</p>
<span id="more"></span>

<p>—分割线—</p>
<p>上次打折（2018年圣诞促销）买了神海合集和神海4。</p>
<p>目前通了神海4，1和2。说下感受吧。</p>
<p>我先玩的4，画面真的很赞，第一次玩类似的游戏，电影大片即视感，既有点fps还有点揭秘冒险。而且个人觉得枪战，冒险和解谜都恰到好处。诶琳娜真的好美，哈哈。</p>
<p>后来开始玩合集，神海1感觉一直是突突突，枪战，从神海4画面过来看1的画面还是下降挺多，当然了，神海1是十几年前的老游戏，画面在现在看来也是可以理解。就是打到最后变电室出来怪物有点瘆人，有点像指环王的那个咕噜，死了好多次，把难度调到简单通关。</p>
<p>之前在论坛看到说神海2不错。果真，从1开始玩2的时候，电影大片即视感，而且射击可以看到子弹轨迹了，手柄反馈比1要好很多。而且剧情好太多，场面也很足，追火车，打飞机，打坦克。不过个人感觉有点不足的是，为啥非要跟1一样最后整出个怪物来？这点我还是比较喜欢4中，更现实一点。</p>
<p>接下来准备玩3，然后4的dlc。未完待续。</p>
]]></content>
      <categories>
        <category>notes</category>
      </categories>
      <tags>
        <tag>game</tag>
      </tags>
  </entry>
  <entry>
    <title>关于git stash的使用小结</title>
    <url>/2018/08/04/try-not-to-use-git-stash/</url>
    <content><![CDATA[<p>以前使用svn作为版本控制时，每个branch都在本地有一份代码，这样可以同时打开好多个分支。在一个分支加feature，可以很方便的另一个分支上修bug。在切换为git之后，默认所有branch都在本地只有一份copy，有的时候需要临时切换下分支，但不想提交还未完工的代码，会使用到git stash来暂存下代码。然后bug修改之后，再使用git stash pop将暂存的代码恢复过来。</p>
<p>但是在使用了几次git stach之后，经常会遇到一些问题：忘记pop或者pop到了错误的分支导致冲突。本文结合再v2ex上的一些回答，建议最好不要使用git stash，直接通过commit然后最后再通过git reset来回到原来的commit点，完成之后重新commit。</p>
<span id="more"></span>

<h2 id="使用git-stash"><a href="#使用git-stash" class="headerlink" title="使用git stash"></a>使用git stash</h2><p>stash暂时将你做的修改保存起来，然后恢复到未修改的状态。这样可以去做其他事，比如你已经修改了一些东西，但是现在还不能提交，但是要去修改其他功能</p>
<blockquote>
<p>The git stash command takes your uncommitted changes (both staged and unstaged), saves them away for later use, and then reverts them from your working copy</p>
</blockquote>
<ul>
<li><p>git stash</p>
<p>将当前工作保存</p>
</li>
<li><p>git stash show -p stash@{1}</p>
<p>显示哪些文件被修改。如果不指定某个stash，则显示最近的一次stach的修改情况</p>
</li>
<li><p>git stash list</p>
<p>查看有哪些stash，分别位于哪个分支上</p>
</li>
<li><p>git stash pop</p>
<p>将暂存的修改恢复到本地中并删掉该stash，注意在git stash pop之前先确认下stash是在哪个分支的,使用git stash list来查看</p>
</li>
<li><p>git stash apply</p>
<p>与git stash pop的区别是，apply不会将stash删除</p>
</li>
<li><p>git stash clear</p>
<p>删除所有的stash entry， 不可恢复</p>
</li>
<li><p>git stash drop <stash></p>
<p>删除某一个stash entry，如果不给出具体stash，则删除最新的一个</p>
</li>
</ul>
<h2 id="使用git-commit"><a href="#使用git-commit" class="headerlink" title="使用git commit"></a>使用git commit</h2><p>假设遇到需要暂时保存的情况可以选择将修改记录直接commit，commit message可以写WIP commit（work in progress）。这样在完成其他工作之后，通过git reset  –mixed 可以恢复到commit时的状态，然后完成feature，重新填写commit message</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">//you are adding a feature, <span class="keyword">then</span> a bug come <span class="keyword">in</span> ,you have to fix bug</span><br><span class="line">git add .</span><br><span class="line">git commit -m <span class="string">&quot;WIP commit: i will be back&quot;</span></span><br><span class="line">...</span><br><span class="line">//after the bug, xxxxxxxxxxx is the WIP commit SHA-1</span><br><span class="line">git reset --mixed xxxxxxxxxxx</span><br><span class="line">//THEN you finish the feature, and remend the commit message</span><br><span class="line">git commit -m <span class="string">&quot;i am done&quot;</span></span><br></pre></td></tr></table></figure>

<h2 id="git-worktree"><a href="#git-worktree" class="headerlink" title="git worktree"></a>git worktree</h2><p>如果需要同时checkout多个branch到本地，可以使用git worktree，这个命令与git clone多份代码的区别是，使用git worktree可以使得多个worktree之间有联系，比如可以直接将其他worktree中merge过来。</p>
<p>git worktree可以支持不同的worktree attach到同一个repo上,方便同时查看两个分支的代码 .</p>
<blockquote>
<p>A git repository can support multiple working trees, allowing you to check out more than one branch at a time. With git worktree add a new working tree is associated with the repository. This new working tree is called a “<strong>linked working tree</strong>“ as opposed to the “<strong>main working tree</strong>“ prepared by “git init” or “git clone”. A repository has one main working tree (if it’s not a bare repository) and zero or more linked working trees. When you are done with a linked working tree, remove it with git worktree remove.</p>
</blockquote>
<ul>
<li><p>git worktree add ../new_directory feature_branch</p>
<p>添加worktree</p>
</li>
<li><p>git worktree list</p>
<p>列出所有worktree</p>
</li>
<li><p>git worktree move <worktree> <new-path></p>
<p>移动worktree到新路径</p>
</li>
<li><p>git worktree remove [-f] <worktree></p>
<p>移除worktree，只有clean的worktree才可以被删除掉</p>
</li>
</ul>
<h2 id="git-workflow"><a href="#git-workflow" class="headerlink" title="git workflow"></a>git workflow</h2><p>网上推崇的workflow，具体参见这个<a href="https://nvie.com/posts/a-successful-git-branching-model/">blog</a></p>
<img src="/2018/08/04/try-not-to-use-git-stash/git-model.png" class="">

]]></content>
      <categories>
        <category>tutorial</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title>浅谈MemoryMappedFile</title>
    <url>/2018/05/24/understand-memory-mapped-file/</url>
    <content><![CDATA[<p>Memory Mapped File (MMF)，内存映射文件。该技术将一个文件或者其他对象映射到进程的地址空间（虚拟内存），实现文件磁盘地址和进程虚拟地址空间中的一段虚拟地址的一一映射关系。</p>
<h2 id="为什么要使用MMF？"><a href="#为什么要使用MMF？" class="headerlink" title="为什么要使用MMF？"></a>为什么要使用MMF？</h2><p>MMF可以提高I/O性能，特别是对于大文件来说。</p>
<blockquote>
<p>因为<strong>常规文件操作需要从磁盘到页缓存再到用户主存的两次数据拷贝。而mmap操控文件，只需要从磁盘到用户主存的一次数据拷贝过程。</strong>说白了，mmap的关键点是实现了用户空间和内核空间的数据直接交互而省去了空间不同数据不通的繁琐过程。因此mmap效率更高。 </p>
</blockquote>
<span id="more"></span>

<p>这里涉及一些操作系统的一些原理。</p>
<ul>
<li>进程的概念</li>
<li>内核空间和用户空间</li>
<li>系统调用(system call)</li>
<li>内存管理，分页，分段</li>
</ul>
<p>有时间整理下。</p>
<p>从网上扒的两张图：</p>
<img src="/2018/05/24/understand-memory-mapped-file/memory_mapped_file_principle.gif" class="" title="memory mapped file 原理">





<img src="/2018/05/24/understand-memory-mapped-file/normal_io.gif" class="" title="常规IO操作">



<h2 id="NET中的MemoryMappedFile-API"><a href="#NET中的MemoryMappedFile-API" class="headerlink" title=".NET中的MemoryMappedFile API"></a>.NET中的MemoryMappedFile API</h2><p>根据<a href="https://docs.microsoft.com/en-us/dotnet/standard/io/memory-mapped-files">MSDN</a>的说法，MMF分为两种情况：</p>
<ul>
<li>持久化的MMF<ul>
<li>持久化的MMF是与磁盘上的文件相关，调用<code>MemoryMappedFile.CreateFromFile</code>方法创建的。当最后一个进程完成操作MMF操作之后，操作系统会将修改写回磁盘中。这个方式特别适合操作特别大的文件。</li>
</ul>
</li>
<li>非持久化的MMF<ul>
<li>这种MMF不与磁盘上的文件相关联，调用<code>MemoryMappedFile.CreateNew</code>方法创建的。当最后一个进程使用完毕之后，映射到内存的MMF被垃圾回收机制回收。这种方式适合用于多个进程之间通信（IPC）。</li>
</ul>
</li>
</ul>
<img src="/2018/05/24/understand-memory-mapped-file/mmf.png" class="">



<p>.Net framework中MMF的API</p>
<ol>
<li><p>创建MMF对象</p>
<blockquote>
<p>MemoryMappedFile.CreateFromFile : 创建持久化MMF</p>
<p>MemoryMappedFile.CreateNew：创建非持久化MMF</p>
</blockquote>
</li>
<li><p>创建View对象</p>
<blockquote>
<p>MemoryMappedViewAccessor:  ramdom access view，适合与持久化MMF一起使用</p>
<p>MemoryMappedViewStream: sequence access view，适合与非持久MMF或IPC</p>
</blockquote>
</li>
<li><p>使用上一步创建的view对象进行读写</p>
</li>
<li><p>Dispose View对象和MMF对象</p>
</li>
</ol>
<p>摘自MSDN:</p>
<blockquote>
<p>Memory-mapped files can be shared across multiple processes. Processes can map to the same memory-mapped file by using a common name that is assigned by the process that created the file.</p>
<p>To work with a memory-mapped file, you must create a view of the entire memory-mapped file or a part of it. You can also create multiple views to the same part of the memory-mapped file, thereby creating concurrent memory. For two views to remain concurrent, they have to be created from the same memory-mapped file.</p>
<p>Multiple views may also be necessary if the file is greater than the size of the application’s logical memory space available for memory mapping (2 GB on a 32-bit computer).</p>
<p>There are two types of views: stream access view and random access view. Use stream access views for sequential access to a file; this is recommended for non-persisted files and IPC. Random access views are preferred for working with persisted files.</p>
<p>Memory-mapped files are accessed through the operating system’s memory manager, so the file is automatically partitioned into a number of pages and accessed as needed. You do not have to handle the memory management yourself.</p>
</blockquote>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>写了一个简单的demo，来实现两个进程间通信。创建一个mmf.data文件，并由该文件创建MMF，Test1启动后检查该文件的某个字节，如果置位则退出。Test2进程启动后将MMF的这个直接置位。</p>
<p>Test1 进程：</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">string</span> filePath = <span class="string">@&quot;mmf.data&quot;</span>;</span><br><span class="line">         <span class="keyword">if</span> (!System.IO.File.Exists(filePath))</span><br><span class="line">             System.IO.File.Create(filePath).Close();</span><br><span class="line"></span><br><span class="line">         MemoryMappedFile mmf = MemoryMappedFile.CreateFromFile(filePath, System.IO.FileMode.Create, <span class="string">&quot;mmftest&quot;</span>, <span class="number">1024</span> * <span class="number">1024</span> * <span class="number">20</span>, MemoryMappedFileAccess.ReadWrite);</span><br><span class="line">         MemoryMappedViewAccessor viewAccessor = mmf.CreateViewAccessor(<span class="number">0</span>, <span class="number">0</span>, MemoryMappedFileAccess.ReadWrite);</span><br><span class="line"></span><br><span class="line">         <span class="comment">//use Mutex to sync between process, in this case, Test1 and Test2</span></span><br><span class="line">         <span class="built_in">bool</span> mutexCreated = <span class="literal">false</span>;</span><br><span class="line">         Mutex mutex = <span class="keyword">new</span> Mutex(<span class="literal">true</span>, <span class="string">&quot;mymutex&quot;</span>, <span class="keyword">out</span> mutexCreated);</span><br><span class="line"></span><br><span class="line">         <span class="keyword">if</span> (mutexCreated)</span><br><span class="line">         &#123;</span><br><span class="line">             viewAccessor.Write(<span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line">             viewAccessor.Write(<span class="number">2</span>, Process.GetCurrentProcess().Id);</span><br><span class="line">         &#125;</span><br><span class="line"></span><br><span class="line">         mutex.ReleaseMutex();</span><br><span class="line"></span><br><span class="line">         Console.WriteLine(<span class="string">&quot;wait process test2 to start...&quot;</span>);</span><br><span class="line"></span><br><span class="line">         <span class="keyword">var</span> flag = <span class="number">0</span>;</span><br><span class="line">         <span class="keyword">while</span>(<span class="literal">true</span>)</span><br><span class="line">         &#123;</span><br><span class="line">             flag =  viewAccessor.ReadByte(<span class="number">1</span>);  <span class="comment">//read the second byte of mmf, which will be set to 1 when Test2 started.</span></span><br><span class="line">             <span class="keyword">if</span>(flag == <span class="number">1</span>)</span><br><span class="line">             &#123;</span><br><span class="line">                 <span class="keyword">break</span>;</span><br><span class="line">             &#125;</span><br><span class="line">             <span class="keyword">else</span></span><br><span class="line">             &#123;</span><br><span class="line">                 System.Threading.Thread.Sleep(<span class="number">1000</span>);</span><br><span class="line">             &#125;</span><br><span class="line">         &#125;</span><br><span class="line"></span><br><span class="line">         <span class="comment">//dispose</span></span><br><span class="line">         viewAccessor.Dispose();</span><br><span class="line">         mmf.Dispose();</span><br></pre></td></tr></table></figure>



<p>Test2进程：</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line">MemoryMappedFile mmf = MemoryMappedFile.OpenExisting(<span class="string">&quot;mmftest&quot;</span>, MemoryMappedFileRights.ReadWrite);</span><br><span class="line">            MemoryMappedViewAccessor viewAccessor = mmf.CreateViewAccessor(<span class="number">0</span>, <span class="number">0</span>, MemoryMappedFileAccess.ReadWrite);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            Mutex mutex = Mutex.OpenExisting(<span class="string">&quot;mymutex&quot;</span>);</span><br><span class="line">            mutex.WaitOne();  <span class="comment">//require mutex to go on</span></span><br><span class="line"></span><br><span class="line">            viewAccessor.Write(<span class="number">1</span>, <span class="number">1</span>);  <span class="comment">//set the second byte to 1</span></span><br><span class="line"></span><br><span class="line">            Console.WriteLine(<span class="string">&quot;test2 started&quot;</span>);</span><br><span class="line"></span><br><span class="line">            viewAccessor.Write(<span class="number">6</span>, System.Diagnostics.Process.GetCurrentProcess().Id);</span><br><span class="line"></span><br><span class="line">            mutex.ReleaseMutex();</span><br><span class="line"></span><br><span class="line">            viewAccessor.Dispose();</span><br><span class="line">            mmf.Dispose();</span><br><span class="line"></span><br><span class="line">            Console.WriteLine(<span class="string">&quot;quit myself after 5 seconds...&quot;</span>);</span><br><span class="line"></span><br><span class="line">            System.Threading.Thread.Sleep(<span class="number">5000</span>);</span><br></pre></td></tr></table></figure>



<p>具体看这里：<a href="https://github.com/byGeek/MemoryMappedFileTest">Github</a></p>
<h2 id="windows提供的C-API"><a href="#windows提供的C-API" class="headerlink" title="windows提供的C++ API"></a>windows提供的C++ API</h2><p>其实.net framework中MMF的api只是对C++ api的封装。windows提供的API如下：</p>
<ul>
<li><strong>CreateFileMapping</strong></li>
<li><strong>OpenFileMapping</strong></li>
<li><strong>MapViewOfFile</strong></li>
<li><strong>MapViewOfFileEx</strong></li>
<li><strong>UnmapViewOfFile</strong></li>
<li><strong>FlushViewOfFile</strong></li>
<li><strong>CloseHandle</strong></li>
</ul>
<p>具体参考 <a href="https://msdn.microsoft.com/en-us/library/ms810613.aspx">这里</a></p>
<h2 id="推荐阅读"><a href="#推荐阅读" class="headerlink" title="推荐阅读"></a>推荐阅读</h2><ul>
<li><a href="https://www.cnblogs.com/huxiao-tee/p/4660352.html">认真分析mmap：是什么 为什么 怎么用</a></li>
<li><a href="https://blog.csdn.net/mg0832058/article/details/5890688">内存映射文件原理探索</a></li>
<li><a href="https://ayende.com/blog/162791/on-memory-mapped-files">On Memory Mapped Files</a></li>
</ul>
]]></content>
      <categories>
        <category>coding</category>
      </categories>
      <tags>
        <tag>MMF</tag>
      </tags>
  </entry>
  <entry>
    <title>使用DebugView来debug</title>
    <url>/2019/05/10/use-dbgviewer-to-debug-your-code/</url>
    <content><![CDATA[<p>在windows开发的过程中，经常会碰到这样的问题：我们需要记录一些程序的运行期间的信息（log），但是又不想直接记录成log文件保存在用户磁盘上。一般在develop的过程中，我们会将 一些信息直接输入到console或者visual studio中的Output窗口中，但是一旦release给用户之后，我们无法获取这些信息。</p>
<p>That’s where DebugView COMES IN!</p>
<span id="more"></span>

<h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><p><a href="https://docs.microsoft.com/en-us/sysinternals/downloads/debugview">DebugView</a>原来是sysinternals开发的一系列工具包中的一个，现在早已被MS收购。简单来说，这个工具可以用来显示打印到Debug output windows中的信息。比如使用WIN32 OutputDebugString中的消息在visual studio中可以在output  windows中查看的信息。但是在release build版本中，可以通过DebugView工具查看。</p>
<blockquote>
<p><em>DebugView</em> is an application that lets you monitor debug output on your local system, or any computer on the network that you can reach via TCP/IP. It is capable of displaying both kernel-mode and Win32 debug output, so you don’t need a debugger to catch the debug output your applications or device drivers generate, nor do you need to modify your applications or drivers to use non-standard debug output APIs.</p>
</blockquote>
<h3 id="DebugView能做的"><a href="#DebugView能做的" class="headerlink" title="DebugView能做的"></a>DebugView能做的</h3><blockquote>
<p>Under Windows 2000, XP, Server 2003 and Vista <em>DebugView</em> will capture:</p>
<ul>
<li>Win32 <strong>OutputDebugString</strong></li>
<li>Kernel-mode <strong>DbgPrint</strong></li>
<li>All kernel-mode variants of <strong>DbgPrint</strong> implemented in Windows XP and Server 2003</li>
</ul>
<p><em>DebugView</em> also extracts kernel-mode debug output generated before a crash from Window’s 2000/XP crash dump files if <em>DebugView</em> was capturing at the time of the crash.</p>
</blockquote>
<p>就是说DebugView可以抓取到程序中的OutputDebugString, DbgPrint等函数调用。在.net中，同样抓取<code>System.Diagnostic.Debug.WriteLine</code>输出的信息。</p>
<h3 id="基本功能"><a href="#基本功能" class="headerlink" title="基本功能"></a>基本功能</h3><p>使用DebugView很简单，只需要设置下需要capture的类型，如下图只capture win32 调用OutputDebugString的输出，capture events指的是开始/暂停 捕捉。</p>
<img src="/2019/05/10/use-dbgviewer-to-debug-your-code/01_set_capture_type.png" class="">

<h3 id="使用highlight高亮功能"><a href="#使用highlight高亮功能" class="headerlink" title="使用highlight高亮功能"></a>使用highlight高亮功能</h3><p>log一多久容易迷失方向，使用highlight功能，方便查找含有特定字符串的信息。注意是在include中输入通配符，然后在highlight下输入要包含的关键字，如下图。注意，在include中一般直接输入通配符*，如果想只显示包含特定字符的信息，可以输入关键字，多个关键词已；隔开。</p>


<h3 id="设置最多显示多少条记录"><a href="#设置最多显示多少条记录" class="headerlink" title="设置最多显示多少条记录"></a>设置最多显示多少条记录</h3><p>如下图，这样在GUI中只会显示最新的500条记录。</p>
<img src="/2019/05/10/use-dbgviewer-to-debug-your-code/03_maximum_record.png" class="">

<h3 id="显示PID"><a href="#显示PID" class="headerlink" title="显示PID"></a>显示PID</h3><p>在option中可以设置是否显示进程的PID，如果勾选，则在每一行中都会显示进程的PID。这个功能可以配合highlight高亮功能，用来关注特定进程的log信息。</p>
<img src="/2019/05/10/use-dbgviewer-to-debug-your-code/04_use_pid.png" class="">

<h3 id="查看帮助文档"><a href="#查看帮助文档" class="headerlink" title="查看帮助文档"></a>查看帮助文档</h3><p>以上只是debugview的简单功能的介绍，详细功能使用可以参考下载包里的帮助文件：dbgview.chm。</p>
]]></content>
      <categories>
        <category>coding</category>
      </categories>
      <tags>
        <tag>windows</tag>
      </tags>
  </entry>
  <entry>
    <title>个人windows实用工具推荐</title>
    <url>/2018/04/05/useful-tools-for-windows/</url>
    <content><![CDATA[<p>今天清明节，一个人呆在家里没啥事，就想着整理整理博客，写个个人认为比较实用的小工具推荐吧。这些工具也是自己用过一段时间，觉得能提高效率，小而美的。</p>
<ul>
<li>StarDock Fences</li>
<li>Listary</li>
<li>Internet Download Manager</li>
<li>Cmder</li>
<li>Clover</li>
<li>Snipaste</li>
</ul>
<span id="more"></span>

<h2 id="StarDock-Fences"><a href="#StarDock-Fences" class="headerlink" title="StarDock Fences"></a>StarDock Fences</h2><blockquote>
<p>关键词：桌面管理</p>
</blockquote>
<p><a href="https://www.stardock.com/products/fences/">StarDock Fences</a>可谓是一款桌面管理的神器了。曾几何时，桌面一大堆乱而杂的图片，密密麻麻。而有了Fences，自动给图标分类，整齐多了。盗用Fences官网的一张图。桌面从此告别”脏乱差”。</p>
<p><img src="https://www.stardock.com/products/fences/images/fences3/Fences3_SideBySide.jpg" alt="with or with out fences"></p>
<p>Fences是一个收费软件，售价9.99刀，还是很值的。</p>
<h2 id="Listary"><a href="#Listary" class="headerlink" title="Listary"></a>Listary</h2><blockquote>
<p>关键词: 文件搜索，app启动器</p>
</blockquote>
<p><a href="http://www.listary.com/">Listary</a>是我平时使用的频率最高的一款windows工具了。定位文件或是作为高效率的app启动器，用来来得心应手而且基础版软件免费。</p>
<p>Listary使用操作也很简单，安装完毕之后，会有一个简单的tutorial，基本过完几步之后，就基本掌握了Listary的使用方法。下面简单介绍几个使用场景。</p>
<ul>
<li><p>app启动器</p>
<p>双击ctrl键打开Listary搜索框，可以搜索文件或者程序，比如输入QQ</p>
</li>
<li><p>文件检索</p>
<p>双击ctrl键呼出检索框，输入文件名之后按下空格键，表示搜索文件/文件夹</p>
<img src="/2018/04/05/useful-tools-for-windows/listary_file_search1.png" class=""></li>
<li><p>文件定位</p>
<p>Listary与windows资源管理器深度整合，可以快速定位到要找到的文件。window本身是支持首字母的快速定位的。Listary可以支持文件名精确定位，模糊定位等。如下图，在资源管理器中直接敲击键盘，输入<code>work</code>，listary自动在右下方列出相关的文件夹</p>
<img src="/2018/04/05/useful-tools-for-windows/listary_locate_file.png" class="">

<p>对于右边搜索的结果，你可以继续使用键盘的箭头键(window arrow key)导航，可以对文件/文件夹进行操作。</p>
<img src="/2018/04/05/useful-tools-for-windows/listary_navigate.png" class="">

<p>这个功能实在太方便了，可以在不需要利用鼠标直接通过键盘定位文件，提高效率。</p>
</li>
<li><p>文件夹定位</p>
<p>有的时候需要上传或者保存东西的时候，一般程序会pop一个Folder Browse Dialog出来，如果你的文件隐藏路径比较深的情况下，需要一层一层的找，有了Listary，你可以在先使用windows 资源管理器定位目录，按下ctrl + G，然后回到Dialog，点击一下，Dialog的目录自动定位到你刚才的路径。</p>
</li>
</ul>
<h2 id="Internet-Download-Manager"><a href="#Internet-Download-Manager" class="headerlink" title="Internet Download Manager"></a>Internet Download Manager</h2><blockquote>
<p>关键词：下载利器</p>
</blockquote>
<p><a href="https://www.internetdownloadmanager.com/">Internet Download Manager</a> ，简称IDM，可以自动开启多线程下载，基本能跑满带宽。配合Chrome插件–Internet download module（安装IDM的时候自动会安装插件），可以自动调用IDM进行下载。</p>
<img src="/2018/04/05/useful-tools-for-windows/IDM.png" class="">

<p>虽然UI有些“复古”，但是确实下载速度快的飞起。美中不足的是，IDM是收费软件，license要25刀一年。</p>
<h2 id="Cmder"><a href="#Cmder" class="headerlink" title="Cmder"></a>Cmder</h2><blockquote>
<p> 关键词：统一命令行工具</p>
</blockquote>
<p><a href="http://cmder.net/">Cmder</a> 是一款终端命令行工具，界面美观，配色舒服。有了Cmder，你可以抛弃其他的命令行工具了，git bash， cmd， powershell……</p>
<img src="/2018/04/05/useful-tools-for-windows/cmder.png" class="">

<p>Cmder支持多Tab页面，方便用户打开和切换console。</p>
<h2 id="Clover"><a href="#Clover" class="headerlink" title="Clover"></a>Clover</h2><blockquote>
<p>关键词：多标签</p>
</blockquote>
<p><a href="http://cn.ejie.me/">Clover</a> 是一款令windows 资源管理器支持多标签的工具。值得一提的是，该软件是有国人开发的免费工具。Clover在让资源管理器支持多Tab的同时，在工具栏加入了书签功能，可以将经常访问的目录收藏起来，类似浏览器的书签功能。</p>
<p><img src="http://cn.ejie.me/images/clover.jpg" alt="clover"></p>
<p>Clover的易用性和方便性在双屏的情况下体现的淋漓尽致，没使用Clover之前，在双显示器的情况下，我经常要早资源管理器在A屏还是B屏，有了clover之后，每次开机将管理器放在左边屏，下次要切屏方便多了。</p>
<p>美中不足的是Clover在windows 10上经常会crash。而且在Window 10中微软会带来原生的多Tab支持—Microsoft Set。期待微软给力。</p>
<p>支持多Tab的我了解到的还有一款应用，StarDock Groupy，这个不仅支持资源管理器，貌似其他应该也可以支持多标签，鉴于自己没有体验锅，暂不发表评论。</p>
<h2 id="Snipaste"><a href="#Snipaste" class="headerlink" title="Snipaste"></a>Snipaste</h2><blockquote>
<p>关键词：截图神器</p>
</blockquote>
<p><a href="https://www.snipaste.com/">Snipaste</a> 是一款强大的截图软件，小巧简约，典型的小而美。以前截图工具一直使用系统自带的Snipping Tool，Snipaste使用体验不知道甩Snipping Tool几条街。</p>
<p><img src="https://i.v2ex.co/71Ftp04b.png" alt="snipaste"></p>
<p>F1快捷键直接呼出截图界面，智能识别边框，而且带简单的编辑和标注功能，箭头，马赛克，应有尽有。还可以拾取颜色，是我用过的最好用的截图工具。而且免费哦。</p>
<p>以上就是个人使用中遇到的不可多得的小工具，完。</p>
]]></content>
      <categories>
        <category>notes</category>
      </categories>
      <tags>
        <tag>windows</tag>
        <tag>tool</tag>
      </tags>
  </entry>
  <entry>
    <title>visual studio:应用程序处于中断模式</title>
    <url>/2018/04/04/visual-studio-is-in-break-mode/</url>
    <content><![CDATA[<p>在使用Visual studio 2017 这一宇宙最强IDE一段时间，发现偶尔碰到提示：<code>the application is in break mode</code>。</p>
<img src="/2018/04/04/visual-studio-is-in-break-mode/break_mode.png" class="" title="break mode">



<span id="more"></span>

<p>由于这个时候visual studio没有给出具体的stack trace信息，不好debug。我们可以在修改visual studio的exception setting，让exception都thrown出来，便于debug。</p>
<img src="/2018/04/04/visual-studio-is-in-break-mode/open_exception_setting.png" class="" title="open exception setting in vs2017">

<img src="/2018/04/04/visual-studio-is-in-break-mode/open_exception_setting_in_vs2013.png" class="" title="open exception setting in vs2013">

<p>在exception setting中勾选所有的设定。</p>
<img src="/2018/04/04/visual-studio-is-in-break-mode/exception_setting.png" class="" title="exception setting in vs2017">

<img src="/2018/04/04/visual-studio-is-in-break-mode/exception_setting_in_vs2013.png" class="" title="exception_setting in vs2013">



<p>设置之后，visual studio会在exception的地方停下，给出异常信息。</p>
]]></content>
      <categories>
        <category>coding</category>
      </categories>
      <tags>
        <tag>visual studio</tag>
      </tags>
  </entry>
  <entry>
    <title>c/c++ 中的变长参数</title>
    <url>/2018/09/28/variable-arguments-in-c-c/</url>
    <content><![CDATA[<h2 id="一个bug引起的思考"><a href="#一个bug引起的思考" class="headerlink" title="一个bug引起的思考"></a>一个bug引起的思考</h2><p>最近碰到一个bug，是在一个log模块，在使用<code>vsprintf_s</code>函数时发生access deny错误。奇怪的是在Debug模式下没有问题，切换到Release模式下就会重现。我把问题<strong>简单化后的代码</strong>如下：</p>
<span id="more"></span>

<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;stdafx.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdarg.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test_var_args</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* format, ...)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	va_list args;</span><br><span class="line">	va_start(args, format);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">char</span> buf[<span class="number">512</span>];</span><br><span class="line">	<span class="keyword">int</span> len = vsprintf_s(buf, <span class="number">512</span>, format, args);</span><br><span class="line">	<span class="comment">//buf[len] = &#x27;\0&#x27;;</span></span><br><span class="line">	<span class="built_in">printf</span>(buf);</span><br><span class="line">	va_end(args);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test_var_args</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="built_in">std</span>::<span class="built_in">string</span> <span class="title">s</span><span class="params">(<span class="string">&quot;robert&quot;</span>)</span></span>;</span><br><span class="line">	<span class="comment">//const char* str = &quot;robert&quot;;</span></span><br><span class="line">	test_var_args(<span class="string">&quot;%s age is %d&quot;</span>, s, <span class="number">25</span>);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	test_var_args();</span><br><span class="line">	getchar();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>代码很简单。使用vs2017 在debug模式下编译，成功运行，当然输出的字符串有问题，先暂时忽略。在release下直接报如下的错误</p>
<img src="/2018/09/28/variable-arguments-in-c-c/access_violation.png" class="">

<p>当然了，因为上面的代码是简化后的代码，所以直接看输出就能定位到是变长参数带来的内存访问问题。</p>
<p>我在debug实际代码的过程中，开始并没有发现问题的根源。而是纠结在为什么debug模式能work而release不行。于是面向stackoverflow编程(<a href="https://stackoverflow.com/questions/1762088/common-reasons-for-bugs-in-release-version-not-present-in-debug-mode">Common reasons for bugs in release version not present in debug mode</a>)。在试过了修改release模式下的配置，使得尽量与debug下一致（比如使用相同的Runtime Library，不启用优化等），无果。后来看到一个答案，大致意思是， 除了性能上的影响之外，debug和release模式配置无影响，debug working而release not working的原因很可能是bug其实一直都在，只是在debug下没有注意到一些细节，应该去分析代码。</p>
<p>再次去debug下分析代码，单步调试到vsprintf_s，发现格式化输出的字符串有一个变量明显不对(为什么开始没有注意到！！！)，类似上面的简单化代码的输出效果。定位到问题就好了，这个应该是变长参数传递的锅。再次面向stackoverflow编程(<a href="https://stackoverflow.com/questions/36478609/trouble-with-va-list-c">Trouble with va_list c++</a>)。</p>
<blockquote>
<p> you can’t portably extract <code>std::string</code> from variadic function arguments. Only trivial types are fully supported, and for strings you have to use <code>char*</code>. <code>std::string</code> is not trivial, because it has non-trivial constructor and destructor. Some compilers do support non-trivial types as arguments for such functions, but others do not, so you shouldn’t try this.<br>The last, but not the least: variadic functions have no place in C++ world, even for assignments.</p>
</blockquote>
<p>大致意思是在可变参数传递中只支持简单类型(trivial types), <code>std::string</code>传递会有问题。果不其然，查看call stack的调用关系，其中有一步，变长参数传递中，有一个参数直接传递的<code>std::string</code>类型。将其修改调用string的<code>c_str()</code>方法，问题解决。</p>
<p>这个问题解决了，心里有了另外的问题，变长参数是如何实现的呢？</p>
<h2 id="c中的变长参数实现"><a href="#c中的变长参数实现" class="headerlink" title="c中的变长参数实现"></a>c中的变长参数实现</h2><p>C语言中提供了变长函数声明，使用省略号<code>...</code>(ellipses)表示参数是可变的。通过位于<code>stdarg.h</code>头文件中定义的三个宏<code>va_start, va_end, va_args</code>和一个类型<code>va_list</code>来实现。先看个例子。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdarg.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">test_sum</span><span class="params">(<span class="keyword">int</span> num, ...)</span> </span>&#123;</span><br><span class="line">	va_list <span class="built_in">list</span>;</span><br><span class="line">	va_start(<span class="built_in">list</span>, num);</span><br><span class="line">	<span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span> (i &lt; num)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">int</span> value = va_arg(<span class="built_in">list</span>, <span class="keyword">int</span>);</span><br><span class="line">		sum += value;</span><br><span class="line">		++i;</span><br><span class="line">	&#125;</span><br><span class="line">	va_end(<span class="built_in">list</span>);</span><br><span class="line">	<span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">	sum =test_sum(<span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">	sum =test_sum(<span class="number">3</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>);</span><br><span class="line">	sum =test_sum(<span class="number">3</span>, <span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line">	sum =test_sum(<span class="number">4</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中<code>test_sum</code>定义中第一个形参为后面的参数个数，第二个形参为可变参数。之所以需要第一个形参，是因为在<code>while</code>循环中去通过<code>va_arg</code>去取得参数。那么问题来了，函数的参数是如何传递的呢？</p>
<p>可参考我的另外一边文章: <a href="https://bygeek.cn/2018/09/05/what-is-calling-convention/">什么是调用惯例</a>。<br>在C中通过cdecl方式,参数是从右至左的顺序入栈。以<code>test_sum(3,1,2,3)</code>调用为例，参数入栈后结果示意。注意，栈是高地址向低地址增长的。</p>
<table>
<thead>
<tr>
<th>address</th>
<th>stack</th>
</tr>
</thead>
<tbody><tr>
<td>high_addr</td>
<td>3</td>
</tr>
<tr>
<td></td>
<td>2</td>
</tr>
<tr>
<td></td>
<td>1</td>
</tr>
<tr>
<td></td>
<td>3</td>
</tr>
<tr>
<td>low_addr(top)</td>
<td>ret_addr</td>
</tr>
</tbody></table>
<p>下面来看下几个宏定义的声明和定义。摘自MSDN</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">type <span class="title">va_arg</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">   va_list arg_ptr,</span></span></span><br><span class="line"><span class="function"><span class="params">   type</span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">va_copy</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">   va_list dest,</span></span></span><br><span class="line"><span class="function"><span class="params">   va_list src</span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>; <span class="comment">// (ISO C99 and later)</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">va_end</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">   va_list arg_ptr</span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">va_start</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">   va_list arg_ptr,</span></span></span><br><span class="line"><span class="function"><span class="params">   prev_param</span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>; <span class="comment">// (ANSI C89 and later)</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">va_start</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">   arg_ptr</span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>;  <span class="comment">// (deprecated Pre-ANSI C89 standardization version)</span></span><br></pre></td></tr></table></figure>

<p>定义摘录自<code>stdarg.h</code>和<code>vadefs.h</code>。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">char</span>* va_list;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> va_start __crt_va_start</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> va_arg   __crt_va_arg</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> va_end   __crt_va_end</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> va_copy(destination, source) ((destination) = (source))</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __crt_va_start_a(ap, v) ((void)(ap = (va_list)_ADDRESSOF(v) + _INTSIZEOF(v)))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __crt_va_arg(ap, t)     (*(t*)((ap += _INTSIZEOF(t)) - _INTSIZEOF(t)))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __crt_va_end(ap)        ((void)(ap = (va_list)0))</span></span><br></pre></td></tr></table></figure>

<p>从源码可以看出：</p>
<ul>
<li><code>va_list</code>只是<code>char*</code>的别称而已。</li>
<li><code>va_start</code>的实现有使用了<code>_INTSIZEOF</code>, <code>_ADDRESSOF</code>两个宏定义。先不管，望文生义结合<code>va_start</code>的声明，可以推测<code>va_start</code>是通过可变参数中前一个参数的地址得到第一个可变参数地址。</li>
<li><code>va_arg</code>通过<code>va_list</code>指针获取下一个参数的地址，并转化为相应的type</li>
<li><code>va_end</code> 将<code>va_list</code>置为空。</li>
</ul>
<p>接下来看下<code>_INTSIZEOF</code>, <code>_ADDRESSOF</code>两个宏定义。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _INTSIZEOF(n)          ((sizeof(n) + sizeof(int) - 1) &amp; ~(sizeof(int) - 1))</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> __cplusplus</span></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> _ADDRESSOF(v) (&amp;const_cast<span class="meta-string">&lt;char&amp;&gt;(reinterpret_cast&lt;const volatile char&amp;&gt;(v)))</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> _ADDRESSOF(v) (&amp;(v))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<ul>
<li><code>_ADDRESSOF</code>很明显就是取地址</li>
<li><code>_INTSIZEOF</code>是对int类型所占字节数进行对齐。</li>
</ul>
<p>举个例子</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test_INTSIZEOF</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> size = <span class="number">0</span>;</span><br><span class="line">	size = _INTSIZEOF(<span class="string">&quot;hello&quot;</span>);  <span class="comment">//8</span></span><br><span class="line">	size = _INTSIZEOF(<span class="string">&quot;h&quot;</span>); <span class="comment">//4</span></span><br><span class="line">	size = <span class="keyword">sizeof</span>(<span class="string">&quot;hello&quot;</span>);  <span class="comment">//6</span></span><br><span class="line">	size = <span class="keyword">sizeof</span>(<span class="string">&quot;h&quot;</span>);  <span class="comment">//2</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>字符串结尾的’\0’字符也会被记为一个字节长度。由例子很容易理解<code>_INTSIZEOF</code>宏的作用。<br>那么问题又来了，为什么要做这个字节对齐处理呢？简单的说，因为参数在入栈的时候就是这样存放的，更详细的理解，请参考wiki: <a href="https://en.wikipedia.org/wiki/Data_structure_alignment">Data structure alignment</a></p>
<p>其实变长参数我们遇到最多的应该是<code>printf</code>了。在格式化一些输出时，printf是如何知道参数的个数呢？在上面的演示中，我们是手动传递了参数个数，作为第一个参数的。</p>
<p>答案就在于格式化字符中。例如<code>&quot;%s age is %d&quot;</code>,通过这个格式化字符串，可以知道需要两个参数, 类型分别是”%s”与”%d”。</p>
<h2 id="c-中变长参数实现"><a href="#c-中变长参数实现" class="headerlink" title="c++中变长参数实现"></a>c++中变长参数实现</h2><p>根据stackoverflow上的回答</p>
<blockquote>
<p>The last, but not the least: variadic functions have no place in C++ world, even for assignments.</p>
</blockquote>
<p>c语言中对变长参数的实现在C++中是有更modern的实现的.所以我有对C++中的实现做了一番总结.主要参考了《C++ PRIMER 5TH Edition》。以下基于C++ 11 标准。</p>
<h3 id="使用initializer-list"><a href="#使用initializer-list" class="headerlink" title="使用initializer_list"></a>使用initializer_list</h3><p>对于可变参数是同一类型，可以使用C++11新增的一个类型<code>initialize_list</code>。举例如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;initializer_list&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sum_initializer_list</span><span class="params">(<span class="built_in">std</span>::<span class="built_in">initializer_list</span>&lt;<span class="keyword">int</span>&gt; <span class="built_in">list</span>)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">auto</span> beg = <span class="built_in">list</span>.begin();</span><br><span class="line">	<span class="keyword">auto</span> sum = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (; beg != <span class="built_in">list</span>.end(); ++beg) &#123;</span><br><span class="line">		sum += *beg;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test_sum_initilizer_list</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	sum_initializer_list(&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;);</span><br><span class="line">	sum_initializer_list(&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>&#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="使用可变参数模板template-lt-typename…-Args-gt"><a href="#使用可变参数模板template-lt-typename…-Args-gt" class="headerlink" title="使用可变参数模板template&lt;typename… Args&gt;"></a>使用可变参数模板template&lt;typename… Args&gt;</h3><p>在C++中可变参数被称为参数包(parameter package), 存在两种：模板参数包，表示零个或多个模板参数；函数参数包，表示零个或多个函数参数。举例如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Args 是模板参数包，args是函数参数包</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span>... Args&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">foo</span><span class="params">(<span class="keyword">const</span> T&amp; t, <span class="keyword">const</span> Args&amp;... args)</span></span>;</span><br></pre></td></tr></table></figure>

<p>可变参数函数通常是递归的。第一部调用处理包中的第一个实参，然后用剩余实参调用自身。举个例子：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test_vaargs</span><span class="params">(<span class="keyword">const</span> T&amp; t)</span> </span>&#123;</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; t &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span>... args&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test_vaargs</span><span class="params">(<span class="keyword">const</span> T&amp; t, <span class="keyword">const</span> args&amp;... param)</span> </span>&#123;</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;sizeof...(args): &quot;</span> &lt;&lt; <span class="keyword">sizeof</span>...(args) &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;sizeof...(param): &quot;</span> &lt;&lt;<span class="keyword">sizeof</span>...(param) &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;print: &quot;</span> &lt;&lt; t &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">	test_vaargs(param...);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//call</span></span><br><span class="line">test_vaargs(<span class="number">1</span>, <span class="number">2</span>, <span class="string">&quot;robert&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>当我们需要知道包中有多少元素时，可以使用<code>sizeof...</code>运算符。<br>对于一个参数包，在模板实例化的时候，是对包里的每一个元素进行扩展。包扩展（package expend）是对省略号前面的pattern进行扩展。比如上面的foo声明。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//declaration</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span>... Args&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">foo</span><span class="params">(<span class="keyword">const</span> T&amp; t, <span class="keyword">const</span> Args&amp;... args)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//test</span></span><br><span class="line"><span class="function"><span class="built_in">std</span>::<span class="built_in">string</span> <span class="title">str</span><span class="params">(<span class="string">&quot;robert&quot;</span>)</span></span>; <span class="keyword">int</span> a=<span class="number">1</span>; <span class="keyword">double</span> b=<span class="number">0.1</span>;</span><br><span class="line">foo(a, b, str);</span><br><span class="line">foo(b, <span class="string">&quot;robert&quot;</span>, a);</span><br></pre></td></tr></table></figure>
<p>编译器通过类型推断，分别实例化生成对应的声明：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//参数包const Args&amp;... 被扩展，可以理解为此时的pattern为const Args&amp;</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">foo</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span>&amp;, <span class="keyword">const</span> <span class="keyword">double</span>&amp;, <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp;)</span></span>;  <span class="comment">//注意string类型推断为string</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">foo</span><span class="params">(<span class="keyword">const</span> <span class="keyword">double</span>&amp;, <span class="keyword">const</span> <span class="keyword">char</span>[<span class="number">7</span>]&amp;, <span class="keyword">const</span> <span class="keyword">int</span>&amp;)</span></span>;  <span class="comment">//字符串字面量类型推断为const char[len]&amp;</span></span><br></pre></td></tr></table></figure>



<h2 id="心得"><a href="#心得" class="headerlink" title="心得"></a>心得</h2><p>在troobleshooting的过程中还是要多注意细节，多观察一些预期的变量是否正确。当然了，c/c++的知识还要加强啊。</p>
]]></content>
      <categories>
        <category>coding</category>
      </categories>
      <tags>
        <tag>c/c++</tag>
      </tags>
  </entry>
  <entry>
    <title>什么是调用惯例</title>
    <url>/2018/09/05/what-is-calling-convention/</url>
    <content><![CDATA[<p>调用惯例（Calling Convention）是指函数调用时发生的一些约定。wikipedia定义如下：</p>
<blockquote>
<p>a calling convention is an implementation-level (low-level) scheme for how subroutines receive parameters from their caller and how they return a result. Differences in various implementations include where parameters, return values, return addresses and scope links are placed, and how the tasks of preparing for a function call and restoring the environment afterward are divided between the caller and the callee.</p>
</blockquote>
<span id="more"></span>

<p>经常在一些代码中看到：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> __stdcall <span class="title">foo</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> __cdelc <span class="title">bar</span><span class="params">(<span class="keyword">double</span> a, <span class="keyword">double</span> b)</span></span>;</span><br></pre></td></tr></table></figure>

<p>或者在c#中利用P/Invoke一些native代码时：</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line">[<span class="meta">DllImport(<span class="meta-string">&quot;User32.dll&quot;</span>, EntryPoint = <span class="meta-string">&quot;SetForegroundWindow&quot;</span>, CallingConvention = CallingConvention.StdCall)</span>]</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">extern</span> <span class="built_in">bool</span> <span class="title">SetForegroundWindow</span>(<span class="params">IntPtr hWnd</span>)</span>;</span><br></pre></td></tr></table></figure>

<p>代码中的<code>__stdcall</code>和<code>__cdecl</code>即调用惯例。在csharp中P/Invoke时默认的CallingConvention是StdCall。</p>
<h2 id="具体指什么"><a href="#具体指什么" class="headerlink" title="具体指什么"></a>具体指什么</h2><p>一般来说，调用惯例一般会规定以下的内容：</p>
<ul>
<li><p>函数参数的传递顺序和方式</p>
<p>函数参数的传递可以有很多种方式，最常见的一种是通过栈传递。函数的调用方将参数压入栈中，函数自己再从栈中将参数取出。对于有多个函数参数的函数，调用惯例要规定函数调用将参数压栈的顺序：是从左到右还是从右到左。有些调用惯例还允许使用寄存器传递参数，以提高性能。</p>
</li>
<li><p>栈的维护方式</p>
<p>在函数将参数压栈之后，函数体会被调用，此后需要将被压入栈中的参数全部弹出，以使得栈在函数调用前后保持一致。这个弹出的工作可以由函数的调用方来完成，也可以由函数本身来完成。</p>
<p>cdecl由函数调用方来完成，stdcall由函数本身来完成。在WIN32 API中，除了变长的参数的函数之后，都是用的调用管理是stdcall。因为变长的函数参数，函数本身并不知道参数的个数，所以只能由函数调用方来处理出栈。</p>
</li>
<li><p>名字修饰(name-mangling)的策略</p>
<p>为了链接的时候对调用管理进行区分，调用惯例要对函数本身的名字进行修饰，不同的调用惯例有不同的名字修饰策略。</p>
<p>cdecl采用的名字修饰策略是： 下划线+函数名</p>
<p>stdcall: 下划线+函数名+@+参数的字节数，如函数int func(int a, double b)的修饰名为_func@12</p>
</li>
</ul>
<p>《程序员的自我修养–链接，装载与库》一书中有详细的解释（这本书是对底层的一些概念解释的很清楚，推荐阅读）。摘录一图如下：</p>
<img src="/2018/09/05/what-is-calling-convention/calling-convention.png" class="">



]]></content>
      <categories>
        <category>coding</category>
      </categories>
      <tags>
        <tag>c</tag>
      </tags>
  </entry>
  <entry>
    <title>vtable and object memory layout in cpp</title>
    <url>/2018/10/22/vtable-and-object-memory-layout-in-cpp-language/</url>
    <content><![CDATA[<p>在C语言中，data和function是独立的entity，换句话说data和function是没有直接关联的。所以说使用C编程是面向过程编程，使用一个个的function来操作外在的data。而在C++中，通过Class将data和function集合在一起，形成一个Object。通过面向对象编程的三大特点：1)封装2)继承3)多态 来实现更好的灵活性。</p>
<span id="more"></span>

<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">//c style： declare data structure and function seperately</span></span><br><span class="line"><span class="comment">//data</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">point</span>&#123;</span></span><br><span class="line">    <span class="keyword">float</span> x;</span><br><span class="line">    <span class="keyword">float</span> y;</span><br><span class="line">&#125;Point_t;</span><br><span class="line"></span><br><span class="line"><span class="comment">//function</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print_point</span><span class="params">(<span class="keyword">const</span> Point_t* ptr)</span></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%f %f&quot;</span>, ptr-&gt;x, ptr-&gt;y);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//c++ style: use class</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Point(<span class="keyword">float</span> x, <span class="keyword">float</span> y): m_x(x), m_y(y)&#123;&#125;</span><br><span class="line">    ~Point() = <span class="keyword">default</span>;</span><br><span class="line">   </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%f %f&quot;</span>, m_x, m_y);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">float</span> <span class="title">x</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> m_x;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">float</span> <span class="title">y</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> m_y;&#125;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">float</span> m_x;</span><br><span class="line">    <span class="keyword">float</span> m_y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="c-Object-Memory-Model"><a href="#c-Object-Memory-Model" class="headerlink" title="c++ Object Memory Model"></a>c++ Object Memory Model</h2><p>在上述代码中，Point类的大小跟C语言中的Point 结构体的大小是一致的，在64bit机器上使用sizeof运算符得到大小都是8 byte。考虑下面的一个例子：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> a;</span><br><span class="line">    <span class="keyword">float</span> f;</span><br><span class="line">    <span class="keyword">char</span> c1;</span><br><span class="line">    <span class="keyword">char</span> c2;</span><br><span class="line">    <span class="keyword">char</span> d[<span class="number">4</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>一个对象所占的内存空间是一块连续的地址，且后声明的数据成员具有更高的地址。</p>
<h2 id="what-is-vtable"><a href="#what-is-vtable" class="headerlink" title="what is vtable"></a>what is vtable</h2><ul>
<li>static array usually the first slot in c++ object model</li>
<li>class-specific</li>
<li>vptr, vptr is assigned in constructor by compiler generated code, that is why member initialization list is different with initialization in constructor body.</li>
<li>polymorphic can be implemented differently between compilers. But generally implement using vtable</li>
<li>use sample code in linux, use gdb to show vtable: -exec info vtbl objectname</li>
</ul>
<h2 id="object-memory-model"><a href="#object-memory-model" class="headerlink" title="object memory model"></a>object memory model</h2><ul>
<li>alignment</li>
</ul>
<h2 id="member-function"><a href="#member-function" class="headerlink" title="member function"></a>member function</h2><ul>
<li>member function is just a tag in code segment, is not include in object memory layout</li>
</ul>
<h2 id="single-inheritance-and-multi-inheritance"><a href="#single-inheritance-and-multi-inheritance" class="headerlink" title="single inheritance and multi-inheritance"></a>single inheritance and multi-inheritance</h2><ul>
<li>pointer fix needed in multi-inheritance</li>
</ul>
<h2 id="notes"><a href="#notes" class="headerlink" title="notes"></a>notes</h2><ul>
<li><a href="https://isocpp.org/wiki/faq/pointers-to-members">pointers-to-members</a></li>
<li>PPT material</li>
</ul>
]]></content>
      <categories>
        <category>coding</category>
      </categories>
      <tags>
        <tag>c++</tag>
      </tags>
  </entry>
  <entry>
    <title>利用beyond compare自动生成patch包</title>
    <url>/2018/03/12/%E5%88%A9%E7%94%A8beyond-compare%E8%87%AA%E5%8A%A8%E7%94%9F%E6%88%90patch%E5%8C%85/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>beyond compare对于程序员来说，可谓是一个不可多得的文件比较工具，试用过winMerge以及一些自带的diff工具之后，还是发现beyond compare界面最为友好，功能也比其他工具强大。</p>
<p>最近有一个需求是能否在每次release之后，可以比较方便的产生各个版本的升级patch包。持续集成的工具(类似jenkins，Travis CI)我没有了解过，不知道是否能有这个功能。但是仅仅对于这个小需求来说，利用beyond compare工具就可以做到。</p>
<span id="more"></span>



<h2 id="利用BC-GUI生成patch包"><a href="#利用BC-GUI生成patch包" class="headerlink" title="利用BC GUI生成patch包"></a>利用BC GUI生成patch包</h2><ol>
<li><p>选中需要对比的两个文件夹，右键选择compare</p>
</li>
<li><p>在BC中选择diff，只显示有变化的文件</p>
</li>
<li><p>在BC菜单栏中Edit -&gt; Expand all, Edit -&gt; select all files</p>
</li>
<li><p>在选中的文件中右击，选择copy to folder</p>
<p><img src="/2018/03/12/%E5%88%A9%E7%94%A8beyond-compare%E8%87%AA%E5%8A%A8%E7%94%9F%E6%88%90patch%E5%8C%85/bc_copy_to_folder.png" alt="bc_copy_to_folder"></p>
</li>
<li><p>在打开的对话框中，选择要生成patch的文件(left/right side)，选择folder structure为base</p>
<p><img src="/2018/03/12/%E5%88%A9%E7%94%A8beyond-compare%E8%87%AA%E5%8A%A8%E7%94%9F%E6%88%90patch%E5%8C%85/copy_to.png" alt="copy_to"></p>
</li>
<li><p>patch包生成完毕。</p>
</li>
</ol>
<h2 id="编写脚本自动化"><a href="#编写脚本自动化" class="headerlink" title="编写脚本自动化"></a>编写脚本自动化</h2><p>BC其实是支持脚本运行的，可移步与<a href="https://www.scootersoftware.com/v4help/index.html?sample_scripts.html">此</a>。同时安装完BC之后，会在安装目录有CHM的帮助文件，具体的一些语法可参考该文件。</p>
<ol>
<li><p>编写脚本，将脚本保存为<code>bc_auto_script.txt</code></p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">log verbose <span class="string">&quot;c:\bclog.txt&quot;</span>        <span class="comment">#表示将脚本的log记录在bclog.txt中</span></span><br><span class="line">load <span class="string">&quot;d:\testv1.0&quot;</span> <span class="string">&quot;d:\testv2.0&quot;</span>     <span class="comment">#加载需要比较的文件夹</span></span><br><span class="line"><span class="keyword">filter</span> <span class="string">&quot;-*.log;-lib\&quot;</span>             <span class="comment">#利用beyong compare中的filter：除去*.log文件以及lib子文件夹，即这些不参与比较</span></span><br><span class="line">expand all                        <span class="comment">#展开文件，这个命令与beyond compare中的UI的expand all是对应的</span></span><br><span class="line"><span class="built_in">select</span> right.diff.files right.orphan.files   <span class="comment">#只选取有差异的文件</span></span><br><span class="line">copyto right path:base <span class="string">&quot;D:\diff.zip&quot;</span>        <span class="comment">#将有差异的文件拷贝到d:\diff中，注意copyto命令的参数</span></span><br><span class="line">                                            <span class="comment">##right: 对应上述load命令中的参数，即testv2.0，意思是将testv2.0的差异文件copy出来</span></span><br><span class="line">                                            <span class="comment">##path:base: 指保留目录结构</span></span><br><span class="line">                                            <span class="comment">##d:\diff: 输出目录，也可以指明为zip文件：如&quot;d:\diff.zip&quot;，这样最后会生成一个zip包</span></span><br></pre></td></tr></table></figure></li>
<li><p>cmd下执行：<code>&quot;C:\Program Files (x86)\Beyond Compare 4\Bcompare.exe&quot; /silent &quot;@D:\bc_auto_script.txt&quot;</code>, BC安装路径， silent参数表示不启动GUI， 后面是在第一部中编写的脚本文件。</p>
</li>
<li><p>diff.zip即为生成的patch文件。如果要实现批量的生成patch包，可以编写一个批处理脚本。可参考<a href="https://github.com/byGeek/auto_patch">这里</a>。</p>
</li>
</ol>
<h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ul>
<li><a href="https://www.scootersoftware.com/v4help/index.html?sample_scripts.html">beyond compare sample script</a></li>
</ul>
]]></content>
      <categories>
        <category>tutorial</category>
      </categories>
      <tags>
        <tag>CI</tag>
      </tags>
  </entry>
  <entry>
    <title>如何删除github敏感文件</title>
    <url>/2018/02/24/%E5%A6%82%E4%BD%95%E5%88%A0%E9%99%A4github%E6%95%8F%E6%84%9F%E6%96%87%E4%BB%B6/</url>
    <content><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>由于当初建立博客的失误，我将一些不可名状的东西上传到了github中，今天才发现，吓的我赶紧找方法如何删除。google了一番之后终于找到了一个repo-cleaner工具：<a href="https://rtyley.github.io/bfg-repo-cleaner/">BFG</a>。 下面就简单记录下如何删除已经commit到服务器上的文件，同时删除commit记录。</p>
<span id="more"></span>

<h3 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h3><ol>
<li><p>在你的local working directory中将你要删除的文件删除，正常commit并push到remote，因为BFG工具会使用最新的一次commit。</p>
<blockquote>
<p>The BFG treats you like a reformed alcoholic: you’ve made some mistakes in the past, but now you’ve cleaned up your act. Thus the BFG assumes that your latest commit is a <em>good</em> one, with none of the dirty files you want removing from your history still in it. This assumption by the BFG protects your work, and gives you peace of mind knowing that the BFG is <em>only</em> changing your repo history, not meddling with the <em>current</em> files of your project.</p>
</blockquote>
</li>
<li><p>下载BFG工具jar包，<a href="http://repo1.maven.org/maven2/com/madgag/bfg/1.13.0/bfg-1.13.0.jar">链接</a> 。（当然要先装java runtime）:)</p>
</li>
<li><p>下载git repo的bare repository：<code>git clone --mirror git://example.com/some-repo.git</code></p>
<p>bare repository并不能看到实际的repo文件，但是却包含了repo的全部数据。下载完之后，最好备份一下。</p>
</li>
<li><p>在目录下执行：<code>java -jar bfg.jar --delete-files filename some-repo.git</code>。</p>
<ul>
<li>后面这个参数为刚刚下载到本地的repo目录，不是完整的git地址。</li>
<li>filename为要删除的文件，注意，该操作会将根目录下及根目录下的子目录的相同filename的文件都删除</li>
<li>如果想删除多个文件，filename参数可以写成<code>&#123;file1,file2&#125;</code>。</li>
</ul>
</li>
<li><p>进入到刚下好的repo目录中，执行：</p>
<p><code>git reflog expire --expire=now --all &amp;&amp; git gc --prune=now --aggressive</code></p>
</li>
<li><p>将修改的repo push到remote：<code>git push</code>。</p>
</li>
<li><p>push成功之后查看remote中是否文件已删除，并且与该文件相关的commit的历史记录也删除了。</p>
</li>
</ol>
<h3 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h3><ul>
<li><a href="https://rtyley.github.io/bfg-repo-cleaner/">bfg-repo-cleaner</a></li>
<li><a href="https://help.github.com/articles/removing-sensitive-data-from-a-repository/">Removing sensitive data from a repository</a></li>
</ul>
<p>下篇博客预告，总结下博客迁移的步骤吧，今天又踩了以前踩过的坑:)</p>
]]></content>
      <categories>
        <category>tutorial</category>
      </categories>
      <tags>
        <tag>github</tag>
        <tag>bfg</tag>
      </tags>
  </entry>
  <entry>
    <title>博客迁移记录</title>
    <url>/2018/02/26/%E5%8D%9A%E5%AE%A2%E8%BF%81%E7%A7%BB%E8%AE%B0%E5%BD%95/</url>
    <content><![CDATA[<p>这几天将博客的主题换成了next。本来使用的是yilia主题，后来发现渲染有序列表会出现换行的问题，同时yilia已经放弃维护了，next主题也很不错，果断换之。使用hexo框架换个主题简直不要太简单，就不多说了。本文是简单记录下博客迁移的过程。</p>
<span id="more"></span>

<p>关于如何使用hexo和github pages来搭建博客，网络上有很多教程。我主要是参考 <a href="http://crazymilk.github.io/2015/12/28/GitHub-Pages-Hexo%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2">此博文</a> 。这篇博文详细记录了如何建立，部署，同时如何进行博客迁移。摘录部分内容如下：</p>
<blockquote>
<h3 id="4-2-我的博客搭建流程"><a href="#4-2-我的博客搭建流程" class="headerlink" title="4.2 我的博客搭建流程"></a>4.2 我的博客搭建流程</h3><ol>
<li>创建仓库，CrazyMilk.github.io；</li>
<li>创建两个分支：master 与 hexo；</li>
<li>设置hexo为默认分支（因为我们只需要手动管理这个分支上的Hexo网站文件）；</li>
<li>使用git clone <a href="mailto:&#x67;&#105;&#x74;&#x40;&#103;&#x69;&#x74;&#104;&#x75;&#98;&#46;&#99;&#111;&#x6d;">&#x67;&#105;&#x74;&#x40;&#103;&#x69;&#x74;&#104;&#x75;&#98;&#46;&#99;&#111;&#x6d;</a>:CrazyMilk/CrazyMilk.github.io.git拷贝仓库；</li>
<li>在本地CrazyMilk.github.io文件夹下通过Git bash依次执行npm install hexo、hexo init、npm install 和 npm install hexo-deployer-git（此时当前分支应显示为hexo）;</li>
<li>修改_config.yml中的deploy参数，分支应为master；</li>
<li>依次执行git add .、git commit -m “…”、git push origin hexo提交网站相关的文件；</li>
<li>执行hexo generate -d生成网站并部署到GitHub上。</li>
</ol>
<p>这样一来，在GitHub上的CrazyMilk.github.io仓库就有两个分支，一个hexo分支用来存放网站的原始文件，一个master分支用来存放生成的静态网页。完美( •̀ ω •́ )y！</p>
<h3 id="4-3-我的博客管理流程"><a href="#4-3-我的博客管理流程" class="headerlink" title="4.3 我的博客管理流程"></a>4.3 我的博客管理流程</h3><h4 id="4-3-1-日常修改"><a href="#4-3-1-日常修改" class="headerlink" title="4.3.1 日常修改"></a>4.3.1 日常修改</h4><p>在本地对博客进行修改（添加新博文、修改样式等等）后，通过下面的流程进行管理：</p>
<ol>
<li>依次执行git add .、git commit -m “…”、git push origin hexo指令将改动推送到GitHub（此时当前分支应为hexo）；</li>
<li>然后才执行hexo generate -d发布网站到master分支上。</li>
</ol>
<p>虽然两个过程顺序调转一般不会有问题，不过逻辑上这样的顺序是绝对没问题的（例如突然死机要重装了，悲催….的情况，调转顺序就有问题了）。</p>
<h4 id="4-3-2-本地资料丢失"><a href="#4-3-2-本地资料丢失" class="headerlink" title="4.3.2 本地资料丢失"></a>4.3.2 本地资料丢失</h4><p>当重装电脑之后，或者想在其他电脑上修改博客，可以使用下列步骤：</p>
<ol>
<li>使用git clone <a href="mailto:&#103;&#105;&#116;&#x40;&#103;&#105;&#x74;&#x68;&#117;&#98;&#x2e;&#99;&#111;&#109;">&#103;&#105;&#116;&#x40;&#103;&#105;&#x74;&#x68;&#117;&#98;&#x2e;&#99;&#111;&#109;</a>:CrazyMilk/CrazyMilk.github.io.git拷贝仓库（默认分支为hexo）；</li>
<li>在本地新拷贝的CrazyMilk.github.io文件夹下通过Git bash依次执行下列指令：npm install hexo、npm install、npm install hexo-deployer-git（记得，不需要hexo init这条指令）。</li>
</ol>
</blockquote>
<p>这样一来，hexo分支用于存放markdown等原文件，master分支用来存放生成之后的html等静态页面，可以方便的进行博客迁移和管理。</p>
]]></content>
      <categories>
        <category>tutorial</category>
      </categories>
      <tags>
        <tag>hexo</tag>
        <tag>博客</tag>
        <tag>next</tag>
      </tags>
  </entry>
  <entry>
    <title>网站备案</title>
    <url>/2018/03/13/%E7%BD%91%E7%AB%99%E5%A4%87%E6%A1%88/</url>
    <content><![CDATA[<p>Update2:</p>
<p>2018/5/15 今天上午收到工信部的邮件，审核已经通过。但是还需要再公安系统中备案。。。晚上又提交了一大推信息，等审核吧。</p>
<p>Update:</p>
<p>直接使用https协议是可以访问的。估计腾讯云只拦截未备案的http站点，现在问题就是http没办法自动跳转https。等居住证办下来再说把。</p>
<p>今天打开博客，发现无法访问了，腾讯云提示需要网站备案。打开备案网址，每个省的备案规则还不一样，江苏省备案要求非省户籍必须提供居住证明。证明链如下：</p>
<blockquote>
<p>网站备案 -&gt; 居住证明 -&gt; 房屋租赁备案证明 -&gt; 房产证</p>
</blockquote>
<p>好吧，看来居住证明是非办理不可了。</p>
<p>现在域名无法解析，暂时将nginx监听端口修改为8080，只能通过ip访问。</p>
]]></content>
      <categories>
        <category>notes</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>C++ 中的智能指针</title>
    <url>/2018/12/04/smart-pointer-in-c-plus-plus/</url>
    <content><![CDATA[<p>C++ 11中共有四种智能指针(Smart Pointers)：<code>std::auto_ptr</code>,<code>std::unique_ptr</code>,<code>std::shared_ptr</code>,<code>std::weak_ptr</code>。其中<code>std::auto_ptr</code>是在C++98中就引入的智能指针，在C++11中已经被<code>std::unique_ptr</code>所取代。所以本文主要讨论讨论剩下的三种智能指针。</p>
<span id="more"></span>

<h3 id="为什么要使用智能指针？"><a href="#为什么要使用智能指针？" class="headerlink" title="为什么要使用智能指针？"></a>为什么要使用智能指针？</h3><p>不像C#/Java等语言拥有垃圾回收机制，C++必须靠程序员自己申请和释放内存。这样就给内存泄漏带来了机会。智能指针就是为了解决可能的内存泄漏的风险而设计的。在C++中局部变量在离开作用域之后，编译器会自动调用变量的析构函数对其进行析构，即使在发生异常的情况下也可以保证对象被析构。</p>
<p>智能指针其实就是贯彻了<a href="https://en.wikipedia.org/wiki/Resource_acquisition_is_initialization"><strong>RAII</strong></a>(Resource acquisition is initialization)的思想。将Raw Pointer作为资源托管起来，在离开作用域之后，自动调用Raw pointer的deletor。智能指针就是对象。</p>
<p>查看智能指针的头文件: memory，这里摘录下MSVC的实现：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">	<span class="comment">// DECLARATIONS</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> _<span class="title">Ty</span>&gt;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">default_delete</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> _<span class="title">Ty</span>,</span></span><br><span class="line"><span class="class">	<span class="keyword">class</span> _<span class="title">Dx</span> =</span> default_delete&lt;_Ty&gt;&gt;</span><br><span class="line">	<span class="class"><span class="keyword">class</span> <span class="title">unique_ptr</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> _<span class="title">Ty</span>&gt;</span></span><br><span class="line">	<span class="class"><span class="keyword">class</span> <span class="title">shared_ptr</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> _<span class="title">Ty</span>&gt;</span></span><br><span class="line">	<span class="class"><span class="keyword">class</span> <span class="title">weak_ptr</span>;</span></span><br></pre></td></tr></table></figure>

<p>可以看到三种智能指针被声明为带有模板参数的类，其中unique_ptr带有两个模板参数，shared_ptr和weak_ptr都只有一个模板参数。</p>
<p>下面我们来分别详细来分析下三种智能指针的使用场景和一些注意事项。</p>
<h3 id="std-unique-ptr"><a href="#std-unique-ptr" class="headerlink" title="std::unique_ptr"></a>std::unique_ptr</h3><p>当需要使用智能指针时，<code>std::unique_ptr</code>应该作为首选，用来表达对资源的专属所有权。</p>
<p>当使用默认deletor时，<code>std::unique_ptr</code>跟裸指针尺寸相同，这意味着不会带来memory overhead。一个非空的<code>std::unique_ptr</code>总是指向涉及的资源。移动一个<code>std::unique_ptr</code>会将所有权将源指针移至目标指针(源指针被置空)。<code>std::unique_ptr</code>不支持复制操作。</p>
<h4 id="创建std-unique-ptr的方法"><a href="#创建std-unique-ptr的方法" class="headerlink" title="创建std::unique_ptr的方法"></a>创建std::unique_ptr的方法</h4><p>我们可以用以下方式来创建<code>std::unique_ptr</code>。</p>
<ul>
<li>通过C++14 引入的标准make函数<code>std::make_unique</code></li>
<li>直接接管newly allocated object</li>
<li>创建自己的make函数</li>
</ul>
<p>举例如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;memory&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MY_PRINT std::cout&lt;&lt; __FUNCTION__ &lt;&lt; std::endl;</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Investment</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	Investment(<span class="keyword">const</span> <span class="keyword">char</span>* name) : m_name(<span class="keyword">new</span> <span class="keyword">char</span>[<span class="number">128</span>])&#123;</span><br><span class="line">		strcpy_s(m_name, <span class="number">128</span>, name);</span><br><span class="line">		MY_PRINT;</span><br><span class="line">	&#125;</span><br><span class="line">    </span><br><span class="line">	<span class="keyword">virtual</span> ~Investment() &#123;</span><br><span class="line">		<span class="keyword">delete</span> m_name;</span><br><span class="line">		MY_PRINT;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">	<span class="keyword">char</span>* m_name;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Stock</span> :</span> <span class="keyword">public</span> Investment &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	Stock(<span class="keyword">const</span> <span class="keyword">char</span>* name) : Investment(name)&#123;</span><br><span class="line">		MY_PRINT;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	~Stock() &#123;</span><br><span class="line">		MY_PRINT;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;Investment&gt; <span class="title">makeInvestment</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="comment">//in c++ 11</span></span><br><span class="line">	<span class="comment">//std::unique_ptr&lt;Stock&gt; stock(new Stock(&quot;hello&quot;));</span></span><br><span class="line">	<span class="comment">//return stock;</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;Stock&gt;(<span class="keyword">new</span> Stock(<span class="string">&quot;hello&quot;</span>));  <span class="comment">//newly allocated object是一个右值</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;Investment&gt; <span class="title">makeInvestment2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="comment">//in c++ 14</span></span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">std</span>::make_unique&lt;Stock&gt;(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>在C++11中，由于没有引入unique_ptr的make函数，我们应该直接从new object接管pointer的控制权。如果使用以下方式来创建unique_ptr，会增加内存泄漏的风险。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">auto</span> ptr = <span class="keyword">new</span> Stock(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line"><span class="function"><span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;Investment&gt; <span class="title">pInvest</span><span class="params">(ptr)</span></span>;  </span><br></pre></td></tr></table></figure>

<p>通过左值来初始化一个unique_ptr不是一个好的选择，因为ptr这个裸指针有可能会被delete掉，而pInvest在析构的时候会再次delete 裸指针，这时会造成未定义行为。</p>
<p>Best practice是通过make函数来创建智能指针。如果使用的是C++11，还有一种方式是创建自定义的make函数。如下是一个简单的版本。当然了，也可以直接去标准库中copy make_unique函数的实现代码。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> ... Args&gt;</span><br><span class="line"><span class="function"><span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;T&gt; <span class="title">make_unique</span><span class="params">(Args&amp;&amp;... params)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;T&gt;(<span class="keyword">new</span> T(<span class="built_in">std</span>::forward&lt;Args&gt;(params)...));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="自定义deletor"><a href="#自定义deletor" class="headerlink" title="自定义deletor"></a>自定义deletor</h4><p>我们也可以为unique_ptr自定义deletor。有以下两种方式：</p>
<ul>
<li>函数对象，如lambda表达式</li>
<li>函数指针</li>
</ul>
<p>举例如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//use lambda expression	</span></span><br><span class="line"><span class="keyword">auto</span> delInvest = [](Investment* pInvestment) &#123;</span><br><span class="line">		<span class="comment">//do something</span></span><br><span class="line">		<span class="keyword">delete</span> pInvestment;</span><br><span class="line">	&#125;;</span><br><span class="line">	 </span><br><span class="line">	std::unique_ptr&lt;Investment, decltype(delInvest)&gt; ptr(new Stock(&quot;hello&quot;), delInvest);</span><br><span class="line"></span><br><span class="line"><span class="comment">//use function pointer</span></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">delInv</span><span class="params">(Investment* pInvestment)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">delete</span> pInvestment;</span><br><span class="line">	&#125;</span><br><span class="line">	 </span><br><span class="line">	std::unique_ptr&lt;Investment, void(*)(Investment* pInvestment)&gt; ptr2(new Stock(&quot;hello&quot;), delInv);</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//或者使用decltype</span></span><br><span class="line">	std::unique_ptr&lt;Investment, decltype(&amp;delInv)&gt; ptr2(new Stock(&quot;hello&quot;), delInv);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>一般来说对于std::unique_ptr，在默认deletor的情况下，unique_ptr和裸指针的大小一样，但是使用自定义的deletor之后，情况变得有所不同。如果自定义的deletor是函数指针，则unique_ptr的大小会至少增加一个函数指针的大小。如果是函数对象，则带来的尺寸变化取决于函数对象中存储了多少状态。无状态的函数对象，如无捕获的lambda表达式不会浪费任何尺寸。 </p>
<p>这意味着一个自定义deletor可以用函数指针也可以使用无捕获的lambda表达式时，lambda表达式是更好的选择。</p>
<p>注意，自定义deletor必须是一个directly-callable object，如果想让一个member function作为deletor的话，可以使用<code>std::mem_fn</code>将其转化为函数对象。</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;functional&gt; //for std::mem_fn</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;memory&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Investment::release</span><span class="params">()</span></span>&#123;  <span class="comment">//release is a member function</span></span><br><span class="line">    <span class="comment">//do something</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">std::unique_ptr&lt;Investment, decltype(std::mem_fn(&amp;Investment::release))&gt; pInvest(new Stock(&quot;hello&quot;), std::mem_fn(&amp;Investment::release));</span><br></pre></td></tr></table></figure>

<h4 id="转化为shared-ptr"><a href="#转化为shared-ptr" class="headerlink" title="转化为shared_ptr"></a>转化为shared_ptr</h4><p><code>std::unique_ptr</code>可以很方便的转换为<code>std::shared_ptr</code>，所以适合作为工厂函数的返回型别。具体可以参考《Modern Effective C++》 item18。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>&gt; unique = <span class="built_in">std</span>::make_unique&lt;<span class="built_in">std</span>::<span class="built_in">string</span>&gt;(<span class="string">&quot;test&quot;</span>);</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>&gt; shared = <span class="built_in">std</span>::move(unique);</span><br><span class="line"></span><br><span class="line"><span class="comment">//or</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>&gt; shared = <span class="built_in">std</span>::make_unique&lt;<span class="built_in">std</span>::<span class="built_in">string</span>&gt;(<span class="string">&quot;test&quot;</span>);</span><br></pre></td></tr></table></figure>

<h4 id="auto-ptr-vs-unique-ptr"><a href="#auto-ptr-vs-unique-ptr" class="headerlink" title="auto_ptr vs unique_ptr"></a>auto_ptr vs unique_ptr</h4><p>在C98标准的时候，由于没有移动语义（move sematic），引入了auto_ptr来表示对资源的所有权。在表示所有权转移的时候，auto_ptr实际是通过拷贝操作来实现的。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="built_in">std</span>::<span class="built_in">auto_ptr</span>&lt;Stock&gt; <span class="title">ap</span><span class="params">(<span class="keyword">new</span> Stock(<span class="string">&quot;hello&quot;</span>))</span></span>;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">auto_ptr</span>&lt;Stock&gt; ap2 = ap;  <span class="comment">//compile success, while unique_ptr don&#x27;t</span></span><br><span class="line"></span><br><span class="line">ap-&gt;foo();  <span class="comment">//crash because ap is set to NULL</span></span><br></pre></td></tr></table></figure>

<p>通过auto_ptr的拷贝赋值运算符之后，ap已经置为了NULL，无法再使用ap2。</p>
<p>在使用unique_ptr时，由于unique_ptr将copy ctor和copy assign operator声明为delete function，所以编译无法通过。如果想转移资源的所有权，必须使用<code>std::move</code>（位于utility头文件）。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;Stock&gt; <span class="title">up</span><span class="params">(<span class="keyword">new</span> Stock(<span class="string">&quot;hello&quot;</span>))</span></span>;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;Stock&gt; up1 = <span class="built_in">std</span>::move(up);  <span class="comment">//use std::move to explicitly transfer ownership, and up is empty, can not use it again</span></span><br><span class="line"></span><br><span class="line">up.foo();  <span class="comment">//crash, can not use up again because ownership has transferred to up1</span></span><br></pre></td></tr></table></figure>

<h4 id="unique-ptr-源码剖析"><a href="#unique-ptr-源码剖析" class="headerlink" title="unique_ptr 源码剖析"></a>unique_ptr 源码剖析</h4><p>从上面unique_ptr的声明可以看到unique_ptr的类型中第二个模板参数默认时一个<code>default_delete</code>。查看其源码发现<code>default_delete</code>就是一个定义了函数调用运算符的函数对象:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> _<span class="title">Ty</span>&gt;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">default_delete</span></span></span><br><span class="line"><span class="class">	&#123;</span>	<span class="comment">// default deleter for unique_ptr</span></span><br><span class="line">	<span class="function"><span class="keyword">constexpr</span> <span class="title">default_delete</span><span class="params">()</span> <span class="keyword">noexcept</span> </span>= <span class="keyword">default</span>;</span><br><span class="line">        <span class="comment">//...省略部分</span></span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">(_Ty * _Ptr)</span> <span class="keyword">const</span> <span class="keyword">noexcept</span></span></span><br><span class="line"><span class="function">		</span>&#123;	<span class="comment">// delete a pointer</span></span><br><span class="line">		<span class="keyword">static_assert</span>(<span class="number">0</span> &lt; <span class="keyword">sizeof</span> (_Ty),</span><br><span class="line">			<span class="string">&quot;can&#x27;t delete an incomplete type&quot;</span>);</span><br><span class="line">		<span class="keyword">delete</span> _Ptr;  <span class="comment">//调用delete</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;;</span><br></pre></td></tr></table></figure>

<p>在函数调用中直接调用delete，delete操作会调用_Ty类型的析构函数。这就是unique_ptr的默认析构所做的事。再看下unique_ptr的具体定义：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> _<span class="title">Ty</span>,</span></span><br><span class="line"><span class="class">	<span class="keyword">class</span> _<span class="title">Dx</span>&gt;</span>	<span class="comment">// = default_delete&lt;_Ty&gt;</span></span><br><span class="line">	<span class="class"><span class="keyword">class</span> <span class="title">unique_ptr</span></span></span><br><span class="line"><span class="class">		:</span> <span class="keyword">public</span> _Unique_ptr_base&lt;_Ty, _Dx&gt;</span><br><span class="line">	&#123;	<span class="comment">// non-copyable pointer to an object</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="comment">//...省略</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>unique_ptr继承自<code>_Unique_ptr_base&lt;_Ty, _Dx&gt;</code>，继续看<code>_Unique_ptr_base&lt;_Ty, _Dx&gt;</code>的代码，其中包含一个成员变量：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">_Compressed_pair&lt;_Dx, pointer&gt; _Mypair;</span><br></pre></td></tr></table></figure>

<p>这里的pointer就是unique_ptr实际的对象的指针。接着在头文件<code>xutility</code>中可以看到<code>_Compressed_pair</code>的两个定义：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//定义1</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> _<span class="title">Ty1</span>,</span></span><br><span class="line"><span class="class">	<span class="keyword">class</span> _<span class="title">Ty2</span>,</span></span><br><span class="line"><span class="class">	<span class="title">bool</span> =</span> is_empty_v&lt;_Ty1&gt; &amp;&amp; !is_final_v&lt;_Ty1&gt;&gt;</span><br><span class="line">	<span class="class"><span class="keyword">class</span> _<span class="title">Compressed_pair</span> <span class="keyword">final</span></span></span><br><span class="line"><span class="class">		:</span> <span class="keyword">private</span> _Ty1</span><br><span class="line">	&#123;	<span class="comment">// store a pair of values, deriving from empty first</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	_Ty2 _Myval2;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">using</span> _Mybase = _Ty1;	<span class="comment">// for visualization</span></span><br><span class="line">	<span class="comment">//...省略</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//定义2</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> _<span class="title">Ty1</span>,</span></span><br><span class="line"><span class="class">	<span class="keyword">class</span> _<span class="title">Ty2</span>&gt;</span></span><br><span class="line">	<span class="class"><span class="keyword">class</span> _<span class="title">Compressed_pair</span>&lt;</span>_Ty1, _Ty2, <span class="literal">false</span>&gt; <span class="keyword">final</span></span><br><span class="line">	&#123;	<span class="comment">// store a pair of values, not deriving from first</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	_Ty1 _Myval1;</span><br><span class="line">	_Ty2 _Myval2;</span><br><span class="line">        <span class="comment">//...省略</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>这两个定义的区别直观上来说声明的内部成员变量不同，一个只有一个实际对象的指针（_Ty2）,另外一个不仅有_Ty2，还包含deletor类型变量。换句话说，这个区别影响了unique_ptr指针所占用的内存大小。</p>
<p><code>_Ty1</code>就是<code>_Dx</code>，也就是deletor的类型，<code>_Ty2</code>也就是unique_ptr实际指向的对象的指针。这里应该是通过重载的机制，让编译器去选择实例化哪个<code>_Compressed_pair</code>模板的代码。这个判断条件就是:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">is_empty_v&lt;_Ty1&gt; &amp;&amp; !is_final_v&lt;_Ty1&gt;</span><br></pre></td></tr></table></figure>

<p>查询cpp reference可以<code>is_empty_v</code>用来标识类是否是一个empty类</p>
<blockquote>
<p>Trait class that identifies whether <em>T</em> is an empty class.</p>
<p>An empty class is a class that stores no data, either cv-qualified or not.  </p>
</blockquote>
<p><code>is_final_v</code>用来标识是否是final类（使用final关键字声明类）。</p>
<p>至此我们可以看到unique_ptr所占空间的大小跟deletor有关，如果使用默认的deletor，则显然<code>default_delete</code>是一个空类，那么unique_ptr跟裸指针具有相同的大小。而如果自定义的deletor（可以理解为function object）包含了其他的data，则unique_ptr的大小是裸指针和function object占用大小之和。</p>
<h3 id="std-shared-ptr"><a href="#std-shared-ptr" class="headerlink" title="std::shared_ptr"></a>std::shared_ptr</h3><h4 id="控制块"><a href="#控制块" class="headerlink" title="控制块"></a>控制块</h4><p>和<code>std::unique_ptr</code>用来表示对资源的独占性相反，<code>std::shared_ptr</code>用来表示对资源的共享。创建的shared_ptr对象共享同一个资源。shared_ptr在内部实现使用引用计数的方式。每个<code>shared_ptr&lt;T&gt;</code>对象都包含两个部分，一个是指向T型别对象的指针，一个是指向控制块的指针，如下图：</p>
<img src="/2018/12/04/smart-pointer-in-c-plus-plus/shared_ptr%20memory%20layout.png" class="">

<p>很显然，从shared_ptr的memory layout可以看到，shared_ptr的大小为裸指针的两倍。</p>
<p>注意：<strong>必须保证对同一个资源只创建一个控制块</strong>。因为当控制块中的引用计数为0时，资源被销毁。如果违反了这个约定，资源会被“销毁两次”，也就是说会造成未定义行为。控制块需要动态分配。控制块的创建遵循以下规则：</p>
<ul>
<li>std::make_shared总是创建一个控制块</li>
<li>从具备专属所有权的指针(即unique_ptr或auto_ptr指针)出发构造一个shared_ptr时，会创建一个控制块。</li>
<li>使用裸指针作为实参来调用（创建）shared_ptr时，会创建一个控制块。如果使用shared_ptr或者weak_ptr来创建shared_ptr，则不会创建控制块。</li>
</ul>
<h4 id="创建std-shared-ptr"><a href="#创建std-shared-ptr" class="headerlink" title="创建std::shared_ptr"></a>创建std::shared_ptr</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Stock和Investment接上面unique_ptr中的定义</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//通过make函数构造</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;Stock&gt; ptr = <span class="built_in">std</span>::make_shared&lt;Stock&gt;(<span class="string">&quot;hello&quot;</span>);  <span class="comment">//创建一个控制块</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//通过传递右值构造</span></span><br><span class="line"><span class="function"><span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;Stock&gt; <span class="title">ptr</span><span class="params">(<span class="keyword">new</span> Stock(<span class="string">&quot;hello&quot;</span>))</span></span>;  <span class="comment">//创建一个控制块</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//bad code: 通过裸指针，左值构造</span></span><br><span class="line"><span class="keyword">auto</span> raw_ptr = <span class="keyword">new</span> Stock(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line"><span class="function"><span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;Stock&gt; <span class="title">ptr1</span><span class="params">(raw_ptr)</span></span>;  <span class="comment">//为raw_ptr创建了一个控制块</span></span><br><span class="line"><span class="function"><span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;Stock&gt; <span class="title">ptr2</span><span class="params">(raw_ptr)</span></span>;  <span class="comment">//又创建了一个控制块，在析构时，会造成未定义行为。</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;Stock&gt; <span class="title">ptr3</span><span class="params">(ptr1)</span></span>;  <span class="comment">//从一个已有的shared_ptr创建另一个shared_ptr，调用shared_ptr的copy ctor，不会再次创建控制块，</span></span><br></pre></td></tr></table></figure>

<p>Best Practice是使用make函数来构造shared_ptr。最后的例子通过裸指针来构造，会为同一个资源创建两个控制块，也就是会有两个引用计数，当一个引用计数为0时，会发生析构，这样会对同一个资源析构两次，造成未定义行为。</p>
<h4 id="自定义deletor-1"><a href="#自定义deletor-1" class="headerlink" title="自定义deletor"></a>自定义deletor</h4><p>在unique_ptr的类型中，自定义的deletor是作为一个模板参数，所以deletor的型别是作为unique_ptr型别的一部分的，而shared_ptr则不一样。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">delete_stock</span><span class="params">(Stock* s)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">delete</span> s;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> stockDeletor = [](Stock* s) &#123;</span><br><span class="line">		<span class="comment">//logsomething();</span></span><br><span class="line">		<span class="keyword">delete</span> s;</span><br><span class="line">	&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//自定义析构</span></span><br><span class="line"><span class="function"><span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;Stock&gt; <span class="title">ptr1</span><span class="params">(<span class="keyword">new</span> Stock(<span class="string">&quot;hello&quot;</span>), stockDeletor)</span></span>;</span><br><span class="line"><span class="function"><span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;Stock&gt; <span class="title">ptr2</span><span class="params">(<span class="keyword">new</span> Stock(<span class="string">&quot;hello&quot;</span>), delete_stock)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;Stock&gt;&gt; v&#123;ptr1, ptr2&#125;;  <span class="comment">//不同的deletor，但是属于同一个类型，可以放在vector容器中，如果是unique_ptr，则不行</span></span><br></pre></td></tr></table></figure>

<h4 id="shared-from-this"><a href="#shared-from-this" class="headerlink" title="shared_from_this"></a>shared_from_this</h4><p>考虑这样一种情况，如果使用this指针直接来创建shared_ptr，会发生什么。以下代码来自<a href="https://en.cppreference.com/w/cpp/memory/enable_shared_from_this">cpp reference</a>：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Good</span>:</span> <span class="built_in">std</span>::enable_shared_from_this&lt;Good&gt; <span class="comment">// note: public inheritance</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;Good&gt; <span class="title">getptr</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> shared_from_this();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Bad</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="function"><span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;Bad&gt; <span class="title">getptr</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;Bad&gt;(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    ~Bad() &#123; <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Bad::~Bad() called\n&quot;</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//example 1</span></span><br><span class="line">    <span class="comment">// Good: the two shared_ptr&#x27;s share the same object</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;Good&gt; gp1 = <span class="built_in">std</span>::make_shared&lt;Good&gt;();</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;Good&gt; gp2 = gp1-&gt;getptr();</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;gp2.use_count() = &quot;</span> &lt;&lt; gp2.use_count() &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">//example 2</span></span><br><span class="line">    <span class="comment">// Bad: shared_from_this is called without having std::shared_ptr owning the caller </span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        Good not_so_good;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;Good&gt; gp1 = not_so_good.getptr();</span><br><span class="line">    &#125; <span class="keyword">catch</span>(<span class="built_in">std</span>::bad_weak_ptr&amp; e) &#123;</span><br><span class="line">        <span class="comment">// undefined behavior (until C++17) and std::bad_weak_ptr thrown (since C++17)</span></span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; e.what() &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;    </span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">//example 3</span></span><br><span class="line">    <span class="comment">// Bad, each shared_ptr thinks it&#x27;s the only owner of the object</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;Bad&gt; bp1 = <span class="built_in">std</span>::make_shared&lt;Bad&gt;();</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;Bad&gt; bp2 = bp1-&gt;getptr();</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;bp2.use_count() = &quot;</span> &lt;&lt; bp2.use_count() &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">&#125; <span class="comment">// UB: double-delete of Bad</span></span><br></pre></td></tr></table></figure>

<p>在example 3，使用make函数来创建bp1，这是会创建一个控制块，后面又通过this裸指针又会创建一个控制块，所以会发生double delete。</p>
<p>在标准库中已经提供了<code>enable_shared_from_this</code>模板来解决这个问题。让类继承自<code>enable_shared_from_this</code>的特化版本，这个模板提供一个<code>shared_from_this</code>成员函数，可以使用这个成员函数来构造新的shared_ptr。但是注意，必须当前shared_ptr已经有一个相关联的控制块之后，才可以安全的使用<code>shared_from_this</code>，否则也会发生未定义行为。如上面的example 2。</p>
<h3 id="std-weak-ptr"><a href="#std-weak-ptr" class="headerlink" title="std::weak_ptr"></a>std::weak_ptr</h3><h4 id="weak-ptr-vs-shared-ptr"><a href="#weak-ptr-vs-shared-ptr" class="headerlink" title="weak_ptr vs shared_ptr"></a>weak_ptr vs shared_ptr</h4><p>weak_ptr并不是一种独立的智能指针，是对shared_ptr的一种扩充。<strong>weak_ptr不能直接由裸指针来构造，只能通过shared_ptr或者其他的weak_ptr来构造</strong>。cpp reference对weak_ptr的定义：</p>
<blockquote>
<p><code>std::weak_ptr</code> is a smart pointer that holds a non-owning (“weak”) reference to an object that is managed by <a href="https://en.cppreference.com/w/cpp/memory/shared_ptr">std::shared_ptr</a>. It must be converted to <a href="https://en.cppreference.com/w/cpp/memory/shared_ptr">std::shared_ptr</a> in order to access the referenced object.</p>
</blockquote>
<p>weak_ptr并不影响指向同一个资源对象的shared_ptr的引用计数，换句话说，weak_ptr不影响对象的共享所有权。前面在shared_ptr中提到的控制块中包含一个弱引用计数，weak_ptr影响的就是这个弱引用计数。当这个弱引用计数为0时，也即没有shared_ptr涉及到这个对象时，weak_ptr失效（过期）。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//call use_count function to get the numbers of shared_ptr instances that</span></span><br><span class="line">   <span class="comment">//shared ownship of the managed object, if 0 then the object has been deleted</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;Stock&gt; sp = <span class="built_in">std</span>::make_shared&lt;Stock&gt;(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; sp.use_count() &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;  <span class="comment">//1</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">std</span>::weak_ptr&lt;Stock&gt; wp = sp;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; sp.use_count() &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;  <span class="comment">//1</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; wp.use_count() &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;  <span class="comment">//1</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">std</span>::weak_ptr&lt;Stock&gt; wp2 = wp;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; wp.use_count() &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;  <span class="comment">//1</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; wp2.use_count() &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">//1</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;Stock&gt; sp2 = wp.lock();  <span class="comment">//use lock to get a shared_ptr instance</span></span><br><span class="line"><span class="keyword">if</span> (sp2) &#123;</span><br><span class="line">	<span class="comment">//sp2 not null</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">	<span class="comment">//sp2 null, mean weak_ptr is expired</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在weak_ptr中使用<code>lock</code>方法来新建一个shared_ptr对象并返回，如果为空，则说明weak_ptr已经过期。也可以使用<code>expired</code>来检测weak_ptr是否过期，在多线程的环境中，可能会带来竞争风险。所以还是推荐使用<code>lock</code>方法。</p>
<h4 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h4><p>weak_ptr可以有以下几种使用场景。</p>
<ul>
<li>用作cache（缓存）</li>
<li>观察者模式</li>
<li>避免shared_ptr指针环路</li>
</ul>
<h5 id="用作cache（缓存）"><a href="#用作cache（缓存）" class="headerlink" title="用作cache（缓存）"></a>用作cache（缓存）</h5><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//use weak_ptr in cache scenario</span></span><br><span class="line"><span class="function"><span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;Widget&gt; <span class="title">loadWidget</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">std</span>::make_shared&lt;Widget&gt;();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;Widget&gt; <span class="title">fast_load_widget</span><span class="params">(<span class="keyword">int</span> id)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">static</span> <span class="built_in">std</span>::<span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="built_in">std</span>::weak_ptr&lt;Widget&gt;&gt; cache;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">auto</span> sp = cache[id].lock();  <span class="comment">//check if exist in cache</span></span><br><span class="line">	<span class="keyword">if</span> (!sp) &#123;</span><br><span class="line">		sp = loadWidget();</span><br><span class="line">		cache[id] = sp;  <span class="comment">//put to cache</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> sp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="观察者模式"><a href="#观察者模式" class="headerlink" title="观察者模式"></a>观察者模式</h5><p>Subject类有一个vector容器，用于保存observers，当需要通知observer时，先检查observer是否还有效。注意：通过<code>std::make_shared</code>创建了一个临时的shared_ptr直接复制给weak_ptr，这个时候shared_ptr即被销毁。在调用<code>lock</code>测试weak_ptr是否过期时，这个observer是过期的。所以在测试函数中另外一个observer能收到通知。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Observer</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">DoStuff</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Got notified&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Subject</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">Notify</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">auto</span>&amp; ob : m_obs) &#123;</span><br><span class="line">			<span class="keyword">auto</span> sp = ob.lock();  <span class="comment">//convert to shared_ptr</span></span><br><span class="line">			<span class="keyword">if</span> (sp) &#123;  <span class="comment">//test if converted shared_ptr is valid</span></span><br><span class="line">				sp-&gt;DoStuff();</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">AddToObserver</span><span class="params">(<span class="built_in">std</span>::weak_ptr&lt;Observer&gt;&amp; ob)</span> </span>&#123;</span><br><span class="line">		m_obs.push_back(ob);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::weak_ptr&lt;Observer&gt;&gt; m_obs;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test_observer_pattern_using_weak_ptr</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	Subject s;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">auto</span> sp = <span class="built_in">std</span>::make_shared&lt;Observer&gt;();  <span class="comment">//make a shared_ptr obj</span></span><br><span class="line">	<span class="built_in">std</span>::weak_ptr&lt;Observer&gt; ob1 = <span class="built_in">std</span>::make_shared&lt;Observer&gt;();  <span class="comment">//make a temp shared_ptr, after the assignment, shared_ptr is deleted</span></span><br><span class="line">	<span class="function"><span class="built_in">std</span>::weak_ptr&lt;Observer&gt; <span class="title">ob2</span><span class="params">(sp)</span></span>;  <span class="comment">//only this observer can receive notification!!!</span></span><br><span class="line"></span><br><span class="line">	s.AddToObserver(ob1);  </span><br><span class="line">	s.AddToObserver(ob2);</span><br><span class="line"></span><br><span class="line">	s.Notify();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="避免shared-ptr指针环路"><a href="#避免shared-ptr指针环路" class="headerlink" title="避免shared_ptr指针环路"></a>避免shared_ptr指针环路</h5><img src="/2018/12/04/smart-pointer-in-c-plus-plus/avoid_shared_ptr_loop.png" class="">

<p>A, C都共享B，如果B需要保有一个对A的指针，这时候如果使用shared_ptr的话，会造成shared_ptr 环路，A, B互相保持引用，这样A和B的引用计数都不为0，无法析构，造成内存泄漏。</p>
<p>weak_ptr可以避免这个问题。当A的引用计数为0，即使B保有一个指向A的weak_ptr，不影响A被销毁。</p>
<h3 id="Make函数的几个注意点"><a href="#Make函数的几个注意点" class="headerlink" title="Make函数的几个注意点"></a>Make函数的几个注意点</h3><p>在使用智能指针时，Best Practice都是使用make函数来创建。特别是对于shared_ptr， 因为与之相关的控制块需要动态分配，如果使用make函数，则可以进行一次系统调用来分配内存（包含控制块和shared_ptr对象的内存）。而如果使用先创建裸指针，然后再创建shared_ptr的方法，需要进行两次系统调用来申请内存。这样做带来裸指针安全性的问题，也增加的性能上的开销。</p>
<p>当然了，make函数也不是万能的，如果需要使用自定义的deletor，那么只能通过其他方式来创建智能指针。</p>
<p>本文主要参考了Scott Meyers大师的  ***Effective Modern C++***，可以直接在网络上阅读：<a href="https://www.oreilly.com/library/view/effective-modern-c/9781491908419/ch04.html">地址在这</a>.</p>
<h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><ul>
<li>Scott Meyers <em><strong>Effective Modern C++</strong></em></li>
<li><a href="https://herbsutter.com/2013/06/05/gotw-91-solution-smart-pointer-parameters/">GotW91: Smart Pointer Parameters</a></li>
<li><a href="https://www.acodersjourney.com/top-10-dumb-mistakes-avoid-c-11-smart-pointers/">top-10-dumb-mistakes-avoid-c-11-smart-pointers</a></li>
</ul>
]]></content>
      <categories>
        <category>coding</category>
      </categories>
      <tags>
        <tag>c++</tag>
      </tags>
  </entry>
  <entry>
    <title>cpp core guidelines</title>
    <url>/2018/07/13/cpp-core-guidelines/</url>
    <content><![CDATA[<p>在github上看到的一片文章，转载到此。</p>
<span id="more"></span>

<h1 id="C-Core-Guidelines"><a href="#C-Core-Guidelines" class="headerlink" title="C++ Core Guidelines"></a><a name="main"></a>C++ Core Guidelines</h1><p>April 16, 2018</p>
<p>Editors:</p>
<ul>
<li><a href="http://www.stroustrup.com/">Bjarne Stroustrup</a></li>
<li><a href="http://herbsutter.com/">Herb Sutter</a></li>
</ul>
<p>This is a living document under continuous improvement.<br>Had it been an open-source (code) project, this would have been release 0.8.<br>Copying, use, modification, and creation of derivative works from this project is licensed under an MIT-style license.<br>Contributing to this project requires agreeing to a Contributor License. See the accompanying <a href="LICENSE">LICENSE</a> file for details.<br>We make this project available to “friendly users” to use, copy, modify, and derive from, hoping for constructive input.</p>
<p>Comments and suggestions for improvements are most welcome.<br>We plan to modify and extend this document as our understanding improves and the language and the set of available libraries improve.<br>When commenting, please note <a href="#S-introduction">the introduction</a> that outlines our aims and general approach.<br>The list of contributors is <a href="#SS-ack">here</a>.</p>
<p>Problems:</p>
<ul>
<li>The sets of rules have not been completely checked for completeness, consistency, or enforceability.</li>
<li>Triple question marks (???) mark known missing information</li>
<li>Update reference sections; many pre-C++11 sources are too old.</li>
<li>For a more-or-less up-to-date to-do list see: <a href="#S-unclassified">To-do: Unclassified proto-rules</a></li>
</ul>
<p>You can <a href="#S-abstract">read an explanation of the scope and structure of this Guide</a> or just jump straight in:</p>
<ul>
<li><a href="#S-introduction">In: Introduction</a></li>
<li><a href="#S-philosophy">P: Philosophy</a></li>
<li><a href="#S-interfaces">I: Interfaces</a></li>
<li><a href="#S-functions">F: Functions</a></li>
<li><a href="#S-class">C: Classes and class hierarchies</a></li>
<li><a href="#S-enum">Enum: Enumerations</a></li>
<li><a href="#S-resource">R: Resource management</a></li>
<li><a href="#S-expr">ES: Expressions and statements</a></li>
<li><a href="#S-performance">Per: Performance</a></li>
<li><a href="#S-concurrency">CP: Concurrency and parallelism</a></li>
<li><a href="#S-errors">E: Error handling</a></li>
<li><a href="#S-const">Con: Constants and immutability</a></li>
<li><a href="#S-templates">T: Templates and generic programming</a></li>
<li><a href="#S-cpl">CPL: C-style programming</a></li>
<li><a href="#S-source">SF: Source files</a></li>
<li><a href="#S-stdlib">SL: The Standard Library</a></li>
</ul>
<p>Supporting sections:</p>
<ul>
<li><a href="#S-A">A: Architectural ideas</a></li>
<li><a href="#S-not">NR: Non-Rules and myths</a></li>
<li><a href="#S-references">RF: References</a></li>
<li><a href="#S-profile">Pro: Profiles</a></li>
<li><a href="#S-gsl">GSL: Guideline support library</a></li>
<li><a href="#S-naming">NL: Naming and layout rules</a></li>
<li><a href="#S-faq">FAQ: Answers to frequently asked questions</a></li>
<li><a href="#S-libraries">Appendix A: Libraries</a></li>
<li><a href="#S-modernizing">Appendix B: Modernizing code</a></li>
<li><a href="#S-discussion">Appendix C: Discussion</a></li>
<li><a href="#S-tools">Appendix D: Supporting tools</a></li>
<li><a href="#S-glossary">Glossary</a></li>
<li><a href="#S-unclassified">To-do: Unclassified proto-rules</a></li>
</ul>
<p>You can sample rules for specific language features:</p>
<ul>
<li>assignment:<br><a href="#Rc-regular">regular types</a> –<br><a href="#Rc-initialize">prefer initialization</a> –<br><a href="#Rc-copy-semantics">copy</a> –<br><a href="#Rc-move-semantics">move</a> –<br><a href="#Rc-matched">other operations</a> –<br><a href="#Rc-eqdefault">default</a></li>
<li><code>class</code>:<br><a href="#Rc-org">data</a> –<br><a href="#Rc-struct">invariant</a> –<br><a href="#Rc-member">members</a> –<br><a href="#Rc-helper">helpers</a> –<br><a href="#SS-concrete">concrete types</a> –<br><a href="#S-ctor">ctors, =, and dtors</a> –<br><a href="#SS-hier">hierarchy</a> –<br><a href="#SS-overload">operators</a></li>
<li><code>concept</code>:<br><a href="#SS-concepts">rules</a> –<br><a href="#Rt-raise">in generic programming</a> –<br><a href="#Rt-concepts">template arguments</a> –<br><a href="#Rt-low">semantics</a></li>
<li>constructor:<br><a href="#Rc-struct">invariant</a> –<br><a href="#Rc-ctor">establish invariant</a> –<br><a href="#Rc-throw"><code>throw</code></a> –<br><a href="#Rc-default0">default</a> –<br><a href="#Rc-default">not needed</a> –<br><a href="#Rc-explicit"><code>explicit</code></a> –<br><a href="#Rc-delegating">delegating</a> –<br><a href="#Rc-ctor-virtual"><code>virtual</code></a></li>
<li>derived <code>class</code>:<br><a href="#Rh-domain">when to use</a> –<br><a href="#Rh-abstract">as interface</a> –<br><a href="#Rh-dtor">destructors</a> –<br><a href="#Rh-copy">copy</a> –<br><a href="#Rh-get">getters and setters</a> –<br><a href="#Rh-mi-interface">multiple inheritance</a> –<br><a href="#Rh-using">overloading</a> –<br><a href="#Rc-copy-virtual">slicing</a> –<br><a href="#Rh-dynamic_cast"><code>dynamic_cast</code></a></li>
<li>destructor:<br><a href="#Rc-matched">and constructors</a> –<br><a href="#Rc-dtor">when needed?</a> –<br><a href="#Rc-dtor-fail">may not fail</a></li>
<li>exception:<br><a href="#S-errors">errors</a> –<br><a href="#Re-throw"><code>throw</code></a> –<br><a href="#Re-errors">for errors only</a> –<br><a href="#Re-noexcept"><code>noexcept</code></a> –<br><a href="#Re-catch">minimize <code>try</code></a> –<br><a href="#Re-no-throw-codes">what if no exceptions?</a></li>
<li><code>for</code>:<br><a href="#Res-for-range">range-for and for</a> –<br><a href="#Res-for-while">for and while</a> –<br><a href="#Res-for-init">for-initializer</a> –<br><a href="#Res-empty">empty body</a> –<br><a href="#Res-loop-counter">loop variable</a> –<br><a href="#Res-???">loop variable type ???</a></li>
<li>function:<br><a href="#Rf-package">naming</a> –<br><a href="#Rf-logical">single operation</a> –<br><a href="#Rf-noexcept">no throw</a> –<br><a href="#Rf-smart">arguments</a> –<br><a href="#Rf-conventional">argument passing</a> –<br><a href="#Rf-out-multi">multiple return values</a> –<br><a href="#Rf-return-ptr">pointers</a> –<br><a href="#Rf-capture-vs-overload">lambdas</a></li>
<li><code>inline</code>:<br><a href="#Rf-inline">small functions</a> –<br><a href="#Rs-inline">in headers</a></li>
<li>initialization:<br><a href="#Res-always">always</a> –<br><a href="#Res-list">prefer <code>&#123;&#125;</code></a> –<br><a href="#Res-lambda-init">lambdas</a> –<br><a href="#Rc-in-class-initializer">in-class initializers</a> –<br><a href="#Rc-initialize">class members</a> –<br><a href="#Rc-factory">factory functions</a></li>
<li>lambda expression:<br><a href="#SS-lambdas">when to use</a></li>
<li>operator:<br><a href="#Ro-conventional">conventional</a> –<br><a href="#Ro-conversion">avoid conversion operators</a> –<br><a href="#Ro-lambda">and lambdas</a></li>
<li><code>public</code>, <code>private</code>, and <code>protected</code>:<br><a href="#Rc-private">information hiding</a> –<br><a href="#Rh-public">consistency</a> –<br><a href="#Rh-protected"><code>protected</code></a></li>
<li><code>static_assert</code>:<br><a href="#Rp-compile-time">compile-time checking</a> –<br><a href="#Rt-check-class">and concepts</a></li>
<li><code>struct</code>:<br><a href="#Rc-org">for organizing data</a> –<br><a href="#Rc-struct">use if no invariant</a> –<br><a href="#Rc-class">no private members</a></li>
<li><code>template</code>:<br><a href="#Rt-raise">abstraction</a> –<br><a href="#Rt-cont">containers</a> –<br><a href="#Rt-concepts">concepts</a></li>
<li><code>unsigned</code>:<br><a href="#Res-mix">and signed</a> –<br><a href="#Res-unsigned">bit manipulation</a></li>
<li><code>virtual</code>:<br><a href="#Ri-abstract">interfaces</a> –<br><a href="#Rc-concrete">not <code>virtual</code></a> –<br><a href="#Rc-dtor-virtual">destructor</a> –<br><a href="#Rc-dtor-fail">never fail</a></li>
</ul>
<p>You can look at design concepts used to express the rules:</p>
<ul>
<li>assertion: ???</li>
<li>error: ???</li>
<li>exception: exception guarantee (???)</li>
<li>failure: ???</li>
<li>invariant: ???</li>
<li>leak: ???</li>
<li>library: ???</li>
<li>precondition: ???</li>
<li>postcondition: ???</li>
<li>resource: ???</li>
</ul>
<h1 id="Abstract"><a href="#Abstract" class="headerlink" title="Abstract"></a><a name="S-abstract"></a>Abstract</h1><p>This document is a set of guidelines for using C++ well.<br>The aim of this document is to help people to use modern C++ effectively.<br>By “modern C++” we mean C++17, C++14, and C++11.<br>In other words, what would you like your code to look like in 5 years’ time, given that you can start now? In 10 years’ time?</p>
<p>The guidelines are focused on relatively high-level issues, such as interfaces, resource management, memory management, and concurrency.<br>Such rules affect application architecture and library design.<br>Following the rules will lead to code that is statically type safe, has no resource leaks, and catches many more programming logic errors than is common in code today.<br>And it will run fast – you can afford to do things right.</p>
<p>We are less concerned with low-level issues, such as naming conventions and indentation style.<br>However, no topic that can help a programmer is out of bounds.</p>
<p>Our initial set of rules emphasizes safety (of various forms) and simplicity.<br>They may very well be too strict.<br>We expect to have to introduce more exceptions to better accommodate real-world needs.<br>We also need more rules.</p>
<p>You will find some of the rules contrary to your expectations or even contrary to your experience.<br>If we haven’t suggested you change your coding style in any way, we have failed!<br>Please try to verify or disprove rules!<br>In particular, we’d really like to have some of our rules backed up with measurements or better examples.</p>
<p>You will find some of the rules obvious or even trivial.<br>Please remember that one purpose of a guideline is to help someone who is less experienced or coming from a different background or language to get up to speed.</p>
<p>Many of the rules are designed to be supported by an analysis tool.<br>Violations of rules will be flagged with references (or links) to the relevant rule.<br>We do not expect you to memorize all the rules before trying to write code.<br>One way of thinking about these guidelines is as a specification for tools that happens to be readable by humans.</p>
<p>The rules are meant for gradual introduction into a code base.<br>We plan to build tools for that and hope others will too.</p>
<p>Comments and suggestions for improvements are most welcome.<br>We plan to modify and extend this document as our understanding improves and the language and the set of available libraries improve.</p>
<h1 id="In-Introduction"><a href="#In-Introduction" class="headerlink" title="In: Introduction"></a><a name="S-introduction"></a>In: Introduction</h1><p>This is a set of core guidelines for modern C++, C++17, C++14, and C++11, taking likely future enhancements and ISO Technical Specifications (TSs) into account.<br>The aim is to help C++ programmers to write simpler, more efficient, more maintainable code.</p>
<p>Introduction summary:</p>
<ul>
<li><a href="#SS-readers">In.target: Target readership</a></li>
<li><a href="#SS-aims">In.aims: Aims</a></li>
<li><a href="#SS-non">In.not: Non-aims</a></li>
<li><a href="#SS-force">In.force: Enforcement</a></li>
<li><a href="#SS-struct">In.struct: The structure of this document</a></li>
<li><a href="#SS-sec">In.sec: Major sections</a></li>
</ul>
<h2 id="In-target-Target-readership"><a href="#In-target-Target-readership" class="headerlink" title="In.target: Target readership"></a><a name="SS-readers"></a>In.target: Target readership</h2><p>All C++ programmers. This includes <a href="#S-cpl">programmers who might consider C</a>.</p>
<h2 id="In-aims-Aims"><a href="#In-aims-Aims" class="headerlink" title="In.aims: Aims"></a><a name="SS-aims"></a>In.aims: Aims</h2><p>The purpose of this document is to help developers to adopt modern C++ (C++17, C++14, and C++11) and to achieve a more uniform style across code bases.</p>
<p>We do not suffer the delusion that every one of these rules can be effectively applied to every code base. Upgrading old systems is hard. However, we do believe that a program that uses a rule is less error-prone and more maintainable than one that does not. Often, rules also lead to faster/easier initial development.<br>As far as we can tell, these rules lead to code that performs as well or better than older, more conventional techniques; they are meant to follow the zero-overhead principle (“what you don’t use, you don’t pay for” or “when you use an abstraction mechanism appropriately, you get at least as good performance as if you had handcoded using lower-level language constructs”).<br>Consider these rules ideals for new code, opportunities to exploit when working on older code, and try to approximate these ideals as closely as feasible.<br>Remember:</p>
<h3 id="In-0-Don’t-panic"><a href="#In-0-Don’t-panic" class="headerlink" title="In.0: Don’t panic!"></a><a name="R0"></a>In.0: Don’t panic!</h3><p>Take the time to understand the implications of a guideline rule on your program.</p>
<p>These guidelines are designed according to the “subset of superset” principle (<a href="#Stroustrup05">Stroustrup05</a>).<br>They do not simply define a subset of C++ to be used (for reliability, safety, performance, or whatever).<br>Instead, they strongly recommend the use of a few simple “extensions” (<a href="#S-gsl">library components</a>)<br>that make the use of the most error-prone features of C++ redundant, so that they can be banned (in our set of rules).</p>
<p>The rules emphasize static type safety and resource safety.<br>For that reason, they emphasize possibilities for range checking, for avoiding dereferencing <code>nullptr</code>, for avoiding dangling pointers, and the systematic use of exceptions (via RAII).<br>Partly to achieve that and partly to minimize obscure code as a source of errors, the rules also emphasize simplicity and the hiding of necessary complexity behind well-specified interfaces.</p>
<p>Many of the rules are prescriptive.<br>We are uncomfortable with rules that simply state “don’t do that!” without offering an alternative.<br>One consequence of that is that some rules can be supported only by heuristics, rather than precise and mechanically verifiable checks.<br>Other rules articulate general principles. For these more general rules, more detailed and specific rules provide partial checking.</p>
<p>These guidelines address the core of C++ and its use.<br>We expect that most large organizations, specific application areas, and even large projects will need further rules, possibly further restrictions, and further library support.<br>For example, hard-real-time programmers typically can’t use free store (dynamic memory) freely and will be restricted in their choice of libraries.<br>We encourage the development of such more specific rules as addenda to these core guidelines.<br>Build your ideal small foundation library and use that, rather than lowering your level of programming to glorified assembly code.</p>
<p>The rules are designed to allow <a href="#S-modernizing">gradual adoption</a>.</p>
<p>Some rules aim to increase various forms of safety while others aim to reduce the likelihood of accidents, many do both.<br>The guidelines aimed at preventing accidents often ban perfectly legal C++.<br>However, when there are two ways of expressing an idea and one has shown itself a common source of errors and the other has not, we try to guide programmers towards the latter.</p>
<h2 id="In-not-Non-aims"><a href="#In-not-Non-aims" class="headerlink" title="In.not: Non-aims"></a><a name="SS-non"></a>In.not: Non-aims</h2><p>The rules are not intended to be minimal or orthogonal.<br>In particular, general rules can be simple, but unenforceable.<br>Also, it is often hard to understand the implications of a general rule.<br>More specialized rules are often easier to understand and to enforce, but without general rules, they would just be a long list of special cases.<br>We provide rules aimed at helping novices as well as rules supporting expert use.<br>Some rules can be completely enforced, but others are based on heuristics.</p>
<p>These rules are not meant to be read serially, like a book.<br>You can browse through them using the links.<br>However, their main intended use is to be targets for tools.<br>That is, a tool looks for violations and the tool returns links to violated rules.<br>The rules then provide reasons, examples of potential consequences of the violation, and suggested remedies.</p>
<p>These guidelines are not intended to be a substitute for a tutorial treatment of C++.<br>If you need a tutorial for some given level of experience, see <a href="#S-references">the references</a>.</p>
<p>This is not a guide on how to convert old C++ code to more modern code.<br>It is meant to articulate ideas for new code in a concrete fashion.<br>However, see <a href="#S-modernizing">the modernization section</a> for some possible approaches to modernizing/rejuvenating/upgrading.<br>Importantly, the rules support gradual adoption: It is typically infeasible to completely convert a large code base all at once.</p>
<p>These guidelines are not meant to be complete or exact in every language-technical detail.<br>For the final word on language definition issues, including every exception to general rules and every feature, see the ISO C++ standard.</p>
<p>The rules are not intended to force you to write in an impoverished subset of C++.<br>They are <em>emphatically</em> not meant to define a, say, Java-like subset of C++.<br>They are not meant to define a single “one true C++” language.<br>We value expressiveness and uncompromised performance.</p>
<p>The rules are not value-neutral.<br>They are meant to make code simpler and more correct/safer than most existing C++ code, without loss of performance.<br>They are meant to inhibit perfectly valid C++ code that correlates with errors, spurious complexity, and poor performance.</p>
<p>The rules are not perfect.<br>A rule can do harm by prohibiting something that is useful in a given situation.<br>A rule can do harm by failing to prohibit something that enables a serious error in a given situation.<br>A rule can do a lot of harm by being vague, ambiguous, unenforceable, or by enabling every solution to a problem.<br>It is impossible to completely meet the “do no harm” criteria.<br>Instead, our aim is the less ambitious: “Do the most good for most programmers”;<br>if you cannot live with a rule, object to it, ignore it, but don’t water it down until it becomes meaningless.<br>Also, suggest an improvement.</p>
<h2 id="In-force-Enforcement"><a href="#In-force-Enforcement" class="headerlink" title="In.force: Enforcement"></a><a name="SS-force"></a>In.force: Enforcement</h2><p>Rules with no enforcement are unmanageable for large code bases.<br>Enforcement of all rules is possible only for a small weak set of rules or for a specific user community.</p>
<ul>
<li>But we want lots of rules, and we want rules that everybody can use.</li>
<li>But different people have different needs.</li>
<li>But people don’t like to read lots of rules.</li>
<li>But people can’t remember many rules.</li>
</ul>
<p>So, we need subsetting to meet a variety of needs.</p>
<ul>
<li>But arbitrary subsetting leads to chaos.</li>
</ul>
<p>We want guidelines that help a lot of people, make code more uniform, and strongly encourage people to modernize their code.<br>We want to encourage best practices, rather than leave all to individual choices and management pressures.<br>The ideal is to use all rules; that gives the greatest benefits.</p>
<p>This adds up to quite a few dilemmas.<br>We try to resolve those using tools.<br>Each rule has an <strong>Enforcement</strong> section listing ideas for enforcement.<br>Enforcement might be done by code review, by static analysis, by compiler, or by run-time checks.<br>Wherever possible, we prefer “mechanical” checking (humans are slow, inaccurate, and bore easily) and static checking.<br>Run-time checks are suggested only rarely where no alternative exists; we do not want to introduce “distributed fat”.<br>Where appropriate, we label a rule (in the <strong>Enforcement</strong> sections) with the name of groups of related rules (called “profiles”).<br>A rule can be part of several profiles, or none.<br>For a start, we have a few profiles corresponding to common needs (desires, ideals):</p>
<ul>
<li><strong>type</strong>: No type violations (reinterpreting a <code>T</code> as a <code>U</code> through casts, unions, or varargs)</li>
<li><strong>bounds</strong>: No bounds violations (accessing beyond the range of an array)</li>
<li><strong>lifetime</strong>: No leaks (failing to <code>delete</code> or multiple <code>delete</code>) and no access to invalid objects (dereferencing <code>nullptr</code>, using a dangling reference).</li>
</ul>
<p>The profiles are intended to be used by tools, but also serve as an aid to the human reader.<br>We do not limit our comment in the <strong>Enforcement</strong> sections to things we know how to enforce; some comments are mere wishes that might inspire some tool builder.</p>
<p>Tools that implement these rules shall respect the following syntax to explicitly suppress a rule:</p>
<pre><code>[[gsl::suppress(tag)]]
</code></pre>
<p>where “tag” is the anchor name of the item where the Enforcement rule appears (e.g., for <a href="#Rh-public">C.134</a> it is “Rh-public”), the<br>name of a profile group-of-rules (“type”, “bounds”, or “lifetime”),<br>or a specific rule in a profile (<a href="#Pro-type-cstylecast">type.4</a>, or <a href="#Pro-bounds-arrayindex">bounds.2</a>).</p>
<h2 id="In-struct-The-structure-of-this-document"><a href="#In-struct-The-structure-of-this-document" class="headerlink" title="In.struct: The structure of this document"></a><a name="SS-struct"></a>In.struct: The structure of this document</h2><p>Each rule (guideline, suggestion) can have several parts:</p>
<ul>
<li>The rule itself – e.g., <strong>no naked <code>new</code></strong></li>
<li>A rule reference number – e.g., <strong>C.7</strong> (the 7th rule related to classes).<br>Since the major sections are not inherently ordered, we use letters as the first part of a rule reference “number”.<br>We leave gaps in the numbering to minimize “disruption” when we add or remove rules.</li>
<li><strong>Reason</strong>s (rationales) – because programmers find it hard to follow rules they don’t understand</li>
<li><strong>Example</strong>s – because rules are hard to understand in the abstract; can be positive or negative</li>
<li><strong>Alternative</strong>s – for “don’t do this” rules</li>
<li><strong>Exception</strong>s – we prefer simple general rules. However, many rules apply widely, but not universally, so exceptions must be listed</li>
<li><strong>Enforcement</strong> – ideas about how the rule might be checked “mechanically”</li>
<li><strong>See also</strong>s – references to related rules and/or further discussion (in this document or elsewhere)</li>
<li><strong>Note</strong>s (comments) – something that needs saying that doesn’t fit the other classifications</li>
<li><strong>Discussion</strong> – references to more extensive rationale and/or examples placed outside the main lists of rules</li>
</ul>
<p>Some rules are hard to check mechanically, but they all meet the minimal criteria that an expert programmer can spot many violations without too much trouble.<br>We hope that “mechanical” tools will improve with time to approximate what such an expert programmer notices.<br>Also, we assume that the rules will be refined over time to make them more precise and checkable.</p>
<p>A rule is aimed at being simple, rather than carefully phrased to mention every alternative and special case.<br>Such information is found in the <strong>Alternative</strong> paragraphs and the <a href="#S-discussion">Discussion</a> sections.<br>If you don’t understand a rule or disagree with it, please visit its <strong>Discussion</strong>.<br>If you feel that a discussion is missing or incomplete, enter an <a href="https://github.com/isocpp/CppCoreGuidelines/issues">Issue</a><br>explaining your concerns and possibly a corresponding PR.</p>
<p>This is not a language manual.<br>It is meant to be helpful, rather than complete, fully accurate on technical details, or a guide to existing code.<br>Recommended information sources can be found in <a href="#S-references">the references</a>.</p>
<h2 id="In-sec-Major-sections"><a href="#In-sec-Major-sections" class="headerlink" title="In.sec: Major sections"></a><a name="SS-sec"></a>In.sec: Major sections</h2><ul>
<li><a href="#S-introduction">In: Introduction</a></li>
<li><a href="#S-philosophy">P: Philosophy</a></li>
<li><a href="#S-interfaces">I: Interfaces</a></li>
<li><a href="#S-functions">F: Functions</a></li>
<li><a href="#S-class">C: Classes and class hierarchies</a></li>
<li><a href="#S-enum">Enum: Enumerations</a></li>
<li><a href="#S-resource">R: Resource management</a></li>
<li><a href="#S-expr">ES: Expressions and statements</a></li>
<li><a href="#S-performance">Per: Performance</a></li>
<li><a href="#S-concurrency">CP: Concurrency and parallelism</a></li>
<li><a href="#S-errors">E: Error handling</a></li>
<li><a href="#S-const">Con: Constants and immutability</a></li>
<li><a href="#S-templates">T: Templates and generic programming</a></li>
<li><a href="#S-cpl">CPL: C-style programming</a></li>
<li><a href="#S-source">SF: Source files</a></li>
<li><a href="#S-stdlib">SL: The Standard Library</a></li>
</ul>
<p>Supporting sections:</p>
<ul>
<li><a href="#S-A">A: Architectural ideas</a></li>
<li><a href="#S-not">NR: Non-Rules and myths</a></li>
<li><a href="#S-references">RF: References</a></li>
<li><a href="#S-profile">Pro: Profiles</a></li>
<li><a href="#S-gsl">GSL: Guideline support library</a></li>
<li><a href="#S-naming">NL: Naming and layout rules</a></li>
<li><a href="#S-faq">FAQ: Answers to frequently asked questions</a></li>
<li><a href="#S-libraries">Appendix A: Libraries</a></li>
<li><a href="#S-modernizing">Appendix B: Modernizing code</a></li>
<li><a href="#S-discussion">Appendix C: Discussion</a></li>
<li><a href="#S-tools">Appendix D: Supporting tools</a></li>
<li><a href="#S-glossary">Glossary</a></li>
<li><a href="#S-unclassified">To-do: Unclassified proto-rules</a></li>
</ul>
<p>These sections are not orthogonal.</p>
<p>Each section (e.g., “P” for “Philosophy”) and each subsection (e.g., “C.hier” for “Class Hierarchies (OOP)”) have an abbreviation for ease of searching and reference.<br>The main section abbreviations are also used in rule numbers (e.g., “C.11” for “Make concrete types regular”).</p>
<h1 id="P-Philosophy"><a href="#P-Philosophy" class="headerlink" title="P: Philosophy"></a><a name="S-philosophy"></a>P: Philosophy</h1><p>The rules in this section are very general.</p>
<p>Philosophy rules summary:</p>
<ul>
<li><a href="#Rp-direct">P.1: Express ideas directly in code</a></li>
<li><a href="#Rp-Cplusplus">P.2: Write in ISO Standard C++</a></li>
<li><a href="#Rp-what">P.3: Express intent</a></li>
<li><a href="#Rp-typesafe">P.4: Ideally, a program should be statically type safe</a></li>
<li><a href="#Rp-compile-time">P.5: Prefer compile-time checking to run-time checking</a></li>
<li><a href="#Rp-run-time">P.6: What cannot be checked at compile time should be checkable at run time</a></li>
<li><a href="#Rp-early">P.7: Catch run-time errors early</a></li>
<li><a href="#Rp-leak">P.8: Don’t leak any resources</a></li>
<li><a href="#Rp-waste">P.9: Don’t waste time or space</a></li>
<li><a href="#Rp-mutable">P.10: Prefer immutable data to mutable data</a></li>
<li><a href="#Rp-library">P.11: Encapsulate messy constructs, rather than spreading through the code</a></li>
<li><a href="#Rp-tools">P.12: Use supporting tools as appropriate</a></li>
<li><a href="#Rp-lib">P.13: Use support libraries as appropriate</a></li>
</ul>
<p>Philosophical rules are generally not mechanically checkable.<br>However, individual rules reflecting these philosophical themes are.<br>Without a philosophical basis, the more concrete/specific/checkable rules lack rationale.</p>
<h3 id="P-1-Express-ideas-directly-in-code"><a href="#P-1-Express-ideas-directly-in-code" class="headerlink" title="P.1: Express ideas directly in code"></a><a name="Rp-direct"></a>P.1: Express ideas directly in code</h3><h5 id="Reason"><a href="#Reason" class="headerlink" title="Reason"></a>Reason</h5><p>Compilers don’t read comments (or design documents) and neither do many programmers (consistently).<br>What is expressed in code has defined semantics and can (in principle) be checked by compilers and other tools.</p>
<h5 id="Example"><a href="#Example" class="headerlink" title="Example"></a>Example</h5><pre><code>class Date &#123;
    // ...
public:
    Month month() const;  // do
    int month();          // don&#39;t
    // ...
&#125;;
</code></pre>
<p>The first declaration of <code>month</code> is explicit about returning a <code>Month</code> and about not modifying the state of the <code>Date</code> object.<br>The second version leaves the reader guessing and opens more possibilities for uncaught bugs.</p>
<h5 id="Example-bad"><a href="#Example-bad" class="headerlink" title="Example; bad"></a>Example; bad</h5><p>This loop is a restricted form of <code>std::find</code>:</p>
<pre><code>void f(vector&lt;string&gt;&amp; v)
&#123;
    string val;
    cin &gt;&gt; val;
    // ...
    int index = -1;                    // bad, plus should use gsl::index
    for (int i = 0; i &lt; v.size(); ++i) &#123;
        if (v[i] == val) &#123;
            index = i;
            break;
        &#125;
    &#125;
    // ...
&#125;
</code></pre>
<h5 id="Example-good"><a href="#Example-good" class="headerlink" title="Example; good"></a>Example; good</h5><p>A much clearer expression of intent would be:</p>
<pre><code>void f(vector&lt;string&gt;&amp; v)
&#123;
    string val;
    cin &gt;&gt; val;
    // ...
    auto p = find(begin(v), end(v), val);  // better
    // ...
&#125;
</code></pre>
<p>A well-designed library expresses intent (what is to be done, rather than just how something is being done) far better than direct use of language features.</p>
<p>A C++ programmer should know the basics of the standard library, and use it where appropriate.<br>Any programmer should know the basics of the foundation libraries of the project being worked on, and use them appropriately.<br>Any programmer using these guidelines should know the <a href="#S-gsl">guideline support library</a>, and use it appropriately.</p>
<h5 id="Example-1"><a href="#Example-1" class="headerlink" title="Example"></a>Example</h5><pre><code>change_speed(double s);   // bad: what does s signify?
// ...
change_speed(2.3);
</code></pre>
<p>A better approach is to be explicit about the meaning of the double (new speed or delta on old speed?) and the unit used:</p>
<pre><code>change_speed(Speed s);    // better: the meaning of s is specified
// ...
change_speed(2.3);        // error: no unit
change_speed(23m / 10s);  // meters per second
</code></pre>
<p>We could have accepted a plain (unit-less) <code>double</code> as a delta, but that would have been error-prone.<br>If we wanted both absolute speed and deltas, we would have defined a <code>Delta</code> type.</p>
<h5 id="Enforcement"><a href="#Enforcement" class="headerlink" title="Enforcement"></a>Enforcement</h5><p>Very hard in general.</p>
<ul>
<li>use <code>const</code> consistently (check if member functions modify their object; check if functions modify arguments passed by pointer or reference)</li>
<li>flag uses of casts (casts neuter the type system)</li>
<li>detect code that mimics the standard library (hard)</li>
</ul>
<h3 id="P-2-Write-in-ISO-Standard-C"><a href="#P-2-Write-in-ISO-Standard-C" class="headerlink" title="P.2: Write in ISO Standard C++"></a><a name="Rp-Cplusplus"></a>P.2: Write in ISO Standard C++</h3><h5 id="Reason-1"><a href="#Reason-1" class="headerlink" title="Reason"></a>Reason</h5><p>This is a set of guidelines for writing ISO Standard C++.</p>
<h5 id="Note"><a href="#Note" class="headerlink" title="Note"></a>Note</h5><p>There are environments where extensions are necessary, e.g., to access system resources.<br>In such cases, localize the use of necessary extensions and control their use with non-core Coding Guidelines.  If possible, build interfaces that encapsulate the extensions so they can be turned off or compiled away on systems that do not support those extensions.</p>
<p>Extensions often do not have rigorously defined semantics.  Even extensions that<br>are common and implemented by multiple compilers may have slightly different<br>behaviors and edge case behavior as a direct result of <em>not</em> having a rigorous<br>standard definition.  With sufficient use of any such extension, expected<br>portability will be impacted.</p>
<h5 id="Note-1"><a href="#Note-1" class="headerlink" title="Note"></a>Note</h5><p>Using valid ISO C++ does not guarantee portability (let alone correctness).<br>Avoid dependence on undefined behavior (e.g., <a href="#Res-order">undefined order of evaluation</a>)<br>and be aware of constructs with implementation defined meaning (e.g., <code>sizeof(int)</code>).</p>
<h5 id="Note-2"><a href="#Note-2" class="headerlink" title="Note"></a>Note</h5><p>There are environments where restrictions on use of standard C++ language or library features are necessary, e.g., to avoid dynamic memory allocation as required by aircraft control software standards.<br>In such cases, control their (dis)use with an extension of these Coding Guidelines customized to the specific environment.</p>
<h5 id="Enforcement-1"><a href="#Enforcement-1" class="headerlink" title="Enforcement"></a>Enforcement</h5><p>Use an up-to-date C++ compiler (currently C++17, C++14, or C++11) with a set of options that do not accept extensions.</p>
<h3 id="P-3-Express-intent"><a href="#P-3-Express-intent" class="headerlink" title="P.3: Express intent"></a><a name="Rp-what"></a>P.3: Express intent</h3><h5 id="Reason-2"><a href="#Reason-2" class="headerlink" title="Reason"></a>Reason</h5><p>Unless the intent of some code is stated (e.g., in names or comments), it is impossible to tell whether the code does what it is supposed to do.</p>
<h5 id="Example-2"><a href="#Example-2" class="headerlink" title="Example"></a>Example</h5><pre><code>gsl::index i = 0;
while (i &lt; v.size()) &#123;
    // ... do something with v[i] ...
&#125;
</code></pre>
<p>The intent of “just” looping over the elements of <code>v</code> is not expressed here. The implementation detail of an index is exposed (so that it might be misused), and <code>i</code> outlives the scope of the loop, which may or may not be intended. The reader cannot know from just this section of code.</p>
<p>Better:</p>
<pre><code>for (const auto&amp; x : v) &#123; /* do something with the value of x */ &#125;
</code></pre>
<p>Now, there is no explicit mention of the iteration mechanism, and the loop operates on a reference to <code>const</code> elements so that accidental modification cannot happen. If modification is desired, say so:</p>
<pre><code>for (auto&amp; x : v) &#123; /* modify x */ &#125;
</code></pre>
<p>For more details about for-statements, see <a href="#Res-for-range">ES.71</a>.<br>Sometimes better still, use a named algorithm:</p>
<pre><code>for_each(v, [](int x) &#123; /* do something with the value of x */ &#125;);
for_each(par, v, [](int x) &#123; /* do something with the value of x */ &#125;);
</code></pre>
<p>The last variant makes it clear that we are not interested in the order in which the elements of <code>v</code> are handled.</p>
<p>A programmer should be familiar with</p>
<ul>
<li><a href="#S-gsl">The guideline support library</a></li>
<li><a href="#S-stdlib">The ISO C++ Standard Library</a></li>
<li>Whatever foundation libraries are used for the current project(s)</li>
</ul>
<h5 id="Note-3"><a href="#Note-3" class="headerlink" title="Note"></a>Note</h5><p>Alternative formulation: Say what should be done, rather than just how it should be done.</p>
<h5 id="Note-4"><a href="#Note-4" class="headerlink" title="Note"></a>Note</h5><p>Some language constructs express intent better than others.</p>
<h5 id="Example-3"><a href="#Example-3" class="headerlink" title="Example"></a>Example</h5><p>If two <code>int</code>s are meant to be the coordinates of a 2D point, say so:</p>
<pre><code>draw_line(int, int, int, int);  // obscure
draw_line(Point, Point);        // clearer
</code></pre>
<h5 id="Enforcement-2"><a href="#Enforcement-2" class="headerlink" title="Enforcement"></a>Enforcement</h5><p>Look for common patterns for which there are better alternatives</p>
<ul>
<li>simple <code>for</code> loops vs. range-<code>for</code> loops</li>
<li><code>f(T*, int)</code> interfaces vs. <code>f(span&lt;T&gt;)</code> interfaces</li>
<li>loop variables in too large a scope</li>
<li>naked <code>new</code> and <code>delete</code></li>
<li>functions with many parameters of built-in types</li>
</ul>
<p>There is a huge scope for cleverness and semi-automated program transformation.</p>
<h3 id="P-4-Ideally-a-program-should-be-statically-type-safe"><a href="#P-4-Ideally-a-program-should-be-statically-type-safe" class="headerlink" title="P.4: Ideally, a program should be statically type safe"></a><a name="Rp-typesafe"></a>P.4: Ideally, a program should be statically type safe</h3><h5 id="Reason-3"><a href="#Reason-3" class="headerlink" title="Reason"></a>Reason</h5><p>Ideally, a program would be completely statically (compile-time) type safe.<br>Unfortunately, that is not possible. Problem areas:</p>
<ul>
<li>unions</li>
<li>casts</li>
<li>array decay</li>
<li>range errors</li>
<li>narrowing conversions</li>
</ul>
<h5 id="Note-5"><a href="#Note-5" class="headerlink" title="Note"></a>Note</h5><p>These areas are sources of serious problems (e.g., crashes and security violations).<br>We try to provide alternative techniques.</p>
<h5 id="Enforcement-3"><a href="#Enforcement-3" class="headerlink" title="Enforcement"></a>Enforcement</h5><p>We can ban, restrain, or detect the individual problem categories separately, as required and feasible for individual programs.<br>Always suggest an alternative.<br>For example:</p>
<ul>
<li>unions – use <code>variant</code> (in C++17)</li>
<li>casts – minimize their use; templates can help</li>
<li>array decay – use <code>span</code> (from the GSL)</li>
<li>range errors – use <code>span</code></li>
<li>narrowing conversions – minimize their use and use <code>narrow</code> or <code>narrow_cast</code> (from the GSL) where they are necessary</li>
</ul>
<h3 id="P-5-Prefer-compile-time-checking-to-run-time-checking"><a href="#P-5-Prefer-compile-time-checking-to-run-time-checking" class="headerlink" title="P.5: Prefer compile-time checking to run-time checking"></a><a name="Rp-compile-time"></a>P.5: Prefer compile-time checking to run-time checking</h3><h5 id="Reason-4"><a href="#Reason-4" class="headerlink" title="Reason"></a>Reason</h5><p>Code clarity and performance.<br>You don’t need to write error handlers for errors caught at compile time.</p>
<h5 id="Example-4"><a href="#Example-4" class="headerlink" title="Example"></a>Example</h5><pre><code>// Int is an alias used for integers
int bits = 0;         // don&#39;t: avoidable code
for (Int i = 1; i; i &lt;&lt;= 1)
    ++bits;
if (bits &lt; 32)
    cerr &lt;&lt; &quot;Int too small\n&quot;;
</code></pre>
<p>This example fails to achieve what it is trying to achieve (because overflow is undefined) and should be replaced with a simple <code>static_assert</code>:</p>
<pre><code>// Int is an alias used for integers
static_assert(sizeof(Int) &gt;= 4);    // do: compile-time check
</code></pre>
<p>Or better still just use the type system and replace <code>Int</code> with <code>int32_t</code>.</p>
<h5 id="Example-5"><a href="#Example-5" class="headerlink" title="Example"></a>Example</h5><pre><code>void read(int* p, int n);   // read max n integers into *p

int a[100];
read(a, 1000);    // bad, off the end
</code></pre>
<p>better</p>
<pre><code>void read(span&lt;int&gt; r); // read into the range of integers r

int a[100];
read(a);        // better: let the compiler figure out the number of elements
</code></pre>
<p><strong>Alternative formulation</strong>: Don’t postpone to run time what can be done well at compile time.</p>
<h5 id="Enforcement-4"><a href="#Enforcement-4" class="headerlink" title="Enforcement"></a>Enforcement</h5><ul>
<li>Look for pointer arguments.</li>
<li>Look for run-time checks for range violations.</li>
</ul>
<h3 id="P-6-What-cannot-be-checked-at-compile-time-should-be-checkable-at-run-time"><a href="#P-6-What-cannot-be-checked-at-compile-time-should-be-checkable-at-run-time" class="headerlink" title="P.6: What cannot be checked at compile time should be checkable at run time"></a><a name="Rp-run-time"></a>P.6: What cannot be checked at compile time should be checkable at run time</h3><h5 id="Reason-5"><a href="#Reason-5" class="headerlink" title="Reason"></a>Reason</h5><p>Leaving hard-to-detect errors in a program is asking for crashes and bad results.</p>
<h5 id="Note-6"><a href="#Note-6" class="headerlink" title="Note"></a>Note</h5><p>Ideally, we catch all errors (that are not errors in the programmer’s logic) at either compile time or run time. It is impossible to catch all errors at compile time and often not affordable to catch all remaining errors at run time. However, we should endeavor to write programs that in principle can be checked, given sufficient resources (analysis programs, run-time checks, machine resources, time).</p>
<h5 id="Example-bad-1"><a href="#Example-bad-1" class="headerlink" title="Example, bad"></a>Example, bad</h5><pre><code>// separately compiled, possibly dynamically loaded
extern void f(int* p);

void g(int n)
&#123;
    // bad: the number of elements is not passed to f()
    f(new int[n]);
&#125;
</code></pre>
<p>Here, a crucial bit of information (the number of elements) has been so thoroughly “obscured” that static analysis is probably rendered infeasible and dynamic checking can be very difficult when <code>f()</code> is part of an ABI so that we cannot “instrument” that pointer. We could embed helpful information into the free store, but that requires global changes to a system and maybe to the compiler. What we have here is a design that makes error detection very hard.</p>
<h5 id="Example-bad-2"><a href="#Example-bad-2" class="headerlink" title="Example, bad"></a>Example, bad</h5><p>We can of course pass the number of elements along with the pointer:</p>
<pre><code>// separately compiled, possibly dynamically loaded
extern void f2(int* p, int n);

void g2(int n)
&#123;
    f2(new int[n], m);  // bad: a wrong number of elements can be passed to f()
&#125;
</code></pre>
<p>Passing the number of elements as an argument is better (and far more common) than just passing the pointer and relying on some (unstated) convention for knowing or discovering the number of elements. However (as shown), a simple typo can introduce a serious error. The connection between the two arguments of <code>f2()</code> is conventional, rather than explicit.</p>
<p>Also, it is implicit that <code>f2()</code> is supposed to <code>delete</code> its argument (or did the caller make a second mistake?).</p>
<h5 id="Example-bad-3"><a href="#Example-bad-3" class="headerlink" title="Example, bad"></a>Example, bad</h5><p>The standard library resource management pointers fail to pass the size when they point to an object:</p>
<pre><code>// separately compiled, possibly dynamically loaded
// NB: this assumes the calling code is ABI-compatible, using a
// compatible C++ compiler and the same stdlib implementation
extern void f3(unique_ptr&lt;int[]&gt;, int n);

void g3(int n)
&#123;
    f3(make_unique&lt;int[]&gt;(n), m);    // bad: pass ownership and size separately
&#125;
</code></pre>
<h5 id="Example-6"><a href="#Example-6" class="headerlink" title="Example"></a>Example</h5><p>We need to pass the pointer and the number of elements as an integral object:</p>
<pre><code>extern void f4(vector&lt;int&gt;&amp;);   // separately compiled, possibly dynamically loaded
extern void f4(span&lt;int&gt;);      // separately compiled, possibly dynamically loaded
                                // NB: this assumes the calling code is ABI-compatible, using a
                                // compatible C++ compiler and the same stdlib implementation

void g3(int n)
&#123;
    vector&lt;int&gt; v(n);
    f4(v);                     // pass a reference, retain ownership
    f4(span&lt;int&gt;&#123;v&#125;);          // pass a view, retain ownership
&#125;
</code></pre>
<p>This design carries the number of elements along as an integral part of an object, so that errors are unlikely and dynamic (run-time) checking is always feasible, if not always affordable.</p>
<h5 id="Example-7"><a href="#Example-7" class="headerlink" title="Example"></a>Example</h5><p>How do we transfer both ownership and all information needed for validating use?</p>
<pre><code>vector&lt;int&gt; f5(int n)    // OK: move
&#123;
    vector&lt;int&gt; v(n);
    // ... initialize v ...
    return v;
&#125;

unique_ptr&lt;int[]&gt; f6(int n)    // bad: loses n
&#123;
    auto p = make_unique&lt;int[]&gt;(n);
    // ... initialize *p ...
    return p;
&#125;

owner&lt;int*&gt; f7(int n)    // bad: loses n and we might forget to delete
&#123;
    owner&lt;int*&gt; p = new int[n];
    // ... initialize *p ...
    return p;
&#125;
</code></pre>
<h5 id="Example-8"><a href="#Example-8" class="headerlink" title="Example"></a>Example</h5><ul>
<li>???</li>
<li>show how possible checks are avoided by interfaces that pass polymorphic base classes around, when they actually know what they need?<br>Or strings as “free-style” options</li>
</ul>
<h5 id="Enforcement-5"><a href="#Enforcement-5" class="headerlink" title="Enforcement"></a>Enforcement</h5><ul>
<li>Flag (pointer, count)-style interfaces (this will flag a lot of examples that can’t be fixed for compatibility reasons)</li>
<li>???</li>
</ul>
<h3 id="P-7-Catch-run-time-errors-early"><a href="#P-7-Catch-run-time-errors-early" class="headerlink" title="P.7: Catch run-time errors early"></a><a name="Rp-early"></a>P.7: Catch run-time errors early</h3><h5 id="Reason-6"><a href="#Reason-6" class="headerlink" title="Reason"></a>Reason</h5><p>Avoid “mysterious” crashes.<br>Avoid errors leading to (possibly unrecognized) wrong results.</p>
<h5 id="Example-9"><a href="#Example-9" class="headerlink" title="Example"></a>Example</h5><pre><code>void increment1(int* p, int n)    // bad: error-prone
&#123;
    for (int i = 0; i &lt; n; ++i) ++p[i];
&#125;

void use1(int m)
&#123;
    const int n = 10;
    int a[n] = &#123;&#125;;
    // ...
    increment1(a, m);   // maybe typo, maybe m &lt;= n is supposed
                        // but assume that m == 20
    // ...
&#125;
</code></pre>
<p>Here we made a small error in <code>use1</code> that will lead to corrupted data or a crash.<br>The (pointer, count)-style interface leaves <code>increment1()</code> with no realistic way of defending itself against out-of-range errors.<br>If we could check subscripts for out of range access, then the error would not be discovered until <code>p[10]</code> was accessed.<br>We could check earlier and improve the code:</p>
<pre><code>void increment2(span&lt;int&gt; p)
&#123;
    for (int&amp; x : p) ++x;
&#125;

void use2(int m)
&#123;
    const int n = 10;
    int a[n] = &#123;&#125;;
    // ...
    increment2(&#123;a, m&#125;);    // maybe typo, maybe m &lt;= n is supposed
    // ...
&#125;
</code></pre>
<p>Now, <code>m &lt;= n</code> can be checked at the point of call (early) rather than later.<br>If all we had was a typo so that we meant to use <code>n</code> as the bound, the code could be further simplified (eliminating the possibility of an error):</p>
<pre><code>void use3(int m)
&#123;
    const int n = 10;
    int a[n] = &#123;&#125;;
    // ...
    increment2(a);   // the number of elements of a need not be repeated
    // ...
&#125;
</code></pre>
<h5 id="Example-bad-4"><a href="#Example-bad-4" class="headerlink" title="Example, bad"></a>Example, bad</h5><p>Don’t repeatedly check the same value. Don’t pass structured data as strings:</p>
<pre><code>Date read_date(istream&amp; is);    // read date from istream

Date extract_date(const string&amp; s);    // extract date from string

void user1(const string&amp; date)    // manipulate date
&#123;
    auto d = extract_date(date);
    // ...
&#125;

void user2()
&#123;
    Date d = read_date(cin);
    // ...
    user1(d.to_string());
    // ...
&#125;
</code></pre>
<p>The date is validated twice (by the <code>Date</code> constructor) and passed as a character string (unstructured data).</p>
<h5 id="Example-10"><a href="#Example-10" class="headerlink" title="Example"></a>Example</h5><p>Excess checking can be costly.<br>There are cases where checking early is dumb because you may not ever need the value, or may only need part of the value that is more easily checked than the whole.  Similarly, don’t add validity checks that change the asymptotic behavior of your interface (e.g., don’t add a <code>O(n)</code> check to an interface with an average complexity of <code>O(1)</code>).</p>
<pre><code>class Jet &#123;    // Physics says: e * e &lt; x * x + y * y + z * z
    float x;
    float y;
    float z;
    float e;
public:
    Jet(float x, float y, float z, float e)
        :x(x), y(y), z(z), e(e)
    &#123;
        // Should I check here that the values are physically meaningful?
    &#125;

    float m() const
    &#123;
        // Should I handle the degenerate case here?
        return sqrt(x * x + y * y + z * z - e * e);
    &#125;

    ???
&#125;;
</code></pre>
<p>The physical law for a jet (<code>e * e &lt; x * x + y * y + z * z</code>) is not an invariant because of the possibility for measurement errors.</p>
<p>???</p>
<h5 id="Enforcement-6"><a href="#Enforcement-6" class="headerlink" title="Enforcement"></a>Enforcement</h5><ul>
<li>Look at pointers and arrays: Do range-checking early and not repeatedly</li>
<li>Look at conversions: Eliminate or mark narrowing conversions</li>
<li>Look for unchecked values coming from input</li>
<li>Look for structured data (objects of classes with invariants) being converted into strings</li>
<li>???</li>
</ul>
<h3 id="P-8-Don’t-leak-any-resources"><a href="#P-8-Don’t-leak-any-resources" class="headerlink" title="P.8: Don’t leak any resources"></a><a name="Rp-leak"></a>P.8: Don’t leak any resources</h3><h5 id="Reason-7"><a href="#Reason-7" class="headerlink" title="Reason"></a>Reason</h5><p>Even a slow growth in resources will, over time, exhaust the availability of those resources.<br>This is particularly important for long-running programs, but is an essential piece of responsible programming behavior.</p>
<h5 id="Example-bad-5"><a href="#Example-bad-5" class="headerlink" title="Example, bad"></a>Example, bad</h5><pre><code>void f(char* name)
&#123;
    FILE* input = fopen(name, &quot;r&quot;);
    // ...
    if (something) return;   // bad: if something == true, a file handle is leaked
    // ...
    fclose(input);
&#125;
</code></pre>
<p>Prefer <a href="#Rr-raii">RAII</a>:</p>
<pre><code>void f(char* name)
&#123;
    ifstream input &#123;name&#125;;
    // ...
    if (something) return;   // OK: no leak
    // ...
&#125;
</code></pre>
<p><strong>See also</strong>: <a href="#S-resource">The resource management section</a></p>
<h5 id="Note-7"><a href="#Note-7" class="headerlink" title="Note"></a>Note</h5><p>A leak is colloquially “anything that isn’t cleaned up.”<br>The more important classification is “anything that can no longer be cleaned up.”<br>For example, allocating an object on the heap and then losing the last pointer that points to that allocation.<br>This rule should not be taken as requiring that allocations within long-lived objects must be returned during program shutdown.<br>For example, relying on system guaranteed cleanup such as file closing and memory deallocation upon process shutdown can simplify code.<br>However, relying on abstractions that implicitly clean up can be as simple, and often safer.</p>
<h5 id="Note-8"><a href="#Note-8" class="headerlink" title="Note"></a>Note</h5><p>Enforcing <a href="#SS-lifetime">the lifetime safety profile</a> eliminates leaks.<br>When combined with resource safety provided by <a href="#Rr-raii">RAII</a>, it eliminates the need for “garbage collection” (by generating no garbage).<br>Combine this with enforcement of <a href="#SS-force">the type and bounds profiles</a> and you get complete type- and resource-safety, guaranteed by tools.</p>
<h5 id="Enforcement-7"><a href="#Enforcement-7" class="headerlink" title="Enforcement"></a>Enforcement</h5><ul>
<li>Look at pointers: Classify them into non-owners (the default) and owners.<br>Where feasible, replace owners with standard-library resource handles (as in the example above).<br>Alternatively, mark an owner as such using <code>owner</code> from <a href="#S-gsl">the GSL</a>.</li>
<li>Look for naked <code>new</code> and <code>delete</code></li>
<li>Look for known resource allocating functions returning raw pointers (such as <code>fopen</code>, <code>malloc</code>, and <code>strdup</code>)</li>
</ul>
<h3 id="P-9-Don’t-waste-time-or-space"><a href="#P-9-Don’t-waste-time-or-space" class="headerlink" title="P.9: Don’t waste time or space"></a><a name="Rp-waste"></a>P.9: Don’t waste time or space</h3><h5 id="Reason-8"><a href="#Reason-8" class="headerlink" title="Reason"></a>Reason</h5><p>This is C++.</p>
<h5 id="Note-9"><a href="#Note-9" class="headerlink" title="Note"></a>Note</h5><p>Time and space that you spend well to achieve a goal (e.g., speed of development, resource safety, or simplification of testing) is not wasted.<br>“Another benefit of striving for efficiency is that the process forces you to understand the problem in more depth.” - Alex Stepanov</p>
<h5 id="Example-bad-6"><a href="#Example-bad-6" class="headerlink" title="Example, bad"></a>Example, bad</h5><pre><code>struct X &#123;
    char ch;
    int i;
    string s;
    char ch2;

    X&amp; operator=(const X&amp; a);
    X(const X&amp;);
&#125;;

X waste(const char* p)
&#123;
    if (!p) throw Nullptr_error&#123;&#125;;
    int n = strlen(p);
    auto buf = new char[n];
    if (!buf) throw Allocation_error&#123;&#125;;
    for (int i = 0; i &lt; n; ++i) buf[i] = p[i];
    // ... manipulate buffer ...
    X x;
    x.ch = &#39;a&#39;;
    x.s = string(n);    // give x.s space for *p
    for (gsl::index i = 0; i &lt; x.s.size(); ++i) x.s[i] = buf[i];  // copy buf into x.s
    delete[] buf;
    return x;
&#125;

void driver()
&#123;
    X x = waste(&quot;Typical argument&quot;);
    // ...
&#125;
</code></pre>
<p>Yes, this is a caricature, but we have seen every individual mistake in production code, and worse.<br>Note that the layout of <code>X</code> guarantees that at least 6 bytes (and most likely more) are wasted.<br>The spurious definition of copy operations disables move semantics so that the return operation is slow<br>(please note that the Return Value Optimization, RVO, is not guaranteed here).<br>The use of <code>new</code> and <code>delete</code> for <code>buf</code> is redundant; if we really needed a local string, we should use a local <code>string</code>.<br>There are several more performance bugs and gratuitous complication.</p>
<h5 id="Example-bad-7"><a href="#Example-bad-7" class="headerlink" title="Example, bad"></a>Example, bad</h5><pre><code>void lower(zstring s)
&#123;
    for (int i = 0; i &lt; strlen(s); ++i) s[i] = tolower(s[i]);
&#125;
</code></pre>
<p>Yes, this is an example from production code.<br>We leave it to the reader to figure out what’s wasted.</p>
<h5 id="Note-10"><a href="#Note-10" class="headerlink" title="Note"></a>Note</h5><p>An individual example of waste is rarely significant, and where it is significant, it is typically easily eliminated by an expert.<br>However, waste spread liberally across a code base can easily be significant and experts are not always as available as we would like.<br>The aim of this rule (and the more specific rules that support it) is to eliminate most waste related to the use of C++ before it happens.<br>After that, we can look at waste related to algorithms and requirements, but that is beyond the scope of these guidelines.</p>
<h5 id="Enforcement-8"><a href="#Enforcement-8" class="headerlink" title="Enforcement"></a>Enforcement</h5><p>Many more specific rules aim at the overall goals of simplicity and elimination of gratuitous waste.</p>
<h3 id="P-10-Prefer-immutable-data-to-mutable-data"><a href="#P-10-Prefer-immutable-data-to-mutable-data" class="headerlink" title="P.10: Prefer immutable data to mutable data"></a><a name="Rp-mutable"></a>P.10: Prefer immutable data to mutable data</h3><h5 id="Reason-9"><a href="#Reason-9" class="headerlink" title="Reason"></a>Reason</h5><p>It is easier to reason about constants than about variables.<br>Something immutable cannot change unexpectedly.<br>Sometimes immutability enables better optimization.<br>You can’t have a data race on a constant.</p>
<p>See <a href="#S-const">Con: Constants and immutability</a></p>
<h3 id="P-11-Encapsulate-messy-constructs-rather-than-spreading-through-the-code"><a href="#P-11-Encapsulate-messy-constructs-rather-than-spreading-through-the-code" class="headerlink" title="P.11: Encapsulate messy constructs, rather than spreading through the code"></a><a name="Rp-library"></a>P.11: Encapsulate messy constructs, rather than spreading through the code</h3><h5 id="Reason-10"><a href="#Reason-10" class="headerlink" title="Reason"></a>Reason</h5><p>Messy code is more likely to hide bugs and harder to write.<br>A good interface is easier and safer to use.<br>Messy, low-level code breeds more such code.</p>
<h5 id="Example-11"><a href="#Example-11" class="headerlink" title="Example"></a>Example</h5><pre><code>int sz = 100;
int* p = (int*) malloc(sizeof(int) * sz);
int count = 0;
// ...
for (;;) &#123;
    // ... read an int into x, exit loop if end of file is reached ...
    // ... check that x is valid ...
    if (count == sz)
        p = (int*) realloc(p, sizeof(int) * sz * 2);
    p[count++] = x;
    // ...
&#125;
</code></pre>
<p>This is low-level, verbose, and error-prone.<br>For example, we “forgot” to test for memory exhaustion.<br>Instead, we could use <code>vector</code>:</p>
<pre><code>vector&lt;int&gt; v;
v.reserve(100);
// ...
for (int x; cin &gt;&gt; x; ) &#123;
    // ... check that x is valid ...
    v.push_back(x);
&#125;
</code></pre>
<h5 id="Note-11"><a href="#Note-11" class="headerlink" title="Note"></a>Note</h5><p>The standards library and the GSL are examples of this philosophy.<br>For example, instead of messing with the arrays, unions, cast, tricky lifetime issues, <code>gsl::owner</code>, etc.,<br>that are needed to implement key abstractions, such as <code>vector</code>, <code>span</code>, <code>lock_guard</code>, and <code>future</code>, we use the libraries<br>designed and implemented by people with more time and expertise than we usually have.<br>Similarly, we can and should design and implement more specialized libraries, rather than leaving the users (often ourselves)<br>with the challenge of repeatedly getting low-level code well.<br>This is a variant of the <a href="#R0">subset of superset principle</a> that underlies these guidelines.</p>
<h5 id="Enforcement-9"><a href="#Enforcement-9" class="headerlink" title="Enforcement"></a>Enforcement</h5><ul>
<li>Look for “messy code” such as complex pointer manipulation and casting outside the implementation of abstractions.</li>
</ul>
<h3 id="P-12-Use-supporting-tools-as-appropriate"><a href="#P-12-Use-supporting-tools-as-appropriate" class="headerlink" title="P.12: Use supporting tools as appropriate"></a><a name="Rp-tools"></a>P.12: Use supporting tools as appropriate</h3><h5 id="Reason-11"><a href="#Reason-11" class="headerlink" title="Reason"></a>Reason</h5><p>There are many things that are done better “by machine”.<br>Computers don’t tire or get bored by repetitive tasks.<br>We typically have better things to do than repeatedly do routine tasks.</p>
<h5 id="Example-12"><a href="#Example-12" class="headerlink" title="Example"></a>Example</h5><p>Run a static analyzer to verify that your code follows the guidelines you want it to follow.</p>
<h5 id="Note-12"><a href="#Note-12" class="headerlink" title="Note"></a>Note</h5><p>See</p>
<ul>
<li><a href="???">Static analysis tools</a></li>
<li><a href="#Rconc-tools">Concurrency tools</a></li>
<li><a href="???">Testing tools</a></li>
</ul>
<p>There are many other kinds of tools, such as source code repositories, build tools, etc.,<br>but those are beyond the scope of these guidelines.</p>
<h5 id="Note-13"><a href="#Note-13" class="headerlink" title="Note"></a>Note</h5><p>Be careful not to become dependent on over-elaborate or over-specialized tool chains.<br>Those can make your otherwise portable code non-portable.</p>
<h3 id="P-13-Use-support-libraries-as-appropriate"><a href="#P-13-Use-support-libraries-as-appropriate" class="headerlink" title="P.13: Use support libraries as appropriate"></a><a name="Rp-lib"></a>P.13: Use support libraries as appropriate</h3><h5 id="Reason-12"><a href="#Reason-12" class="headerlink" title="Reason"></a>Reason</h5><p>Using a well-designed, well-documented, and well-supported library saves time and effort;<br>its quality and documentation are likely to be greater than what you could do<br>if the majority of your time must be spent on an implementation.<br>The cost (time, effort, money, etc.) of a library can be shared over many users.<br>A widely used library is more likely to be kept up-to-date and ported to new systems than an individual application.<br>Knowledge of a widely-used library can save time on other/future projects.<br>So, if a suitable library exists for your application domain, use it.</p>
<h5 id="Example-13"><a href="#Example-13" class="headerlink" title="Example"></a>Example</h5><pre><code>std::sort(begin(v), end(v), std::greater&lt;&gt;());
</code></pre>
<p>Unless you are an expert in sorting algorithms and have plenty of time,<br>this is more likely to be correct and to run faster than anything you write for a specific application.<br>You need a reason not to use the standard library (or whatever foundational libraries your application uses) rather than a reason to use it.</p>
<h5 id="Note-14"><a href="#Note-14" class="headerlink" title="Note"></a>Note</h5><p>By default use</p>
<ul>
<li>The <a href="#S-stdlib">ISO C++ Standard Library</a></li>
<li>The <a href="#S-gsl">Guidelines Support Library</a></li>
</ul>
<h5 id="Note-15"><a href="#Note-15" class="headerlink" title="Note"></a>Note</h5><p>If no well-designed, well-documented, and well-supported library exists for an important domain,<br>maybe you should design and implement it, and then use it.</p>
<h1 id="I-Interfaces"><a href="#I-Interfaces" class="headerlink" title="I: Interfaces"></a><a name="S-interfaces"></a>I: Interfaces</h1><p>An interface is a contract between two parts of a program. Precisely stating what is expected of a supplier of a service and a user of that service is essential.<br>Having good (easy-to-understand, encouraging efficient use, not error-prone, supporting testing, etc.) interfaces is probably the most important single aspect of code organization.</p>
<p>Interface rule summary:</p>
<ul>
<li><a href="#Ri-explicit">I.1: Make interfaces explicit</a></li>
<li><a href="#Ri-global">I.2: Avoid non-<code>const</code> global variables</a></li>
<li><a href="#Ri-singleton">I.3: Avoid singletons</a></li>
<li><a href="#Ri-typed">I.4: Make interfaces precisely and strongly typed</a></li>
<li><a href="#Ri-pre">I.5: State preconditions (if any)</a></li>
<li><a href="#Ri-expects">I.6: Prefer <code>Expects()</code> for expressing preconditions</a></li>
<li><a href="#Ri-post">I.7: State postconditions</a></li>
<li><a href="#Ri-ensures">I.8: Prefer <code>Ensures()</code> for expressing postconditions</a></li>
<li><a href="#Ri-concepts">I.9: If an interface is a template, document its parameters using concepts</a></li>
<li><a href="#Ri-except">I.10: Use exceptions to signal a failure to perform a required task</a></li>
<li><a href="#Ri-raw">I.11: Never transfer ownership by a raw pointer (<code>T*</code>) or reference (<code>T&amp;</code>)</a></li>
<li><a href="#Ri-nullptr">I.12: Declare a pointer that must not be null as <code>not_null</code></a></li>
<li><a href="#Ri-array">I.13: Do not pass an array as a single pointer</a></li>
<li><a href="#Ri-global-init">I.22: Avoid complex initialization of global objects</a></li>
<li><a href="#Ri-nargs">I.23: Keep the number of function arguments low</a></li>
<li><a href="#Ri-unrelated">I.24: Avoid adjacent unrelated parameters of the same type</a></li>
<li><a href="#Ri-abstract">I.25: Prefer abstract classes as interfaces to class hierarchies</a></li>
<li><a href="#Ri-abi">I.26: If you want a cross-compiler ABI, use a C-style subset</a></li>
<li><a href="#Ri-pimpl">I.27: For stable library ABI, consider the Pimpl idiom</a></li>
<li><a href="#Ri-encapsulate">I.30: Encapsulate rule violations</a></li>
</ul>
<p><strong>See also</strong>:</p>
<ul>
<li><a href="#S-functions">F: Functions</a></li>
<li><a href="#SS-concrete">C.concrete: Concrete types</a></li>
<li><a href="#SS-hier">C.hier: Class hierarchies</a></li>
<li><a href="#SS-overload">C.over: Overloading and overloaded operators</a></li>
<li><a href="#SS-containers">C.con: Containers and other resource handles</a></li>
<li><a href="#S-errors">E: Error handling</a></li>
<li><a href="#S-templates">T: Templates and generic programming</a></li>
</ul>
<h3 id="I-1-Make-interfaces-explicit"><a href="#I-1-Make-interfaces-explicit" class="headerlink" title="I.1: Make interfaces explicit"></a><a name="Ri-explicit"></a>I.1: Make interfaces explicit</h3><h5 id="Reason-13"><a href="#Reason-13" class="headerlink" title="Reason"></a>Reason</h5><p>Correctness. Assumptions not stated in an interface are easily overlooked and hard to test.</p>
<h5 id="Example-bad-8"><a href="#Example-bad-8" class="headerlink" title="Example, bad"></a>Example, bad</h5><p>Controlling the behavior of a function through a global (namespace scope) variable (a call mode) is implicit and potentially confusing. For example:</p>
<pre><code>int round(double d)
&#123;
    return (round_up) ? ceil(d) : d;    // don&#39;t: &quot;invisible&quot; dependency
&#125;
</code></pre>
<p>It will not be obvious to a caller that the meaning of two calls of <code>round(7.2)</code> might give different results.</p>
<h5 id="Exception"><a href="#Exception" class="headerlink" title="Exception"></a>Exception</h5><p>Sometimes we control the details of a set of operations by an environment variable, e.g., normal vs. verbose output or debug vs. optimized.<br>The use of a non-local control is potentially confusing, but controls only implementation details of otherwise fixed semantics.</p>
<h5 id="Example-bad-9"><a href="#Example-bad-9" class="headerlink" title="Example, bad"></a>Example, bad</h5><p>Reporting through non-local variables (e.g., <code>errno</code>) is easily ignored. For example:</p>
<pre><code>// don&#39;t: no test of printf&#39;s return value
fprintf(connection, &quot;logging: %d %d %d\n&quot;, x, y, s);
</code></pre>
<p>What if the connection goes down so that no logging output is produced? See I.???.</p>
<p><strong>Alternative</strong>: Throw an exception. An exception cannot be ignored.</p>
<p><strong>Alternative formulation</strong>: Avoid passing information across an interface through non-local or implicit state.<br>Note that non-<code>const</code> member functions pass information to other member functions through their object’s state.</p>
<p><strong>Alternative formulation</strong>: An interface should be a function or a set of functions.<br>Functions can be template functions and sets of functions can be classes or class templates.</p>
<h5 id="Enforcement-10"><a href="#Enforcement-10" class="headerlink" title="Enforcement"></a>Enforcement</h5><ul>
<li>(Simple) A function should not make control-flow decisions based on the values of variables declared at namespace scope.</li>
<li>(Simple) A function should not write to variables declared at namespace scope.</li>
</ul>
<h3 id="I-2-Avoid-non-const-global-variables"><a href="#I-2-Avoid-non-const-global-variables" class="headerlink" title="I.2: Avoid non-const global variables"></a><a name="Ri-global"></a>I.2: Avoid non-<code>const</code> global variables</h3><h5 id="Reason-14"><a href="#Reason-14" class="headerlink" title="Reason"></a>Reason</h5><p>Non-<code>const</code> global variables hide dependencies and make the dependencies subject to unpredictable changes.</p>
<h5 id="Example-14"><a href="#Example-14" class="headerlink" title="Example"></a>Example</h5><pre><code>struct Data &#123;
    // ... lots of stuff ...
&#125; data;            // non-const data

void compute()     // don&#39;t
&#123;
    // ... use data ...
&#125;

void output()     // don&#39;t
&#123;
    // ... use data ...
&#125;
</code></pre>
<p>Who else might modify <code>data</code>?</p>
<h5 id="Note-16"><a href="#Note-16" class="headerlink" title="Note"></a>Note</h5><p>Global constants are useful.</p>
<h5 id="Note-17"><a href="#Note-17" class="headerlink" title="Note"></a>Note</h5><p>The rule against global variables applies to namespace scope variables as well.</p>
<p><strong>Alternative</strong>: If you use global (more generally namespace scope) data to avoid copying, consider passing the data as an object by reference to <code>const</code>.<br>Another solution is to define the data as the state of some object and the operations as member functions.</p>
<p><strong>Warning</strong>: Beware of data races: If one thread can access nonlocal data (or data passed by reference) while another thread executes the callee, we can have a data race.<br>Every pointer or reference to mutable data is a potential data race.</p>
<h5 id="Note-18"><a href="#Note-18" class="headerlink" title="Note"></a>Note</h5><p>You cannot have a race condition on immutable data.</p>
<p><strong>References</strong>: See the <a href="#SS-call">rules for calling functions</a>.</p>
<h5 id="Note-19"><a href="#Note-19" class="headerlink" title="Note"></a>Note</h5><p>The rule is “avoid”, not “don’t use.” Of course there will be (rare) exceptions, such as <code>cin</code>, <code>cout</code>, and <code>cerr</code>.</p>
<h5 id="Enforcement-11"><a href="#Enforcement-11" class="headerlink" title="Enforcement"></a>Enforcement</h5><p>(Simple) Report all non-<code>const</code> variables declared at namespace scope.</p>
<h3 id="I-3-Avoid-singletons"><a href="#I-3-Avoid-singletons" class="headerlink" title="I.3: Avoid singletons"></a><a name="Ri-singleton"></a>I.3: Avoid singletons</h3><h5 id="Reason-15"><a href="#Reason-15" class="headerlink" title="Reason"></a>Reason</h5><p>Singletons are basically complicated global objects in disguise.</p>
<h5 id="Example-15"><a href="#Example-15" class="headerlink" title="Example"></a>Example</h5><pre><code>class Singleton &#123;
    // ... lots of stuff to ensure that only one Singleton object is created,
    // that it is initialized properly, etc.
&#125;;
</code></pre>
<p>There are many variants of the singleton idea.<br>That’s part of the problem.</p>
<h5 id="Note-20"><a href="#Note-20" class="headerlink" title="Note"></a>Note</h5><p>If you don’t want a global object to change, declare it <code>const</code> or <code>constexpr</code>.</p>
<h5 id="Exception-1"><a href="#Exception-1" class="headerlink" title="Exception"></a>Exception</h5><p>You can use the simplest “singleton” (so simple that it is often not considered a singleton) to get initialization on first use, if any:</p>
<pre><code>X&amp; myX()
&#123;
    static X my_x &#123;3&#125;;
    return my_x;
&#125;
</code></pre>
<p>This is one of the most effective solutions to problems related to initialization order.<br>In a multi-threaded environment, the initialization of the static object does not introduce a race condition<br>(unless you carelessly access a shared object from within its constructor).</p>
<p>Note that the initialization of a local <code>static</code> does not imply a race condition.<br>However, if the destruction of <code>X</code> involves an operation that needs to be synchronized we must use a less simple solution.<br>For example:</p>
<pre><code>X&amp; myX()
&#123;
    static auto p = new X &#123;3&#125;;
    return *p;  // potential leak
&#125;
</code></pre>
<p>Now someone must <code>delete</code> that object in some suitably thread-safe way.<br>That’s error-prone, so we don’t use that technique unless</p>
<ul>
<li><code>myX</code> is in multi-threaded code,</li>
<li>that <code>X</code> object needs to be destroyed (e.g., because it releases a resource), and</li>
<li><code>X</code>‘s destructor’s code needs to be synchronized.</li>
</ul>
<p>If you, as many do, define a singleton as a class for which only one object is created, functions like <code>myX</code> are not singletons, and this useful technique is not an exception to the no-singleton rule.</p>
<h5 id="Enforcement-12"><a href="#Enforcement-12" class="headerlink" title="Enforcement"></a>Enforcement</h5><p>Very hard in general.</p>
<ul>
<li>Look for classes with names that include <code>singleton</code>.</li>
<li>Look for classes for which only a single object is created (by counting objects or by examining constructors).</li>
<li>If a class X has a public static function that contains a function-local static of the class’ type X and returns a pointer or reference to it, ban that.</li>
</ul>
<h3 id="I-4-Make-interfaces-precisely-and-strongly-typed"><a href="#I-4-Make-interfaces-precisely-and-strongly-typed" class="headerlink" title="I.4: Make interfaces precisely and strongly typed"></a><a name="Ri-typed"></a>I.4: Make interfaces precisely and strongly typed</h3><h5 id="Reason-16"><a href="#Reason-16" class="headerlink" title="Reason"></a>Reason</h5><p>Types are the simplest and best documentation, have well-defined meaning, and are guaranteed to be checked at compile time.<br>Also, precisely typed code is often optimized better.</p>
<h5 id="Example-don’t"><a href="#Example-don’t" class="headerlink" title="Example, don’t"></a>Example, don’t</h5><p>Consider:</p>
<pre><code>void pass(void* data);    // void* is suspicious
</code></pre>
<p>Now the callee must cast the data pointer (back) to a correct type to use it. That is error-prone and often verbose.<br>Avoid <code>void*</code>, especially in interfaces.<br>Consider using a <code>variant</code> or a pointer to base instead.</p>
<p><strong>Alternative</strong>: Often, a template parameter can eliminate the <code>void*</code> turning it into a <code>T*</code> or <code>T&amp;</code>.<br>For generic code these <code>T</code>s can be general or concept constrained template parameters.</p>
<h5 id="Example-bad-10"><a href="#Example-bad-10" class="headerlink" title="Example, bad"></a>Example, bad</h5><p>Consider:</p>
<pre><code>void draw_rect(int, int, int, int);   // great opportunities for mistakes

draw_rect(p.x, p.y, 10, 20);          // what does 10, 20 mean?
</code></pre>
<p>An <code>int</code> can carry arbitrary forms of information, so we must guess about the meaning of the four <code>int</code>s.<br>Most likely, the first two are an <code>x</code>,<code>y</code> coordinate pair, but what are the last two?<br>Comments and parameter names can help, but we could be explicit:</p>
<pre><code>void draw_rectangle(Point top_left, Point bottom_right);
void draw_rectangle(Point top_left, Size height_width);

draw_rectangle(p, Point&#123;10, 20&#125;);  // two corners
draw_rectangle(p, Size&#123;10, 20&#125;);   // one corner and a (height, width) pair
</code></pre>
<p>Obviously, we cannot catch all errors through the static type system<br>(e.g., the fact that a first argument is supposed to be a top-left point is left to convention (naming and comments)).</p>
<h5 id="Example-bad-11"><a href="#Example-bad-11" class="headerlink" title="Example, bad"></a>Example, bad</h5><p>In the following example, it is not clear from the interface what <code>time_to_blink</code> means: Seconds? Milliseconds?</p>
<pre><code>void blink_led(int time_to_blink) // bad -- the unit is ambiguous
&#123;
    // ...
    // do something with time_to_blink
    // ...
&#125;

void use()
&#123;
    blink_led(2);
&#125;
</code></pre>
<h5 id="Example-good-1"><a href="#Example-good-1" class="headerlink" title="Example, good"></a>Example, good</h5><p><code>std::chrono::duration</code> types (C++11) helps making the unit of time duration explicit.</p>
<pre><code>void blink_led(milliseconds time_to_blink) // good -- the unit is explicit
&#123;
    // ...
    // do something with time_to_blink
    // ...
&#125;

void use()
&#123;
    blink_led(1500ms);
&#125;
</code></pre>
<p>The function can also be written in such a way that it will accept any time duration unit.</p>
<pre><code>template&lt;class rep, class period&gt;
void blink_led(duration&lt;rep, period&gt; time_to_blink) // good -- accepts any unit
&#123;
    // assuming that millisecond is the smallest relevant unit
    auto milliseconds_to_blink = duration_cast&lt;milliseconds&gt;(time_to_blink);
    // ...
    // do something with milliseconds_to_blink
    // ...
&#125;

void use()
&#123;
    blink_led(2s);
    blink_led(1500ms);
&#125;
</code></pre>
<h5 id="Enforcement-13"><a href="#Enforcement-13" class="headerlink" title="Enforcement"></a>Enforcement</h5><ul>
<li>(Simple) Report the use of <code>void*</code> as a parameter or return type.</li>
<li>(Hard to do well) Look for member functions with many built-in type arguments.</li>
</ul>
<h3 id="I-5-State-preconditions-if-any"><a href="#I-5-State-preconditions-if-any" class="headerlink" title="I.5: State preconditions (if any)"></a><a name="Ri-pre"></a>I.5: State preconditions (if any)</h3><h5 id="Reason-17"><a href="#Reason-17" class="headerlink" title="Reason"></a>Reason</h5><p>Arguments have meaning that may constrain their proper use in the callee.</p>
<h5 id="Example-16"><a href="#Example-16" class="headerlink" title="Example"></a>Example</h5><p>Consider:</p>
<pre><code>double sqrt(double x);
</code></pre>
<p>Here <code>x</code> must be nonnegative. The type system cannot (easily and naturally) express that, so we must use other means. For example:</p>
<pre><code>double sqrt(double x); // x must be nonnegative
</code></pre>
<p>Some preconditions can be expressed as assertions. For example:</p>
<pre><code>double sqrt(double x) &#123; Expects(x &gt;= 0); /* ... */ &#125;
</code></pre>
<p>Ideally, that <code>Expects(x &gt;= 0)</code> should be part of the interface of <code>sqrt()</code> but that’s not easily done. For now, we place it in the definition (function body).</p>
<p><strong>References</strong>: <code>Expects()</code> is described in <a href="#S-gsl">GSL</a>.</p>
<h5 id="Note-21"><a href="#Note-21" class="headerlink" title="Note"></a>Note</h5><p>Prefer a formal specification of requirements, such as <code>Expects(p);</code>.<br>If that is infeasible, use English text in comments, such as <code>// the sequence [p:q) is ordered using &lt;</code>.</p>
<h5 id="Note-22"><a href="#Note-22" class="headerlink" title="Note"></a>Note</h5><p>Most member functions have as a precondition that some class invariant holds.<br>That invariant is established by a constructor and must be reestablished upon exit by every member function called from outside the class.<br>We don’t need to mention it for each member function.</p>
<h5 id="Enforcement-14"><a href="#Enforcement-14" class="headerlink" title="Enforcement"></a>Enforcement</h5><p>(Not enforceable)</p>
<p><strong>See also</strong>: The rules for passing pointers. ???</p>
<h3 id="I-6-Prefer-Expects-for-expressing-preconditions"><a href="#I-6-Prefer-Expects-for-expressing-preconditions" class="headerlink" title="I.6: Prefer Expects() for expressing preconditions"></a><a name="Ri-expects"></a>I.6: Prefer <code>Expects()</code> for expressing preconditions</h3><h5 id="Reason-18"><a href="#Reason-18" class="headerlink" title="Reason"></a>Reason</h5><p>To make it clear that the condition is a precondition and to enable tool use.</p>
<h5 id="Example-17"><a href="#Example-17" class="headerlink" title="Example"></a>Example</h5><pre><code>int area(int height, int width)
&#123;
    Expects(height &gt; 0 &amp;&amp; width &gt; 0);            // good
    if (height &lt;= 0 || width &lt;= 0) my_error();   // obscure
    // ...
&#125;
</code></pre>
<h5 id="Note-23"><a href="#Note-23" class="headerlink" title="Note"></a>Note</h5><p>Preconditions can be stated in many ways, including comments, <code>if</code>-statements, and <code>assert()</code>.<br>This can make them hard to distinguish from ordinary code, hard to update, hard to manipulate by tools, and may have the wrong semantics (do you always want to abort in debug mode and check nothing in productions runs?).</p>
<h5 id="Note-24"><a href="#Note-24" class="headerlink" title="Note"></a>Note</h5><p>Preconditions should be part of the interface rather than part of the implementation,<br>but we don’t yet have the language facilities to do that.<br>Once language support becomes available (e.g., see the <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/p0380r1.pdf">contract proposal</a>) we will adopt the standard version of preconditions, postconditions, and assertions.</p>
<h5 id="Note-25"><a href="#Note-25" class="headerlink" title="Note"></a>Note</h5><p><code>Expects()</code> can also be used to check a condition in the middle of an algorithm.</p>
<h5 id="Note-26"><a href="#Note-26" class="headerlink" title="Note"></a>Note</h5><p>No, using <code>unsigned</code> is not a good way to sidestep the problem of <a href="#Res-nonnegative">ensuring that a value is nonnegative</a>.</p>
<h5 id="Enforcement-15"><a href="#Enforcement-15" class="headerlink" title="Enforcement"></a>Enforcement</h5><p>(Not enforceable) Finding the variety of ways preconditions can be asserted is not feasible. Warning about those that can be easily identified (<code>assert()</code>) has questionable value in the absence of a language facility.</p>
<h3 id="I-7-State-postconditions"><a href="#I-7-State-postconditions" class="headerlink" title="I.7: State postconditions"></a><a name="Ri-post"></a>I.7: State postconditions</h3><h5 id="Reason-19"><a href="#Reason-19" class="headerlink" title="Reason"></a>Reason</h5><p>To detect misunderstandings about the result and possibly catch erroneous implementations.</p>
<h5 id="Example-bad-12"><a href="#Example-bad-12" class="headerlink" title="Example, bad"></a>Example, bad</h5><p>Consider:</p>
<pre><code>int area(int height, int width) &#123; return height * width; &#125;  // bad
</code></pre>
<p>Here, we (incautiously) left out the precondition specification, so it is not explicit that height and width must be positive.<br>We also left out the postcondition specification, so it is not obvious that the algorithm (<code>height * width</code>) is wrong for areas larger than the largest integer.<br>Overflow can happen.<br>Consider using:</p>
<pre><code>int area(int height, int width)
&#123;
    auto res = height * width;
    Ensures(res &gt; 0);
    return res;
&#125;
</code></pre>
<h5 id="Example-bad-13"><a href="#Example-bad-13" class="headerlink" title="Example, bad"></a>Example, bad</h5><p>Consider a famous security bug:</p>
<pre><code>void f()    // problematic
&#123;
    char buffer[MAX];
    // ...
    memset(buffer, 0, sizeof(buffer));
&#125;
</code></pre>
<p>There was no postcondition stating that the buffer should be cleared and the optimizer eliminated the apparently redundant <code>memset()</code> call:</p>
<pre><code>void f()    // better
&#123;
    char buffer[MAX];
    // ...
    memset(buffer, 0, sizeof(buffer));
    Ensures(buffer[0] == 0);
&#125;
</code></pre>
<h5 id="Note-27"><a href="#Note-27" class="headerlink" title="Note"></a>Note</h5><p>Postconditions are often informally stated in a comment that states the purpose of a function; <code>Ensures()</code> can be used to make this more systematic, visible, and checkable.</p>
<h5 id="Note-28"><a href="#Note-28" class="headerlink" title="Note"></a>Note</h5><p>Postconditions are especially important when they relate to something that is not directly reflected in a returned result, such as a state of a data structure used.</p>
<h5 id="Example-18"><a href="#Example-18" class="headerlink" title="Example"></a>Example</h5><p>Consider a function that manipulates a <code>Record</code>, using a <code>mutex</code> to avoid race conditions:</p>
<pre><code>mutex m;

void manipulate(Record&amp; r)    // don&#39;t
&#123;
    m.lock();
    // ... no m.unlock() ...
&#125;
</code></pre>
<p>Here, we “forgot” to state that the <code>mutex</code> should be released, so we don’t know if the failure to ensure release of the <code>mutex</code> was a bug or a feature.<br>Stating the postcondition would have made it clear:</p>
<pre><code>void manipulate(Record&amp; r)    // postcondition: m is unlocked upon exit
&#123;
    m.lock();
    // ... no m.unlock() ...
&#125;
</code></pre>
<p>The bug is now obvious (but only to a human reading comments).</p>
<p>Better still, use <a href="#Rr-raii">RAII</a> to ensure that the postcondition (“the lock must be released”) is enforced in code:</p>
<pre><code>void manipulate(Record&amp; r)    // best
&#123;
    lock_guard&lt;mutex&gt; _ &#123;m&#125;;
    // ...
&#125;
</code></pre>
<h5 id="Note-29"><a href="#Note-29" class="headerlink" title="Note"></a>Note</h5><p>Ideally, postconditions are stated in the interface/declaration so that users can easily see them.<br>Only postconditions related to the users can be stated in the interface.<br>Postconditions related only to internal state belongs in the definition/implementation.</p>
<h5 id="Enforcement-16"><a href="#Enforcement-16" class="headerlink" title="Enforcement"></a>Enforcement</h5><p>(Not enforceable) This is a philosophical guideline that is infeasible to check<br>directly in the general case. Domain specific checkers (like lock-holding<br>checkers) exist for many toolchains.</p>
<h3 id="I-8-Prefer-Ensures-for-expressing-postconditions"><a href="#I-8-Prefer-Ensures-for-expressing-postconditions" class="headerlink" title="I.8: Prefer Ensures() for expressing postconditions"></a><a name="Ri-ensures"></a>I.8: Prefer <code>Ensures()</code> for expressing postconditions</h3><h5 id="Reason-20"><a href="#Reason-20" class="headerlink" title="Reason"></a>Reason</h5><p>To make it clear that the condition is a postcondition and to enable tool use.</p>
<h5 id="Example-19"><a href="#Example-19" class="headerlink" title="Example"></a>Example</h5><pre><code>void f()
&#123;
    char buffer[MAX];
    // ...
    memset(buffer, 0, MAX);
    Ensures(buffer[0] == 0);
&#125;
</code></pre>
<h5 id="Note-30"><a href="#Note-30" class="headerlink" title="Note"></a>Note</h5><p>Postconditions can be stated in many ways, including comments, <code>if</code>-statements, and <code>assert()</code>.<br>This can make them hard to distinguish from ordinary code, hard to update, hard to manipulate by tools, and may have the wrong semantics.</p>
<p><strong>Alternative</strong>: Postconditions of the form “this resource must be released” are best expressed by <a href="#Rr-raii">RAII</a>.</p>
<h5 id="Note-31"><a href="#Note-31" class="headerlink" title="Note"></a>Note</h5><p>Ideally, that <code>Ensures</code> should be part of the interface, but that’s not easily done.<br>For now, we place it in the definition (function body).<br>Once language support becomes available (e.g., see the <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/p0380r1.pdf">contract proposal</a>) we will adopt the standard version of preconditions, postconditions, and assertions.</p>
<h5 id="Enforcement-17"><a href="#Enforcement-17" class="headerlink" title="Enforcement"></a>Enforcement</h5><p>(Not enforceable) Finding the variety of ways postconditions can be asserted is not feasible. Warning about those that can be easily identified (<code>assert()</code>) has questionable value in the absence of a language facility.</p>
<h3 id="I-9-If-an-interface-is-a-template-document-its-parameters-using-concepts"><a href="#I-9-If-an-interface-is-a-template-document-its-parameters-using-concepts" class="headerlink" title="I.9: If an interface is a template, document its parameters using concepts"></a><a name="Ri-concepts"></a>I.9: If an interface is a template, document its parameters using concepts</h3><h5 id="Reason-21"><a href="#Reason-21" class="headerlink" title="Reason"></a>Reason</h5><p>Make the interface precisely specified and compile-time checkable in the (not so distant) future.</p>
<h5 id="Example-20"><a href="#Example-20" class="headerlink" title="Example"></a>Example</h5><p>Use the ISO Concepts TS style of requirements specification. For example:</p>
<pre><code>template&lt;typename Iter, typename Val&gt;
// requires InputIterator&lt;Iter&gt; &amp;&amp; EqualityComparable&lt;ValueType&lt;Iter&gt;&gt;, Val&gt;
Iter find(Iter first, Iter last, Val v)
&#123;
    // ...
&#125;
</code></pre>
<h5 id="Note-32"><a href="#Note-32" class="headerlink" title="Note"></a>Note</h5><p>Soon (maybe in 2018), most compilers will be able to check <code>requires</code> clauses once the <code>//</code> is removed.<br>Concepts are supported in GCC 6.1 and later.</p>
<p><strong>See also</strong>: <a href="#SS-GP">Generic programming</a> and <a href="#SS-concepts">concepts</a>.</p>
<h5 id="Enforcement-18"><a href="#Enforcement-18" class="headerlink" title="Enforcement"></a>Enforcement</h5><p>(Not yet enforceable) A language facility is under specification. When the language facility is available, warn if any non-variadic template parameter is not constrained by a concept (in its declaration or mentioned in a <code>requires</code> clause).</p>
<h3 id="I-10-Use-exceptions-to-signal-a-failure-to-perform-a-required-task"><a href="#I-10-Use-exceptions-to-signal-a-failure-to-perform-a-required-task" class="headerlink" title="I.10: Use exceptions to signal a failure to perform a required task"></a><a name="Ri-except"></a>I.10: Use exceptions to signal a failure to perform a required task</h3><h5 id="Reason-22"><a href="#Reason-22" class="headerlink" title="Reason"></a>Reason</h5><p>It should not be possible to ignore an error because that could leave the system or a computation in an undefined (or unexpected) state.<br>This is a major source of errors.</p>
<h5 id="Example-21"><a href="#Example-21" class="headerlink" title="Example"></a>Example</h5><pre><code>int printf(const char* ...);    // bad: return negative number if output fails

template &lt;class F, class ...Args&gt;
// good: throw system_error if unable to start the new thread
explicit thread(F&amp;&amp; f, Args&amp;&amp;... args);
</code></pre>
<h5 id="Note-33"><a href="#Note-33" class="headerlink" title="Note"></a>Note</h5><p>What is an error?</p>
<p>An error means that the function cannot achieve its advertised purpose (including establishing postconditions).<br>Calling code that ignores an error could lead to wrong results or undefined systems state.<br>For example, not being able to connect to a remote server is not by itself an error:<br>the server can refuse a connection for all kinds of reasons, so the natural thing is to return a result that the caller should always check.<br>However, if failing to make a connection is considered an error, then a failure should throw an exception.</p>
<h5 id="Exception-2"><a href="#Exception-2" class="headerlink" title="Exception"></a>Exception</h5><p>Many traditional interface functions (e.g., UNIX signal handlers) use error codes (e.g., <code>errno</code>) to report what are really status codes, rather than errors. You don’t have a good alternative to using such, so calling these does not violate the rule.</p>
<h5 id="Alternative"><a href="#Alternative" class="headerlink" title="Alternative"></a>Alternative</h5><p>If you can’t use exceptions (e.g., because your code is full of old-style raw-pointer use or because there are hard-real-time constraints), consider using a style that returns a pair of values:</p>
<pre><code>int val;
int error_code;
tie(val, error_code) = do_something();
if (error_code) &#123;
    // ... handle the error or exit ...
&#125;
// ... use val ...
</code></pre>
<p>This style unfortunately leads to uninitialized variables.<br>A facility <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/p0144r1.pdf">structured bindings</a> to deal with that will become available in C++17.</p>
<pre><code>auto [val, error_code] = do_something();
if (error_code) &#123;
    // ... handle the error or exit ...
&#125;
// ... use val ...
</code></pre>
<h5 id="Note-34"><a href="#Note-34" class="headerlink" title="Note"></a>Note</h5><p>We don’t consider “performance” a valid reason not to use exceptions.</p>
<ul>
<li>Often, explicit error checking and handling consume as much time and space as exception handling.</li>
<li>Often, cleaner code yields better performance with exceptions (simplifying the tracing of paths through the program and their optimization).</li>
<li>A good rule for performance critical code is to move checking outside the critical part of the code (<a href="#Rper-checking">checking</a>).</li>
<li>In the longer term, more regular code gets better optimized.</li>
<li>Always carefully <a href="#Rper-measure">measure</a> before making performance claims.</li>
</ul>
<p><strong>See also</strong>: <a href="#Ri-pre">I.5</a> and <a href="#Ri-post">I.7</a> for reporting precondition and postcondition violations.</p>
<h5 id="Enforcement-19"><a href="#Enforcement-19" class="headerlink" title="Enforcement"></a>Enforcement</h5><ul>
<li>(Not enforceable) This is a philosophical guideline that is infeasible to check directly.</li>
<li>Look for <code>errno</code>.</li>
</ul>
<h3 id="I-11-Never-transfer-ownership-by-a-raw-pointer-T-or-reference-T-amp"><a href="#I-11-Never-transfer-ownership-by-a-raw-pointer-T-or-reference-T-amp" class="headerlink" title="I.11: Never transfer ownership by a raw pointer (T*) or reference (T&amp;)"></a><a name="Ri-raw"></a>I.11: Never transfer ownership by a raw pointer (<code>T*</code>) or reference (<code>T&amp;</code>)</h3><h5 id="Reason-23"><a href="#Reason-23" class="headerlink" title="Reason"></a>Reason</h5><p>If there is any doubt whether the caller or the callee owns an object, leaks or premature destruction will occur.</p>
<h5 id="Example-22"><a href="#Example-22" class="headerlink" title="Example"></a>Example</h5><p>Consider:</p>
<pre><code>X* compute(args)    // don&#39;t
&#123;
    X* res = new X&#123;&#125;;
    // ...
    return res;
&#125;
</code></pre>
<p>Who deletes the returned <code>X</code>? The problem would be harder to spot if <code>compute</code> returned a reference.<br>Consider returning the result by value (use move semantics if the result is large):</p>
<pre><code>vector&lt;double&gt; compute(args)  // good
&#123;
    vector&lt;double&gt; res(10000);
    // ...
    return res;
&#125;
</code></pre>
<p><strong>Alternative</strong>: <a href="#Rr-smartptrparam">Pass ownership</a> using a “smart pointer”, such as <code>unique_ptr</code> (for exclusive ownership) and <code>shared_ptr</code> (for shared ownership).<br>However, that is less elegant and often less efficient than returning the object itself,<br>so use smart pointers only if reference semantics are needed.</p>
<p><strong>Alternative</strong>: Sometimes older code can’t be modified because of ABI compatibility requirements or lack of resources.<br>In that case, mark owning pointers using <code>owner</code> from the <a href="#S-gsl">guideline support library</a>:</p>
<pre><code>owner&lt;X*&gt; compute(args)    // It is now clear that ownership is transferred
&#123;
    owner&lt;X*&gt; res = new X&#123;&#125;;
    // ...
    return res;
&#125;
</code></pre>
<p>This tells analysis tools that <code>res</code> is an owner.<br>That is, its value must be <code>delete</code>d or transferred to another owner, as is done here by the <code>return</code>.</p>
<p><code>owner</code> is used similarly in the implementation of resource handles.</p>
<h5 id="Note-35"><a href="#Note-35" class="headerlink" title="Note"></a>Note</h5><p>Every object passed as a raw pointer (or iterator) is assumed to be owned by the<br>caller, so that its lifetime is handled by the caller. Viewed another way:<br>ownership transferring APIs are relatively rare compared to pointer-passing APIs,<br>so the default is “no ownership transfer.”</p>
<p><strong>See also</strong>: <a href="#Rf-conventional">Argument passing</a>, <a href="#Rr-smartptrparam">use of smart pointer arguments</a>, and <a href="#Rf-value-return">value return</a>.</p>
<h5 id="Enforcement-20"><a href="#Enforcement-20" class="headerlink" title="Enforcement"></a>Enforcement</h5><ul>
<li>(Simple) Warn on <code>delete</code> of a raw pointer that is not an <code>owner&lt;T&gt;</code>. Suggest use of standard-library resource handle or use of <code>owner&lt;T&gt;</code>.</li>
<li>(Simple) Warn on failure to either <code>reset</code> or explicitly <code>delete</code> an <code>owner</code> pointer on every code path.</li>
<li>(Simple) Warn if the return value of <code>new</code> or a function call with an <code>owner</code> return value is assigned to a raw pointer or non-<code>owner</code> reference.</li>
</ul>
<h3 id="I-12-Declare-a-pointer-that-must-not-be-null-as-not-null"><a href="#I-12-Declare-a-pointer-that-must-not-be-null-as-not-null" class="headerlink" title="I.12: Declare a pointer that must not be null as not_null"></a><a name="Ri-nullptr"></a>I.12: Declare a pointer that must not be null as <code>not_null</code></h3><h5 id="Reason-24"><a href="#Reason-24" class="headerlink" title="Reason"></a>Reason</h5><p>To help avoid dereferencing <code>nullptr</code> errors.<br>To improve performance by avoiding redundant checks for <code>nullptr</code>.</p>
<h5 id="Example-23"><a href="#Example-23" class="headerlink" title="Example"></a>Example</h5><pre><code>int length(const char* p);            // it is not clear whether length(nullptr) is valid

length(nullptr);                      // OK?

int length(not_null&lt;const char*&gt; p);  // better: we can assume that p cannot be nullptr

int length(const char* p);            // we must assume that p can be nullptr
</code></pre>
<p>By stating the intent in source, implementers and tools can provide better diagnostics, such as finding some classes of errors through static analysis, and perform optimizations, such as removing branches and null tests.</p>
<h5 id="Note-36"><a href="#Note-36" class="headerlink" title="Note"></a>Note</h5><p><code>not_null</code> is defined in the <a href="#S-gsl">guideline support library</a>.</p>
<h5 id="Note-37"><a href="#Note-37" class="headerlink" title="Note"></a>Note</h5><p>The assumption that the pointer to <code>char</code> pointed to a C-style string (a zero-terminated string of characters) was still implicit, and a potential source of confusion and errors. Use <code>czstring</code> in preference to <code>const char*</code>.</p>
<pre><code>// we can assume that p cannot be nullptr
// we can assume that p points to a zero-terminated array of characters
int length(not_null&lt;zstring&gt; p);
</code></pre>
<p>Note: <code>length()</code> is, of course, <code>std::strlen()</code> in disguise.</p>
<h5 id="Enforcement-21"><a href="#Enforcement-21" class="headerlink" title="Enforcement"></a>Enforcement</h5><ul>
<li>(Simple) ((Foundation)) If a function checks a pointer parameter against <code>nullptr</code> before access, on all control-flow paths, then warn it should be declared <code>not_null</code>.</li>
<li>(Complex) If a function with pointer return value ensures it is not <code>nullptr</code> on all return paths, then warn the return type should be declared <code>not_null</code>.</li>
</ul>
<h3 id="I-13-Do-not-pass-an-array-as-a-single-pointer"><a href="#I-13-Do-not-pass-an-array-as-a-single-pointer" class="headerlink" title="I.13: Do not pass an array as a single pointer"></a><a name="Ri-array"></a>I.13: Do not pass an array as a single pointer</h3><h5 id="Reason-25"><a href="#Reason-25" class="headerlink" title="Reason"></a>Reason</h5><p> (pointer, size)-style interfaces are error-prone. Also, a plain pointer (to array) must rely on some convention to allow the callee to determine the size.</p>
<h5 id="Example-24"><a href="#Example-24" class="headerlink" title="Example"></a>Example</h5><p>Consider:</p>
<pre><code>void copy_n(const T* p, T* q, int n); // copy from [p:p+n) to [q:q+n)
</code></pre>
<p>What if there are fewer than <code>n</code> elements in the array pointed to by <code>q</code>? Then, we overwrite some probably unrelated memory.<br>What if there are fewer than <code>n</code> elements in the array pointed to by <code>p</code>? Then, we read some probably unrelated memory.<br>Either is undefined behavior and a potentially very nasty bug.</p>
<h5 id="Alternative-1"><a href="#Alternative-1" class="headerlink" title="Alternative"></a>Alternative</h5><p>Consider using explicit spans:</p>
<pre><code>void copy(span&lt;const T&gt; r, span&lt;T&gt; r2); // copy r to r2
</code></pre>
<h5 id="Example-bad-14"><a href="#Example-bad-14" class="headerlink" title="Example, bad"></a>Example, bad</h5><p>Consider:</p>
<pre><code>void draw(Shape* p, int n);  // poor interface; poor code
Circle arr[10];
// ...
draw(arr, 10);
</code></pre>
<p>Passing <code>10</code> as the <code>n</code> argument may be a mistake: the most common convention is to assume <code>[0:n)</code> but that is nowhere stated. Worse is that the call of <code>draw()</code> compiled at all: there was an implicit conversion from array to pointer (array decay) and then another implicit conversion from <code>Circle</code> to <code>Shape</code>. There is no way that <code>draw()</code> can safely iterate through that array: it has no way of knowing the size of the elements.</p>
<p><strong>Alternative</strong>: Use a support class that ensures that the number of elements is correct and prevents dangerous implicit conversions. For example:</p>
<pre><code>void draw2(span&lt;Circle&gt;);
Circle arr[10];
// ...
draw2(span&lt;Circle&gt;(arr));  // deduce the number of elements
draw2(arr);    // deduce the element type and array size

void draw3(span&lt;Shape&gt;);
draw3(arr);    // error: cannot convert Circle[10] to span&lt;Shape&gt;
</code></pre>
<p>This <code>draw2()</code> passes the same amount of information to <code>draw()</code>, but makes the fact that it is supposed to be a range of <code>Circle</code>s explicit. See ???.</p>
<h5 id="Exception-3"><a href="#Exception-3" class="headerlink" title="Exception"></a>Exception</h5><p>Use <code>zstring</code> and <code>czstring</code> to represent a C-style, zero-terminated strings.<br>But when doing so, use <code>string_span</code> from the <a href="#GSL">GSL</a> to prevent range errors.</p>
<h5 id="Enforcement-22"><a href="#Enforcement-22" class="headerlink" title="Enforcement"></a>Enforcement</h5><ul>
<li>(Simple) ((Bounds)) Warn for any expression that would rely on implicit conversion of an array type to a pointer type. Allow exception for zstring/czstring pointer types.</li>
<li>(Simple) ((Bounds)) Warn for any arithmetic operation on an expression of pointer type that results in a value of pointer type. Allow exception for zstring/czstring pointer types.</li>
</ul>
<h3 id="I-22-Avoid-complex-initialization-of-global-objects"><a href="#I-22-Avoid-complex-initialization-of-global-objects" class="headerlink" title="I.22: Avoid complex initialization of global objects"></a><a name="Ri-global-init"></a>I.22: Avoid complex initialization of global objects</h3><h5 id="Reason-26"><a href="#Reason-26" class="headerlink" title="Reason"></a>Reason</h5><p>Complex initialization can lead to undefined order of execution.</p>
<h5 id="Example-25"><a href="#Example-25" class="headerlink" title="Example"></a>Example</h5><pre><code>// file1.c

extern const X x;

const Y y = f(x);   // read x; write y

// file2.c

extern const Y y;

const X x = g(y);   // read y; write x
</code></pre>
<p>Since <code>x</code> and <code>y</code> are in different translation units the order of calls to <code>f()</code> and <code>g()</code> is undefined;<br>one will access an uninitialized <code>const</code>.<br>This shows that the order-of-initialization problem for global (namespace scope) objects is not limited to global <em>variables</em>.</p>
<h5 id="Note-38"><a href="#Note-38" class="headerlink" title="Note"></a>Note</h5><p>Order of initialization problems become particularly difficult to handle in concurrent code.<br>It is usually best to avoid global (namespace scope) objects altogether.</p>
<h5 id="Enforcement-23"><a href="#Enforcement-23" class="headerlink" title="Enforcement"></a>Enforcement</h5><ul>
<li>Flag initializers of globals that call non-<code>constexpr</code> functions</li>
<li>Flag initializers of globals that access <code>extern</code> objects</li>
</ul>
<h3 id="I-23-Keep-the-number-of-function-arguments-low"><a href="#I-23-Keep-the-number-of-function-arguments-low" class="headerlink" title="I.23: Keep the number of function arguments low"></a><a name="Ri-nargs"></a>I.23: Keep the number of function arguments low</h3><h5 id="Reason-27"><a href="#Reason-27" class="headerlink" title="Reason"></a>Reason</h5><p>Having many arguments opens opportunities for confusion. Passing lots of arguments is often costly compared to alternatives.</p>
<h5 id="Discussion"><a href="#Discussion" class="headerlink" title="Discussion"></a>Discussion</h5><p>The two most common reasons why functions have too many parameters are:</p>
<ol>
<li><p><em>Missing an abstraction.</em><br>There is an abstraction missing, so that a compound value is being<br>passed as individual elements instead of as a single object that enforces an invariant.<br>This not only expands the parameter list, but it leads to errors because the component values<br>are no longer protected by an enforced invariant.</p>
</li>
<li><p><em>Violating “one function, one responsibility.”</em><br>The function is trying to do more than one job and should probably be refactored.</p>
</li>
</ol>
<h5 id="Example-26"><a href="#Example-26" class="headerlink" title="Example"></a>Example</h5><p>The standard-library <code>merge()</code> is at the limit of what we can comfortably handle:</p>
<pre><code>template&lt;class InputIterator1, class InputIterator2, class OutputIterator, class Compare&gt;
OutputIterator merge(InputIterator1 first1, InputIterator1 last1,
                     InputIterator2 first2, InputIterator2 last2,
                     OutputIterator result, Compare comp);
</code></pre>
<p>Note that this is because of problem 1 above – missing abstraction. Instead of passing a range (abstraction), STL passed iterator pairs (unencapsulated component values).</p>
<p>Here, we have four template arguments and six function arguments.<br>To simplify the most frequent and simplest uses, the comparison argument can be defaulted to <code>&lt;</code>:</p>
<pre><code>template&lt;class InputIterator1, class InputIterator2, class OutputIterator&gt;
OutputIterator merge(InputIterator1 first1, InputIterator1 last1,
                     InputIterator2 first2, InputIterator2 last2,
                     OutputIterator result);
</code></pre>
<p>This doesn’t reduce the total complexity, but it reduces the surface complexity presented to many users.<br>To really reduce the number of arguments, we need to bundle the arguments into higher-level abstractions:</p>
<pre><code>template&lt;class InputRange1, class InputRange2, class OutputIterator&gt;
OutputIterator merge(InputRange1 r1, InputRange2 r2, OutputIterator result);
</code></pre>
<p>Grouping arguments into “bundles” is a general technique to reduce the number of arguments and to increase the opportunities for checking.</p>
<p>Alternatively, we could use concepts (as defined by the ISO TS) to define the notion of three types that must be usable for merging:</p>
<pre><code>Mergeable&#123;In1, In2, Out&#125;
OutputIterator merge(In1 r1, In2 r2, Out result);
</code></pre>
<h5 id="Example-27"><a href="#Example-27" class="headerlink" title="Example"></a>Example</h5><p>The safety Profiles recommend replacing</p>
<pre><code>void f(int* some_ints, int some_ints_length);  // BAD: C style, unsafe
</code></pre>
<p>with</p>
<pre><code>void f(gsl::span&lt;int&gt; some_ints);              // GOOD: safe, bounds-checked
</code></pre>
<p>Here, using an abstraction has safety and robustness benefits, and naturally also reduces the number of parameters.</p>
<h5 id="Note-39"><a href="#Note-39" class="headerlink" title="Note"></a>Note</h5><p>How many parameters are too many? Try to use fewer than four (4) parameters.<br>There are functions that are best expressed with four individual parameters, but not many.</p>
<p><strong>Alternative</strong>: Use better abstraction: Group arguments into meaningful objects and pass the objects (by value or by reference).</p>
<p><strong>Alternative</strong>: Use default arguments or overloads to allow the most common forms of calls to be done with fewer arguments.</p>
<h5 id="Enforcement-24"><a href="#Enforcement-24" class="headerlink" title="Enforcement"></a>Enforcement</h5><ul>
<li>Warn when a function declares two iterators (including pointers) of the same type instead of a range or a view.</li>
<li>(Not enforceable) This is a philosophical guideline that is infeasible to check directly.</li>
</ul>
<h3 id="I-24-Avoid-adjacent-unrelated-parameters-of-the-same-type"><a href="#I-24-Avoid-adjacent-unrelated-parameters-of-the-same-type" class="headerlink" title="I.24: Avoid adjacent unrelated parameters of the same type"></a><a name="Ri-unrelated"></a>I.24: Avoid adjacent unrelated parameters of the same type</h3><h5 id="Reason-28"><a href="#Reason-28" class="headerlink" title="Reason"></a>Reason</h5><p>Adjacent arguments of the same type are easily swapped by mistake.</p>
<h5 id="Example-bad-15"><a href="#Example-bad-15" class="headerlink" title="Example, bad"></a>Example, bad</h5><p>Consider:</p>
<pre><code>void copy_n(T* p, T* q, int n);  // copy from [p:p + n) to [q:q + n)
</code></pre>
<p>This is a nasty variant of a K&amp;R C-style interface. It is easy to reverse the “to” and “from” arguments.</p>
<p>Use <code>const</code> for the “from” argument:</p>
<pre><code>void copy_n(const T* p, T* q, int n);  // copy from [p:p + n) to [q:q + n)
</code></pre>
<h5 id="Exception-4"><a href="#Exception-4" class="headerlink" title="Exception"></a>Exception</h5><p>If the order of the parameters is not important, there is no problem:</p>
<pre><code>int max(int a, int b);
</code></pre>
<h5 id="Alternative-2"><a href="#Alternative-2" class="headerlink" title="Alternative"></a>Alternative</h5><p>Don’t pass arrays as pointers, pass an object representing a range (e.g., a <code>span</code>):</p>
<pre><code>void copy_n(span&lt;const T&gt; p, span&lt;T&gt; q);  // copy from p to q
</code></pre>
<h5 id="Alternative-3"><a href="#Alternative-3" class="headerlink" title="Alternative"></a>Alternative</h5><p>Define a <code>struct</code> as the parameter type and name the fields for those parameters accordingly:</p>
<pre><code>struct SystemParams &#123;
    string config_file;
    string output_path;
    seconds timeout;
&#125;;
void initialize(SystemParams p);
</code></pre>
<p>This tends to make invocations of this clear to future readers, as the parameters<br>are often filled in by name at the call site.</p>
<h5 id="Enforcement-25"><a href="#Enforcement-25" class="headerlink" title="Enforcement"></a>Enforcement</h5><p>(Simple) Warn if two consecutive parameters share the same type.</p>
<h3 id="I-25-Prefer-abstract-classes-as-interfaces-to-class-hierarchies"><a href="#I-25-Prefer-abstract-classes-as-interfaces-to-class-hierarchies" class="headerlink" title="I.25: Prefer abstract classes as interfaces to class hierarchies"></a><a name="Ri-abstract"></a>I.25: Prefer abstract classes as interfaces to class hierarchies</h3><h5 id="Reason-29"><a href="#Reason-29" class="headerlink" title="Reason"></a>Reason</h5><p>Abstract classes are more likely to be stable than base classes with state.</p>
<h5 id="Example-bad-16"><a href="#Example-bad-16" class="headerlink" title="Example, bad"></a>Example, bad</h5><p>You just knew that <code>Shape</code> would turn up somewhere :-)</p>
<pre><code>class Shape &#123;  // bad: interface class loaded with data
public:
    Point center() const &#123; return c; &#125;
    virtual void draw() const;
    virtual void rotate(int);
    // ...
private:
    Point c;
    vector&lt;Point&gt; outline;
    Color col;
&#125;;
</code></pre>
<p>This will force every derived class to compute a center – even if that’s non-trivial and the center is never used. Similarly, not every <code>Shape</code> has a <code>Color</code>, and many <code>Shape</code>s are best represented without an outline defined as a sequence of <code>Point</code>s. Abstract classes were invented to discourage users from writing such classes:</p>
<pre><code>class Shape &#123;    // better: Shape is a pure interface
public:
    virtual Point center() const = 0;   // pure virtual functions
    virtual void draw() const = 0;
    virtual void rotate(int) = 0;
    // ...
    // ... no data members ...
    // ...
    virtual ~Shape() = default;
&#125;;
</code></pre>
<h5 id="Enforcement-26"><a href="#Enforcement-26" class="headerlink" title="Enforcement"></a>Enforcement</h5><p>(Simple) Warn if a pointer/reference to a class <code>C</code> is assigned to a pointer/reference to a base of <code>C</code> and the base class contains data members.</p>
<h3 id="I-26-If-you-want-a-cross-compiler-ABI-use-a-C-style-subset"><a href="#I-26-If-you-want-a-cross-compiler-ABI-use-a-C-style-subset" class="headerlink" title="I.26: If you want a cross-compiler ABI, use a C-style subset"></a><a name="Ri-abi"></a>I.26: If you want a cross-compiler ABI, use a C-style subset</h3><h5 id="Reason-30"><a href="#Reason-30" class="headerlink" title="Reason"></a>Reason</h5><p>Different compilers implement different binary layouts for classes, exception handling, function names, and other implementation details.</p>
<h5 id="Exception-5"><a href="#Exception-5" class="headerlink" title="Exception"></a>Exception</h5><p>You can carefully craft an interface using a few carefully selected higher-level C++ types. See ???.</p>
<h5 id="Exception-6"><a href="#Exception-6" class="headerlink" title="Exception"></a>Exception</h5><p>Common ABIs are emerging on some platforms freeing you from the more draconian restrictions.</p>
<h5 id="Note-40"><a href="#Note-40" class="headerlink" title="Note"></a>Note</h5><p>If you use a single compiler, you can use full C++ in interfaces. That may require recompilation after an upgrade to a new compiler version.</p>
<h5 id="Enforcement-27"><a href="#Enforcement-27" class="headerlink" title="Enforcement"></a>Enforcement</h5><p>(Not enforceable) It is difficult to reliably identify where an interface forms part of an ABI.</p>
<h3 id="I-27-For-stable-library-ABI-consider-the-Pimpl-idiom"><a href="#I-27-For-stable-library-ABI-consider-the-Pimpl-idiom" class="headerlink" title="I.27: For stable library ABI, consider the Pimpl idiom"></a><a name="Ri-pimpl"></a>I.27: For stable library ABI, consider the Pimpl idiom</h3><h5 id="Reason-31"><a href="#Reason-31" class="headerlink" title="Reason"></a>Reason</h5><p>Because private data members participate in class layout and private member functions participate in overload resolution, changes to those<br>implementation details require recompilation of all users of a class that uses them. A non-polymorphic interface class holding a pointer to<br>implementation (Pimpl) can isolate the users of a class from changes in its implementation at the cost of an indirection.</p>
<h5 id="Example-28"><a href="#Example-28" class="headerlink" title="Example"></a>Example</h5><p>interface (widget.h)</p>
<pre><code>class widget &#123;
    class impl;
    std::unique_ptr&lt;impl&gt; pimpl;
public:
    void draw(); // public API that will be forwarded to the implementation
    widget(int); // defined in the implementation file
    ~widget();   // defined in the implementation file, where impl is a complete type
    widget(widget&amp;&amp;) = default;
    widget(const widget&amp;) = delete;
    widget&amp; operator=(widget&amp;&amp;); // defined in the implementation file
    widget&amp; operator=(const widget&amp;) = delete;
&#125;;
</code></pre>
<p>implementation (widget.cpp)</p>
<pre><code>class widget::impl &#123;
    int n; // private data
public:
    void draw(const widget&amp; w) &#123; /* ... */ &#125;
    impl(int n) : n(n) &#123;&#125;
&#125;;
void widget::draw() &#123; pimpl-&gt;draw(*this); &#125;
widget::widget(int n) : pimpl&#123;std::make_unique&lt;impl&gt;(n)&#125; &#123;&#125;
widget::~widget() = default;
widget&amp; widget::operator=(widget&amp;&amp;) = default;
</code></pre>
<h5 id="Notes"><a href="#Notes" class="headerlink" title="Notes"></a>Notes</h5><p>See <a href="https://herbsutter.com/gotw/_100/">GOTW #100</a> and <a href="http://en.cppreference.com/w/cpp/language/pimpl">cppreference</a> for the trade-offs and additional implementation details associated with this idiom.</p>
<h5 id="Enforcement-28"><a href="#Enforcement-28" class="headerlink" title="Enforcement"></a>Enforcement</h5><p>(Not enforceable) It is difficult to reliably identify where an interface forms part of an ABI.</p>
<h3 id="I-30-Encapsulate-rule-violations"><a href="#I-30-Encapsulate-rule-violations" class="headerlink" title="I.30: Encapsulate rule violations"></a><a name="Ri-encapsulate"></a>I.30: Encapsulate rule violations</h3><h5 id="Reason-32"><a href="#Reason-32" class="headerlink" title="Reason"></a>Reason</h5><p>To keep code simple and safe.<br>Sometimes, ugly, unsafe, or error-prone techniques are necessary for logical or performance reasons.<br>If so, keep them local, rather than “infecting” interfaces so that larger groups of programmers have to be aware of the<br>subtleties.<br>Implementation complexity should, if at all possible, not leak through interfaces into user code.</p>
<h5 id="Example-29"><a href="#Example-29" class="headerlink" title="Example"></a>Example</h5><p>Consider a program that, depending on some form of input (e.g., arguments to <code>main</code>), should consume input<br>from a file, from the command line, or from standard input.<br>We might write</p>
<pre><code>bool owned;
owner&lt;istream*&gt; inp;
switch (source) &#123;
case std_in:        owned = false; inp = &amp;cin;                       break;
case command_line:  owned = true;  inp = new istringstream&#123;argv[2]&#125;; break;
case file:          owned = true;  inp = new ifstream&#123;argv[2]&#125;;      break;
&#125;
istream&amp; in = *inp;
</code></pre>
<p>This violated the rule <a href="#Res-always">against uninitialized variables</a>,<br>the rule against <a href="#Ri-raw">ignoring ownership</a>,<br>and the rule <a href="#Res-magic">against magic constants</a>.<br>In particular, someone has to remember to somewhere write</p>
<pre><code>if (owned) delete inp;
</code></pre>
<p>We could handle this particular example by using <code>unique_ptr</code> with a special deleter that does nothing for <code>cin</code>,<br>but that’s complicated for novices (who can easily encounter this problem) and the example is an example of a more general<br>problem where a property that we would like to consider static (here, ownership) needs infrequently be addressed<br>at run time.<br>The common, most frequent, and safest examples can be handled statically, so we don’t want to add cost and complexity to those.<br>But we must also cope with the uncommon, less-safe, and necessarily more expensive cases.<br>Such examples are discussed in <a href="http://www.stroustrup.com/resource-model.pdf">[Str15]</a>.</p>
<p>So, we write a class</p>
<pre><code>class Istream &#123; [[gsl::suppress(lifetime)]]
public:
    enum Opt &#123; from_line = 1 &#125;;
    Istream() &#123; &#125;
    Istream(zstring p) :owned&#123;true&#125;, inp&#123;new ifstream&#123;p&#125;&#125; &#123;&#125;            // read from file
    Istream(zstring p, Opt) :owned&#123;true&#125;, inp&#123;new istringstream&#123;p&#125;&#125; &#123;&#125;  // read from command line
    ~Istream() &#123; if (owned) delete inp; &#125;
    operator istream&amp; () &#123; return *inp; &#125;
private:
    bool owned = false;
    istream* inp = &amp;cin;
&#125;;
</code></pre>
<p>Now, the dynamic nature of <code>istream</code> ownership has been encapsulated.<br>Presumably, a bit of checking for potential errors would be added in real code.</p>
<h5 id="Enforcement-29"><a href="#Enforcement-29" class="headerlink" title="Enforcement"></a>Enforcement</h5><ul>
<li>Hard, it is hard to decide what rule-breaking code is essential</li>
<li>Flag rule suppression that enable rule-violations to cross interfaces</li>
</ul>
<h1 id="F-Functions"><a href="#F-Functions" class="headerlink" title="F: Functions"></a><a name="S-functions"></a>F: Functions</h1><p>A function specifies an action or a computation that takes the system from one consistent state to the next. It is the fundamental building block of programs.</p>
<p>It should be possible to name a function meaningfully, to specify the requirements of its argument, and clearly state the relationship between the arguments and the result. An implementation is not a specification. Try to think about what a function does as well as about how it does it.<br>Functions are the most critical part in most interfaces, so see the interface rules.</p>
<p>Function rule summary:</p>
<p>Function definition rules:</p>
<ul>
<li><a href="#Rf-package">F.1: “Package” meaningful operations as carefully named functions</a></li>
<li><a href="#Rf-logical">F.2: A function should perform a single logical operation</a></li>
<li><a href="#Rf-single">F.3: Keep functions short and simple</a></li>
<li><a href="#Rf-constexpr">F.4: If a function may have to be evaluated at compile time, declare it <code>constexpr</code></a></li>
<li><a href="#Rf-inline">F.5: If a function is very small and time-critical, declare it inline</a></li>
<li><a href="#Rf-noexcept">F.6: If your function may not throw, declare it <code>noexcept</code></a></li>
<li><a href="#Rf-smart">F.7: For general use, take <code>T*</code> or <code>T&amp;</code> arguments rather than smart pointers</a></li>
<li><a href="#Rf-pure">F.8: Prefer pure functions</a></li>
<li><a href="#Rf-unused">F.9: Unused parameters should be unnamed</a></li>
</ul>
<p>Parameter passing expression rules:</p>
<ul>
<li><a href="#Rf-conventional">F.15: Prefer simple and conventional ways of passing information</a></li>
<li><a href="#Rf-in">F.16: For “in” parameters, pass cheaply-copied types by value and others by reference to <code>const</code></a></li>
<li><a href="#Rf-inout">F.17: For “in-out” parameters, pass by reference to non-<code>const</code></a></li>
<li><a href="#Rf-consume">F.18: For “will-move-from” parameters, pass by <code>X&amp;&amp;</code> and <code>std::move</code> the parameter</a></li>
<li><a href="#Rf-forward">F.19: For “forward” parameters, pass by <code>TP&amp;&amp;</code> and only <code>std::forward</code> the parameter</a></li>
<li><a href="#Rf-out">F.20: For “out” output values, prefer return values to output parameters</a></li>
<li><a href="#Rf-out-multi">F.21: To return multiple “out” values, prefer returning a struct or tuple</a></li>
<li><a href="#Rf-ptr-ref">F.60: Prefer <code>T*</code> over <code>T&amp;</code> when “no argument” is a valid option</a></li>
</ul>
<p>Parameter passing semantic rules:</p>
<ul>
<li><a href="#Rf-ptr">F.22: Use <code>T*</code> or <code>owner&lt;T*&gt;</code> to designate a single object</a></li>
<li><a href="#Rf-nullptr">F.23: Use a <code>not_null&lt;T&gt;</code> to indicate that “null” is not a valid value</a></li>
<li><a href="#Rf-range">F.24: Use a <code>span&lt;T&gt;</code> or a <code>span_p&lt;T&gt;</code> to designate a half-open sequence</a></li>
<li><a href="#Rf-zstring">F.25: Use a <code>zstring</code> or a <code>not_null&lt;zstring&gt;</code> to designate a C-style string</a></li>
<li><a href="#Rf-unique_ptr">F.26: Use a <code>unique_ptr&lt;T&gt;</code> to transfer ownership where a pointer is needed</a></li>
<li><a href="#Rf-shared_ptr">F.27: Use a <code>shared_ptr&lt;T&gt;</code> to share ownership</a></li>
</ul>
<p><a name="Rf-value-return"></a>Value return semantic rules:</p>
<ul>
<li><a href="#Rf-return-ptr">F.42: Return a <code>T*</code> to indicate a position (only)</a></li>
<li><a href="#Rf-dangle">F.43: Never (directly or indirectly) return a pointer or a reference to a local object</a></li>
<li><a href="#Rf-return-ref">F.44: Return a <code>T&amp;</code> when copy is undesirable and “returning no object” isn’t needed</a></li>
<li><a href="#Rf-return-ref-ref">F.45: Don’t return a <code>T&amp;&amp;</code></a></li>
<li><a href="#Rf-main">F.46: <code>int</code> is the return type for <code>main()</code></a></li>
<li><a href="#Rf-assignment-op">F.47: Return <code>T&amp;</code> from assignment operators</a></li>
<li><a href="#Rf-return-move-local">F.48: Don’t <code>return std::move(local)</code></a></li>
</ul>
<p>Other function rules:</p>
<ul>
<li><a href="#Rf-capture-vs-overload">F.50: Use a lambda when a function won’t do (to capture local variables, or to write a local function)</a></li>
<li><a href="#Rf-default-args">F.51: Where there is a choice, prefer default arguments over overloading</a></li>
<li><a href="#Rf-reference-capture">F.52: Prefer capturing by reference in lambdas that will be used locally, including passed to algorithms</a></li>
<li><a href="#Rf-value-capture">F.53: Avoid capturing by reference in lambdas that will be used nonlocally, including returned, stored on the heap, or passed to another thread</a></li>
<li><a href="#Rf-this-capture">F.54: If you capture <code>this</code>, capture all variables explicitly (no default capture)</a></li>
<li><a href="#F-varargs">F.55: Don’t use <code>va_arg</code> arguments</a></li>
</ul>
<p>Functions have strong similarities to lambdas and function objects.</p>
<p><strong>See also</strong>: <a href="#SS-lambdas">C.lambdas: Function objects and lambdas</a></p>
<h2 id="F-def-Function-definitions"><a href="#F-def-Function-definitions" class="headerlink" title="F.def: Function definitions"></a><a name="SS-fct-def"></a>F.def: Function definitions</h2><p>A function definition is a function declaration that also specifies the function’s implementation, the function body.</p>
<h3 id="F-1-“Package”-meaningful-operations-as-carefully-named-functions"><a href="#F-1-“Package”-meaningful-operations-as-carefully-named-functions" class="headerlink" title="F.1: “Package” meaningful operations as carefully named functions"></a><a name="Rf-package"></a>F.1: “Package” meaningful operations as carefully named functions</h3><h5 id="Reason-33"><a href="#Reason-33" class="headerlink" title="Reason"></a>Reason</h5><p>Factoring out common code makes code more readable, more likely to be reused, and limit errors from complex code.<br>If something is a well-specified action, separate it out from its surrounding code and give it a name.</p>
<h5 id="Example-don’t-1"><a href="#Example-don’t-1" class="headerlink" title="Example, don’t"></a>Example, don’t</h5><pre><code>void read_and_print(istream&amp; is)    // read and print an int
&#123;
    int x;
    if (is &gt;&gt; x)
        cout &lt;&lt; &quot;the int is &quot; &lt;&lt; x &lt;&lt; &#39;\n&#39;;
    else
        cerr &lt;&lt; &quot;no int on input\n&quot;;
&#125;
</code></pre>
<p>Almost everything is wrong with <code>read_and_print</code>.<br>It reads, it writes (to a fixed <code>ostream</code>), it writes error messages (to a fixed <code>ostream</code>), it handles only <code>int</code>s.<br>There is nothing to reuse, logically separate operations are intermingled and local variables are in scope after the end of their logical use.<br>For a tiny example, this looks OK, but if the input operation, the output operation, and the error handling had been more complicated the tangled<br>mess could become hard to understand.</p>
<h5 id="Note-41"><a href="#Note-41" class="headerlink" title="Note"></a>Note</h5><p>If you write a non-trivial lambda that potentially can be used in more than one place, give it a name by assigning it to a (usually non-local) variable.</p>
<h5 id="Example-30"><a href="#Example-30" class="headerlink" title="Example"></a>Example</h5><pre><code>sort(a, b, [](T x, T y) &#123; return x.rank() &lt; y.rank() &amp;&amp; x.value() &lt; y.value(); &#125;);
</code></pre>
<p>Naming that lambda breaks up the expression into its logical parts and provides a strong hint to the meaning of the lambda.</p>
<pre><code>auto lessT = [](T x, T y) &#123; return x.rank() &lt; y.rank() &amp;&amp; x.value() &lt; y.value(); &#125;;

sort(a, b, lessT);
find_if(a, b, lessT);
</code></pre>
<p>The shortest code is not always the best for performance or maintainability.</p>
<h5 id="Exception-7"><a href="#Exception-7" class="headerlink" title="Exception"></a>Exception</h5><p>Loop bodies, including lambdas used as loop bodies, rarely need to be named.<br>However, large loop bodies (e.g., dozens of lines or dozens of pages) can be a problem.<br>The rule <a href="#Rf-single">Keep functions short and simple</a> implies “Keep loop bodies short.”<br>Similarly, lambdas used as callback arguments are sometimes non-trivial, yet unlikely to be reusable.</p>
<h5 id="Enforcement-30"><a href="#Enforcement-30" class="headerlink" title="Enforcement"></a>Enforcement</h5><ul>
<li>See <a href="#Rf-single">Keep functions short and simple</a></li>
<li>Flag identical and very similar lambdas used in different places.</li>
</ul>
<h3 id="F-2-A-function-should-perform-a-single-logical-operation"><a href="#F-2-A-function-should-perform-a-single-logical-operation" class="headerlink" title="F.2: A function should perform a single logical operation"></a><a name="Rf-logical"></a>F.2: A function should perform a single logical operation</h3><h5 id="Reason-34"><a href="#Reason-34" class="headerlink" title="Reason"></a>Reason</h5><p>A function that performs a single operation is simpler to understand, test, and reuse.</p>
<h5 id="Example-31"><a href="#Example-31" class="headerlink" title="Example"></a>Example</h5><p>Consider:</p>
<pre><code>void read_and_print()    // bad
&#123;
    int x;
    cin &gt;&gt; x;
    // check for errors
    cout &lt;&lt; x &lt;&lt; &quot;\n&quot;;
&#125;
</code></pre>
<p>This is a monolith that is tied to a specific input and will never find another (different) use. Instead, break functions up into suitable logical parts and parameterize:</p>
<pre><code>int read(istream&amp; is)    // better
&#123;
    int x;
    is &gt;&gt; x;
    // check for errors
    return x;
&#125;

void print(ostream&amp; os, int x)
&#123;
    os &lt;&lt; x &lt;&lt; &quot;\n&quot;;
&#125;
</code></pre>
<p>These can now be combined where needed:</p>
<pre><code>void read_and_print()
&#123;
    auto x = read(cin);
    print(cout, x);
&#125;
</code></pre>
<p>If there was a need, we could further templatize <code>read()</code> and <code>print()</code> on the data type, the I/O mechanism, the response to errors, etc. Example:</p>
<pre><code>auto read = [](auto&amp; input, auto&amp; value)    // better
&#123;
    input &gt;&gt; value;
    // check for errors
&#125;;

auto print(auto&amp; output, const auto&amp; value)
&#123;
    output &lt;&lt; value &lt;&lt; &quot;\n&quot;;
&#125;
</code></pre>
<h5 id="Enforcement-31"><a href="#Enforcement-31" class="headerlink" title="Enforcement"></a>Enforcement</h5><ul>
<li>Consider functions with more than one “out” parameter suspicious. Use return values instead, including <code>tuple</code> for multiple return values.</li>
<li>Consider “large” functions that don’t fit on one editor screen suspicious. Consider factoring such a function into smaller well-named suboperations.</li>
<li>Consider functions with 7 or more parameters suspicious.</li>
</ul>
<h3 id="F-3-Keep-functions-short-and-simple"><a href="#F-3-Keep-functions-short-and-simple" class="headerlink" title="F.3: Keep functions short and simple"></a><a name="Rf-single"></a>F.3: Keep functions short and simple</h3><h5 id="Reason-35"><a href="#Reason-35" class="headerlink" title="Reason"></a>Reason</h5><p>Large functions are hard to read, more likely to contain complex code, and more likely to have variables in larger than minimal scopes.<br>Functions with complex control structures are more likely to be long and more likely to hide logical errors</p>
<h5 id="Example-32"><a href="#Example-32" class="headerlink" title="Example"></a>Example</h5><p>Consider:</p>
<pre><code>double simple_func(double val, int flag1, int flag2)
    // simple_func: takes a value and calculates the expected ASIC output,
    // given the two mode flags.
&#123;
    double intermediate;
    if (flag1 &gt; 0) &#123;
        intermediate = func1(val);
        if (flag2 % 2)
             intermediate = sqrt(intermediate);
    &#125;
    else if (flag1 == -1) &#123;
        intermediate = func1(-val);
        if (flag2 % 2)
             intermediate = sqrt(-intermediate);
        flag1 = -flag1;
    &#125;
    if (abs(flag2) &gt; 10) &#123;
        intermediate = func2(intermediate);
    &#125;
    switch (flag2 / 10) &#123;
    case 1: if (flag1 == -1) return finalize(intermediate, 1.171);
            break;
    case 2: return finalize(intermediate, 13.1);
    default: break;
    &#125;
    return finalize(intermediate, 0.);
&#125;
</code></pre>
<p>This is too complex (and long).<br>How would you know if all possible alternatives have been correctly handled?<br>Yes, it breaks other rules also.</p>
<p>We can refactor:</p>
<pre><code>double func1_muon(double val, int flag)
&#123;
    // ???
&#125;

double funct1_tau(double val, int flag1, int flag2)
&#123;
    // ???
&#125;

double simple_func(double val, int flag1, int flag2)
    // simple_func: takes a value and calculates the expected ASIC output,
    // given the two mode flags.
&#123;
    if (flag1 &gt; 0)
        return func1_muon(val, flag2);
    if (flag1 == -1)
        // handled by func1_tau: flag1 = -flag1;
        return func1_tau(-val, flag1, flag2);
    return 0.;
&#125;
</code></pre>
<h5 id="Note-42"><a href="#Note-42" class="headerlink" title="Note"></a>Note</h5><p>“It doesn’t fit on a screen” is often a good practical definition of “far too large.”<br>One-to-five-line functions should be considered normal.</p>
<h5 id="Note-43"><a href="#Note-43" class="headerlink" title="Note"></a>Note</h5><p>Break large functions up into smaller cohesive and named functions.<br>Small simple functions are easily inlined where the cost of a function call is significant.</p>
<h5 id="Enforcement-32"><a href="#Enforcement-32" class="headerlink" title="Enforcement"></a>Enforcement</h5><ul>
<li>Flag functions that do not “fit on a screen.”<br>How big is a screen? Try 60 lines by 140 characters; that’s roughly the maximum that’s comfortable for a book page.</li>
<li>Flag functions that are too complex. How complex is too complex?<br>You could use cyclomatic complexity. Try “more than 10 logical path through.” Count a simple switch as one path.</li>
</ul>
<h3 id="F-4-If-a-function-may-have-to-be-evaluated-at-compile-time-declare-it-constexpr"><a href="#F-4-If-a-function-may-have-to-be-evaluated-at-compile-time-declare-it-constexpr" class="headerlink" title="F.4: If a function may have to be evaluated at compile time, declare it constexpr"></a><a name="Rf-constexpr"></a>F.4: If a function may have to be evaluated at compile time, declare it <code>constexpr</code></h3><h5 id="Reason-36"><a href="#Reason-36" class="headerlink" title="Reason"></a>Reason</h5><p> <code>constexpr</code> is needed to tell the compiler to allow compile-time evaluation.</p>
<h5 id="Example-33"><a href="#Example-33" class="headerlink" title="Example"></a>Example</h5><p>The (in)famous factorial:</p>
<pre><code>constexpr int fac(int n)
&#123;
    constexpr int max_exp = 17;      // constexpr enables max_exp to be used in Expects
    Expects(0 &lt;= n &amp;&amp; n &lt; max_exp);  // prevent silliness and overflow
    int x = 1;
    for (int i = 2; i &lt;= n; ++i) x *= i;
    return x;
&#125;
</code></pre>
<p>This is C++14.<br>For C++11, use a recursive formulation of <code>fac()</code>.</p>
<h5 id="Note-44"><a href="#Note-44" class="headerlink" title="Note"></a>Note</h5><p><code>constexpr</code> does not guarantee compile-time evaluation;<br>it just guarantees that the function can be evaluated at compile time for constant expression arguments if the programmer requires it or the compiler decides to do so to optimize.</p>
<pre><code>constexpr int min(int x, int y) &#123; return x &lt; y ? x : y; &#125;

void test(int v)
&#123;
    int m1 = min(-1, 2);            // probably compile-time evaluation
    constexpr int m2 = min(-1, 2);  // compile-time evaluation
    int m3 = min(-1, v);            // run-time evaluation
    constexpr int m4 = min(-1, v);  // error: cannot evaluate at compile time
&#125;
</code></pre>
<h5 id="Note-45"><a href="#Note-45" class="headerlink" title="Note"></a>Note</h5><p><code>constexpr</code> functions are pure: they can have no side effects.</p>
<pre><code>int dcount = 0;
constexpr int double(int v)
&#123;
    ++dcount;   // error: attempted side effect from constexpr function
    return v + v;
&#125;
</code></pre>
<p>This is usually a very good thing.</p>
<p>When given a non-constant argument, a <code>constexpr</code> function can throw.<br>If you consider exiting by throwing a side effect, a <code>constexpr</code> function isn’t completely pure;<br>if not, this is not an issue.<br>??? A question for the committee: can a constructor for an exception thrown by a <code>constexpr</code> function modify state?<br>“No” would be a nice answer that matches most practice.</p>
<h5 id="Note-46"><a href="#Note-46" class="headerlink" title="Note"></a>Note</h5><p>Don’t try to make all functions <code>constexpr</code>.<br>Most computation is best done at run time.</p>
<h5 id="Note-47"><a href="#Note-47" class="headerlink" title="Note"></a>Note</h5><p>Any API that may eventually depend on high-level run-time configuration or<br>business logic should not be made <code>constexpr</code>. Such customization can not be<br>evaluated by the compiler, and any <code>constexpr</code> functions that depended upon<br>that API would have to be refactored or drop <code>constexpr</code>.</p>
<h5 id="Enforcement-33"><a href="#Enforcement-33" class="headerlink" title="Enforcement"></a>Enforcement</h5><p>Impossible and unnecessary.<br>The compiler gives an error if a non-<code>constexpr</code> function is called where a constant is required.</p>
<h3 id="F-5-If-a-function-is-very-small-and-time-critical-declare-it-inline"><a href="#F-5-If-a-function-is-very-small-and-time-critical-declare-it-inline" class="headerlink" title="F.5: If a function is very small and time-critical, declare it inline"></a><a name="Rf-inline"></a>F.5: If a function is very small and time-critical, declare it <code>inline</code></h3><h5 id="Reason-37"><a href="#Reason-37" class="headerlink" title="Reason"></a>Reason</h5><p>Some optimizers are good at inlining without hints from the programmer, but don’t rely on it.<br>Measure! Over the last 40 years or so, we have been promised compilers that can inline better than humans without hints from humans.<br>We are still waiting.<br>Specifying <code>inline</code> encourages the compiler to do a better job.</p>
<h5 id="Example-34"><a href="#Example-34" class="headerlink" title="Example"></a>Example</h5><pre><code>inline string cat(const string&amp; s, const string&amp; s2) &#123; return s + s2; &#125;
</code></pre>
<h5 id="Exception-8"><a href="#Exception-8" class="headerlink" title="Exception"></a>Exception</h5><p>Do not put an <code>inline</code> function in what is meant to be a stable interface unless you are certain that it will not change.<br>An inline function is part of the ABI.</p>
<h5 id="Note-48"><a href="#Note-48" class="headerlink" title="Note"></a>Note</h5><p><code>constexpr</code> implies <code>inline</code>.</p>
<h5 id="Note-49"><a href="#Note-49" class="headerlink" title="Note"></a>Note</h5><p>Member functions defined in-class are <code>inline</code> by default.</p>
<h5 id="Exception-9"><a href="#Exception-9" class="headerlink" title="Exception"></a>Exception</h5><p>Template functions (incl. template member functions) are normally defined in headers and therefore inline.</p>
<h5 id="Enforcement-34"><a href="#Enforcement-34" class="headerlink" title="Enforcement"></a>Enforcement</h5><p>Flag <code>inline</code> functions that are more than three statements and could have been declared out of line (such as class member functions).</p>
<h3 id="F-6-If-your-function-may-not-throw-declare-it-noexcept"><a href="#F-6-If-your-function-may-not-throw-declare-it-noexcept" class="headerlink" title="F.6: If your function may not throw, declare it noexcept"></a><a name="Rf-noexcept"></a>F.6: If your function may not throw, declare it <code>noexcept</code></h3><h5 id="Reason-38"><a href="#Reason-38" class="headerlink" title="Reason"></a>Reason</h5><p>If an exception is not supposed to be thrown, the program cannot be assumed to cope with the error and should be terminated as soon as possible. Declaring a function <code>noexcept</code> helps optimizers by reducing the number of alternative execution paths. It also speeds up the exit after failure.</p>
<h5 id="Example-35"><a href="#Example-35" class="headerlink" title="Example"></a>Example</h5><p>Put <code>noexcept</code> on every function written completely in C or in any other language without exceptions.<br>The C++ Standard Library does that implicitly for all functions in the C Standard Library.</p>
<h5 id="Note-50"><a href="#Note-50" class="headerlink" title="Note"></a>Note</h5><p><code>constexpr</code> functions can throw when evaluated at run time, so you may need <code>noexcept</code> for some of those.</p>
<h5 id="Example-36"><a href="#Example-36" class="headerlink" title="Example"></a>Example</h5><p>You can use <code>noexcept</code> even on functions that can throw:</p>
<pre><code>vector&lt;string&gt; collect(istream&amp; is) noexcept
&#123;
    vector&lt;string&gt; res;
    for (string s; is &gt;&gt; s;)
        res.push_back(s);
    return res;
&#125;
</code></pre>
<p>If <code>collect()</code> runs out of memory, the program crashes.<br>Unless the program is crafted to survive memory exhaustion, that may be just the right thing to do;<br><code>terminate()</code> may generate suitable error log information (but after memory runs out it is hard to do anything clever).</p>
<h5 id="Note-51"><a href="#Note-51" class="headerlink" title="Note"></a>Note</h5><p>You must be aware of the execution environment that your code is running when<br>deciding whether to tag a function <code>noexcept</code>, especially because of the issue<br>of throwing and allocation.  Code that is intended to be perfectly general (like<br>the standard library and other utility code of that sort) needs to support<br>environments where a <code>bad_alloc</code> exception may be handled meaningfully.<br>However, most programs and execution environments cannot meaningfully<br>handle a failure to allocate, and aborting the program is the cleanest and<br>simplest response to an allocation failure in those cases.  If you know that<br>your application code cannot respond to an allocation failure, it may be<br>appropriate to add <code>noexcept</code> even on functions that allocate.</p>
<p>Put another way: In most programs, most functions can throw (e.g., because they<br>use <code>new</code>, call functions that do, or use library functions that reports failure<br>by throwing), so don’t just sprinkle <code>noexcept</code> all over the place without<br>considering whether the possible exceptions can be handled.</p>
<p><code>noexcept</code> is most useful (and most clearly correct) for frequently used,<br>low-level functions.</p>
<h5 id="Note-52"><a href="#Note-52" class="headerlink" title="Note"></a>Note</h5><p>Destructors, <code>swap</code> functions, move operations, and default constructors should never throw.</p>
<h5 id="Enforcement-35"><a href="#Enforcement-35" class="headerlink" title="Enforcement"></a>Enforcement</h5><ul>
<li>Flag functions that are not <code>noexcept</code>, yet cannot throw.</li>
<li>Flag throwing <code>swap</code>, <code>move</code>, destructors, and default constructors.</li>
</ul>
<h3 id="F-7-For-general-use-take-T-or-T-amp-arguments-rather-than-smart-pointers"><a href="#F-7-For-general-use-take-T-or-T-amp-arguments-rather-than-smart-pointers" class="headerlink" title="F.7: For general use, take T* or T&amp; arguments rather than smart pointers"></a><a name="Rf-smart"></a>F.7: For general use, take <code>T*</code> or <code>T&amp;</code> arguments rather than smart pointers</h3><h5 id="Reason-39"><a href="#Reason-39" class="headerlink" title="Reason"></a>Reason</h5><p>Passing a smart pointer transfers or shares ownership and should only be used when ownership semantics are intended (see <a href="#Rr-smartptrparam">R.30</a>).<br>Passing by smart pointer restricts the use of a function to callers that use smart pointers.<br>Passing a shared smart pointer (e.g., <code>std::shared_ptr</code>) implies a run-time cost.</p>
<h5 id="Example-37"><a href="#Example-37" class="headerlink" title="Example"></a>Example</h5><pre><code>// accepts any int*
void f(int*);

// can only accept ints for which you want to transfer ownership
void g(unique_ptr&lt;int&gt;);

// can only accept ints for which you are willing to share ownership
void g(shared_ptr&lt;int&gt;);

// doesn&#39;t change ownership, but requires a particular ownership of the caller
void h(const unique_ptr&lt;int&gt;&amp;);

// accepts any int
void h(int&amp;);
</code></pre>
<h5 id="Example-bad-17"><a href="#Example-bad-17" class="headerlink" title="Example, bad"></a>Example, bad</h5><pre><code>// callee
void f(shared_ptr&lt;widget&gt;&amp; w)
&#123;
    // ...
    use(*w); // only use of w -- the lifetime is not used at all
    // ...
&#125;;
</code></pre>
<p>See further in <a href="#Rr-smartptrparam">R.30</a>.</p>
<h5 id="Note-53"><a href="#Note-53" class="headerlink" title="Note"></a>Note</h5><p>We can catch dangling pointers statically, so we don’t need to rely on resource management to avoid violations from dangling pointers.</p>
<p><strong>See also</strong>:</p>
<ul>
<li><a href="#Rf-ptr-ref">Prefer <code>T*</code> over <code>T&amp;</code> when “no argument” is a valid option</a></li>
<li><a href="#Rr-summary-smartptrs">Smart pointer rule summary</a></li>
</ul>
<h5 id="Enforcement-36"><a href="#Enforcement-36" class="headerlink" title="Enforcement"></a>Enforcement</h5><p>Flag a parameter of a smart pointer type (a type that overloads <code>operator-&gt;</code> or <code>operator*</code>) for which the ownership semantics are not used;<br>that is</p>
<ul>
<li>copyable but never copied/moved from or movable but never moved</li>
<li>and that is never modified or passed along to another function that could do so.</li>
</ul>
<h3 id="F-8-Prefer-pure-functions"><a href="#F-8-Prefer-pure-functions" class="headerlink" title="F.8: Prefer pure functions"></a><a name="Rf-pure"></a>F.8: Prefer pure functions</h3><h5 id="Reason-40"><a href="#Reason-40" class="headerlink" title="Reason"></a>Reason</h5><p>Pure functions are easier to reason about, sometimes easier to optimize (and even parallelize), and sometimes can be memoized.</p>
<h5 id="Example-38"><a href="#Example-38" class="headerlink" title="Example"></a>Example</h5><pre><code>template&lt;class T&gt;
auto square(T t) &#123; return t * t; &#125;
</code></pre>
<h5 id="Note-54"><a href="#Note-54" class="headerlink" title="Note"></a>Note</h5><p><code>constexpr</code> functions are pure.</p>
<p>When given a non-constant argument, a <code>constexpr</code> function can throw.<br>If you consider exiting by throwing a side effect, a <code>constexpr</code> function isn’t completely pure;<br>if not, this is not an issue.<br>??? A question for the committee: can a constructor for an exception thrown by a <code>constexpr</code> function modify state?<br>“No” would be a nice answer that matches most practice.</p>
<h5 id="Enforcement-37"><a href="#Enforcement-37" class="headerlink" title="Enforcement"></a>Enforcement</h5><p>Not possible.</p>
<h3 id="F-9-Unused-parameters-should-be-unnamed"><a href="#F-9-Unused-parameters-should-be-unnamed" class="headerlink" title="F.9: Unused parameters should be unnamed"></a><a name="Rf-unused"></a>F.9: Unused parameters should be unnamed</h3><h5 id="Reason-41"><a href="#Reason-41" class="headerlink" title="Reason"></a>Reason</h5><p>Readability.<br>Suppression of unused parameter warnings.</p>
<h5 id="Example-39"><a href="#Example-39" class="headerlink" title="Example"></a>Example</h5><pre><code>X* find(map&lt;Blob&gt;&amp; m, const string&amp; s, Hint);   // once upon a time, a hint was used
</code></pre>
<h5 id="Note-55"><a href="#Note-55" class="headerlink" title="Note"></a>Note</h5><p>Allowing parameters to be unnamed was introduced in the early 1980 to address this problem.</p>
<h5 id="Enforcement-38"><a href="#Enforcement-38" class="headerlink" title="Enforcement"></a>Enforcement</h5><p>Flag named unused parameters.</p>
<h2 id="F-call-Parameter-passing"><a href="#F-call-Parameter-passing" class="headerlink" title="F.call: Parameter passing"></a><a name="SS-call"></a>F.call: Parameter passing</h2><p>There are a variety of ways to pass parameters to a function and to return values.</p>
<h3 id="F-15-Prefer-simple-and-conventional-ways-of-passing-information"><a href="#F-15-Prefer-simple-and-conventional-ways-of-passing-information" class="headerlink" title="F.15: Prefer simple and conventional ways of passing information"></a><a name="Rf-conventional"></a>F.15: Prefer simple and conventional ways of passing information</h3><h5 id="Reason-42"><a href="#Reason-42" class="headerlink" title="Reason"></a>Reason</h5><p>Using “unusual and clever” techniques causes surprises, slows understanding by other programmers, and encourages bugs.<br>If you really feel the need for an optimization beyond the common techniques, measure to ensure that it really is an improvement, and document/comment because the improvement may not be portable.</p>
<p>The following tables summarize the advice in the following Guidelines, F.16-21.</p>
<p>Normal parameter passing:</p>
<p><img src="/./param-passing-normal.png" alt="Normal parameter passing table" title="Normal parameter passing"></p>
<p>Advanced parameter passing:</p>
<p><img src="/./param-passing-advanced.png" alt="Advanced parameter passing table" title="Advanced parameter passing"></p>
<p>Use the advanced techniques only after demonstrating need, and document that need in a comment.</p>
<h3 id="F-16-For-“in”-parameters-pass-cheaply-copied-types-by-value-and-others-by-reference-to-const"><a href="#F-16-For-“in”-parameters-pass-cheaply-copied-types-by-value-and-others-by-reference-to-const" class="headerlink" title="F.16: For “in” parameters, pass cheaply-copied types by value and others by reference to const"></a><a name="Rf-in"></a>F.16: For “in” parameters, pass cheaply-copied types by value and others by reference to <code>const</code></h3><h5 id="Reason-43"><a href="#Reason-43" class="headerlink" title="Reason"></a>Reason</h5><p>Both let the caller know that a function will not modify the argument, and both allow initialization by rvalues.</p>
<p>What is “cheap to copy” depends on the machine architecture, but two or three words (doubles, pointers, references) are usually best passed by value.<br>When copying is cheap, nothing beats the simplicity and safety of copying, and for small objects (up to two or three words) it is also faster than passing by reference because it does not require an extra indirection to access from the function.</p>
<h5 id="Example-40"><a href="#Example-40" class="headerlink" title="Example"></a>Example</h5><pre><code>void f1(const string&amp; s);  // OK: pass by reference to const; always cheap

void f2(string s);         // bad: potentially expensive

void f3(int x);            // OK: Unbeatable

void f4(const int&amp; x);     // bad: overhead on access in f4()
</code></pre>
<p>For advanced uses (only), where you really need to optimize for rvalues passed to “input-only” parameters:</p>
<ul>
<li>If the function is going to unconditionally move from the argument, take it by <code>&amp;&amp;</code>. See <a href="#Rf-consume">F.18</a>.</li>
<li>If the function is going to keep a copy of the argument, in addition to passing by <code>const&amp;</code> (for lvalues),<br>add an overload that passes the parameter by <code>&amp;&amp;</code> (for rvalues) and in the body <code>std::move</code>s it to its destination. Essentially this overloads a “will-move-from”; see <a href="#Rf-consume">F.18</a>.</li>
<li>In special cases, such as multiple “input + copy” parameters, consider using perfect forwarding. See <a href="#Rf-forward">F.19</a>.</li>
</ul>
<h5 id="Example-41"><a href="#Example-41" class="headerlink" title="Example"></a>Example</h5><pre><code>int multiply(int, int); // just input ints, pass by value

// suffix is input-only but not as cheap as an int, pass by const&amp;
string&amp; concatenate(string&amp;, const string&amp; suffix);

void sink(unique_ptr&lt;widget&gt;);  // input only, and moves ownership of the widget
</code></pre>
<p>Avoid “esoteric techniques” such as:</p>
<ul>
<li>Passing arguments as <code>T&amp;&amp;</code> “for efficiency”.<br>Most rumors about performance advantages from passing by <code>&amp;&amp;</code> are false or brittle (but see <a href="#Rf-consume">F.18</a> and <a href="#Rf-forward">F.19</a>).</li>
<li>Returning <code>const T&amp;</code> from assignments and similar operations (see <a href="#Rf-assignment-op">F.47</a>.)</li>
</ul>
<h5 id="Example-42"><a href="#Example-42" class="headerlink" title="Example"></a>Example</h5><p>Assuming that <code>Matrix</code> has move operations (possibly by keeping its elements in a <code>std::vector</code>):</p>
<pre><code>Matrix operator+(const Matrix&amp; a, const Matrix&amp; b)
&#123;
    Matrix res;
    // ... fill res with the sum ...
    return res;
&#125;

Matrix x = m1 + m2;  // move constructor

y = m3 + m3;         // move assignment
</code></pre>
<h5 id="Notes-1"><a href="#Notes-1" class="headerlink" title="Notes"></a>Notes</h5><p>The return value optimization doesn’t handle the assignment case, but the move assignment does.</p>
<p>A reference may be assumed to refer to a valid object (language rule).<br>There is no (legitimate) “null reference.”<br>If you need the notion of an optional value, use a pointer, <code>std::optional</code>, or a special value used to denote “no value.”</p>
<h5 id="Enforcement-39"><a href="#Enforcement-39" class="headerlink" title="Enforcement"></a>Enforcement</h5><ul>
<li>(Simple) ((Foundation)) Warn when a parameter being passed by value has a size greater than <code>4 * sizeof(int)</code>.<br>Suggest using a reference to <code>const</code> instead.</li>
<li>(Simple) ((Foundation)) Warn when a <code>const</code> parameter being passed by reference has a size less than <code>3 * sizeof(int)</code>. Suggest passing by value instead.</li>
<li>(Simple) ((Foundation)) Warn when a <code>const</code> parameter being passed by reference is <code>move</code>d.</li>
</ul>
<h3 id="F-17-For-“in-out”-parameters-pass-by-reference-to-non-const"><a href="#F-17-For-“in-out”-parameters-pass-by-reference-to-non-const" class="headerlink" title="F.17: For “in-out” parameters, pass by reference to non-const"></a><a name="Rf-inout"></a>F.17: For “in-out” parameters, pass by reference to non-<code>const</code></h3><h5 id="Reason-44"><a href="#Reason-44" class="headerlink" title="Reason"></a>Reason</h5><p>This makes it clear to callers that the object is assumed to be modified.</p>
<h5 id="Example-43"><a href="#Example-43" class="headerlink" title="Example"></a>Example</h5><pre><code>void update(Record&amp; r);  // assume that update writes to r
</code></pre>
<h5 id="Note-56"><a href="#Note-56" class="headerlink" title="Note"></a>Note</h5><p>A <code>T&amp;</code> argument can pass information into a function as well as out of it.<br>Thus <code>T&amp;</code> could be an in-out-parameter. That can in itself be a problem and a source of errors:</p>
<pre><code>void f(string&amp; s)
&#123;
    s = &quot;New York&quot;;  // non-obvious error
&#125;

void g()
&#123;
    string buffer = &quot;.................................&quot;;
    f(buffer);
    // ...
&#125;
</code></pre>
<p>Here, the writer of <code>g()</code> is supplying a buffer for <code>f()</code> to fill, but <code>f()</code> simply replaces it (at a somewhat higher cost than a simple copy of the characters).<br>A bad logic error can happen if the writer of <code>g()</code> incorrectly assumes the size of the <code>buffer</code>.</p>
<h5 id="Enforcement-40"><a href="#Enforcement-40" class="headerlink" title="Enforcement"></a>Enforcement</h5><ul>
<li>(Moderate) ((Foundation)) Warn about functions regarding reference to non-<code>const</code> parameters that do <em>not</em> write to them.</li>
<li>(Simple) ((Foundation)) Warn when a non-<code>const</code> parameter being passed by reference is <code>move</code>d.</li>
</ul>
<h3 id="F-18-For-“will-move-from”-parameters-pass-by-X-amp-amp-and-std-move-the-parameter"><a href="#F-18-For-“will-move-from”-parameters-pass-by-X-amp-amp-and-std-move-the-parameter" class="headerlink" title="F.18: For “will-move-from” parameters, pass by X&amp;&amp; and std::move the parameter"></a><a name="Rf-consume"></a>F.18: For “will-move-from” parameters, pass by <code>X&amp;&amp;</code> and <code>std::move</code> the parameter</h3><h5 id="Reason-45"><a href="#Reason-45" class="headerlink" title="Reason"></a>Reason</h5><p>It’s efficient and eliminates bugs at the call site: <code>X&amp;&amp;</code> binds to rvalues, which requires an explicit <code>std::move</code> at the call site if passing an lvalue.</p>
<h5 id="Example-44"><a href="#Example-44" class="headerlink" title="Example"></a>Example</h5><pre><code>void sink(vector&lt;int&gt;&amp;&amp; v) &#123;   // sink takes ownership of whatever the argument owned
    // usually there might be const accesses of v here
    store_somewhere(std::move(v));
    // usually no more use of v here; it is moved-from
&#125;
</code></pre>
<p>Note that the <code>std::move(v)</code> makes it possible for <code>store_somewhere()</code> to leave <code>v</code> in a moved-from state.<br><a href="#Rc-move-semantic">That could be dangerous</a>.</p>
<h5 id="Exception-10"><a href="#Exception-10" class="headerlink" title="Exception"></a>Exception</h5><p>Unique owner types that are move-only and cheap-to-move, such as <code>unique_ptr</code>, can also be passed by value which is simpler to write and achieves the same effect. Passing by value does generate one extra (cheap) move operation, but prefer simplicity and clarity first.</p>
<p>For example:</p>
<pre><code>template &lt;class T&gt;
void sink(std::unique_ptr&lt;T&gt; p) &#123;
    // use p ... possibly std::move(p) onward somewhere else
&#125;   // p gets destroyed
</code></pre>
<h5 id="Enforcement-41"><a href="#Enforcement-41" class="headerlink" title="Enforcement"></a>Enforcement</h5><ul>
<li>Flag all <code>X&amp;&amp;</code> parameters (where <code>X</code> is not a template type parameter name) where the function body uses them without <code>std::move</code>.</li>
<li>Flag access to moved-from objects.</li>
<li>Don’t conditionally move from objects</li>
</ul>
<h3 id="F-19-For-“forward”-parameters-pass-by-TP-amp-amp-and-only-std-forward-the-parameter"><a href="#F-19-For-“forward”-parameters-pass-by-TP-amp-amp-and-only-std-forward-the-parameter" class="headerlink" title="F.19: For “forward” parameters, pass by TP&amp;&amp; and only std::forward the parameter"></a><a name="Rf-forward"></a>F.19: For “forward” parameters, pass by <code>TP&amp;&amp;</code> and only <code>std::forward</code> the parameter</h3><h5 id="Reason-46"><a href="#Reason-46" class="headerlink" title="Reason"></a>Reason</h5><p>If the object is to be passed onward to other code and not directly used by this function, we want to make this function agnostic to the argument <code>const</code>-ness and rvalue-ness.</p>
<p>In that case, and only that case, make the parameter <code>TP&amp;&amp;</code> where <code>TP</code> is a template type parameter – it both <em>ignores</em> and <em>preserves</em> <code>const</code>-ness and rvalue-ness. Therefore any code that uses a <code>TP&amp;&amp;</code> is implicitly declaring that it itself doesn’t care about the variable’s <code>const</code>-ness and rvalue-ness (because it is ignored), but that intends to pass the value onward to other code that does care about <code>const</code>-ness and rvalue-ness (because it is preserved). When used as a parameter <code>TP&amp;&amp;</code> is safe because any temporary objects passed from the caller will live for the duration of the function call. A parameter of type <code>TP&amp;&amp;</code> should essentially always be passed onward via <code>std::forward</code> in the body of the function.</p>
<h5 id="Example-45"><a href="#Example-45" class="headerlink" title="Example"></a>Example</h5><pre><code>template &lt;class F, class... Args&gt;
inline auto invoke(F f, Args&amp;&amp;... args) &#123;
    return f(forward&lt;Args&gt;(args)...);
&#125;

??? calls ???
</code></pre>
<h5 id="Enforcement-42"><a href="#Enforcement-42" class="headerlink" title="Enforcement"></a>Enforcement</h5><ul>
<li>Flag a function that takes a <code>TP&amp;&amp;</code> parameter (where <code>TP</code> is a template type parameter name) and does anything with it other than <code>std::forward</code>ing it exactly once on every static path.</li>
</ul>
<h3 id="F-20-For-“out”-output-values-prefer-return-values-to-output-parameters"><a href="#F-20-For-“out”-output-values-prefer-return-values-to-output-parameters" class="headerlink" title="F.20: For “out” output values, prefer return values to output parameters"></a><a name="Rf-out"></a>F.20: For “out” output values, prefer return values to output parameters</h3><h5 id="Reason-47"><a href="#Reason-47" class="headerlink" title="Reason"></a>Reason</h5><p>A return value is self-documenting, whereas a <code>&amp;</code> could be either in-out or out-only and is liable to be misused.</p>
<p>This includes large objects like standard containers that use implicit move operations for performance and to avoid explicit memory management.</p>
<p>If you have multiple values to return, <a href="#Rf-out-multi">use a tuple</a> or similar multi-member type.</p>
<h5 id="Example-46"><a href="#Example-46" class="headerlink" title="Example"></a>Example</h5><pre><code>// OK: return pointers to elements with the value x
vector&lt;const int*&gt; find_all(const vector&lt;int&gt;&amp;, int x);

// Bad: place pointers to elements with value x in-out
void find_all(const vector&lt;int&gt;&amp;, vector&lt;const int*&gt;&amp; out, int x);
</code></pre>
<h5 id="Note-57"><a href="#Note-57" class="headerlink" title="Note"></a>Note</h5><p>A <code>struct</code> of many (individually cheap-to-move) elements may be in aggregate expensive to move.</p>
<p>It is not recommended to return a <code>const</code> value.<br>Such older advice is now obsolete; it does not add value, and it interferes with move semantics.</p>
<pre><code>const vector&lt;int&gt; fct();    // bad: that &quot;const&quot; is more trouble than it is worth

vector&lt;int&gt; g(const vector&lt;int&gt;&amp; vx)
&#123;
    // ...
    fct() = vx;   // prevented by the &quot;const&quot;
    // ...
    return fct(); // expensive copy: move semantics suppressed by the &quot;const&quot;
&#125;
</code></pre>
<p>The argument for adding <code>const</code> to a return value is that it prevents (very rare) accidental access to a temporary.<br>The argument against is prevents (very frequent) use of move semantics.</p>
<h5 id="Exceptions"><a href="#Exceptions" class="headerlink" title="Exceptions"></a>Exceptions</h5><ul>
<li>For non-value types, such as types in an inheritance hierarchy, return the object by <code>unique_ptr</code> or <code>shared_ptr</code>.</li>
<li>If a type is expensive to move (e.g., <code>array&lt;BigPOD&gt;</code>), consider allocating it on the free store and return a handle (e.g., <code>unique_ptr</code>), or passing it in a reference to non-<code>const</code> target object to fill (to be used as an out-parameter).</li>
<li>To reuse an object that carries capacity (e.g., <code>std::string</code>, <code>std::vector</code>) across multiple calls to the function in an inner loop: <a href="#Rf-out-multi">treat it as an in/out parameter and pass by reference</a>.</li>
</ul>
<h5 id="Example-47"><a href="#Example-47" class="headerlink" title="Example"></a>Example</h5><pre><code>struct Package &#123;      // exceptional case: expensive-to-move object
    char header[16];
    char load[2024 - 16];
&#125;;

Package fill();       // Bad: large return value
void fill(Package&amp;);  // OK

int val();            // OK
void val(int&amp;);       // Bad: Is val reading its argument
</code></pre>
<h5 id="Enforcement-43"><a href="#Enforcement-43" class="headerlink" title="Enforcement"></a>Enforcement</h5><ul>
<li>Flag reference to non-<code>const</code> parameters that are not read before being written to and are a type that could be cheaply returned; they should be “out” return values.</li>
<li>Flag returning a <code>const</code> value. To fix: Remove <code>const</code> to return a non-<code>const</code> value instead.</li>
</ul>
<h3 id="F-21-To-return-multiple-“out”-values-prefer-returning-a-struct-or-tuple"><a href="#F-21-To-return-multiple-“out”-values-prefer-returning-a-struct-or-tuple" class="headerlink" title="F.21: To return multiple “out” values, prefer returning a struct or tuple"></a><a name="Rf-out-multi"></a>F.21: To return multiple “out” values, prefer returning a struct or tuple</h3><h5 id="Reason-48"><a href="#Reason-48" class="headerlink" title="Reason"></a>Reason</h5><p>A return value is self-documenting as an “output-only” value.<br>Note that C++ does have multiple return values, by convention of using a <code>tuple</code> (including <code>pair</code>),<br>possibly with the extra convenience of <code>tie</code> at the call site.<br>Prefer using a named struct where there are semantics to the returned value. Otherwise, a nameless <code>tuple</code> is useful in generic code.</p>
<h5 id="Example-48"><a href="#Example-48" class="headerlink" title="Example"></a>Example</h5><pre><code>// BAD: output-only parameter documented in a comment
int f(const string&amp; input, /*output only*/ string&amp; output_data)
&#123;
    // ...
    output_data = something();
    return status;
&#125;

// GOOD: self-documenting
tuple&lt;int, string&gt; f(const string&amp; input)
&#123;
    // ...
    return make_tuple(status, something());
&#125;
</code></pre>
<p>C++98’s standard library already used this style, because a <code>pair</code> is like a two-element <code>tuple</code>.<br>For example, given a <code>set&lt;string&gt; my_set</code>, consider:</p>
<pre><code>// C++98
result = my_set.insert(&quot;Hello&quot;);
if (result.second) do_something_with(result.first);    // workaround
</code></pre>
<p>With C++11 we can write this, putting the results directly in existing local variables:</p>
<pre><code>Sometype iter;                                // default initialize if we haven&#39;t already
Someothertype success;                        // used these variables for some other purpose

tie(iter, success) = my_set.insert(&quot;Hello&quot;);   // normal return value
if (success) do_something_with(iter);
</code></pre>
<p>With C++17 we should be able to use “structured bindings” to declare and initialize the multiple variables:</p>
<pre><code>if (auto [ iter, success ] = my_set.insert(&quot;Hello&quot;); success) do_something_with(iter);
</code></pre>
<h5 id="Exception-11"><a href="#Exception-11" class="headerlink" title="Exception"></a>Exception</h5><p>Sometimes, we need to pass an object to a function to manipulate its state.<br>In such cases, passing the object by reference <a href="#Rf-inout"><code>T&amp;</code></a> is usually the right technique.<br>Explicitly passing an in-out parameter back out again as a return value is often not necessary.<br>For example:</p>
<pre><code>istream&amp; operator&gt;&gt;(istream&amp; is, string&amp; s);    // much like std::operator&gt;&gt;()

for (string s; cin &gt;&gt; s; ) &#123;
    // do something with line
&#125;
</code></pre>
<p>Here, both <code>s</code> and <code>cin</code> are used as in-out parameters.<br>We pass <code>cin</code> by (non-<code>const</code>) reference to be able to manipulate its state.<br>We pass <code>s</code> to avoid repeated allocations.<br>By reusing <code>s</code> (passed by reference), we allocate new memory only when we need to expand <code>s</code>‘s capacity.<br>This technique is sometimes called the “caller-allocated out” pattern and is particularly useful for types,<br>such as <code>string</code> and <code>vector</code>, that needs to do free store allocations.</p>
<p>To compare, if we passed out all values as return values, we would something like this:</p>
<pre><code>pair&lt;istream&amp;, string&gt; get_string(istream&amp; is);  // not recommended
&#123;
    string s;
    is &gt;&gt; s;
    return &#123;is, s&#125;;
&#125;

for (auto p = get_string(cin); p.first; ) &#123;
    // do something with p.second
&#125;
</code></pre>
<p>We consider that significantly less elegant with significantly less performance.</p>
<p>For a truly strict reading of this rule (F.21), the exception isn’t really an exception because it relies on in-out parameters,<br>rather than the plain out parameters mentioned in the rule.<br>However, we prefer to be explicit, rather than subtle.</p>
<h5 id="Note-58"><a href="#Note-58" class="headerlink" title="Note"></a>Note</h5><p>In many cases, it may be useful to return a specific, user-defined type.<br>For example:</p>
<pre><code>struct Distance &#123;
    int value;
    int unit = 1;   // 1 means meters
&#125;;

Distance d1 = measure(obj1);        // access d1.value and d1.unit
auto d2 = measure(obj2);            // access d2.value and d2.unit
auto [value, unit] = measure(obj3); // access value and unit; somewhat redundant
                                    // to people who know measure()
auto [x, y] = measure(obj4);        // don&#39;t; it&#39;s likely to be confusing
</code></pre>
<p>The overly-generic <code>pair</code> and <code>tuple</code> should be used only when the value returned represents to independent entities rather than an abstraction.</p>
<p>Another example, use a specific type along the lines of <code>variant&lt;T, error_code&gt;</code>, rather than using the generic <code>tuple</code>.</p>
<h5 id="Enforcement-44"><a href="#Enforcement-44" class="headerlink" title="Enforcement"></a>Enforcement</h5><ul>
<li>Output parameters should be replaced by return values.<br>An output parameter is one that the function writes to, invokes a non-<code>const</code> member function, or passes on as a non-<code>const</code>.</li>
</ul>
<h3 id="F-22-Use-T-or-owner-lt-T-gt-to-designate-a-single-object"><a href="#F-22-Use-T-or-owner-lt-T-gt-to-designate-a-single-object" class="headerlink" title="F.22: Use T* or owner&lt;T*&gt; to designate a single object"></a><a name="Rf-ptr"></a>F.22: Use <code>T*</code> or <code>owner&lt;T*&gt;</code> to designate a single object</h3><h5 id="Reason-49"><a href="#Reason-49" class="headerlink" title="Reason"></a>Reason</h5><p>Readability: it makes the meaning of a plain pointer clear.<br>Enables significant tool support.</p>
<h5 id="Note-59"><a href="#Note-59" class="headerlink" title="Note"></a>Note</h5><p>In traditional C and C++ code, plain <code>T*</code> is used for many weakly-related purposes, such as:</p>
<ul>
<li>Identify a (single) object (not to be deleted by this function)</li>
<li>Point to an object allocated on the free store (and delete it later)</li>
<li>Hold the <code>nullptr</code></li>
<li>Identify a C-style string (zero-terminated array of characters)</li>
<li>Identify an array with a length specified separately</li>
<li>Identify a location in an array</li>
</ul>
<p>This makes it hard to understand what the code does and is supposed to do.<br>It complicates checking and tool support.</p>
<h5 id="Example-49"><a href="#Example-49" class="headerlink" title="Example"></a>Example</h5><pre><code>void use(int* p, int n, char* s, int* q)
&#123;
    p[n - 1] = 666; // Bad: we don&#39;t know if p points to n elements;
                    // assume it does not or use span&lt;int&gt;
    cout &lt;&lt; s;      // Bad: we don&#39;t know if that s points to a zero-terminated array of char;
                    // assume it does not or use zstring
    delete q;       // Bad: we don&#39;t know if *q is allocated on the free store;
                    // assume it does not or use owner
&#125;
</code></pre>
<p>better</p>
<pre><code>void use2(span&lt;int&gt; p, zstring s, owner&lt;int*&gt; q)
&#123;
    p[p.size() - 1] = 666; // OK, a range error can be caught
    cout &lt;&lt; s; // OK
    delete q;  // OK
&#125;
</code></pre>
<h5 id="Note-60"><a href="#Note-60" class="headerlink" title="Note"></a>Note</h5><p><code>owner&lt;T*&gt;</code> represents ownership, <code>zstring</code> represents a C-style string.</p>
<p><strong>Also</strong>: Assume that a <code>T*</code> obtained from a smart pointer to <code>T</code> (e.g., <code>unique_ptr&lt;T&gt;</code>) points to a single element.</p>
<p><strong>See also</strong>: <a href="#S-gsl">Support library</a></p>
<p><strong>See also</strong>: <a href="#Ri-array">Do not pass an array as a single pointer</a></p>
<h5 id="Enforcement-45"><a href="#Enforcement-45" class="headerlink" title="Enforcement"></a>Enforcement</h5><ul>
<li>(Simple) ((Bounds)) Warn for any arithmetic operation on an expression of pointer type that results in a value of pointer type.</li>
</ul>
<h3 id="F-23-Use-a-not-null-lt-T-gt-to-indicate-that-“null”-is-not-a-valid-value"><a href="#F-23-Use-a-not-null-lt-T-gt-to-indicate-that-“null”-is-not-a-valid-value" class="headerlink" title="F.23: Use a not_null&lt;T&gt; to indicate that “null” is not a valid value"></a><a name="Rf-nullptr"></a>F.23: Use a <code>not_null&lt;T&gt;</code> to indicate that “null” is not a valid value</h3><h5 id="Reason-50"><a href="#Reason-50" class="headerlink" title="Reason"></a>Reason</h5><p>Clarity. A function with a <code>not_null&lt;T&gt;</code> parameter makes it clear that the caller of the function is responsible for any <code>nullptr</code> checks that may be necessary.<br>Similarly, a function with a return value of <code>not_null&lt;T&gt;</code> makes it clear that the caller of the function does not need to check for <code>nullptr</code>.</p>
<h5 id="Example-50"><a href="#Example-50" class="headerlink" title="Example"></a>Example</h5><p><code>not_null&lt;T*&gt;</code> makes it obvious to a reader (human or machine) that a test for <code>nullptr</code> is not necessary before dereference.<br>Additionally, when debugging, <code>owner&lt;T*&gt;</code> and <code>not_null&lt;T&gt;</code> can be instrumented to check for correctness.</p>
<p>Consider:</p>
<pre><code>int length(Record* p);
</code></pre>
<p>When I call <code>length(p)</code> should I check if <code>p</code> is <code>nullptr</code> first? Should the implementation of <code>length()</code> check if <code>p</code> is <code>nullptr</code>?</p>
<pre><code>// it is the caller&#39;s job to make sure p != nullptr
int length(not_null&lt;Record*&gt; p);

// the implementor of length() must assume that p == nullptr is possible
int length(Record* p);
</code></pre>
<h5 id="Note-61"><a href="#Note-61" class="headerlink" title="Note"></a>Note</h5><p>A <code>not_null&lt;T*&gt;</code> is assumed not to be the <code>nullptr</code>; a <code>T*</code> may be the <code>nullptr</code>; both can be represented in memory as a <code>T*</code> (so no run-time overhead is implied).</p>
<h5 id="Note-62"><a href="#Note-62" class="headerlink" title="Note"></a>Note</h5><p><code>not_null</code> is not just for built-in pointers. It works for <code>unique_ptr</code>, <code>shared_ptr</code>, and other pointer-like types.</p>
<h5 id="Enforcement-46"><a href="#Enforcement-46" class="headerlink" title="Enforcement"></a>Enforcement</h5><ul>
<li>(Simple) Warn if a raw pointer is dereferenced without being tested against <code>nullptr</code> (or equivalent) within a function, suggest it is declared <code>not_null</code> instead.</li>
<li>(Simple) Error if a raw pointer is sometimes dereferenced after first being tested against <code>nullptr</code> (or equivalent) within the function and sometimes is not.</li>
<li>(Simple) Warn if a <code>not_null</code> pointer is tested against <code>nullptr</code> within a function.</li>
</ul>
<h3 id="F-24-Use-a-span-lt-T-gt-or-a-span-p-lt-T-gt-to-designate-a-half-open-sequence"><a href="#F-24-Use-a-span-lt-T-gt-or-a-span-p-lt-T-gt-to-designate-a-half-open-sequence" class="headerlink" title="F.24: Use a span&lt;T&gt; or a span_p&lt;T&gt; to designate a half-open sequence"></a><a name="Rf-range"></a>F.24: Use a <code>span&lt;T&gt;</code> or a <code>span_p&lt;T&gt;</code> to designate a half-open sequence</h3><h5 id="Reason-51"><a href="#Reason-51" class="headerlink" title="Reason"></a>Reason</h5><p>Informal/non-explicit ranges are a source of errors.</p>
<h5 id="Example-51"><a href="#Example-51" class="headerlink" title="Example"></a>Example</h5><pre><code>X* find(span&lt;X&gt; r, const X&amp; v);    // find v in r

vector&lt;X&gt; vec;
// ...
auto p = find(&#123;vec.begin(), vec.end()&#125;, X&#123;&#125;);  // find X&#123;&#125; in vec
</code></pre>
<h5 id="Note-63"><a href="#Note-63" class="headerlink" title="Note"></a>Note</h5><p>Ranges are extremely common in C++ code. Typically, they are implicit and their correct use is very hard to ensure.<br>In particular, given a pair of arguments <code>(p, n)</code> designating an array <code>[p:p+n)</code>,<br>it is in general impossible to know if there really are <code>n</code> elements to access following <code>*p</code>.<br><code>span&lt;T&gt;</code> and <code>span_p&lt;T&gt;</code> are simple helper classes designating a <code>[p:q)</code> range and a range starting with <code>p</code> and ending with the first element for which a predicate is true, respectively.</p>
<h5 id="Example-52"><a href="#Example-52" class="headerlink" title="Example"></a>Example</h5><p>A <code>span</code> represents a range of elements, but how do we manipulate elements of that range?</p>
<pre><code>void f(span&lt;int&gt; s)
&#123;
    // range traversal (guaranteed correct)
    for (int x : s) cout &lt;&lt; x &lt;&lt; &#39;\n&#39;;

    // C-style traversal (potentially checked)
    for (gsl::index i = 0; i &lt; s.size(); ++i) cout &lt;&lt; s[i] &lt;&lt; &#39;\n&#39;;

    // random access (potentially checked)
    s[7] = 9;

    // extract pointers (potentially checked)
    std::sort(&amp;s[0], &amp;s[s.size() / 2]);
&#125;
</code></pre>
<h5 id="Note-64"><a href="#Note-64" class="headerlink" title="Note"></a>Note</h5><p>A <code>span&lt;T&gt;</code> object does not own its elements and is so small that it can be passed by value.</p>
<p>Passing a <code>span</code> object as an argument is exactly as efficient as passing a pair of pointer arguments or passing a pointer and an integer count.</p>
<p><strong>See also</strong>: <a href="#S-gsl">Support library</a></p>
<h5 id="Enforcement-47"><a href="#Enforcement-47" class="headerlink" title="Enforcement"></a>Enforcement</h5><p>(Complex) Warn where accesses to pointer parameters are bounded by other parameters that are integral types and suggest they could use <code>span</code> instead.</p>
<h3 id="F-25-Use-a-zstring-or-a-not-null-lt-zstring-gt-to-designate-a-C-style-string"><a href="#F-25-Use-a-zstring-or-a-not-null-lt-zstring-gt-to-designate-a-C-style-string" class="headerlink" title="F.25: Use a zstring or a not_null&lt;zstring&gt; to designate a C-style string"></a><a name="Rf-zstring"></a>F.25: Use a <code>zstring</code> or a <code>not_null&lt;zstring&gt;</code> to designate a C-style string</h3><h5 id="Reason-52"><a href="#Reason-52" class="headerlink" title="Reason"></a>Reason</h5><p>C-style strings are ubiquitous. They are defined by convention: zero-terminated arrays of characters.<br>We must distinguish C-style strings from a pointer to a single character or an old-fashioned pointer to an array of characters.</p>
<h5 id="Example-53"><a href="#Example-53" class="headerlink" title="Example"></a>Example</h5><p>Consider:</p>
<pre><code>int length(const char* p);
</code></pre>
<p>When I call <code>length(s)</code> should I check if <code>s</code> is <code>nullptr</code> first? Should the implementation of <code>length()</code> check if <code>p</code> is <code>nullptr</code>?</p>
<pre><code>// the implementor of length() must assume that p == nullptr is possible
int length(zstring p);

// it is the caller&#39;s job to make sure p != nullptr
int length(not_null&lt;zstring&gt; p);
</code></pre>
<h5 id="Note-65"><a href="#Note-65" class="headerlink" title="Note"></a>Note</h5><p><code>zstring</code> do not represent ownership.</p>
<p><strong>See also</strong>: <a href="#S-gsl">Support library</a></p>
<h3 id="F-26-Use-a-unique-ptr-lt-T-gt-to-transfer-ownership-where-a-pointer-is-needed"><a href="#F-26-Use-a-unique-ptr-lt-T-gt-to-transfer-ownership-where-a-pointer-is-needed" class="headerlink" title="F.26: Use a unique_ptr&lt;T&gt; to transfer ownership where a pointer is needed"></a><a name="Rf-unique_ptr"></a>F.26: Use a <code>unique_ptr&lt;T&gt;</code> to transfer ownership where a pointer is needed</h3><h5 id="Reason-53"><a href="#Reason-53" class="headerlink" title="Reason"></a>Reason</h5><p>Using <code>unique_ptr</code> is the cheapest way to pass a pointer safely.</p>
<p><strong>See also</strong>: <a href="#Rc-factory">C.50</a> regarding when to return a <code>shared_ptr</code> from a factory.</p>
<h5 id="Example-54"><a href="#Example-54" class="headerlink" title="Example"></a>Example</h5><pre><code>unique_ptr&lt;Shape&gt; get_shape(istream&amp; is)  // assemble shape from input stream
&#123;
    auto kind = read_header(is); // read header and identify the next shape on input
    switch (kind) &#123;
    case kCircle:
        return make_unique&lt;Circle&gt;(is);
    case kTriangle:
        return make_unique&lt;Triangle&gt;(is);
    // ...
    &#125;
&#125;
</code></pre>
<h5 id="Note-66"><a href="#Note-66" class="headerlink" title="Note"></a>Note</h5><p>You need to pass a pointer rather than an object if what you are transferring is an object from a class hierarchy that is to be used through an interface (base class).</p>
<h5 id="Enforcement-48"><a href="#Enforcement-48" class="headerlink" title="Enforcement"></a>Enforcement</h5><p>(Simple) Warn if a function returns a locally allocated raw pointer. Suggest using either <code>unique_ptr</code> or <code>shared_ptr</code> instead.</p>
<h3 id="F-27-Use-a-shared-ptr-lt-T-gt-to-share-ownership"><a href="#F-27-Use-a-shared-ptr-lt-T-gt-to-share-ownership" class="headerlink" title="F.27: Use a shared_ptr&lt;T&gt; to share ownership"></a><a name="Rf-shared_ptr"></a>F.27: Use a <code>shared_ptr&lt;T&gt;</code> to share ownership</h3><h5 id="Reason-54"><a href="#Reason-54" class="headerlink" title="Reason"></a>Reason</h5><p>Using <code>std::shared_ptr</code> is the standard way to represent shared ownership. That is, the last owner deletes the object.</p>
<h5 id="Example-55"><a href="#Example-55" class="headerlink" title="Example"></a>Example</h5><pre><code>shared_ptr&lt;const Image&gt; im &#123; read_image(somewhere) &#125;;

std::thread t0 &#123;shade, args0, top_left, im&#125;;
std::thread t1 &#123;shade, args1, top_right, im&#125;;
std::thread t2 &#123;shade, args2, bottom_left, im&#125;;
std::thread t3 &#123;shade, args3, bottom_right, im&#125;;

// detach threads
// last thread to finish deletes the image
</code></pre>
<h5 id="Note-67"><a href="#Note-67" class="headerlink" title="Note"></a>Note</h5><p>Prefer a <code>unique_ptr</code> over a <code>shared_ptr</code> if there is never more than one owner at a time.<br><code>shared_ptr</code> is for shared ownership.</p>
<p>Note that pervasive use of <code>shared_ptr</code> has a cost (atomic operations on the <code>shared_ptr</code>‘s reference count have a measurable aggregate cost).</p>
<h5 id="Alternative-4"><a href="#Alternative-4" class="headerlink" title="Alternative"></a>Alternative</h5><p>Have a single object own the shared object (e.g. a scoped object) and destroy that (preferably implicitly) when all users have completed.</p>
<h5 id="Enforcement-49"><a href="#Enforcement-49" class="headerlink" title="Enforcement"></a>Enforcement</h5><p>(Not enforceable) This is a too complex pattern to reliably detect.</p>
<h3 id="F-60-Prefer-T-over-T-amp-when-“no-argument”-is-a-valid-option"><a href="#F-60-Prefer-T-over-T-amp-when-“no-argument”-is-a-valid-option" class="headerlink" title="F.60: Prefer T* over T&amp; when “no argument” is a valid option"></a><a name="Rf-ptr-ref"></a>F.60: Prefer <code>T*</code> over <code>T&amp;</code> when “no argument” is a valid option</h3><h5 id="Reason-55"><a href="#Reason-55" class="headerlink" title="Reason"></a>Reason</h5><p>A pointer (<code>T*</code>) can be a <code>nullptr</code> and a reference (<code>T&amp;</code>) cannot, there is no valid “null reference”.<br>Sometimes having <code>nullptr</code> as an alternative to indicated “no object” is useful, but if it is not, a reference is notationally simpler and might yield better code.</p>
<h5 id="Example-56"><a href="#Example-56" class="headerlink" title="Example"></a>Example</h5><pre><code>string zstring_to_string(zstring p) // zstring is a char*; that is a C-style string
&#123;
    if (!p) return string&#123;&#125;;    // p might be nullptr; remember to check
    return string&#123;p&#125;;
&#125;

void print(const vector&lt;int&gt;&amp; r)
&#123;
    // r refers to a vector&lt;int&gt;; no check needed
&#125;
</code></pre>
<h5 id="Note-68"><a href="#Note-68" class="headerlink" title="Note"></a>Note</h5><p>It is possible, but not valid C++ to construct a reference that is essentially a <code>nullptr</code> (e.g., <code>T* p = nullptr; T&amp; r = (T&amp;)*p;</code>).<br>That error is very uncommon.</p>
<h5 id="Note-69"><a href="#Note-69" class="headerlink" title="Note"></a>Note</h5><p>If you prefer the pointer notation (<code>-&gt;</code> and/or <code>*</code> vs. <code>.</code>), <code>not_null&lt;T*&gt;</code> provides the same guarantee as <code>T&amp;</code>.</p>
<h5 id="Enforcement-50"><a href="#Enforcement-50" class="headerlink" title="Enforcement"></a>Enforcement</h5><ul>
<li>Flag ???</li>
</ul>
<h3 id="F-42-Return-a-T-to-indicate-a-position-only"><a href="#F-42-Return-a-T-to-indicate-a-position-only" class="headerlink" title="F.42: Return a T* to indicate a position (only)"></a><a name="Rf-return-ptr"></a>F.42: Return a <code>T*</code> to indicate a position (only)</h3><h5 id="Reason-56"><a href="#Reason-56" class="headerlink" title="Reason"></a>Reason</h5><p>That’s what pointers are good for.<br>Returning a <code>T*</code> to transfer ownership is a misuse.</p>
<h5 id="Example-57"><a href="#Example-57" class="headerlink" title="Example"></a>Example</h5><pre><code>Node* find(Node* t, const string&amp; s)  // find s in a binary tree of Nodes
&#123;
    if (!t || t-&gt;name == s) return t;
    if ((auto p = find(t-&gt;left, s))) return p;
    if ((auto p = find(t-&gt;right, s))) return p;
    return nullptr;
&#125;
</code></pre>
<p>If it isn’t the <code>nullptr</code>, the pointer returned by <code>find</code> indicates a <code>Node</code> holding <code>s</code>.<br>Importantly, that does not imply a transfer of ownership of the pointed-to object to the caller.</p>
<h5 id="Note-70"><a href="#Note-70" class="headerlink" title="Note"></a>Note</h5><p>Positions can also be transferred by iterators, indices, and references.<br>A reference is often a superior alternative to a pointer <a href="#Rf-ptr-ref">if there is no need to use <code>nullptr</code></a> or <a href="???">if the object referred to should not change</a>.</p>
<h5 id="Note-71"><a href="#Note-71" class="headerlink" title="Note"></a>Note</h5><p>Do not return a pointer to something that is not in the caller’s scope; see <a href="#Rf-dangle">F.43</a>.</p>
<p><strong>See also</strong>: <a href="#???">discussion of dangling pointer prevention</a></p>
<h5 id="Enforcement-51"><a href="#Enforcement-51" class="headerlink" title="Enforcement"></a>Enforcement</h5><ul>
<li>Flag <code>delete</code>, <code>std::free()</code>, etc. applied to a plain <code>T*</code>.<br>Only owners should be deleted.</li>
<li>Flag <code>new</code>, <code>malloc()</code>, etc. assigned to a plain <code>T*</code>.<br>Only owners should be responsible for deletion.</li>
</ul>
<h3 id="F-43-Never-directly-or-indirectly-return-a-pointer-or-a-reference-to-a-local-object"><a href="#F-43-Never-directly-or-indirectly-return-a-pointer-or-a-reference-to-a-local-object" class="headerlink" title="F.43: Never (directly or indirectly) return a pointer or a reference to a local object"></a><a name="Rf-dangle"></a>F.43: Never (directly or indirectly) return a pointer or a reference to a local object</h3><h5 id="Reason-57"><a href="#Reason-57" class="headerlink" title="Reason"></a>Reason</h5><p>To avoid the crashes and data corruption that can result from the use of such a dangling pointer.</p>
<h5 id="Example-bad-18"><a href="#Example-bad-18" class="headerlink" title="Example, bad"></a>Example, bad</h5><p>After the return from a function its local objects no longer exist:</p>
<pre><code>int* f()
&#123;
    int fx = 9;
    return &amp;fx;  // BAD
&#125;

void g(int* p)   // looks innocent enough
&#123;
    int gx;
    cout &lt;&lt; &quot;*p == &quot; &lt;&lt; *p &lt;&lt; &#39;\n&#39;;
    *p = 999;
    cout &lt;&lt; &quot;gx == &quot; &lt;&lt; gx &lt;&lt; &#39;\n&#39;;
&#125;

void h()
&#123;
    int* p = f();
    int z = *p;  // read from abandoned stack frame (bad)
    g(p);        // pass pointer to abandoned stack frame to function (bad)
&#125;
</code></pre>
<p>Here on one popular implementation I got the output:</p>
<pre><code>*p == 999
gx == 999
</code></pre>
<p>I expected that because the call of <code>g()</code> reuses the stack space abandoned by the call of <code>f()</code> so <code>*p</code> refers to the space now occupied by <code>gx</code>.</p>
<ul>
<li>Imagine what would happen if <code>fx</code> and <code>gx</code> were of different types.</li>
<li>Imagine what would happen if <code>fx</code> or <code>gx</code> was a type with an invariant.</li>
<li>Imagine what would happen if more that dangling pointer was passed around among a larger set of functions.</li>
<li>Imagine what a cracker could do with that dangling pointer.</li>
</ul>
<p>Fortunately, most (all?) modern compilers catch and warn against this simple case.</p>
<h5 id="Note-72"><a href="#Note-72" class="headerlink" title="Note"></a>Note</h5><p>This applies to references as well:</p>
<pre><code>int&amp; f()
&#123;
    int x = 7;
    // ...
    return x;  // Bad: returns reference to object that is about to be destroyed
&#125;
</code></pre>
<h5 id="Note-73"><a href="#Note-73" class="headerlink" title="Note"></a>Note</h5><p>This applies only to non-<code>static</code> local variables.<br>All <code>static</code> variables are (as their name indicates) statically allocated, so that pointers to them cannot dangle.</p>
<h5 id="Example-bad-19"><a href="#Example-bad-19" class="headerlink" title="Example, bad"></a>Example, bad</h5><p>Not all examples of leaking a pointer to a local variable are that obvious:</p>
<pre><code>int* glob;       // global variables are bad in so many ways

template&lt;class T&gt;
void steal(T x)
&#123;
    glob = x();  // BAD
&#125;

void f()
&#123;
    int i = 99;
    steal([&amp;] &#123; return &amp;i; &#125;);
&#125;

int main()
&#123;
    f();
    cout &lt;&lt; *glob &lt;&lt; &#39;\n&#39;;
&#125;
</code></pre>
<p>Here I managed to read the location abandoned by the call of <code>f</code>.<br>The pointer stored in <code>glob</code> could be used much later and cause trouble in unpredictable ways.</p>
<h5 id="Note-74"><a href="#Note-74" class="headerlink" title="Note"></a>Note</h5><p>The address of a local variable can be “returned”/leaked by a return statement, by a <code>T&amp;</code> out-parameter, as a member of a returned object, as an element of a returned array, and more.</p>
<h5 id="Note-75"><a href="#Note-75" class="headerlink" title="Note"></a>Note</h5><p>Similar examples can be constructed “leaking” a pointer from an inner scope to an outer one;<br>such examples are handled equivalently to leaks of pointers out of a function.</p>
<p>A slightly different variant of the problem is placing pointers in a container that outlives the objects pointed to.</p>
<p><strong>See also</strong>: Another way of getting dangling pointers is <a href="#???">pointer invalidation</a>.<br>It can be detected/prevented with similar techniques.</p>
<h5 id="Enforcement-52"><a href="#Enforcement-52" class="headerlink" title="Enforcement"></a>Enforcement</h5><ul>
<li>Compilers tend to catch return of reference to locals and could in many cases catch return of pointers to locals.</li>
<li>Static analysis can catch many common patterns of the use of pointers indicating positions (thus eliminating dangling pointers)</li>
</ul>
<h3 id="F-44-Return-a-T-amp-when-copy-is-undesirable-and-“returning-no-object”-isn’t-needed"><a href="#F-44-Return-a-T-amp-when-copy-is-undesirable-and-“returning-no-object”-isn’t-needed" class="headerlink" title="F.44: Return a T&amp; when copy is undesirable and “returning no object” isn’t needed"></a><a name="Rf-return-ref"></a>F.44: Return a <code>T&amp;</code> when copy is undesirable and “returning no object” isn’t needed</h3><h5 id="Reason-58"><a href="#Reason-58" class="headerlink" title="Reason"></a>Reason</h5><p>The language guarantees that a <code>T&amp;</code> refers to an object, so that testing for <code>nullptr</code> isn’t necessary.</p>
<p><strong>See also</strong>: The return of a reference must not imply transfer of ownership:<br><a href="#???">discussion of dangling pointer prevention</a> and <a href="#???">discussion of ownership</a>.</p>
<h5 id="Example-58"><a href="#Example-58" class="headerlink" title="Example"></a>Example</h5><pre><code>class Car
&#123;
    array&lt;wheel, 4&gt; w;
    // ...
public:
    wheel&amp; get_wheel(int i) &#123; Expects(i &lt; w.size()); return w[i]; &#125;
    // ...
&#125;;

void use()
&#123;
    Car c;
    wheel&amp; w0 = c.get_wheel(0); // w0 has the same lifetime as c
&#125;
</code></pre>
<h5 id="Enforcement-53"><a href="#Enforcement-53" class="headerlink" title="Enforcement"></a>Enforcement</h5><p>Flag functions where no <code>return</code> expression could yield <code>nullptr</code></p>
<h3 id="F-45-Don’t-return-a-T-amp-amp"><a href="#F-45-Don’t-return-a-T-amp-amp" class="headerlink" title="F.45: Don’t return a T&amp;&amp;"></a><a name="Rf-return-ref-ref"></a>F.45: Don’t return a <code>T&amp;&amp;</code></h3><h5 id="Reason-59"><a href="#Reason-59" class="headerlink" title="Reason"></a>Reason</h5><p>It’s asking to return a reference to a destroyed temporary object. A <code>&amp;&amp;</code> is a magnet for temporary objects. This is fine when the reference to the temporary is being passed “downward” to a callee, because the temporary is guaranteed to outlive the function call (see <a href="#Rf-consume">F.18</a> and <a href="#Rf-forward">F.19</a>). However, it’s not fine when passing such a reference “upward” to a larger caller scope. See also ???.</p>
<p>For passthrough functions that pass in parameters (by ordinary reference or by perfect forwarding) and want to return values, use simple <code>auto</code> return type deduction (not <code>auto&amp;&amp;</code>).</p>
<h5 id="Example-bad-20"><a href="#Example-bad-20" class="headerlink" title="Example, bad"></a>Example, bad</h5><p>If <code>F</code> returns by value, this function returns a reference to a temporary.</p>
<pre><code>template&lt;class F&gt;
auto&amp;&amp; wrapper(F f)
&#123;
    log_call(typeid(f)); // or whatever instrumentation
    return f();
&#125;
</code></pre>
<h5 id="Example-good-2"><a href="#Example-good-2" class="headerlink" title="Example, good"></a>Example, good</h5><p>Better:</p>
<pre><code>template&lt;class F&gt;
auto wrapper(F f)
&#123;
    log_call(typeid(f)); // or whatever instrumentation
    return f();
&#125;
</code></pre>
<h5 id="Exception-12"><a href="#Exception-12" class="headerlink" title="Exception"></a>Exception</h5><p><code>std::move</code> and <code>std::forward</code> do return <code>&amp;&amp;</code>, but they are just casts – used by convention only in expression contexts where a reference to a temporary object is passed along within the same expression before the temporary is destroyed. We don’t know of any other good examples of returning <code>&amp;&amp;</code>.</p>
<h5 id="Enforcement-54"><a href="#Enforcement-54" class="headerlink" title="Enforcement"></a>Enforcement</h5><p>Flag any use of <code>&amp;&amp;</code> as a return type, except in <code>std::move</code> and <code>std::forward</code>.</p>
<h3 id="F-46-int-is-the-return-type-for-main"><a href="#F-46-int-is-the-return-type-for-main" class="headerlink" title="F.46: int is the return type for main()"></a><a name="Rf-main"></a>F.46: <code>int</code> is the return type for <code>main()</code></h3><h5 id="Reason-60"><a href="#Reason-60" class="headerlink" title="Reason"></a>Reason</h5><p>It’s a language rule, but violated through “language extensions” so often that it is worth mentioning.<br>Declaring <code>main</code> (the one global <code>main</code> of a program) <code>void</code> limits portability.</p>
<h5 id="Example-59"><a href="#Example-59" class="headerlink" title="Example"></a>Example</h5><pre><code>    void main() &#123; /* ... */ &#125;;  // bad, not C++

    int main()
    &#123;
        std::cout &lt;&lt; &quot;This is the way to do it\n&quot;;
    &#125;
</code></pre>
<h5 id="Note-76"><a href="#Note-76" class="headerlink" title="Note"></a>Note</h5><p>We mention this only because of the persistence of this error in the community.</p>
<h5 id="Enforcement-55"><a href="#Enforcement-55" class="headerlink" title="Enforcement"></a>Enforcement</h5><ul>
<li>The compiler should do it</li>
<li>If the compiler doesn’t do it, let tools flag it</li>
</ul>
<h3 id="F-47-Return-T-amp-from-assignment-operators"><a href="#F-47-Return-T-amp-from-assignment-operators" class="headerlink" title="F.47: Return T&amp; from assignment operators"></a><a name="Rf-assignment-op"></a>F.47: Return <code>T&amp;</code> from assignment operators</h3><h5 id="Reason-61"><a href="#Reason-61" class="headerlink" title="Reason"></a>Reason</h5><p>The convention for operator overloads (especially on value types) is for<br><code>operator=(const T&amp;)</code> to perform the assignment and then return (non-<code>const</code>)<br><code>*this</code>.  This ensures consistency with standard-library types and follows the<br>principle of “do as the ints do.”</p>
<h5 id="Note-77"><a href="#Note-77" class="headerlink" title="Note"></a>Note</h5><p>Historically there was some guidance to make the assignment operator return <code>const T&amp;</code>.<br>This was primarily to avoid code of the form <code>(a = b) = c</code> – such code is not common enough to warrant violating consistency with standard types.</p>
<h5 id="Example-60"><a href="#Example-60" class="headerlink" title="Example"></a>Example</h5><pre><code>class Foo
&#123;
 public:
    ...
    Foo&amp; operator=(const Foo&amp; rhs) &#123;
      // Copy members.
      ...
      return *this;
    &#125;
&#125;;
</code></pre>
<h5 id="Enforcement-56"><a href="#Enforcement-56" class="headerlink" title="Enforcement"></a>Enforcement</h5><p>This should be enforced by tooling by checking the return type (and return<br>value) of any assignment operator.</p>
<h3 id="F-48-Don’t-return-std-move-local"><a href="#F-48-Don’t-return-std-move-local" class="headerlink" title="F.48: Don’t return std::move(local)"></a><a name="Rf-return-move-local"></a>F.48: Don’t <code>return std::move(local)</code></h3><h5 id="Reason-62"><a href="#Reason-62" class="headerlink" title="Reason"></a>Reason</h5><p>With guaranteed copy elision, it is now almost always a pessimization to expressly use <code>std::move</code> in a return statement.</p>
<h5 id="Example-bad-21"><a href="#Example-bad-21" class="headerlink" title="Example; bad"></a>Example; bad</h5><pre><code>S f()
&#123;
  S result;
  return std::move(result);
&#125;
</code></pre>
<h5 id="Example-good-3"><a href="#Example-good-3" class="headerlink" title="Example; good"></a>Example; good</h5><pre><code>S f()
&#123;
  S result;
  return result;
&#125;
</code></pre>
<h5 id="Enforcement-57"><a href="#Enforcement-57" class="headerlink" title="Enforcement"></a>Enforcement</h5><p>This should be enforced by tooling by checking the return expression .</p>
<h3 id="F-50-Use-a-lambda-when-a-function-won’t-do-to-capture-local-variables-or-to-write-a-local-function"><a href="#F-50-Use-a-lambda-when-a-function-won’t-do-to-capture-local-variables-or-to-write-a-local-function" class="headerlink" title="F.50: Use a lambda when a function won’t do (to capture local variables, or to write a local function)"></a><a name="Rf-capture-vs-overload"></a>F.50: Use a lambda when a function won’t do (to capture local variables, or to write a local function)</h3><h5 id="Reason-63"><a href="#Reason-63" class="headerlink" title="Reason"></a>Reason</h5><p>Functions can’t capture local variables or be declared at local scope; if you need those things, prefer a lambda where possible, and a handwritten function object where not. On the other hand, lambdas and function objects don’t overload; if you need to overload, prefer a function (the workarounds to make lambdas overload are ornate). If either will work, prefer writing a function; use the simplest tool necessary.</p>
<h5 id="Example-61"><a href="#Example-61" class="headerlink" title="Example"></a>Example</h5><pre><code>// writing a function that should only take an int or a string
// -- overloading is natural
void f(int);
void f(const string&amp;);

// writing a function object that needs to capture local state and appear
// at statement or expression scope -- a lambda is natural
vector&lt;work&gt; v = lots_of_work();
for (int tasknum = 0; tasknum &lt; max; ++tasknum) &#123;
    pool.run([=, &amp;v]&#123;
        /*
        ...
        ... process 1 / max - th of v, the tasknum - th chunk
        ...
        */
    &#125;);
&#125;
pool.join();
</code></pre>
<h5 id="Exception-13"><a href="#Exception-13" class="headerlink" title="Exception"></a>Exception</h5><p>Generic lambdas offer a concise way to write function templates and so can be useful even when a normal function template would do equally well with a little more syntax. This advantage will probably disappear in the future once all functions gain the ability to have Concept parameters.</p>
<h5 id="Enforcement-58"><a href="#Enforcement-58" class="headerlink" title="Enforcement"></a>Enforcement</h5><ul>
<li>Warn on use of a named non-generic lambda (e.g., <code>auto x = [](int i)&#123; /*...*/; &#125;;</code>) that captures nothing and appears at global scope. Write an ordinary function instead.</li>
</ul>
<h3 id="F-51-Where-there-is-a-choice-prefer-default-arguments-over-overloading"><a href="#F-51-Where-there-is-a-choice-prefer-default-arguments-over-overloading" class="headerlink" title="F.51: Where there is a choice, prefer default arguments over overloading"></a><a name="Rf-default-args"></a>F.51: Where there is a choice, prefer default arguments over overloading</h3><h5 id="Reason-64"><a href="#Reason-64" class="headerlink" title="Reason"></a>Reason</h5><p>Default arguments simply provide alternative interfaces to a single implementation.<br>There is no guarantee that a set of overloaded functions all implement the same semantics.<br>The use of default arguments can avoid code replication.</p>
<h5 id="Note-78"><a href="#Note-78" class="headerlink" title="Note"></a>Note</h5><p>There is a choice between using default argument and overloading when the alternatives are from a set of arguments of the same types.<br>For example:</p>
<pre><code>void print(const string&amp; s, format f = &#123;&#125;);
</code></pre>
<p>as opposed to</p>
<pre><code>void print(const string&amp; s);  // use default format
void print(const string&amp; s, format f);
</code></pre>
<p>There is not a choice when a set of functions are used to do a semantically equivalent operation to a set of types. For example:</p>
<pre><code>void print(const char&amp;);
void print(int);
void print(zstring);
</code></pre>
<h5 id="See-also"><a href="#See-also" class="headerlink" title="See also"></a>See also</h5><p><a href="#Rh-virtual-default-arg">Default arguments for virtual functions</a></p>
<h5 id="Enforcement-59"><a href="#Enforcement-59" class="headerlink" title="Enforcement"></a>Enforcement</h5><pre><code>???
</code></pre>
<h3 id="F-52-Prefer-capturing-by-reference-in-lambdas-that-will-be-used-locally-including-passed-to-algorithms"><a href="#F-52-Prefer-capturing-by-reference-in-lambdas-that-will-be-used-locally-including-passed-to-algorithms" class="headerlink" title="F.52: Prefer capturing by reference in lambdas that will be used locally, including passed to algorithms"></a><a name="Rf-reference-capture"></a>F.52: Prefer capturing by reference in lambdas that will be used locally, including passed to algorithms</h3><h5 id="Reason-65"><a href="#Reason-65" class="headerlink" title="Reason"></a>Reason</h5><p>For efficiency and correctness, you nearly always want to capture by reference when using the lambda locally. This includes when writing or calling parallel algorithms that are local because they join before returning.</p>
<h5 id="Discussion-1"><a href="#Discussion-1" class="headerlink" title="Discussion"></a>Discussion</h5><p>The efficiency consideration is that most types are cheaper to pass by reference than by value.</p>
<p>The correctness consideration is that many calls want to perform side effects on the original object at the call site (see example below). Passing by value prevents this.</p>
<h5 id="Note-79"><a href="#Note-79" class="headerlink" title="Note"></a>Note</h5><p>Unfortunately, there is no simple way to capture by reference to <code>const</code> to get the efficiency for a local call but also prevent side effects.</p>
<h5 id="Example-62"><a href="#Example-62" class="headerlink" title="Example"></a>Example</h5><p>Here, a large object (a network message) is passed to an iterative algorithm, and is it not efficient or correct to copy the message (which may not be copyable):</p>
<pre><code>std::for_each(begin(sockets), end(sockets), [&amp;message](auto&amp; socket)
&#123;
    socket.send(message);
&#125;);
</code></pre>
<h5 id="Example-63"><a href="#Example-63" class="headerlink" title="Example"></a>Example</h5><p>This is a simple three-stage parallel pipeline. Each <code>stage</code> object encapsulates a worker thread and a queue, has a <code>process</code> function to enqueue work, and in its destructor automatically blocks waiting for the queue to empty before ending the thread.</p>
<pre><code>void send_packets(buffers&amp; bufs)
&#123;
    stage encryptor([] (buffer&amp; b)&#123; encrypt(b); &#125;);
    stage compressor([&amp;](buffer&amp; b)&#123; compress(b); encryptor.process(b); &#125;);
    stage decorator([&amp;](buffer&amp; b)&#123; decorate(b); compressor.process(b); &#125;);
    for (auto&amp; b : bufs) &#123; decorator.process(b); &#125;
&#125;  // automatically blocks waiting for pipeline to finish
</code></pre>
<h5 id="Enforcement-60"><a href="#Enforcement-60" class="headerlink" title="Enforcement"></a>Enforcement</h5><p>Flag a lambda that captures by reference, but is used other than locally within the function scope or passed to a function by reference. (Note: This rule is an approximation, but does flag passing by pointer as those are more likely to be stored by the callee, writing to a heap location accessed via a parameter, returning the lambda, etc. The Lifetime rules will also provide general rules that flag escaping pointers and references including via lambdas.)</p>
<h3 id="F-53-Avoid-capturing-by-reference-in-lambdas-that-will-be-used-nonlocally-including-returned-stored-on-the-heap-or-passed-to-another-thread"><a href="#F-53-Avoid-capturing-by-reference-in-lambdas-that-will-be-used-nonlocally-including-returned-stored-on-the-heap-or-passed-to-another-thread" class="headerlink" title="F.53: Avoid capturing by reference in lambdas that will be used nonlocally, including returned, stored on the heap, or passed to another thread"></a><a name="Rf-value-capture"></a>F.53: Avoid capturing by reference in lambdas that will be used nonlocally, including returned, stored on the heap, or passed to another thread</h3><h5 id="Reason-66"><a href="#Reason-66" class="headerlink" title="Reason"></a>Reason</h5><p>Pointers and references to locals shouldn’t outlive their scope. Lambdas that capture by reference are just another place to store a reference to a local object, and shouldn’t do so if they (or a copy) outlive the scope.</p>
<h5 id="Example-bad-22"><a href="#Example-bad-22" class="headerlink" title="Example, bad"></a>Example, bad</h5><pre><code>int local = 42;

// Want a reference to local.
// Note, that after program exits this scope,
// local no longer exists, therefore
// process() call will have undefined behavior!
thread_pool.queue_work([&amp;]&#123; process(local); &#125;);
</code></pre>
<h5 id="Example-good-4"><a href="#Example-good-4" class="headerlink" title="Example, good"></a>Example, good</h5><pre><code>int local = 42;
// Want a copy of local.
// Since a copy of local is made, it will
// always be available for the call.
thread_pool.queue_work([=]&#123; process(local); &#125;);
</code></pre>
<h5 id="Enforcement-61"><a href="#Enforcement-61" class="headerlink" title="Enforcement"></a>Enforcement</h5><ul>
<li>(Simple) Warn when capture-list contains a reference to a locally declared variable</li>
<li>(Complex) Flag when capture-list contains a reference to a locally declared variable and the lambda is passed to a non-<code>const</code> and non-local context</li>
</ul>
<h3 id="F-54-If-you-capture-this-capture-all-variables-explicitly-no-default-capture"><a href="#F-54-If-you-capture-this-capture-all-variables-explicitly-no-default-capture" class="headerlink" title="F.54: If you capture this, capture all variables explicitly (no default capture)"></a><a name="Rf-this-capture"></a>F.54: If you capture <code>this</code>, capture all variables explicitly (no default capture)</h3><h5 id="Reason-67"><a href="#Reason-67" class="headerlink" title="Reason"></a>Reason</h5><p>It’s confusing. Writing <code>[=]</code> in a member function appears to capture by value, but actually captures data members by reference because it actually captures the invisible <code>this</code> pointer by value. If you meant to do that, write <code>this</code> explicitly.</p>
<h5 id="Example-64"><a href="#Example-64" class="headerlink" title="Example"></a>Example</h5><pre><code>class My_class &#123;
    int x = 0;
    // ...

    void f() &#123;
        int i = 0;
        // ...

        auto lambda = [=]&#123; use(i, x); &#125;;   // BAD: &quot;looks like&quot; copy/value capture
        // [&amp;] has identical semantics and copies the this pointer under the current rules
        // [=,this] and [&amp;,this] are not much better, and confusing

        x = 42;
        lambda(); // calls use(0, 42);
        x = 43;
        lambda(); // calls use(0, 43);

        // ...

        auto lambda2 = [i, this]&#123; use(i, x); &#125;; // ok, most explicit and least confusing

        // ...
    &#125;
&#125;;
</code></pre>
<h5 id="Note-80"><a href="#Note-80" class="headerlink" title="Note"></a>Note</h5><p>This is under active discussion in standardization, and may be addressed in a future version of the standard by adding a new capture mode or possibly adjusting the meaning of <code>[=]</code>. For now, just be explicit.</p>
<h5 id="Enforcement-62"><a href="#Enforcement-62" class="headerlink" title="Enforcement"></a>Enforcement</h5><ul>
<li>Flag any lambda capture-list that specifies a default capture and also captures <code>this</code> (whether explicitly or via default capture)</li>
</ul>
<h3 id="F-55-Don’t-use-va-arg-arguments"><a href="#F-55-Don’t-use-va-arg-arguments" class="headerlink" title="F.55: Don’t use va_arg arguments"></a><a name="F-varargs"></a>F.55: Don’t use <code>va_arg</code> arguments</h3><h5 id="Reason-68"><a href="#Reason-68" class="headerlink" title="Reason"></a>Reason</h5><p>Reading from a <code>va_arg</code> assumes that the correct type was actually passed.<br>Passing to varargs assumes the correct type will be read.<br>This is fragile because it cannot generally be enforced to be safe in the language and so relies on programmer discipline to get it right.</p>
<h5 id="Example-65"><a href="#Example-65" class="headerlink" title="Example"></a>Example</h5><pre><code>int sum(...) &#123;
    // ...
    while (/*...*/)
        result += va_arg(list, int); // BAD, assumes it will be passed ints
    // ...
&#125;

sum(3, 2); // ok
sum(3.14159, 2.71828); // BAD, undefined

template&lt;class ...Args&gt;
auto sum(Args... args) &#123; // GOOD, and much more flexible
    return (... + args); // note: C++17 &quot;fold expression&quot;
&#125;

sum(3, 2); // ok: 5
sum(3.14159, 2.71828); // ok: ~5.85987
</code></pre>
<h5 id="Alternatives"><a href="#Alternatives" class="headerlink" title="Alternatives"></a>Alternatives</h5><ul>
<li>overloading</li>
<li>variadic templates</li>
<li><code>variant</code> arguments</li>
<li><code>initializer_list</code> (homogeneous)</li>
</ul>
<h5 id="Note-81"><a href="#Note-81" class="headerlink" title="Note"></a>Note</h5><p>Declaring a <code>...</code> parameter is sometimes useful for techniques that don’t involve actual argument passing, notably to declare “take-anything” functions so as to disable “everything else” in an overload set or express a catchall case in a template metaprogram.</p>
<h5 id="Enforcement-63"><a href="#Enforcement-63" class="headerlink" title="Enforcement"></a>Enforcement</h5><ul>
<li>Issue a diagnostic for using <code>va_list</code>, <code>va_start</code>, or <code>va_arg</code>.</li>
<li>Issue a diagnostic for passing an argument to a vararg parameter of a function that does not offer an overload for a more specific type in the position of the vararg. To fix: Use a different function, or <code>[[suppress(types)]]</code>.</li>
</ul>
<h1 id="C-Classes-and-class-hierarchies"><a href="#C-Classes-and-class-hierarchies" class="headerlink" title="C: Classes and class hierarchies"></a><a name="S-class"></a>C: Classes and class hierarchies</h1><p>A class is a user-defined type, for which a programmer can define the representation, operations, and interfaces.<br>Class hierarchies are used to organize related classes into hierarchical structures.</p>
<p>Class rule summary:</p>
<ul>
<li><a href="#Rc-org">C.1: Organize related data into structures (<code>struct</code>s or <code>class</code>es)</a></li>
<li><a href="#Rc-struct">C.2: Use <code>class</code> if the class has an invariant; use <code>struct</code> if the data members can vary independently</a></li>
<li><a href="#Rc-interface">C.3: Represent the distinction between an interface and an implementation using a class</a></li>
<li><a href="#Rc-member">C.4: Make a function a member only if it needs direct access to the representation of a class</a></li>
<li><a href="#Rc-helper">C.5: Place helper functions in the same namespace as the class they support</a></li>
<li><a href="#Rc-standalone">C.7: Don’t define a class or enum and declare a variable of its type in the same statement</a></li>
<li><a href="#Rc-class">C.8: Use <code>class</code> rather than <code>struct</code> if any member is non-public</a></li>
<li><a href="#Rc-private">C.9: Minimize exposure of members</a></li>
</ul>
<p>Subsections:</p>
<ul>
<li><a href="#SS-concrete">C.concrete: Concrete types</a></li>
<li><a href="#S-ctor">C.ctor: Constructors, assignments, and destructors</a></li>
<li><a href="#SS-containers">C.con: Containers and other resource handles</a></li>
<li><a href="#SS-lambdas">C.lambdas: Function objects and lambdas</a></li>
<li><a href="#SS-hier">C.hier: Class hierarchies (OOP)</a></li>
<li><a href="#SS-overload">C.over: Overloading and overloaded operators</a></li>
<li><a href="#SS-union">C.union: Unions</a></li>
</ul>
<h3 id="C-1-Organize-related-data-into-structures-structs-or-classes"><a href="#C-1-Organize-related-data-into-structures-structs-or-classes" class="headerlink" title="C.1: Organize related data into structures (structs or classes)"></a><a name="Rc-org"></a>C.1: Organize related data into structures (<code>struct</code>s or <code>class</code>es)</h3><h5 id="Reason-69"><a href="#Reason-69" class="headerlink" title="Reason"></a>Reason</h5><p>Ease of comprehension.<br>If data is related (for fundamental reasons), that fact should be reflected in code.</p>
<h5 id="Example-66"><a href="#Example-66" class="headerlink" title="Example"></a>Example</h5><pre><code>void draw(int x, int y, int x2, int y2);  // BAD: unnecessary implicit relationships
void draw(Point from, Point to);          // better
</code></pre>
<h5 id="Note-82"><a href="#Note-82" class="headerlink" title="Note"></a>Note</h5><p>A simple class without virtual functions implies no space or time overhead.</p>
<h5 id="Note-83"><a href="#Note-83" class="headerlink" title="Note"></a>Note</h5><p>From a language perspective <code>class</code> and <code>struct</code> differ only in the default visibility of their members.</p>
<h5 id="Enforcement-64"><a href="#Enforcement-64" class="headerlink" title="Enforcement"></a>Enforcement</h5><p>Probably impossible. Maybe a heuristic looking for data items used together is possible.</p>
<h3 id="C-2-Use-class-if-the-class-has-an-invariant-use-struct-if-the-data-members-can-vary-independently"><a href="#C-2-Use-class-if-the-class-has-an-invariant-use-struct-if-the-data-members-can-vary-independently" class="headerlink" title="C.2: Use class if the class has an invariant; use struct if the data members can vary independently"></a><a name="Rc-struct"></a>C.2: Use <code>class</code> if the class has an invariant; use <code>struct</code> if the data members can vary independently</h3><h5 id="Reason-70"><a href="#Reason-70" class="headerlink" title="Reason"></a>Reason</h5><p>Readability.<br>Ease of comprehension.<br>The use of <code>class</code> alerts the programmer to the need for an invariant.<br>This is a useful convention.</p>
<h5 id="Note-84"><a href="#Note-84" class="headerlink" title="Note"></a>Note</h5><p>An invariant is a logical condition for the members of an object that a constructor must establish for the public member functions to assume.<br>After the invariant is established (typically by a constructor) every member function can be called for the object.<br>An invariant can be stated informally (e.g., in a comment) or more formally using <code>Expects</code>.</p>
<p>If all data members can vary independently of each other, no invariant is possible.</p>
<h5 id="Example-67"><a href="#Example-67" class="headerlink" title="Example"></a>Example</h5><pre><code>struct Pair &#123;  // the members can vary independently
    string name;
    int volume;
&#125;;
</code></pre>
<p>but:</p>
<pre><code>class Date &#123;
public:
    // validate that &#123;yy, mm, dd&#125; is a valid date and initialize
    Date(int yy, Month mm, char dd);
    // ...
private:
    int y;
    Month m;
    char d;    // day
&#125;;
</code></pre>
<h5 id="Note-85"><a href="#Note-85" class="headerlink" title="Note"></a>Note</h5><p>If a class has any <code>private</code> data, a user cannot completely initialize an object without the use of a constructor.<br>Hence, the class definer will provide a constructor and must specify its meaning.<br>This effectively means the definer need to define an invariant.</p>
<p><strong>See also</strong>:</p>
<ul>
<li><a href="#Rc-class">define a class with private data as <code>class</code></a></li>
<li><a href="#Rl-order">Prefer to place the interface first in a class</a></li>
<li><a href="#Rc-private">minimize exposure of members</a></li>
<li><a href="#Rh-protected">Avoid <code>protected</code> data</a></li>
</ul>
<h5 id="Enforcement-65"><a href="#Enforcement-65" class="headerlink" title="Enforcement"></a>Enforcement</h5><p>Look for <code>struct</code>s with all data private and <code>class</code>es with public members.</p>
<h3 id="C-3-Represent-the-distinction-between-an-interface-and-an-implementation-using-a-class"><a href="#C-3-Represent-the-distinction-between-an-interface-and-an-implementation-using-a-class" class="headerlink" title="C.3: Represent the distinction between an interface and an implementation using a class"></a><a name="Rc-interface"></a>C.3: Represent the distinction between an interface and an implementation using a class</h3><h5 id="Reason-71"><a href="#Reason-71" class="headerlink" title="Reason"></a>Reason</h5><p>An explicit distinction between interface and implementation improves readability and simplifies maintenance.</p>
<h5 id="Example-68"><a href="#Example-68" class="headerlink" title="Example"></a>Example</h5><pre><code>class Date &#123;
    // ... some representation ...
public:
    Date();
    // validate that &#123;yy, mm, dd&#125; is a valid date and initialize
    Date(int yy, Month mm, char dd);

    int day() const;
    Month month() const;
    // ...
&#125;;
</code></pre>
<p>For example, we can now change the representation of a <code>Date</code> without affecting its users (recompilation is likely, though).</p>
<h5 id="Note-86"><a href="#Note-86" class="headerlink" title="Note"></a>Note</h5><p>Using a class in this way to represent the distinction between interface and implementation is of course not the only way.<br>For example, we can use a set of declarations of freestanding functions in a namespace, an abstract base class, or a template function with concepts to represent an interface.<br>The most important issue is to explicitly distinguish between an interface and its implementation “details.”<br>Ideally, and typically, an interface is far more stable than its implementation(s).</p>
<h5 id="Enforcement-66"><a href="#Enforcement-66" class="headerlink" title="Enforcement"></a>Enforcement</h5><p>???</p>
<h3 id="C-4-Make-a-function-a-member-only-if-it-needs-direct-access-to-the-representation-of-a-class"><a href="#C-4-Make-a-function-a-member-only-if-it-needs-direct-access-to-the-representation-of-a-class" class="headerlink" title="C.4: Make a function a member only if it needs direct access to the representation of a class"></a><a name="Rc-member"></a>C.4: Make a function a member only if it needs direct access to the representation of a class</h3><h5 id="Reason-72"><a href="#Reason-72" class="headerlink" title="Reason"></a>Reason</h5><p>Less coupling than with member functions, fewer functions that can cause trouble by modifying object state, reduces the number of functions that needs to be modified after a change in representation.</p>
<h5 id="Example-69"><a href="#Example-69" class="headerlink" title="Example"></a>Example</h5><pre><code>class Date &#123;
    // ... relatively small interface ...
&#125;;

// helper functions:
Date next_weekday(Date);
bool operator==(Date, Date);
</code></pre>
<p>The “helper functions” have no need for direct access to the representation of a <code>Date</code>.</p>
<h5 id="Note-87"><a href="#Note-87" class="headerlink" title="Note"></a>Note</h5><p>This rule becomes even better if C++ gets <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/p0251r0.pdf">“uniform function call”</a>.</p>
<h5 id="Exception-14"><a href="#Exception-14" class="headerlink" title="Exception"></a>Exception</h5><p>The language requires <code>virtual</code> functions to be members, and not all <code>virtual</code> functions directly access data.<br>In particular, members of an abstract class rarely do.</p>
<p>Note <a href="https://parasol.tamu.edu/~yuriys/papers/OMM10.pdf">multi-methods</a>.</p>
<h5 id="Exception-15"><a href="#Exception-15" class="headerlink" title="Exception"></a>Exception</h5><p>The language requires operators <code>=</code>, <code>()</code>, <code>[]</code>, and <code>-&gt;</code> to be members.</p>
<h5 id="Exception-16"><a href="#Exception-16" class="headerlink" title="Exception"></a>Exception</h5><p>An overload set may have some members that do not directly access <code>private</code> data:</p>
<pre><code>class Foobar &#123;
public:
    void foo(long x)    &#123; /* manipulate private data */ &#125;
    void foo(double x) &#123; foo(std::lround(x)); &#125;
    // ...
private:
    // ...
&#125;;
</code></pre>
<p>Similarly, a set of functions may be designed to be used in a chain:</p>
<pre><code>x.scale(0.5).rotate(45).set_color(Color::red);
</code></pre>
<p>Typically, some but not all of such functions directly access <code>private</code> data.</p>
<h5 id="Enforcement-67"><a href="#Enforcement-67" class="headerlink" title="Enforcement"></a>Enforcement</h5><ul>
<li>Look for non-<code>virtual</code> member functions that do not touch data members directly.<br>The snag is that many member functions that do not need to touch data members directly do.</li>
<li>Ignore <code>virtual</code> functions.</li>
<li>Ignore functions that are part of an overload set out of which at least one function accesses <code>private</code> members.</li>
<li>Ignore functions returning <code>this</code>.</li>
</ul>
<h3 id="C-5-Place-helper-functions-in-the-same-namespace-as-the-class-they-support"><a href="#C-5-Place-helper-functions-in-the-same-namespace-as-the-class-they-support" class="headerlink" title="C.5: Place helper functions in the same namespace as the class they support"></a><a name="Rc-helper"></a>C.5: Place helper functions in the same namespace as the class they support</h3><h5 id="Reason-73"><a href="#Reason-73" class="headerlink" title="Reason"></a>Reason</h5><p>A helper function is a function (usually supplied by the writer of a class) that does not need direct access to the representation of the class, yet is seen as part of the useful interface to the class.<br>Placing them in the same namespace as the class makes their relationship to the class obvious and allows them to be found by argument dependent lookup.</p>
<h5 id="Example-70"><a href="#Example-70" class="headerlink" title="Example"></a>Example</h5><pre><code>namespace Chrono &#123; // here we keep time-related services

    class Time &#123; /* ... */ &#125;;
    class Date &#123; /* ... */ &#125;;

    // helper functions:
    bool operator==(Date, Date);
    Date next_weekday(Date);
    // ...
&#125;
</code></pre>
<h5 id="Note-88"><a href="#Note-88" class="headerlink" title="Note"></a>Note</h5><p>This is especially important for <a href="#Ro-namespace">overloaded operators</a>.</p>
<h5 id="Enforcement-68"><a href="#Enforcement-68" class="headerlink" title="Enforcement"></a>Enforcement</h5><ul>
<li>Flag global functions taking argument types from a single namespace.</li>
</ul>
<h3 id="C-7-Don’t-define-a-class-or-enum-and-declare-a-variable-of-its-type-in-the-same-statement"><a href="#C-7-Don’t-define-a-class-or-enum-and-declare-a-variable-of-its-type-in-the-same-statement" class="headerlink" title="C.7: Don’t define a class or enum and declare a variable of its type in the same statement"></a><a name="Rc-standalone"></a>C.7: Don’t define a class or enum and declare a variable of its type in the same statement</h3><h5 id="Reason-74"><a href="#Reason-74" class="headerlink" title="Reason"></a>Reason</h5><p>Mixing a type definition and the definition of another entity in the same declaration is confusing and unnecessary.</p>
<h5 id="Example-bad-23"><a href="#Example-bad-23" class="headerlink" title="Example; bad"></a>Example; bad</h5><pre><code>struct Data &#123; /*...*/ &#125; data&#123; /*...*/ &#125;;
</code></pre>
<h5 id="Example-good-5"><a href="#Example-good-5" class="headerlink" title="Example; good"></a>Example; good</h5><pre><code>struct Data &#123; /*...*/ &#125;;
Data data&#123; /*...*/ &#125;;
</code></pre>
<h5 id="Enforcement-69"><a href="#Enforcement-69" class="headerlink" title="Enforcement"></a>Enforcement</h5><ul>
<li>Flag if the <code>&#125;</code> of a class or enumeration definition is not followed by a <code>;</code>. The <code>;</code> is missing.</li>
</ul>
<h3 id="C-8-Use-class-rather-than-struct-if-any-member-is-non-public"><a href="#C-8-Use-class-rather-than-struct-if-any-member-is-non-public" class="headerlink" title="C.8: Use class rather than struct if any member is non-public"></a><a name="Rc-class"></a>C.8: Use <code>class</code> rather than <code>struct</code> if any member is non-public</h3><h5 id="Reason-75"><a href="#Reason-75" class="headerlink" title="Reason"></a>Reason</h5><p>Readability.<br>To make it clear that something is being hidden/abstracted.<br>This is a useful convention.</p>
<h5 id="Example-bad-24"><a href="#Example-bad-24" class="headerlink" title="Example, bad"></a>Example, bad</h5><pre><code>struct Date &#123;
    int d, m;

    Date(int i, Month m);
    // ... lots of functions ...
private:
    int y;  // year
&#125;;
</code></pre>
<p>There is nothing wrong with this code as far as the C++ language rules are concerned,<br>but nearly everything is wrong from a design perspective.<br>The private data is hidden far from the public data.<br>The data is split in different parts of the class declaration.<br>Different parts of the data have different access.<br>All of this decreases readability and complicates maintenance.</p>
<h5 id="Note-89"><a href="#Note-89" class="headerlink" title="Note"></a>Note</h5><p>Prefer to place the interface first in a class, <a href="#Rl-order">see NL.16</a>.</p>
<h5 id="Enforcement-70"><a href="#Enforcement-70" class="headerlink" title="Enforcement"></a>Enforcement</h5><p>Flag classes declared with <code>struct</code> if there is a <code>private</code> or <code>protected</code> member.</p>
<h3 id="C-9-Minimize-exposure-of-members"><a href="#C-9-Minimize-exposure-of-members" class="headerlink" title="C.9: Minimize exposure of members"></a><a name="Rc-private"></a>C.9: Minimize exposure of members</h3><h5 id="Reason-76"><a href="#Reason-76" class="headerlink" title="Reason"></a>Reason</h5><p>Encapsulation.<br>Information hiding.<br>Minimize the chance of unintended access.<br>This simplifies maintenance.</p>
<h5 id="Example-71"><a href="#Example-71" class="headerlink" title="Example"></a>Example</h5><pre><code>template&lt;typename T, typename U&gt;
struct pair &#123;
    T a;
    U b;
    // ...
&#125;;
</code></pre>
<p>Whatever we do in the <code>//</code>-part, an arbitrary user of a <code>pair</code> can arbitrarily and independently change its <code>a</code> and <code>b</code>.<br>In a large code base, we cannot easily find which code does what to the members of <code>pair</code>.<br>This may be exactly what we want, but if we want to enforce a relation among members, we need to make them <code>private</code><br>and enforce that relation (invariant) through constructors and member functions.<br>For example:</p>
<pre><code>class Distance &#123;
public:
    // ...
    double meters() const &#123; return magnitude*unit; &#125;
    void set_unit(double u)
    &#123;
            // ... check that u is a factor of 10 ...
            // ... change magnitude appropriately ...
            unit = u;
    &#125;
    // ...
private:
    double magnitude;
    double unit;    // 1 is meters, 1000 is kilometers, 0.001 is millimeters, etc.
&#125;;
</code></pre>
<h5 id="Note-90"><a href="#Note-90" class="headerlink" title="Note"></a>Note</h5><p>If the set of direct users of a set of variables cannot be easily determined, the type or usage of that set cannot be (easily) changed/improved.<br>For <code>public</code> and <code>protected</code> data, that’s usually the case.</p>
<h5 id="Example-72"><a href="#Example-72" class="headerlink" title="Example"></a>Example</h5><p>A class can provide two interfaces to its users.<br>One for derived classes (<code>protected</code>) and one for general users (<code>public</code>).<br>For example, a derived class might be allowed to skip a run-time check because it has already guaranteed correctness:</p>
<pre><code>class Foo &#123;
public:
    int bar(int x) &#123; check(x); return do_bar(x); &#125;
    // ...
protected:
    int do_bar(int x); // do some operation on the data
    // ...
private:
    // ... data ...
&#125;;

class Dir : public Foo &#123;
    //...
    int mem(int x, int y)
    &#123;
        /* ... do something ... */
        return do_bar(x + y); // OK: derived class can bypass check
    &#125;
&#125;;

void user(Foo&amp; x)
&#123;
    int r1 = x.bar(1);      // OK, will check
    int r2 = x.do_bar(2);   // error: would bypass check
    // ...
&#125;
</code></pre>
<h5 id="Note-91"><a href="#Note-91" class="headerlink" title="Note"></a>Note</h5><p><a href="#Rh-protected"><code>protected</code> data is a bad idea</a>.</p>
<h5 id="Note-92"><a href="#Note-92" class="headerlink" title="Note"></a>Note</h5><p>Prefer the order <code>public</code> members before <code>protected</code> members before <code>private</code> members <a href="#Rl-order">see</a>.</p>
<h5 id="Enforcement-71"><a href="#Enforcement-71" class="headerlink" title="Enforcement"></a>Enforcement</h5><ul>
<li><a href="#Rh-protected">Flag protected data</a>.</li>
<li>Flag mixtures of <code>public</code> and private <code>data</code></li>
</ul>
<h2 id="C-concrete-Concrete-types"><a href="#C-concrete-Concrete-types" class="headerlink" title="C.concrete: Concrete types"></a><a name="SS-concrete"></a>C.concrete: Concrete types</h2><p>One ideal for a class is to be a regular type.<br>That means roughly “behaves like an <code>int</code>.” A concrete type is the simplest kind of class.<br>A value of regular type can be copied and the result of a copy is an independent object with the same value as the original.<br>If a concrete type has both <code>=</code> and <code>==</code>, <code>a = b</code> should result in <code>a == b</code> being <code>true</code>.<br>Concrete classes without assignment and equality can be defined, but they are (and should be) rare.<br>The C++ built-in types are regular, and so are standard-library classes, such as <code>string</code>, <code>vector</code>, and <code>map</code>.<br>Concrete types are also often referred to as value types to distinguish them from types used as part of a hierarchy.</p>
<p>Concrete type rule summary:</p>
<ul>
<li><a href="#Rc-concrete">C.10: Prefer concrete types over class hierarchies</a></li>
<li><a href="#Rc-regular">C.11: Make concrete types regular</a></li>
</ul>
<h3 id="C-10-Prefer-concrete-types-over-class-hierarchies"><a href="#C-10-Prefer-concrete-types-over-class-hierarchies" class="headerlink" title="C.10: Prefer concrete types over class hierarchies"></a><a name="Rc-concrete"></a>C.10: Prefer concrete types over class hierarchies</h3><h5 id="Reason-77"><a href="#Reason-77" class="headerlink" title="Reason"></a>Reason</h5><p>A concrete type is fundamentally simpler than a hierarchy:<br>easier to design, easier to implement, easier to use, easier to reason about, smaller, and faster.<br>You need a reason (use cases) for using a hierarchy.</p>
<h5 id="Example-73"><a href="#Example-73" class="headerlink" title="Example"></a>Example</h5><pre><code>class Point1 &#123;
    int x, y;
    // ... operations ...
    // ... no virtual functions ...
&#125;;

class Point2 &#123;
    int x, y;
    // ... operations, some virtual ...
    virtual ~Point2();
&#125;;

void use()
&#123;
    Point1 p11 &#123;1, 2&#125;;   // make an object on the stack
    Point1 p12 &#123;p11&#125;;    // a copy

    auto p21 = make_unique&lt;Point2&gt;(1, 2);   // make an object on the free store
    auto p22 = p21.clone();                 // make a copy
    // ...
&#125;
</code></pre>
<p>If a class can be part of a hierarchy, we (in real code if not necessarily in small examples) must manipulate its objects through pointers or references.<br>That implies more memory overhead, more allocations and deallocations, and more run-time overhead to perform the resulting indirections.</p>
<h5 id="Note-93"><a href="#Note-93" class="headerlink" title="Note"></a>Note</h5><p>Concrete types can be stack-allocated and be members of other classes.</p>
<h5 id="Note-94"><a href="#Note-94" class="headerlink" title="Note"></a>Note</h5><p>The use of indirection is fundamental for run-time polymorphic interfaces.<br>The allocation/deallocation overhead is not (that’s just the most common case).<br>We can use a base class as the interface of a scoped object of a derived class.<br>This is done where dynamic allocation is prohibited (e.g. hard-real-time) and to provide a stable interface to some kinds of plug-ins.</p>
<h5 id="Enforcement-72"><a href="#Enforcement-72" class="headerlink" title="Enforcement"></a>Enforcement</h5><p>???</p>
<h3 id="C-11-Make-concrete-types-regular"><a href="#C-11-Make-concrete-types-regular" class="headerlink" title="C.11: Make concrete types regular"></a><a name="Rc-regular"></a>C.11: Make concrete types regular</h3><h5 id="Reason-78"><a href="#Reason-78" class="headerlink" title="Reason"></a>Reason</h5><p>Regular types are easier to understand and reason about than types that are not regular (irregularities requires extra effort to understand and use).</p>
<h5 id="Example-74"><a href="#Example-74" class="headerlink" title="Example"></a>Example</h5><pre><code>struct Bundle &#123;
    string name;
    vector&lt;Record&gt; vr;
&#125;;

bool operator==(const Bundle&amp; a, const Bundle&amp; b)
&#123;
    return a.name == b.name &amp;&amp; a.vr == b.vr;
&#125;

Bundle b1 &#123; &quot;my bundle&quot;, &#123;r1, r2, r3&#125;&#125;;
Bundle b2 = b1;
if (!(b1 == b2)) error(&quot;impossible!&quot;);
b2.name = &quot;the other bundle&quot;;
if (b1 == b2) error(&quot;No!&quot;);
</code></pre>
<p>In particular, if a concrete type has an assignment also give it an equals operator so that <code>a = b</code> implies <code>a == b</code>.</p>
<h5 id="Enforcement-73"><a href="#Enforcement-73" class="headerlink" title="Enforcement"></a>Enforcement</h5><p>???</p>
<h2 id="C-ctor-Constructors-assignments-and-destructors"><a href="#C-ctor-Constructors-assignments-and-destructors" class="headerlink" title="C.ctor: Constructors, assignments, and destructors"></a><a name="S-ctor"></a>C.ctor: Constructors, assignments, and destructors</h2><p>These functions control the lifecycle of objects: creation, copy, move, and destruction.<br>Define constructors to guarantee and simplify initialization of classes.</p>
<p>These are <em>default operations</em>:</p>
<ul>
<li>a default constructor: <code>X()</code></li>
<li>a copy constructor: <code>X(const X&amp;)</code></li>
<li>a copy assignment: <code>operator=(const X&amp;)</code></li>
<li>a move constructor: <code>X(X&amp;&amp;)</code></li>
<li>a move assignment: <code>operator=(X&amp;&amp;)</code></li>
<li>a destructor: <code>~X()</code></li>
</ul>
<p>By default, the compiler defines each of these operations if it is used, but the default can be suppressed.</p>
<p>The default operations are a set of related operations that together implement the lifecycle semantics of an object.<br>By default, C++ treats classes as value-like types, but not all types are value-like.</p>
<p>Set of default operations rules:</p>
<ul>
<li><a href="#Rc-zero">C.20: If you can avoid defining any default operations, do</a></li>
<li><a href="#Rc-five">C.21: If you define or <code>=delete</code> any default operation, define or <code>=delete</code> them all</a></li>
<li><a href="#Rc-matched">C.22: Make default operations consistent</a></li>
</ul>
<p>Destructor rules:</p>
<ul>
<li><a href="#Rc-dtor">C.30: Define a destructor if a class needs an explicit action at object destruction</a></li>
<li><a href="#Rc-dtor-release">C.31: All resources acquired by a class must be released by the class’s destructor</a></li>
<li><a href="#Rc-dtor-ptr">C.32: If a class has a raw pointer (<code>T*</code>) or reference (<code>T&amp;</code>), consider whether it might be owning</a></li>
<li><a href="#Rc-dtor-ptr2">C.33: If a class has an owning pointer member, define or <code>=delete</code> a destructor</a></li>
<li><a href="#Rc-dtor-virtual">C.35: A base class with a virtual function needs a virtual destructor</a></li>
<li><a href="#Rc-dtor-fail">C.36: A destructor may not fail</a></li>
<li><a href="#Rc-dtor-noexcept">C.37: Make destructors <code>noexcept</code></a></li>
</ul>
<p>Constructor rules:</p>
<ul>
<li><a href="#Rc-ctor">C.40: Define a constructor if a class has an invariant</a></li>
<li><a href="#Rc-complete">C.41: A constructor should create a fully initialized object</a></li>
<li><a href="#Rc-throw">C.42: If a constructor cannot construct a valid object, throw an exception</a></li>
<li><a href="#Rc-default0">C.43: Ensure that a copyable (value type) class has a default constructor</a></li>
<li><a href="#Rc-default00">C.44: Prefer default constructors to be simple and non-throwing</a></li>
<li><a href="#Rc-default">C.45: Don’t define a default constructor that only initializes data members; use member initializers instead</a></li>
<li><a href="#Rc-explicit">C.46: By default, declare single-argument constructors <code>explicit</code></a></li>
<li><a href="#Rc-order">C.47: Define and initialize member variables in the order of member declaration</a></li>
<li><a href="#Rc-in-class-initializer">C.48: Prefer in-class initializers to member initializers in constructors for constant initializers</a></li>
<li><a href="#Rc-initialize">C.49: Prefer initialization to assignment in constructors</a></li>
<li><a href="#Rc-factory">C.50: Use a factory function if you need “virtual behavior” during initialization</a></li>
<li><a href="#Rc-delegating">C.51: Use delegating constructors to represent common actions for all constructors of a class</a></li>
<li><a href="#Rc-inheriting">C.52: Use inheriting constructors to import constructors into a derived class that does not need further explicit initialization</a></li>
</ul>
<p>Copy and move rules:</p>
<ul>
<li><a href="#Rc-copy-assignment">C.60: Make copy assignment non-<code>virtual</code>, take the parameter by <code>const&amp;</code>, and return by non-<code>const&amp;</code></a></li>
<li><a href="#Rc-copy-semantic">C.61: A copy operation should copy</a></li>
<li><a href="#Rc-copy-self">C.62: Make copy assignment safe for self-assignment</a></li>
<li><a href="#Rc-move-assignment">C.63: Make move assignment non-<code>virtual</code>, take the parameter by <code>&amp;&amp;</code>, and return by non-<code>const&amp;</code></a></li>
<li><a href="#Rc-move-semantic">C.64: A move operation should move and leave its source in a valid state</a></li>
<li><a href="#Rc-move-self">C.65: Make move assignment safe for self-assignment</a></li>
<li><a href="#Rc-move-noexcept">C.66: Make move operations <code>noexcept</code></a></li>
<li><a href="#Rc-copy-virtual">C.67: A base class should suppress copying, and provide a virtual <code>clone</code> instead if “copying” is desired</a></li>
</ul>
<p>Other default operations rules:</p>
<ul>
<li><a href="#Rc-eqdefault">C.80: Use <code>=default</code> if you have to be explicit about using the default semantics</a></li>
<li><a href="#Rc-delete">C.81: Use <code>=delete</code> when you want to disable default behavior (without wanting an alternative)</a></li>
<li><a href="#Rc-ctor-virtual">C.82: Don’t call virtual functions in constructors and destructors</a></li>
<li><a href="#Rc-swap">C.83: For value-like types, consider providing a <code>noexcept</code> swap function</a></li>
<li><a href="#Rc-swap-fail">C.84: A <code>swap</code> may not fail</a></li>
<li><a href="#Rc-swap-noexcept">C.85: Make <code>swap</code> <code>noexcept</code></a></li>
<li><a href="#Rc-eq">C.86: Make <code>==</code> symmetric with respect of operand types and <code>noexcept</code></a></li>
<li><a href="#Rc-eq-base">C.87: Beware of <code>==</code> on base classes</a></li>
<li><a href="#Rc-hash">C.89: Make a <code>hash</code> <code>noexcept</code></a></li>
</ul>
<h2 id="C-defop-Default-Operations"><a href="#C-defop-Default-Operations" class="headerlink" title="C.defop: Default Operations"></a><a name="SS-defop"></a>C.defop: Default Operations</h2><p>By default, the language supplies the default operations with their default semantics.<br>However, a programmer can disable or replace these defaults.</p>
<h3 id="C-20-If-you-can-avoid-defining-default-operations-do"><a href="#C-20-If-you-can-avoid-defining-default-operations-do" class="headerlink" title="C.20: If you can avoid defining default operations, do"></a><a name="Rc-zero"></a>C.20: If you can avoid defining default operations, do</h3><h5 id="Reason-79"><a href="#Reason-79" class="headerlink" title="Reason"></a>Reason</h5><p>It’s the simplest and gives the cleanest semantics.</p>
<h5 id="Example-75"><a href="#Example-75" class="headerlink" title="Example"></a>Example</h5><pre><code>struct Named_map &#123;
public:
    // ... no default operations declared ...
private:
    string name;
    map&lt;int, int&gt; rep;
&#125;;

Named_map nm;        // default construct
Named_map nm2 &#123;nm&#125;;  // copy construct
</code></pre>
<p>Since <code>std::map</code> and <code>string</code> have all the special functions, no further work is needed.</p>
<h5 id="Note-95"><a href="#Note-95" class="headerlink" title="Note"></a>Note</h5><p>This is known as “the rule of zero”.</p>
<h5 id="Enforcement-74"><a href="#Enforcement-74" class="headerlink" title="Enforcement"></a>Enforcement</h5><p>(Not enforceable) While not enforceable, a good static analyzer can detect patterns that indicate a possible improvement to meet this rule.<br>For example, a class with a (pointer, size) pair of member and a destructor that <code>delete</code>s the pointer could probably be converted to a <code>vector</code>.</p>
<h3 id="C-21-If-you-define-or-delete-any-default-operation-define-or-delete-them-all"><a href="#C-21-If-you-define-or-delete-any-default-operation-define-or-delete-them-all" class="headerlink" title="C.21: If you define or =delete any default operation, define or =delete them all"></a><a name="Rc-five"></a>C.21: If you define or <code>=delete</code> any default operation, define or <code>=delete</code> them all</h3><h5 id="Reason-80"><a href="#Reason-80" class="headerlink" title="Reason"></a>Reason</h5><p>The <em>special member functions</em> are the default constructor, copy constructor,<br>copy assignment operator, move constructor, move assignment operator, and<br>destructor.</p>
<p>The semantics of the special functions are closely related, so if one needs to be declared, the odds are that others need consideration too.</p>
<p>Declaring any special member function except a default constructor,<br>even as <code>=default</code> or <code>=delete</code>, will suppress the implicit declaration<br>of a move constructor and move assignment operator.<br>Declaring a move constructor or move assignment operator, even as<br><code>=default</code> or <code>=delete</code>, will cause an implicitly generated copy constructor<br>or implicitly generated copy assignment operator to be defined as deleted.<br>So as soon as any of the special functions is declared, the others should<br>all be declared to avoid unwanted effects like turning all potential moves<br>into more expensive copies, or making a class move-only.</p>
<h5 id="Example-bad-25"><a href="#Example-bad-25" class="headerlink" title="Example, bad"></a>Example, bad</h5><pre><code>struct M2 &#123;   // bad: incomplete set of default operations
public:
    // ...
    // ... no copy or move operations ...
    ~M2() &#123; delete[] rep; &#125;
private:
    pair&lt;int, int&gt;* rep;  // zero-terminated set of pairs
&#125;;

void use()
&#123;
    M2 x;
    M2 y;
    // ...
    x = y;   // the default assignment
    // ...
&#125;
</code></pre>
<p>Given that “special attention” was needed for the destructor (here, to deallocate), the likelihood that copy and move assignment (both will implicitly destroy an object) are correct is low (here, we would get double deletion).</p>
<h5 id="Note-96"><a href="#Note-96" class="headerlink" title="Note"></a>Note</h5><p>This is known as “the rule of five” or “the rule of six”, depending on whether you count the default constructor.</p>
<h5 id="Note-97"><a href="#Note-97" class="headerlink" title="Note"></a>Note</h5><p>If you want a default implementation of a default operation (while defining another), write <code>=default</code> to show you’re doing so intentionally for that function.<br>If you don’t want a default operation, suppress it with <code>=delete</code>.</p>
<h5 id="Example-good-6"><a href="#Example-good-6" class="headerlink" title="Example, good"></a>Example, good</h5><p>When a destructor needs to be declared just to make it <code>virtual</code>, it can be<br>defined as defaulted. To avoid suppressing the implicit move operations<br>they must also be declared, and then to avoid the class becoming move-only<br>(and not copyable) the copy operations must be declared:</p>
<pre><code>class AbstractBase &#123;
public:
  virtual ~AbstractBase() = default;
  AbstractBase(const AbstractBase&amp;) = default;
  AbstractBase&amp; operator=(const AbstractBase&amp;) = default;
  AbstractBase(AbstractBase&amp;&amp;) = default;
  AbstractBase&amp; operator=(AbstractBase&amp;&amp;) = default;
&#125;;
</code></pre>
<p>Alternatively to prevent slicing as per <a href="#Rc-copy-virtual">C.67</a>,<br>the copy and move operations can all be deleted:</p>
<pre><code>class ClonableBase &#123;
public:
  virtual unique_ptr&lt;ClonableBase&gt; clone() const;
  virtual ~ClonableBase() = default;
  ClonableBase(const ClonableBase&amp;) = delete;
  ClonableBase&amp; operator=(const ClonableBase&amp;) = delete;
  ClonableBase(ClonableBase&amp;&amp;) = delete;
  ClonableBase&amp; operator=(ClonableBase&amp;&amp;) = delete;
&#125;;
</code></pre>
<p>Defining only the move operations or only the copy operations would have the<br>same effect here, but stating the intent explicitly for each special member<br>makes it more obvious to the reader.</p>
<h5 id="Note-98"><a href="#Note-98" class="headerlink" title="Note"></a>Note</h5><p>Compilers enforce much of this rule and ideally warn about any violation.</p>
<h5 id="Note-99"><a href="#Note-99" class="headerlink" title="Note"></a>Note</h5><p>Relying on an implicitly generated copy operation in a class with a destructor is deprecated.</p>
<h5 id="Enforcement-75"><a href="#Enforcement-75" class="headerlink" title="Enforcement"></a>Enforcement</h5><p>(Simple) A class should have a declaration (even a <code>=delete</code> one) for either all or none of the special functions.</p>
<h3 id="C-22-Make-default-operations-consistent"><a href="#C-22-Make-default-operations-consistent" class="headerlink" title="C.22: Make default operations consistent"></a><a name="Rc-matched"></a>C.22: Make default operations consistent</h3><h5 id="Reason-81"><a href="#Reason-81" class="headerlink" title="Reason"></a>Reason</h5><p>The default operations are conceptually a matched set. Their semantics are interrelated.<br>Users will be surprised if copy/move construction and copy/move assignment do logically different things. Users will be surprised if constructors and destructors do not provide a consistent view of resource management. Users will be surprised if copy and move don’t reflect the way constructors and destructors work.</p>
<h5 id="Example-bad-26"><a href="#Example-bad-26" class="headerlink" title="Example, bad"></a>Example, bad</h5><pre><code>class Silly &#123;   // BAD: Inconsistent copy operations
    class Impl &#123;
        // ...
    &#125;;
    shared_ptr&lt;Impl&gt; p;
public:
    Silly(const Silly&amp; a) : p&#123;a.p&#125; &#123; *p = *a.p; &#125;   // deep copy
    Silly&amp; operator=(const Silly&amp; a) &#123; p = a.p; &#125;   // shallow copy
    // ...
&#125;;
</code></pre>
<p>These operations disagree about copy semantics. This will lead to confusion and bugs.</p>
<h5 id="Enforcement-76"><a href="#Enforcement-76" class="headerlink" title="Enforcement"></a>Enforcement</h5><ul>
<li>(Complex) A copy/move constructor and the corresponding copy/move assignment operator should write to the same member variables at the same level of dereference.</li>
<li>(Complex) Any member variables written in a copy/move constructor should also be initialized by all other constructors.</li>
<li>(Complex) If a copy/move constructor performs a deep copy of a member variable, then the destructor should modify the member variable.</li>
<li>(Complex) If a destructor is modifying a member variable, that member variable should be written in any copy/move constructors or assignment operators.</li>
</ul>
<h2 id="C-dtor-Destructors"><a href="#C-dtor-Destructors" class="headerlink" title="C.dtor: Destructors"></a><a name="SS-dtor"></a>C.dtor: Destructors</h2><p>“Does this class need a destructor?” is a surprisingly powerful design question.<br>For most classes the answer is “no” either because the class holds no resources or because destruction is handled by <a href="#Rc-zero">the rule of zero</a>;<br>that is, its members can take care of themselves as concerns destruction.<br>If the answer is “yes”, much of the design of the class follows (see <a href="#Rc-five">the rule of five</a>).</p>
<h3 id="C-30-Define-a-destructor-if-a-class-needs-an-explicit-action-at-object-destruction"><a href="#C-30-Define-a-destructor-if-a-class-needs-an-explicit-action-at-object-destruction" class="headerlink" title="C.30: Define a destructor if a class needs an explicit action at object destruction"></a><a name="Rc-dtor"></a>C.30: Define a destructor if a class needs an explicit action at object destruction</h3><h5 id="Reason-82"><a href="#Reason-82" class="headerlink" title="Reason"></a>Reason</h5><p>A destructor is implicitly invoked at the end of an object’s lifetime.<br>If the default destructor is sufficient, use it.<br>Only define a non-default destructor if a class needs to execute code that is not already part of its members’ destructors.</p>
<h5 id="Example-76"><a href="#Example-76" class="headerlink" title="Example"></a>Example</h5><pre><code>template&lt;typename A&gt;
struct final_action &#123;   // slightly simplified
    A act;
    final_action(A a) :act&#123;a&#125; &#123;&#125;
    ~final_action() &#123; act(); &#125;
&#125;;

template&lt;typename A&gt;
final_action&lt;A&gt; finally(A act)   // deduce action type
&#123;
    return final_action&lt;A&gt;&#123;act&#125;;
&#125;

void test()
&#123;
    auto act = finally([]&#123; cout &lt;&lt; &quot;Exit test\n&quot;; &#125;);  // establish exit action
    // ...
    if (something) return;   // act done here
    // ...
&#125; // act done here
</code></pre>
<p>The whole purpose of <code>final_action</code> is to get a piece of code (usually a lambda) executed upon destruction.</p>
<h5 id="Note-100"><a href="#Note-100" class="headerlink" title="Note"></a>Note</h5><p>There are two general categories of classes that need a user-defined destructor:</p>
<ul>
<li>A class with a resource that is not already represented as a class with a destructor, e.g., a <code>vector</code> or a transaction class.</li>
<li>A class that exists primarily to execute an action upon destruction, such as a tracer or <code>final_action</code>.</li>
</ul>
<h5 id="Example-bad-27"><a href="#Example-bad-27" class="headerlink" title="Example, bad"></a>Example, bad</h5><pre><code>class Foo &#123;   // bad; use the default destructor
public:
    // ...
    ~Foo() &#123; s = &quot;&quot;; i = 0; vi.clear(); &#125;  // clean up
private:
    string s;
    int i;
    vector&lt;int&gt; vi;
&#125;;
</code></pre>
<p>The default destructor does it better, more efficiently, and can’t get it wrong.</p>
<h5 id="Note-101"><a href="#Note-101" class="headerlink" title="Note"></a>Note</h5><p>If the default destructor is needed, but its generation has been suppressed (e.g., by defining a move constructor), use <code>=default</code>.</p>
<h5 id="Enforcement-77"><a href="#Enforcement-77" class="headerlink" title="Enforcement"></a>Enforcement</h5><p>Look for likely “implicit resources”, such as pointers and references. Look for classes with destructors even though all their data members have destructors.</p>
<h3 id="C-31-All-resources-acquired-by-a-class-must-be-released-by-the-class’s-destructor"><a href="#C-31-All-resources-acquired-by-a-class-must-be-released-by-the-class’s-destructor" class="headerlink" title="C.31: All resources acquired by a class must be released by the class’s destructor"></a><a name="Rc-dtor-release"></a>C.31: All resources acquired by a class must be released by the class’s destructor</h3><h5 id="Reason-83"><a href="#Reason-83" class="headerlink" title="Reason"></a>Reason</h5><p>Prevention of resource leaks, especially in error cases.</p>
<h5 id="Note-102"><a href="#Note-102" class="headerlink" title="Note"></a>Note</h5><p>For resources represented as classes with a complete set of default operations, this happens automatically.</p>
<h5 id="Example-77"><a href="#Example-77" class="headerlink" title="Example"></a>Example</h5><pre><code>class X &#123;
    ifstream f;   // may own a file
    // ... no default operations defined or =deleted ...
&#125;;
</code></pre>
<p><code>X</code>‘s <code>ifstream</code> implicitly closes any file it may have open upon destruction of its <code>X</code>.</p>
<h5 id="Example-bad-28"><a href="#Example-bad-28" class="headerlink" title="Example, bad"></a>Example, bad</h5><pre><code>class X2 &#123;     // bad
    FILE* f;   // may own a file
    // ... no default operations defined or =deleted ...
&#125;;
</code></pre>
<p><code>X2</code> may leak a file handle.</p>
<h5 id="Note-103"><a href="#Note-103" class="headerlink" title="Note"></a>Note</h5><p>What about a sockets that won’t close? A destructor, close, or cleanup operation <a href="#Rc-dtor-fail">should never fail</a>.<br>If it does nevertheless, we have a problem that has no really good solution.<br>For starters, the writer of a destructor does not know why the destructor is called and cannot “refuse to act” by throwing an exception.<br>See <a href="#Sd-never-fail">discussion</a>.<br>To make the problem worse, many “close/release” operations are not retryable.<br>Many have tried to solve this problem, but no general solution is known.<br>If at all possible, consider failure to close/cleanup a fundamental design error and terminate.</p>
<h5 id="Note-104"><a href="#Note-104" class="headerlink" title="Note"></a>Note</h5><p>A class can hold pointers and references to objects that it does not own.<br>Obviously, such objects should not be <code>delete</code>d by the class’s destructor.<br>For example:</p>
<pre><code>Preprocessor pp &#123; /* ... */ &#125;;
Parser p &#123; pp, /* ... */ &#125;;
Type_checker tc &#123; p, /* ... */ &#125;;
</code></pre>
<p>Here <code>p</code> refers to <code>pp</code> but does not own it.</p>
<h5 id="Enforcement-78"><a href="#Enforcement-78" class="headerlink" title="Enforcement"></a>Enforcement</h5><ul>
<li>(Simple) If a class has pointer or reference member variables that are owners<br>(e.g., deemed owners by using <code>gsl::owner</code>), then they should be referenced in its destructor.</li>
<li>(Hard) Determine if pointer or reference member variables are owners when there is no explicit statement of ownership<br>(e.g., look into the constructors).</li>
</ul>
<h3 id="C-32-If-a-class-has-a-raw-pointer-T-or-reference-T-amp-consider-whether-it-might-be-owning"><a href="#C-32-If-a-class-has-a-raw-pointer-T-or-reference-T-amp-consider-whether-it-might-be-owning" class="headerlink" title="C.32: If a class has a raw pointer (T*) or reference (T&amp;), consider whether it might be owning"></a><a name="Rc-dtor-ptr"></a>C.32: If a class has a raw pointer (<code>T*</code>) or reference (<code>T&amp;</code>), consider whether it might be owning</h3><h5 id="Reason-84"><a href="#Reason-84" class="headerlink" title="Reason"></a>Reason</h5><p>There is a lot of code that is non-specific about ownership.</p>
<h5 id="Example-78"><a href="#Example-78" class="headerlink" title="Example"></a>Example</h5><pre><code>???
</code></pre>
<h5 id="Note-105"><a href="#Note-105" class="headerlink" title="Note"></a>Note</h5><p>If the <code>T*</code> or <code>T&amp;</code> is owning, mark it <code>owning</code>. If the <code>T*</code> is not owning, consider marking it <code>ptr</code>.<br>This will aid documentation and analysis.</p>
<h5 id="Enforcement-79"><a href="#Enforcement-79" class="headerlink" title="Enforcement"></a>Enforcement</h5><p>Look at the initialization of raw member pointers and member references and see if an allocation is used.</p>
<h3 id="C-33-If-a-class-has-an-owning-pointer-member-define-a-destructor"><a href="#C-33-If-a-class-has-an-owning-pointer-member-define-a-destructor" class="headerlink" title="C.33: If a class has an owning pointer member, define a destructor"></a><a name="Rc-dtor-ptr2"></a>C.33: If a class has an owning pointer member, define a destructor</h3><h5 id="Reason-85"><a href="#Reason-85" class="headerlink" title="Reason"></a>Reason</h5><p>An owned object must be <code>deleted</code> upon destruction of the object that owns it.</p>
<h5 id="Example-79"><a href="#Example-79" class="headerlink" title="Example"></a>Example</h5><p>A pointer member may represent a resource.<br><a href="#Rr-ptr">A <code>T*</code> should not do so</a>, but in older code, that’s common.<br>Consider a <code>T*</code> a possible owner and therefore suspect.</p>
<pre><code>template&lt;typename T&gt;
class Smart_ptr &#123;
    T* p;   // BAD: vague about ownership of *p
    // ...
public:
    // ... no user-defined default operations ...
&#125;;

void use(Smart_ptr&lt;int&gt; p1)
&#123;
    // error: p2.p leaked (if not nullptr and not owned by some other code)
    auto p2 = p1;
&#125;
</code></pre>
<p>Note that if you define a destructor, you must define or delete <a href="#Rc-five">all default operations</a>:</p>
<pre><code>template&lt;typename T&gt;
class Smart_ptr2 &#123;
    T* p;   // BAD: vague about ownership of *p
    // ...
public:
    // ... no user-defined copy operations ...
    ~Smart_ptr2() &#123; delete p; &#125;  // p is an owner!
&#125;;

void use(Smart_ptr2&lt;int&gt; p1)
&#123;
    auto p2 = p1;   // error: double deletion
&#125;
</code></pre>
<p>The default copy operation will just copy the <code>p1.p</code> into <code>p2.p</code> leading to a double destruction of <code>p1.p</code>. Be explicit about ownership:</p>
<pre><code>template&lt;typename T&gt;
class Smart_ptr3 &#123;
    owner&lt;T*&gt; p;   // OK: explicit about ownership of *p
    // ...
public:
    // ...
    // ... copy and move operations ...
    ~Smart_ptr3() &#123; delete p; &#125;
&#125;;

void use(Smart_ptr3&lt;int&gt; p1)
&#123;
    auto p2 = p1;   // error: double deletion
&#125;
</code></pre>
<h5 id="Note-106"><a href="#Note-106" class="headerlink" title="Note"></a>Note</h5><p>Often the simplest way to get a destructor is to replace the pointer with a smart pointer (e.g., <code>std::unique_ptr</code>) and let the compiler arrange for proper destruction to be done implicitly.</p>
<h5 id="Note-107"><a href="#Note-107" class="headerlink" title="Note"></a>Note</h5><p>Why not just require all owning pointers to be “smart pointers”?<br>That would sometimes require non-trivial code changes and may affect ABIs.</p>
<h5 id="Enforcement-80"><a href="#Enforcement-80" class="headerlink" title="Enforcement"></a>Enforcement</h5><ul>
<li>A class with a pointer data member is suspect.</li>
<li>A class with an <code>owner&lt;T&gt;</code> should define its default operations.</li>
</ul>
<h3 id="C-35-A-base-class-destructor-should-be-either-public-and-virtual-or-protected-and-nonvirtual"><a href="#C-35-A-base-class-destructor-should-be-either-public-and-virtual-or-protected-and-nonvirtual" class="headerlink" title="C.35: A base class destructor should be either public and virtual, or protected and nonvirtual"></a><a name="Rc-dtor-virtual"></a>C.35: A base class destructor should be either public and virtual, or protected and nonvirtual</h3><h5 id="Reason-86"><a href="#Reason-86" class="headerlink" title="Reason"></a>Reason</h5><p>To prevent undefined behavior.<br>If the destructor is public, then calling code can attempt to destroy a derived class object through a base class pointer, and the result is undefined if the base class’s destructor is non-virtual.<br>If the destructor is protected, then calling code cannot destroy through a base class pointer and the destructor does not need to be virtual; it does need to be protected, not private, so that derived destructors can invoke it.<br>In general, the writer of a base class does not know the appropriate action to be done upon destruction.</p>
<h5 id="Discussion-2"><a href="#Discussion-2" class="headerlink" title="Discussion"></a>Discussion</h5><p>See <a href="#Sd-dtor">this in the Discussion section</a>.</p>
<h5 id="Example-bad-29"><a href="#Example-bad-29" class="headerlink" title="Example, bad"></a>Example, bad</h5><pre><code>struct Base &#123;  // BAD: no virtual destructor
    virtual void f();
&#125;;

struct D : Base &#123;
    string s &#123;&quot;a resource needing cleanup&quot;&#125;;
    ~D() &#123; /* ... do some cleanup ... */ &#125;
    // ...
&#125;;

void use()
&#123;
    unique_ptr&lt;Base&gt; p = make_unique&lt;D&gt;();
    // ...
&#125; // p&#39;s destruction calls ~Base(), not ~D(), which leaks D::s and possibly more
</code></pre>
<h5 id="Note-108"><a href="#Note-108" class="headerlink" title="Note"></a>Note</h5><p>A virtual function defines an interface to derived classes that can be used without looking at the derived classes.<br>If the interface allows destroying, it should be safe to do so.</p>
<h5 id="Note-109"><a href="#Note-109" class="headerlink" title="Note"></a>Note</h5><p>A destructor must be nonprivate or it will prevent using the type :</p>
<pre><code>class X &#123;
    ~X();   // private destructor
    // ...
&#125;;

void use()
&#123;
    X a;                        // error: cannot destroy
    auto p = make_unique&lt;X&gt;();  // error: cannot destroy
&#125;
</code></pre>
<h5 id="Exception-17"><a href="#Exception-17" class="headerlink" title="Exception"></a>Exception</h5><p>We can imagine one case where you could want a protected virtual destructor: When an object of a derived type (and only of such a type) should be allowed to destroy <em>another</em> object (not itself) through a pointer to base. We haven’t seen such a case in practice, though.</p>
<h5 id="Enforcement-81"><a href="#Enforcement-81" class="headerlink" title="Enforcement"></a>Enforcement</h5><ul>
<li>A class with any virtual functions should have a destructor that is either public and virtual or else protected and nonvirtual.</li>
</ul>
<h3 id="C-36-A-destructor-may-not-fail"><a href="#C-36-A-destructor-may-not-fail" class="headerlink" title="C.36: A destructor may not fail"></a><a name="Rc-dtor-fail"></a>C.36: A destructor may not fail</h3><h5 id="Reason-87"><a href="#Reason-87" class="headerlink" title="Reason"></a>Reason</h5><p>In general we do not know how to write error-free code if a destructor should fail.<br>The standard library requires that all classes it deals with have destructors that do not exit by throwing.</p>
<h5 id="Example-80"><a href="#Example-80" class="headerlink" title="Example"></a>Example</h5><pre><code>class X &#123;
public:
    ~X() noexcept;
    // ...
&#125;;

X::~X() noexcept
&#123;
    // ...
    if (cannot_release_a_resource) terminate();
    // ...
&#125;
</code></pre>
<h5 id="Note-110"><a href="#Note-110" class="headerlink" title="Note"></a>Note</h5><p>Many have tried to devise a fool-proof scheme for dealing with failure in destructors.<br>None have succeeded to come up with a general scheme.<br>This can be a real practical problem: For example, what about a socket that won’t close?<br>The writer of a destructor does not know why the destructor is called and cannot “refuse to act” by throwing an exception.<br>See <a href="#Sd-dtor">discussion</a>.<br>To make the problem worse, many “close/release” operations are not retryable.<br>If at all possible, consider failure to close/cleanup a fundamental design error and terminate.</p>
<h5 id="Note-111"><a href="#Note-111" class="headerlink" title="Note"></a>Note</h5><p>Declare a destructor <code>noexcept</code>. That will ensure that it either completes normally or terminate the program.</p>
<h5 id="Note-112"><a href="#Note-112" class="headerlink" title="Note"></a>Note</h5><p>If a resource cannot be released and the program may not fail, try to signal the failure to the rest of the system somehow<br>(maybe even by modifying some global state and hope something will notice and be able to take care of the problem).<br>Be fully aware that this technique is special-purpose and error-prone.<br>Consider the “my connection will not close” example.<br>Probably there is a problem at the other end of the connection and only a piece of code responsible for both ends of the connection can properly handle the problem.<br>The destructor could send a message (somehow) to the responsible part of the system, consider that to have closed the connection, and return normally.</p>
<h5 id="Note-113"><a href="#Note-113" class="headerlink" title="Note"></a>Note</h5><p>If a destructor uses operations that may fail, it can catch exceptions and in some cases still complete successfully<br>(e.g., by using a different clean-up mechanism from the one that threw an exception).</p>
<h5 id="Enforcement-82"><a href="#Enforcement-82" class="headerlink" title="Enforcement"></a>Enforcement</h5><p>(Simple) A destructor should be declared <code>noexcept</code> if it could throw.</p>
<h3 id="C-37-Make-destructors-noexcept"><a href="#C-37-Make-destructors-noexcept" class="headerlink" title="C.37: Make destructors noexcept"></a><a name="Rc-dtor-noexcept"></a>C.37: Make destructors <code>noexcept</code></h3><h5 id="Reason-88"><a href="#Reason-88" class="headerlink" title="Reason"></a>Reason</h5><p> <a href="#Rc-dtor-fail">A destructor may not fail</a>. If a destructor tries to exit with an exception, it’s a bad design error and the program had better terminate.</p>
<h5 id="Note-114"><a href="#Note-114" class="headerlink" title="Note"></a>Note</h5><p>A destructor (either user-defined or compiler-generated) is implicitly declared <code>noexcept</code> (independently of what code is in its body) if all of the members of its class have <code>noexcept</code> destructors. By explicitly marking destructors <code>noexcept</code>, an author guards against the destructor becoming implicitly <code>noexcept(false)</code> through the addition or modification of a class member.</p>
<h5 id="Enforcement-83"><a href="#Enforcement-83" class="headerlink" title="Enforcement"></a>Enforcement</h5><p>(Simple) A destructor should be declared <code>noexcept</code> if it could throw.</p>
<h2 id="C-ctor-Constructors"><a href="#C-ctor-Constructors" class="headerlink" title="C.ctor: Constructors"></a><a name="SS-ctor"></a>C.ctor: Constructors</h2><p>A constructor defines how an object is initialized (constructed).</p>
<h3 id="C-40-Define-a-constructor-if-a-class-has-an-invariant"><a href="#C-40-Define-a-constructor-if-a-class-has-an-invariant" class="headerlink" title="C.40: Define a constructor if a class has an invariant"></a><a name="Rc-ctor"></a>C.40: Define a constructor if a class has an invariant</h3><h5 id="Reason-89"><a href="#Reason-89" class="headerlink" title="Reason"></a>Reason</h5><p>That’s what constructors are for.</p>
<h5 id="Example-81"><a href="#Example-81" class="headerlink" title="Example"></a>Example</h5><pre><code>class Date &#123;  // a Date represents a valid date
              // in the January 1, 1900 to December 31, 2100 range
    Date(int dd, int mm, int yy)
        :d&#123;dd&#125;, m&#123;mm&#125;, y&#123;yy&#125;
    &#123;
        if (!is_valid(d, m, y)) throw Bad_date&#123;&#125;;  // enforce invariant
    &#125;
    // ...
private:
    int d, m, y;
&#125;;
</code></pre>
<p>It is often a good idea to express the invariant as an <code>Ensures</code> on the constructor.</p>
<h5 id="Note-115"><a href="#Note-115" class="headerlink" title="Note"></a>Note</h5><p>A constructor can be used for convenience even if a class does not have an invariant. For example:</p>
<pre><code>struct Rec &#123;
    string s;
    int i &#123;0&#125;;
    Rec(const string&amp; ss) : s&#123;ss&#125; &#123;&#125;
    Rec(int ii) :i&#123;ii&#125; &#123;&#125;
&#125;;

Rec r1 &#123;7&#125;;
Rec r2 &#123;&quot;Foo bar&quot;&#125;;
</code></pre>
<h5 id="Note-116"><a href="#Note-116" class="headerlink" title="Note"></a>Note</h5><p>The C++11 initializer list rule eliminates the need for many constructors. For example:</p>
<pre><code>struct Rec2&#123;
    string s;
    int i;
    Rec2(const string&amp; ss, int ii = 0) :s&#123;ss&#125;, i&#123;ii&#125; &#123;&#125;   // redundant
&#125;;

Rec2 r1 &#123;&quot;Foo&quot;, 7&#125;;
Rec2 r2 &#123;&quot;Bar&quot;&#125;;
</code></pre>
<p>The <code>Rec2</code> constructor is redundant.<br>Also, the default for <code>int</code> would be better done as a <a href="#Rc-in-class-initializer">member initializer</a>.</p>
<p><strong>See also</strong>: <a href="#Rc-complete">construct valid object</a> and <a href="#Rc-throw">constructor throws</a>.</p>
<h5 id="Enforcement-84"><a href="#Enforcement-84" class="headerlink" title="Enforcement"></a>Enforcement</h5><ul>
<li>Flag classes with user-defined copy operations but no constructor (a user-defined copy is a good indicator that the class has an invariant)</li>
</ul>
<h3 id="C-41-A-constructor-should-create-a-fully-initialized-object"><a href="#C-41-A-constructor-should-create-a-fully-initialized-object" class="headerlink" title="C.41: A constructor should create a fully initialized object"></a><a name="Rc-complete"></a>C.41: A constructor should create a fully initialized object</h3><h5 id="Reason-90"><a href="#Reason-90" class="headerlink" title="Reason"></a>Reason</h5><p>A constructor establishes the invariant for a class. A user of a class should be able to assume that a constructed object is usable.</p>
<h5 id="Example-bad-30"><a href="#Example-bad-30" class="headerlink" title="Example, bad"></a>Example, bad</h5><pre><code>class X1 &#123;
    FILE* f;   // call init() before any other function
    // ...
public:
    X1() &#123;&#125;
    void init();   // initialize f
    void read();   // read from f
    // ...
&#125;;

void f()
&#123;
    X1 file;
    file.read();   // crash or bad read!
    // ...
    file.init();   // too late
    // ...
&#125;
</code></pre>
<p>Compilers do not read comments.</p>
<h5 id="Exception-18"><a href="#Exception-18" class="headerlink" title="Exception"></a>Exception</h5><p>If a valid object cannot conveniently be constructed by a constructor, <a href="#Rc-factory">use a factory function</a>.</p>
<h5 id="Enforcement-85"><a href="#Enforcement-85" class="headerlink" title="Enforcement"></a>Enforcement</h5><ul>
<li>(Simple) Every constructor should initialize every member variable (either explicitly, via a delegating ctor call or via default construction).</li>
<li>(Unknown) If a constructor has an <code>Ensures</code> contract, try to see if it holds as a postcondition.</li>
</ul>
<h5 id="Note-117"><a href="#Note-117" class="headerlink" title="Note"></a>Note</h5><p>If a constructor acquires a resource (to create a valid object), that resource should be <a href="#Rc-dtor-release">released by the destructor</a>.<br>The idiom of having constructors acquire resources and destructors release them is called <a href="#Rr-raii">RAII</a> (“Resource Acquisition Is Initialization”).</p>
<h3 id="C-42-If-a-constructor-cannot-construct-a-valid-object-throw-an-exception"><a href="#C-42-If-a-constructor-cannot-construct-a-valid-object-throw-an-exception" class="headerlink" title="C.42: If a constructor cannot construct a valid object, throw an exception"></a><a name="Rc-throw"></a>C.42: If a constructor cannot construct a valid object, throw an exception</h3><h5 id="Reason-91"><a href="#Reason-91" class="headerlink" title="Reason"></a>Reason</h5><p>Leaving behind an invalid object is asking for trouble.</p>
<h5 id="Example-82"><a href="#Example-82" class="headerlink" title="Example"></a>Example</h5><pre><code>class X2 &#123;
    FILE* f;
    // ...
public:
    X2(const string&amp; name)
        :f&#123;fopen(name.c_str(), &quot;r&quot;)&#125;
    &#123;
        if (!f) throw runtime_error&#123;&quot;could not open&quot; + name&#125;;
        // ...
    &#125;

    void read();      // read from f
    // ...
&#125;;

void f()
&#123;
    X2 file &#123;&quot;Zeno&quot;&#125;; // throws if file isn&#39;t open
    file.read();      // fine
    // ...
&#125;
</code></pre>
<h5 id="Example-bad-31"><a href="#Example-bad-31" class="headerlink" title="Example, bad"></a>Example, bad</h5><pre><code>class X3 &#123;     // bad: the constructor leaves a non-valid object behind
    FILE* f;   // call is_valid() before any other function
    bool valid;
    // ...
public:
    X3(const string&amp; name)
        :f&#123;fopen(name.c_str(), &quot;r&quot;)&#125;, valid&#123;false&#125;
    &#123;
        if (f) valid = true;
        // ...
    &#125;

    bool is_valid() &#123; return valid; &#125;
    void read();   // read from f
    // ...
&#125;;

void f()
&#123;
    X3 file &#123;&quot;Heraclides&quot;&#125;;
    file.read();   // crash or bad read!
    // ...
    if (file.is_valid()) &#123;
        file.read();
        // ...
    &#125;
    else &#123;
        // ... handle error ...
    &#125;
    // ...
&#125;
</code></pre>
<h5 id="Note-118"><a href="#Note-118" class="headerlink" title="Note"></a>Note</h5><p>For a variable definition (e.g., on the stack or as a member of another object) there is no explicit function call from which an error code could be returned.<br>Leaving behind an invalid object and relying on users to consistently check an <code>is_valid()</code> function before use is tedious, error-prone, and inefficient.</p>
<h5 id="Exception-19"><a href="#Exception-19" class="headerlink" title="Exception"></a>Exception</h5><p>There are domains, such as some hard-real-time systems (think airplane controls) where (without additional tool support) exception handling is not sufficiently predictable from a timing perspective.<br>There the <code>is_valid()</code> technique must be used. In such cases, check <code>is_valid()</code> consistently and immediately to simulate <a href="#Rr-raii">RAII</a>.</p>
<h5 id="Alternative-5"><a href="#Alternative-5" class="headerlink" title="Alternative"></a>Alternative</h5><p>If you feel tempted to use some “post-constructor initialization” or “two-stage initialization” idiom, try not to do that.<br>If you really have to, look at <a href="#Rc-factory">factory functions</a>.</p>
<h5 id="Note-119"><a href="#Note-119" class="headerlink" title="Note"></a>Note</h5><p>One reason people have used <code>init()</code> functions rather than doing the initialization work in a constructor has been to avoid code replication.<br><a href="#Rc-delegating">Delegating constructors</a> and <a href="#Rc-in-class-initializer">default member initialization</a> do that better.<br>Another reason has been to delay initialization until an object is needed; the solution to that is often <a href="#Res-init">not to declare a variable until it can be properly initialized</a></p>
<h5 id="Enforcement-86"><a href="#Enforcement-86" class="headerlink" title="Enforcement"></a>Enforcement</h5><p>???</p>
<h3 id="C-43-Ensure-that-a-copyable-value-type-class-has-a-default-constructor"><a href="#C-43-Ensure-that-a-copyable-value-type-class-has-a-default-constructor" class="headerlink" title="C.43: Ensure that a copyable (value type) class has a default constructor"></a><a name="Rc-default0"></a>C.43: Ensure that a copyable (value type) class has a default constructor</h3><h5 id="Reason-92"><a href="#Reason-92" class="headerlink" title="Reason"></a>Reason</h5><p>Many language and library facilities rely on default constructors to initialize their elements, e.g. <code>T a[10]</code> and <code>std::vector&lt;T&gt; v(10)</code>.<br>A default constructor often simplifies the task of defining a suitable <a href="#???">moved-from state</a> for a type that is also copyable.</p>
<h5 id="Note-120"><a href="#Note-120" class="headerlink" title="Note"></a>Note</h5><p>A <a href="#SS-concrete">value type</a> is a class that is copyable (and usually also comparable).<br>It is closely related to the notion of Regular type from <a href="http://elementsofprogramming.com/">EoP</a> and <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2012/n3351.pdf">the Palo Alto TR</a>.</p>
<h5 id="Example-83"><a href="#Example-83" class="headerlink" title="Example"></a>Example</h5><pre><code>class Date &#123; // BAD: no default constructor
public:
    Date(int dd, int mm, int yyyy);
    // ...
&#125;;

vector&lt;Date&gt; vd1(1000);   // default Date needed here
vector&lt;Date&gt; vd2(1000, Date&#123;Month::October, 7, 1885&#125;);   // alternative
</code></pre>
<p>The default constructor is only auto-generated if there is no user-declared constructor, hence it’s impossible to initialize the vector <code>vd1</code> in the example above.<br>The absence of a default value can cause surprises for users and complicate its use, so if one can be reasonably defined, it should be.</p>
<p><code>Date</code> is chosen to encourage thought:<br>There is no “natural” default date (the big bang is too far back in time to be useful for most people), so this example is non-trivial.<br><code>&#123;0, 0, 0&#125;</code> is not a valid date in most calendar systems, so choosing that would be introducing something like floating-point’s <code>NaN</code>.<br>However, most realistic <code>Date</code> classes have a “first date” (e.g. January 1, 1970 is popular), so making that the default is usually trivial.</p>
<pre><code>class Date &#123;
public:
    Date(int dd, int mm, int yyyy);
    Date() = default; // [See also](#Rc-default)
    // ...
private:
    int dd = 1;
    int mm = 1;
    int yyyy = 1970;
    // ...
&#125;;

vector&lt;Date&gt; vd1(1000);
</code></pre>
<h5 id="Note-121"><a href="#Note-121" class="headerlink" title="Note"></a>Note</h5><p>A class with members that all have default constructors implicitly gets a default constructor:</p>
<pre><code>struct X &#123;
    string s;
    vector&lt;int&gt; v;
&#125;;

X x; // means X&#123;&#123;&#125;, &#123;&#125;&#125;; that is the empty string and the empty vector
</code></pre>
<p>Beware that built-in types are not properly default constructed:</p>
<pre><code>struct X &#123;
    string s;
    int i;
&#125;;

void f()
&#123;
    X x;    // x.s is initialized to the empty string; x.i is uninitialized

    cout &lt;&lt; x.s &lt;&lt; &#39; &#39; &lt;&lt; x.i &lt;&lt; &#39;\n&#39;;
    ++x.i;
&#125;
</code></pre>
<p>Statically allocated objects of built-in types are by default initialized to <code>0</code>, but local built-in variables are not.<br>Beware that your compiler may default initialize local built-in variables, whereas an optimized build will not.<br>Thus, code like the example above may appear to work, but it relies on undefined behavior.<br>Assuming that you want initialization, an explicit default initialization can help:</p>
<pre><code>struct X &#123;
    string s;
    int i &#123;&#125;;   // default initialize (to 0)
&#125;;
</code></pre>
<h5 id="Notes-2"><a href="#Notes-2" class="headerlink" title="Notes"></a>Notes</h5><p>Classes that don’t have a reasonable default construction are usually not copyable either, so they don’t fall under this guideline.</p>
<p>For example, a base class is not a value type (base classes should not be copyable) and so does not necessarily need a default constructor:</p>
<pre><code>// Shape is an abstract base class, not a copyable value type.
// It may or may not need a default constructor.
struct Shape &#123;
    virtual void draw() = 0;
    virtual void rotate(int) = 0;
    // =delete copy/move functions
    // ...
&#125;;
</code></pre>
<p>A class that must acquire a caller-provided resource during construction often cannot have a default constructor, but it does not fall under this guideline because such a class is usually not copyable anyway:</p>
<pre><code>// std::lock_guard is not a copyable value type.
// It does not have a default constructor.
lock_guard g &#123;mx&#125;;  // guard the mutex mx
lock_guard g2;      // error: guarding nothing
</code></pre>
<p>A class that has a “special state” that must be handled separately from other states by member functions or users causes extra work<br>(and most likely more errors). Such a type can naturally use the special state as a default constructed value, whether or not it is copyable:</p>
<pre><code>// std::ofstream is not a copyable value type.
// It does happen to have a default constructor
// that goes along with a special &quot;not open&quot; state.
ofstream out &#123;&quot;Foobar&quot;&#125;;
// ...
out &lt;&lt; log(time, transaction);
</code></pre>
<p>Similar special-state types that are copyable, such as copyable smart pointers that have the special state “==nullptr”, should use the special state as their default constructed value.</p>
<p>However, it is preferable to have a default constructor default to a meaningful state such as <code>std::string</code>s <code>&quot;&quot;</code> and <code>std::vector</code>s <code>&#123;&#125;</code>.</p>
<h5 id="Enforcement-87"><a href="#Enforcement-87" class="headerlink" title="Enforcement"></a>Enforcement</h5><ul>
<li>Flag classes that are copyable by <code>=</code> without a default constructor</li>
<li>Flag classes that are comparable with <code>==</code> but not copyable</li>
</ul>
<h3 id="C-44-Prefer-default-constructors-to-be-simple-and-non-throwing"><a href="#C-44-Prefer-default-constructors-to-be-simple-and-non-throwing" class="headerlink" title="C.44: Prefer default constructors to be simple and non-throwing"></a><a name="Rc-default00"></a>C.44: Prefer default constructors to be simple and non-throwing</h3><h5 id="Reason-93"><a href="#Reason-93" class="headerlink" title="Reason"></a>Reason</h5><p>Being able to set a value to “the default” without operations that might fail simplifies error handling and reasoning about move operations.</p>
<h5 id="Example-problematic"><a href="#Example-problematic" class="headerlink" title="Example, problematic"></a>Example, problematic</h5><pre><code>template&lt;typename T&gt;
// elem points to space-elem element allocated using new
class Vector0 &#123;
public:
    Vector0() :Vector0&#123;0&#125; &#123;&#125;
    Vector0(int n) :elem&#123;new T[n]&#125;, space&#123;elem + n&#125;, last&#123;elem&#125; &#123;&#125;
    // ...
private:
    own&lt;T*&gt; elem;
    T* space;
    T* last;
&#125;;
</code></pre>
<p>This is nice and general, but setting a <code>Vector0</code> to empty after an error involves an allocation, which may fail.<br>Also, having a default <code>Vector</code> represented as <code>&#123;new T[0], 0, 0&#125;</code> seems wasteful.<br>For example, <code>Vector0&lt;int&gt; v[100]</code> costs 100 allocations.</p>
<h5 id="Example-84"><a href="#Example-84" class="headerlink" title="Example"></a>Example</h5><pre><code>template&lt;typename T&gt;
// elem is nullptr or elem points to space-elem element allocated using new
class Vector1 &#123;
public:
    // sets the representation to &#123;nullptr, nullptr, nullptr&#125;; doesn&#39;t throw
    Vector1() noexcept &#123;&#125;
    Vector1(int n) :elem&#123;new T[n]&#125;, space&#123;elem + n&#125;, last&#123;elem&#125; &#123;&#125;
    // ...
private:
    own&lt;T*&gt; elem = nullptr;
    T* space = nullptr;
    T* last = nullptr;
&#125;;
</code></pre>
<p>Using <code>&#123;nullptr, nullptr, nullptr&#125;</code> makes <code>Vector1&#123;&#125;</code> cheap, but a special case and implies run-time checks.<br>Setting a <code>Vector1</code> to empty after detecting an error is trivial.</p>
<h5 id="Enforcement-88"><a href="#Enforcement-88" class="headerlink" title="Enforcement"></a>Enforcement</h5><ul>
<li>Flag throwing default constructors</li>
</ul>
<h3 id="C-45-Don’t-define-a-default-constructor-that-only-initializes-data-members-use-in-class-member-initializers-instead"><a href="#C-45-Don’t-define-a-default-constructor-that-only-initializes-data-members-use-in-class-member-initializers-instead" class="headerlink" title="C.45: Don’t define a default constructor that only initializes data members; use in-class member initializers instead"></a><a name="Rc-default"></a>C.45: Don’t define a default constructor that only initializes data members; use in-class member initializers instead</h3><h5 id="Reason-94"><a href="#Reason-94" class="headerlink" title="Reason"></a>Reason</h5><p>Using in-class member initializers lets the compiler generate the function for you. The compiler-generated function can be more efficient.</p>
<h5 id="Example-bad-32"><a href="#Example-bad-32" class="headerlink" title="Example, bad"></a>Example, bad</h5><pre><code>class X1 &#123; // BAD: doesn&#39;t use member initializers
    string s;
    int i;
public:
    X1() :s&#123;&quot;default&quot;&#125;, i&#123;1&#125; &#123; &#125;
    // ...
&#125;;
</code></pre>
<h5 id="Example-85"><a href="#Example-85" class="headerlink" title="Example"></a>Example</h5><pre><code>class X2 &#123;
    string s = &quot;default&quot;;
    int i = 1;
public:
    // use compiler-generated default constructor
    // ...
&#125;;
</code></pre>
<h5 id="Enforcement-89"><a href="#Enforcement-89" class="headerlink" title="Enforcement"></a>Enforcement</h5><p>(Simple) A default constructor should do more than just initialize member variables with constants.</p>
<h3 id="C-46-By-default-declare-single-argument-constructors-explicit"><a href="#C-46-By-default-declare-single-argument-constructors-explicit" class="headerlink" title="C.46: By default, declare single-argument constructors explicit"></a><a name="Rc-explicit"></a>C.46: By default, declare single-argument constructors explicit</h3><h5 id="Reason-95"><a href="#Reason-95" class="headerlink" title="Reason"></a>Reason</h5><p>To avoid unintended conversions.</p>
<h5 id="Example-bad-33"><a href="#Example-bad-33" class="headerlink" title="Example, bad"></a>Example, bad</h5><pre><code>class String &#123;
    // ...
public:
    String(int);   // BAD
    // ...
&#125;;

String s = 10;   // surprise: string of size 10
</code></pre>
<h5 id="Exception-20"><a href="#Exception-20" class="headerlink" title="Exception"></a>Exception</h5><p>If you really want an implicit conversion from the constructor argument type to the class type, don’t use <code>explicit</code>:</p>
<pre><code>class Complex &#123;
    // ...
public:
    Complex(double d);   // OK: we want a conversion from d to &#123;d, 0&#125;
    // ...
&#125;;

Complex z = 10.7;   // unsurprising conversion
</code></pre>
<p><strong>See also</strong>: <a href="#Ro-conversion">Discussion of implicit conversions</a></p>
<h5 id="Note-122"><a href="#Note-122" class="headerlink" title="Note"></a>Note</h5><p>Copy and move constructors should not be made <code>explicit</code> because they do not perform conversions. Explicit copy/move constructors make passing and returning by value difficult.</p>
<h5 id="Enforcement-90"><a href="#Enforcement-90" class="headerlink" title="Enforcement"></a>Enforcement</h5><p>(Simple) Single-argument constructors should be declared <code>explicit</code>. Good single argument non-<code>explicit</code> constructors are rare in most code based. Warn for all that are not on a “positive list”.</p>
<h3 id="C-47-Define-and-initialize-member-variables-in-the-order-of-member-declaration"><a href="#C-47-Define-and-initialize-member-variables-in-the-order-of-member-declaration" class="headerlink" title="C.47: Define and initialize member variables in the order of member declaration"></a><a name="Rc-order"></a>C.47: Define and initialize member variables in the order of member declaration</h3><h5 id="Reason-96"><a href="#Reason-96" class="headerlink" title="Reason"></a>Reason</h5><p>To minimize confusion and errors. That is the order in which the initialization happens (independent of the order of member initializers).</p>
<h5 id="Example-bad-34"><a href="#Example-bad-34" class="headerlink" title="Example, bad"></a>Example, bad</h5><pre><code>class Foo &#123;
    int m1;
    int m2;
public:
    Foo(int x) :m2&#123;x&#125;, m1&#123;++x&#125; &#123; &#125;   // BAD: misleading initializer order
    // ...
&#125;;

Foo x(1); // surprise: x.m1 == x.m2 == 2
</code></pre>
<h5 id="Enforcement-91"><a href="#Enforcement-91" class="headerlink" title="Enforcement"></a>Enforcement</h5><p>(Simple) A member initializer list should mention the members in the same order they are declared.</p>
<p><strong>See also</strong>: <a href="#Sd-order">Discussion</a></p>
<h3 id="C-48-Prefer-in-class-initializers-to-member-initializers-in-constructors-for-constant-initializers"><a href="#C-48-Prefer-in-class-initializers-to-member-initializers-in-constructors-for-constant-initializers" class="headerlink" title="C.48: Prefer in-class initializers to member initializers in constructors for constant initializers"></a><a name="Rc-in-class-initializer"></a>C.48: Prefer in-class initializers to member initializers in constructors for constant initializers</h3><h5 id="Reason-97"><a href="#Reason-97" class="headerlink" title="Reason"></a>Reason</h5><p>Makes it explicit that the same value is expected to be used in all constructors. Avoids repetition. Avoids maintenance problems. It leads to the shortest and most efficient code.</p>
<h5 id="Example-bad-35"><a href="#Example-bad-35" class="headerlink" title="Example, bad"></a>Example, bad</h5><pre><code>class X &#123;   // BAD
    int i;
    string s;
    int j;
public:
    X() :i&#123;666&#125;, s&#123;&quot;qqq&quot;&#125; &#123; &#125;   // j is uninitialized
    X(int ii) :i&#123;ii&#125; &#123;&#125;         // s is &quot;&quot; and j is uninitialized
    // ...
&#125;;
</code></pre>
<p>How would a maintainer know whether <code>j</code> was deliberately uninitialized (probably a poor idea anyway) and whether it was intentional to give <code>s</code> the default value <code>&quot;&quot;</code> in one case and <code>qqq</code> in another (almost certainly a bug)? The problem with <code>j</code> (forgetting to initialize a member) often happens when a new member is added to an existing class.</p>
<h5 id="Example-86"><a href="#Example-86" class="headerlink" title="Example"></a>Example</h5><pre><code>class X2 &#123;
    int i &#123;666&#125;;
    string s &#123;&quot;qqq&quot;&#125;;
    int j &#123;0&#125;;
public:
    X2() = default;        // all members are initialized to their defaults
    X2(int ii) :i&#123;ii&#125; &#123;&#125;   // s and j initialized to their defaults
    // ...
&#125;;
</code></pre>
<p><strong>Alternative</strong>: We can get part of the benefits from default arguments to constructors, and that is not uncommon in older code. However, that is less explicit, causes more arguments to be passed, and is repetitive when there is more than one constructor:</p>
<pre><code>class X3 &#123;   // BAD: inexplicit, argument passing overhead
    int i;
    string s;
    int j;
public:
    X3(int ii = 666, const string&amp; ss = &quot;qqq&quot;, int jj = 0)
        :i&#123;ii&#125;, s&#123;ss&#125;, j&#123;jj&#125; &#123; &#125;   // all members are initialized to their defaults
    // ...
&#125;;
</code></pre>
<h5 id="Enforcement-92"><a href="#Enforcement-92" class="headerlink" title="Enforcement"></a>Enforcement</h5><ul>
<li>(Simple) Every constructor should initialize every member variable (either explicitly, via a delegating ctor call or via default construction).</li>
<li>(Simple) Default arguments to constructors suggest an in-class initializer may be more appropriate.</li>
</ul>
<h3 id="C-49-Prefer-initialization-to-assignment-in-constructors"><a href="#C-49-Prefer-initialization-to-assignment-in-constructors" class="headerlink" title="C.49: Prefer initialization to assignment in constructors"></a><a name="Rc-initialize"></a>C.49: Prefer initialization to assignment in constructors</h3><h5 id="Reason-98"><a href="#Reason-98" class="headerlink" title="Reason"></a>Reason</h5><p>An initialization explicitly states that initialization, rather than assignment, is done and can be more elegant and efficient. Prevents “use before set” errors.</p>
<h5 id="Example-good-7"><a href="#Example-good-7" class="headerlink" title="Example, good"></a>Example, good</h5><pre><code>class A &#123;   // Good
    string s1;
public:
    A() : s1&#123;&quot;Hello, &quot;&#125; &#123; &#125;    // GOOD: directly construct
    // ...
&#125;;
</code></pre>
<h5 id="Example-bad-36"><a href="#Example-bad-36" class="headerlink" title="Example, bad"></a>Example, bad</h5><pre><code>class B &#123;   // BAD
    string s1;
public:
    B() &#123; s1 = &quot;Hello, &quot;; &#125;   // BAD: default constructor followed by assignment
    // ...
&#125;;

class C &#123;   // UGLY, aka very bad
    int* p;
public:
    C() &#123; cout &lt;&lt; *p; p = new int&#123;10&#125;; &#125;   // accidental use before initialized
    // ...
&#125;;
</code></pre>
<h3 id="C-50-Use-a-factory-function-if-you-need-“virtual-behavior”-during-initialization"><a href="#C-50-Use-a-factory-function-if-you-need-“virtual-behavior”-during-initialization" class="headerlink" title="C.50: Use a factory function if you need “virtual behavior” during initialization"></a><a name="Rc-factory"></a>C.50: Use a factory function if you need “virtual behavior” during initialization</h3><h5 id="Reason-99"><a href="#Reason-99" class="headerlink" title="Reason"></a>Reason</h5><p>If the state of a base class object must depend on the state of a derived part of the object, we need to use a virtual function (or equivalent) while minimizing the window of opportunity to misuse an imperfectly constructed object.</p>
<h5 id="Note-123"><a href="#Note-123" class="headerlink" title="Note"></a>Note</h5><p>The return type of the factory should normally be <code>unique_ptr</code> by default; if some uses are shared, the caller can <code>move</code> the <code>unique_ptr</code> into a <code>shared_ptr</code>. However, if the factory author knows that all uses of the returned object will be shared uses, return <code>shared_ptr</code> and use <code>make_shared</code> in the body to save an allocation.</p>
<h5 id="Example-bad-37"><a href="#Example-bad-37" class="headerlink" title="Example, bad"></a>Example, bad</h5><pre><code>class B &#123;
public:
    B()
    &#123;
        // ...
        f();   // BAD: virtual call in constructor
        // ...
    &#125;

    virtual void f() = 0;

    // ...
&#125;;
</code></pre>
<h5 id="Example-87"><a href="#Example-87" class="headerlink" title="Example"></a>Example</h5><pre><code>class B &#123;
protected:
    B() &#123; /* ... */ &#125;              // create an imperfectly initialized object

    virtual void PostInitialize()  // to be called right after construction
    &#123;
        // ...
        f();    // GOOD: virtual dispatch is safe
        // ...
    &#125;

public:
    virtual void f() = 0;

    template&lt;class T&gt;
    static shared_ptr&lt;T&gt; Create()  // interface for creating shared objects
    &#123;
        auto p = make_shared&lt;T&gt;();
        p-&gt;PostInitialize();
        return p;
    &#125;
&#125;;

class D : public B &#123; /* ... */ &#125;;  // some derived class

shared_ptr&lt;D&gt; p = D::Create&lt;D&gt;();  // creating a D object
</code></pre>
<p>By making the constructor <code>protected</code> we avoid an incompletely constructed object escaping into the wild.<br>By providing the factory function <code>Create()</code>, we make construction (on the free store) convenient.</p>
<h5 id="Note-124"><a href="#Note-124" class="headerlink" title="Note"></a>Note</h5><p>Conventional factory functions allocate on the free store, rather than on the stack or in an enclosing object.</p>
<p><strong>See also</strong>: <a href="#Sd-factory">Discussion</a></p>
<h3 id="C-51-Use-delegating-constructors-to-represent-common-actions-for-all-constructors-of-a-class"><a href="#C-51-Use-delegating-constructors-to-represent-common-actions-for-all-constructors-of-a-class" class="headerlink" title="C.51: Use delegating constructors to represent common actions for all constructors of a class"></a><a name="Rc-delegating"></a>C.51: Use delegating constructors to represent common actions for all constructors of a class</h3><h5 id="Reason-100"><a href="#Reason-100" class="headerlink" title="Reason"></a>Reason</h5><p>To avoid repetition and accidental differences.</p>
<h5 id="Example-bad-38"><a href="#Example-bad-38" class="headerlink" title="Example, bad"></a>Example, bad</h5><pre><code>class Date &#123;   // BAD: repetitive
    int d;
    Month m;
    int y;
public:
    Date(int ii, Month mm, year yy)
        :i&#123;ii&#125;, m&#123;mm&#125;, y&#123;yy&#125;
        &#123; if (!valid(i, m, y)) throw Bad_date&#123;&#125;; &#125;

    Date(int ii, Month mm)
        :i&#123;ii&#125;, m&#123;mm&#125; y&#123;current_year()&#125;
        &#123; if (!valid(i, m, y)) throw Bad_date&#123;&#125;; &#125;
    // ...
&#125;;
</code></pre>
<p>The common action gets tedious to write and may accidentally not be common.</p>
<h5 id="Example-88"><a href="#Example-88" class="headerlink" title="Example"></a>Example</h5><pre><code>class Date2 &#123;
    int d;
    Month m;
    int y;
public:
    Date2(int ii, Month mm, year yy)
        :i&#123;ii&#125;, m&#123;mm&#125;, y&#123;yy&#125;
        &#123; if (!valid(i, m, y)) throw Bad_date&#123;&#125;; &#125;

    Date2(int ii, Month mm)
        :Date2&#123;ii, mm, current_year()&#125; &#123;&#125;
    // ...
&#125;;
</code></pre>
<p><strong>See also</strong>: If the “repeated action” is a simple initialization, consider <a href="#Rc-in-class-initializer">an in-class member initializer</a>.</p>
<h5 id="Enforcement-93"><a href="#Enforcement-93" class="headerlink" title="Enforcement"></a>Enforcement</h5><p>(Moderate) Look for similar constructor bodies.</p>
<h3 id="C-52-Use-inheriting-constructors-to-import-constructors-into-a-derived-class-that-does-not-need-further-explicit-initialization"><a href="#C-52-Use-inheriting-constructors-to-import-constructors-into-a-derived-class-that-does-not-need-further-explicit-initialization" class="headerlink" title="C.52: Use inheriting constructors to import constructors into a derived class that does not need further explicit initialization"></a><a name="Rc-inheriting"></a>C.52: Use inheriting constructors to import constructors into a derived class that does not need further explicit initialization</h3><h5 id="Reason-101"><a href="#Reason-101" class="headerlink" title="Reason"></a>Reason</h5><p>If you need those constructors for a derived class, re-implementing them is tedious and error-prone.</p>
<h5 id="Example-89"><a href="#Example-89" class="headerlink" title="Example"></a>Example</h5><p><code>std::vector</code> has a lot of tricky constructors, so if I want my own <code>vector</code>, I don’t want to reimplement them:</p>
<pre><code>class Rec &#123;
    // ... data and lots of nice constructors ...
&#125;;

class Oper : public Rec &#123;
    using Rec::Rec;
    // ... no data members ...
    // ... lots of nice utility functions ...
&#125;;
</code></pre>
<h5 id="Example-bad-39"><a href="#Example-bad-39" class="headerlink" title="Example, bad"></a>Example, bad</h5><pre><code>struct Rec2 : public Rec &#123;
    int x;
    using Rec::Rec;
&#125;;

Rec2 r &#123;&quot;foo&quot;, 7&#125;;
int val = r.x;   // uninitialized
</code></pre>
<h5 id="Enforcement-94"><a href="#Enforcement-94" class="headerlink" title="Enforcement"></a>Enforcement</h5><p>Make sure that every member of the derived class is initialized.</p>
<h2 id="C-copy-Copy-and-move"><a href="#C-copy-Copy-and-move" class="headerlink" title="C.copy: Copy and move"></a><a name="SS-copy"></a>C.copy: Copy and move</h2><p>Value types should generally be copyable, but interfaces in a class hierarchy should not.<br>Resource handles may or may not be copyable.<br>Types can be defined to move for logical as well as performance reasons.</p>
<h3 id="C-60-Make-copy-assignment-non-virtual-take-the-parameter-by-const-amp-and-return-by-non-const-amp"><a href="#C-60-Make-copy-assignment-non-virtual-take-the-parameter-by-const-amp-and-return-by-non-const-amp" class="headerlink" title="C.60: Make copy assignment non-virtual, take the parameter by const&amp;, and return by non-const&amp;"></a><a name="Rc-copy-assignment"></a>C.60: Make copy assignment non-<code>virtual</code>, take the parameter by <code>const&amp;</code>, and return by non-<code>const&amp;</code></h3><h5 id="Reason-102"><a href="#Reason-102" class="headerlink" title="Reason"></a>Reason</h5><p>It is simple and efficient. If you want to optimize for rvalues, provide an overload that takes a <code>&amp;&amp;</code> (see <a href="#Rf-consume">F.18</a>).</p>
<h5 id="Example-90"><a href="#Example-90" class="headerlink" title="Example"></a>Example</h5><pre><code>class Foo &#123;
public:
    Foo&amp; operator=(const Foo&amp; x)
    &#123;
        // GOOD: no need to check for self-assignment (other than performance)
        auto tmp = x;
        std::swap(*this, tmp);
        return *this;
    &#125;
    // ...
&#125;;

Foo a;
Foo b;
Foo f();

a = b;    // assign lvalue: copy
a = f();  // assign rvalue: potentially move
</code></pre>
<h5 id="Note-125"><a href="#Note-125" class="headerlink" title="Note"></a>Note</h5><p>The <code>swap</code> implementation technique offers the <a href="#Abrahams01">strong guarantee</a>.</p>
<h5 id="Example-91"><a href="#Example-91" class="headerlink" title="Example"></a>Example</h5><p>But what if you can get significantly better performance by not making a temporary copy? Consider a simple <code>Vector</code> intended for a domain where assignment of large, equal-sized <code>Vector</code>s is common. In this case, the copy of elements implied by the <code>swap</code> implementation technique could cause an order of magnitude increase in cost:</p>
<pre><code>template&lt;typename T&gt;
class Vector &#123;
public:
    Vector&amp; operator=(const Vector&amp;);
    // ...
private:
    T* elem;
    int sz;
&#125;;

Vector&amp; Vector::operator=(const Vector&amp; a)
&#123;
    if (a.sz &gt; sz) &#123;
        // ... use the swap technique, it can&#39;t be bettered ...
        return *this
    &#125;
    // ... copy sz elements from *a.elem to elem ...
    if (a.sz &lt; sz) &#123;
        // ... destroy the surplus elements in *this* and adjust size ...
    &#125;
    return *this;
&#125;
</code></pre>
<p>By writing directly to the target elements, we will get only <a href="#Abrahams01">the basic guarantee</a> rather than the strong guarantee offered by the <code>swap</code> technique. Beware of <a href="#Rc-copy-self">self-assignment</a>.</p>
<p><strong>Alternatives</strong>: If you think you need a <code>virtual</code> assignment operator, and understand why that’s deeply problematic, don’t call it <code>operator=</code>. Make it a named function like <code>virtual void assign(const Foo&amp;)</code>.<br>See <a href="#Rc-copy-virtual">copy constructor vs. <code>clone()</code></a>.</p>
<h5 id="Enforcement-95"><a href="#Enforcement-95" class="headerlink" title="Enforcement"></a>Enforcement</h5><ul>
<li>(Simple) An assignment operator should not be virtual. Here be dragons!</li>
<li>(Simple) An assignment operator should return <code>T&amp;</code> to enable chaining, not alternatives like <code>const T&amp;</code> which interfere with composability and putting objects in containers.</li>
<li>(Moderate) An assignment operator should (implicitly or explicitly) invoke all base and member assignment operators.<br>Look at the destructor to determine if the type has pointer semantics or value semantics.</li>
</ul>
<h3 id="C-61-A-copy-operation-should-copy"><a href="#C-61-A-copy-operation-should-copy" class="headerlink" title="C.61: A copy operation should copy"></a><a name="Rc-copy-semantic"></a>C.61: A copy operation should copy</h3><h5 id="Reason-103"><a href="#Reason-103" class="headerlink" title="Reason"></a>Reason</h5><p>That is the generally assumed semantics. After <code>x = y</code>, we should have <code>x == y</code>.<br>After a copy <code>x</code> and <code>y</code> can be independent objects (value semantics, the way non-pointer built-in types and the standard-library types work) or refer to a shared object (pointer semantics, the way pointers work).</p>
<h5 id="Example-92"><a href="#Example-92" class="headerlink" title="Example"></a>Example</h5><pre><code>class X &#123;   // OK: value semantics
public:
    X();
    X(const X&amp;);     // copy X
    void modify();   // change the value of X
    // ...
    ~X() &#123; delete[] p; &#125;
private:
    T* p;
    int sz;
&#125;;

bool operator==(const X&amp; a, const X&amp; b)
&#123;
    return a.sz == b.sz &amp;&amp; equal(a.p, a.p + a.sz, b.p, b.p + b.sz);
&#125;

X::X(const X&amp; a)
    :p&#123;new T[a.sz]&#125;, sz&#123;a.sz&#125;
&#123;
    copy(a.p, a.p + sz, p);
&#125;

X x;
X y = x;
if (x != y) throw Bad&#123;&#125;;
x.modify();
if (x == y) throw Bad&#123;&#125;;   // assume value semantics
</code></pre>
<h5 id="Example-93"><a href="#Example-93" class="headerlink" title="Example"></a>Example</h5><pre><code>class X2 &#123;  // OK: pointer semantics
public:
    X2();
    X2(const X2&amp;) = default; // shallow copy
    ~X2() = default;
    void modify();          // change the pointed-to value
    // ...
private:
    T* p;
    int sz;
&#125;;

bool operator==(const X2&amp; a, const X2&amp; b)
&#123;
    return a.sz == b.sz &amp;&amp; a.p == b.p;
&#125;

X2 x;
X2 y = x;
if (x != y) throw Bad&#123;&#125;;
x.modify();
if (x != y) throw Bad&#123;&#125;;  // assume pointer semantics
</code></pre>
<h5 id="Note-126"><a href="#Note-126" class="headerlink" title="Note"></a>Note</h5><p>Prefer copy semantics unless you are building a “smart pointer”. Value semantics is the simplest to reason about and what the standard-library facilities expect.</p>
<h5 id="Enforcement-96"><a href="#Enforcement-96" class="headerlink" title="Enforcement"></a>Enforcement</h5><p>(Not enforceable)</p>
<h3 id="C-62-Make-copy-assignment-safe-for-self-assignment"><a href="#C-62-Make-copy-assignment-safe-for-self-assignment" class="headerlink" title="C.62: Make copy assignment safe for self-assignment"></a><a name="Rc-copy-self"></a>C.62: Make copy assignment safe for self-assignment</h3><h5 id="Reason-104"><a href="#Reason-104" class="headerlink" title="Reason"></a>Reason</h5><p>If <code>x = x</code> changes the value of <code>x</code>, people will be surprised and bad errors will occur (often including leaks).</p>
<h5 id="Example-94"><a href="#Example-94" class="headerlink" title="Example"></a>Example</h5><p>The standard-library containers handle self-assignment elegantly and efficiently:</p>
<pre><code>std::vector&lt;int&gt; v = &#123;3, 1, 4, 1, 5, 9&#125;;
v = v;
// the value of v is still &#123;3, 1, 4, 1, 5, 9&#125;
</code></pre>
<h5 id="Note-127"><a href="#Note-127" class="headerlink" title="Note"></a>Note</h5><p>The default assignment generated from members that handle self-assignment correctly handles self-assignment.</p>
<pre><code>struct Bar &#123;
    vector&lt;pair&lt;int, int&gt;&gt; v;
    map&lt;string, int&gt; m;
    string s;
&#125;;

Bar b;
// ...
b = b;   // correct and efficient
</code></pre>
<h5 id="Note-128"><a href="#Note-128" class="headerlink" title="Note"></a>Note</h5><p>You can handle self-assignment by explicitly testing for self-assignment, but often it is faster and more elegant to cope without such a test (e.g., <a href="#Rc-swap">using <code>swap</code></a>).</p>
<pre><code>class Foo &#123;
    string s;
    int i;
public:
    Foo&amp; operator=(const Foo&amp; a);
    // ...
&#125;;

Foo&amp; Foo::operator=(const Foo&amp; a)   // OK, but there is a cost
&#123;
    if (this == &amp;a) return *this;
    s = a.s;
    i = a.i;
    return *this;
&#125;
</code></pre>
<p>This is obviously safe and apparently efficient.<br>However, what if we do one self-assignment per million assignments?<br>That’s about a million redundant tests (but since the answer is essentially always the same, the computer’s branch predictor will guess right essentially every time).<br>Consider:</p>
<pre><code>Foo&amp; Foo::operator=(const Foo&amp; a)   // simpler, and probably much better
&#123;
    s = a.s;
    i = a.i;
    return *this;
&#125;
</code></pre>
<p><code>std::string</code> is safe for self-assignment and so are <code>int</code>. All the cost is carried by the (rare) case of self-assignment.</p>
<h5 id="Enforcement-97"><a href="#Enforcement-97" class="headerlink" title="Enforcement"></a>Enforcement</h5><p>(Simple) Assignment operators should not contain the pattern <code>if (this == &amp;a) return *this;</code> ???</p>
<h3 id="C-63-Make-move-assignment-non-virtual-take-the-parameter-by-amp-amp-and-return-by-non-const-amp"><a href="#C-63-Make-move-assignment-non-virtual-take-the-parameter-by-amp-amp-and-return-by-non-const-amp" class="headerlink" title="C.63: Make move assignment non-virtual, take the parameter by &amp;&amp;, and return by non-const &amp;"></a><a name="Rc-move-assignment"></a>C.63: Make move assignment non-<code>virtual</code>, take the parameter by <code>&amp;&amp;</code>, and return by non-<code>const &amp;</code></h3><h5 id="Reason-105"><a href="#Reason-105" class="headerlink" title="Reason"></a>Reason</h5><p>It is simple and efficient.</p>
<p><strong>See</strong>: <a href="#Rc-copy-assignment">The rule for copy-assignment</a>.</p>
<h5 id="Enforcement-98"><a href="#Enforcement-98" class="headerlink" title="Enforcement"></a>Enforcement</h5><p>Equivalent to what is done for <a href="#Rc-copy-assignment">copy-assignment</a>.</p>
<ul>
<li>(Simple) An assignment operator should not be virtual. Here be dragons!</li>
<li>(Simple) An assignment operator should return <code>T&amp;</code> to enable chaining, not alternatives like <code>const T&amp;</code> which interfere with composability and putting objects in containers.</li>
<li>(Moderate) A move assignment operator should (implicitly or explicitly) invoke all base and member move assignment operators.</li>
</ul>
<h3 id="C-64-A-move-operation-should-move-and-leave-its-source-in-a-valid-state"><a href="#C-64-A-move-operation-should-move-and-leave-its-source-in-a-valid-state" class="headerlink" title="C.64: A move operation should move and leave its source in a valid state"></a><a name="Rc-move-semantic"></a>C.64: A move operation should move and leave its source in a valid state</h3><h5 id="Reason-106"><a href="#Reason-106" class="headerlink" title="Reason"></a>Reason</h5><p>That is the generally assumed semantics.<br>After <code>y = std::move(x)</code> the value of <code>y</code> should be the value <code>x</code> had and <code>x</code> should be in a valid state.</p>
<h5 id="Example-95"><a href="#Example-95" class="headerlink" title="Example"></a>Example</h5><pre><code>template&lt;typename T&gt;
class X &#123;   // OK: value semantics
public:
    X();
    X(X&amp;&amp; a) noexcept;  // move X
    void modify();     // change the value of X
    // ...
    ~X() &#123; delete[] p; &#125;
private:
    T* p;
    int sz;
&#125;;


X::X(X&amp;&amp; a)
    :p&#123;a.p&#125;, sz&#123;a.sz&#125;  // steal representation
&#123;
    a.p = nullptr;     // set to &quot;empty&quot;
    a.sz = 0;
&#125;

void use()
&#123;
    X x&#123;&#125;;
    // ...
    X y = std::move(x);
    x = X&#123;&#125;;   // OK
&#125; // OK: x can be destroyed
</code></pre>
<h5 id="Note-129"><a href="#Note-129" class="headerlink" title="Note"></a>Note</h5><p>Ideally, that moved-from should be the default value of the type.<br>Ensure that unless there is an exceptionally good reason not to.<br>However, not all types have a default value and for some types establishing the default value can be expensive.<br>The standard requires only that the moved-from object can be destroyed.<br>Often, we can easily and cheaply do better: The standard library assumes that it is possible to assign to a moved-from object.<br>Always leave the moved-from object in some (necessarily specified) valid state.</p>
<h5 id="Note-130"><a href="#Note-130" class="headerlink" title="Note"></a>Note</h5><p>Unless there is an exceptionally strong reason not to, make <code>x = std::move(y); y = z;</code> work with the conventional semantics.</p>
<h5 id="Enforcement-99"><a href="#Enforcement-99" class="headerlink" title="Enforcement"></a>Enforcement</h5><p>(Not enforceable) Look for assignments to members in the move operation. If there is a default constructor, compare those assignments to the initializations in the default constructor.</p>
<h3 id="C-65-Make-move-assignment-safe-for-self-assignment"><a href="#C-65-Make-move-assignment-safe-for-self-assignment" class="headerlink" title="C.65: Make move assignment safe for self-assignment"></a><a name="Rc-move-self"></a>C.65: Make move assignment safe for self-assignment</h3><h5 id="Reason-107"><a href="#Reason-107" class="headerlink" title="Reason"></a>Reason</h5><p>If <code>x = x</code> changes the value of <code>x</code>, people will be surprised and bad errors may occur. However, people don’t usually directly write a self-assignment that turn into a move, but it can occur. However, <code>std::swap</code> is implemented using move operations so if you accidentally do <code>swap(a, b)</code> where <code>a</code> and <code>b</code> refer to the same object, failing to handle self-move could be a serious and subtle error.</p>
<h5 id="Example-96"><a href="#Example-96" class="headerlink" title="Example"></a>Example</h5><pre><code>class Foo &#123;
    string s;
    int i;
public:
    Foo&amp; operator=(Foo&amp;&amp; a);
    // ...
&#125;;

Foo&amp; Foo::operator=(Foo&amp;&amp; a) noexcept  // OK, but there is a cost
&#123;
    if (this == &amp;a) return *this;  // this line is redundant
    s = std::move(a.s);
    i = a.i;
    return *this;
&#125;
</code></pre>
<p>The one-in-a-million argument against <code>if (this == &amp;a) return *this;</code> tests from the discussion of <a href="#Rc-copy-self">self-assignment</a> is even more relevant for self-move.</p>
<h5 id="Note-131"><a href="#Note-131" class="headerlink" title="Note"></a>Note</h5><p>There is no known general way of avoiding a <code>if (this == &amp;a) return *this;</code> test for a move assignment and still get a correct answer (i.e., after <code>x = x</code> the value of <code>x</code> is unchanged).</p>
<h5 id="Note-132"><a href="#Note-132" class="headerlink" title="Note"></a>Note</h5><p>The ISO standard guarantees only a “valid but unspecified” state for the standard-library containers. Apparently this has not been a problem in about 10 years of experimental and production use. Please contact the editors if you find a counter example. The rule here is more caution and insists on complete safety.</p>
<h5 id="Example-97"><a href="#Example-97" class="headerlink" title="Example"></a>Example</h5><p>Here is a way to move a pointer without a test (imagine it as code in the implementation a move assignment):</p>
<pre><code>// move from other.ptr to this-&gt;ptr
T* temp = other.ptr;
other.ptr = nullptr;
delete ptr;
ptr = temp;
</code></pre>
<h5 id="Enforcement-100"><a href="#Enforcement-100" class="headerlink" title="Enforcement"></a>Enforcement</h5><ul>
<li>(Moderate) In the case of self-assignment, a move assignment operator should not leave the object holding pointer members that have been <code>delete</code>d or set to <code>nullptr</code>.</li>
<li>(Not enforceable) Look at the use of standard-library container types (incl. <code>string</code>) and consider them safe for ordinary (not life-critical) uses.</li>
</ul>
<h3 id="C-66-Make-move-operations-noexcept"><a href="#C-66-Make-move-operations-noexcept" class="headerlink" title="C.66: Make move operations noexcept"></a><a name="Rc-move-noexcept"></a>C.66: Make move operations <code>noexcept</code></h3><h5 id="Reason-108"><a href="#Reason-108" class="headerlink" title="Reason"></a>Reason</h5><p>A throwing move violates most people’s reasonably assumptions.<br>A non-throwing move will be used more efficiently by standard-library and language facilities.</p>
<h5 id="Example-98"><a href="#Example-98" class="headerlink" title="Example"></a>Example</h5><pre><code>template&lt;typename T&gt;
class Vector &#123;
    // ...
    Vector(Vector&amp;&amp; a) noexcept :elem&#123;a.elem&#125;, sz&#123;a.sz&#125; &#123; a.sz = 0; a.elem = nullptr; &#125;
    Vector&amp; operator=(Vector&amp;&amp; a) noexcept &#123; elem = a.elem; sz = a.sz; a.sz = 0; a.elem = nullptr; &#125;
    // ...
public:
    T* elem;
    int sz;
&#125;;
</code></pre>
<p>These operations do not throw.</p>
<h5 id="Example-bad-40"><a href="#Example-bad-40" class="headerlink" title="Example, bad"></a>Example, bad</h5><pre><code>template&lt;typename T&gt;
class Vector2 &#123;
    // ...
    Vector2(Vector2&amp;&amp; a) &#123; *this = a; &#125;             // just use the copy
    Vector2&amp; operator=(Vector2&amp;&amp; a) &#123; *this = a; &#125;  // just use the copy
    // ...
public:
    T* elem;
    int sz;
&#125;;
</code></pre>
<p>This <code>Vector2</code> is not just inefficient, but since a vector copy requires allocation, it can throw.</p>
<h5 id="Enforcement-101"><a href="#Enforcement-101" class="headerlink" title="Enforcement"></a>Enforcement</h5><p>(Simple) A move operation should be marked <code>noexcept</code>.</p>
<h3 id="C-67-A-base-class-should-suppress-copying-and-provide-a-virtual-clone-instead-if-“copying”-is-desired"><a href="#C-67-A-base-class-should-suppress-copying-and-provide-a-virtual-clone-instead-if-“copying”-is-desired" class="headerlink" title="C.67: A base class should suppress copying, and provide a virtual clone instead if “copying” is desired"></a><a name="Rc-copy-virtual"></a>C.67: A base class should suppress copying, and provide a virtual <code>clone</code> instead if “copying” is desired</h3><h5 id="Reason-109"><a href="#Reason-109" class="headerlink" title="Reason"></a>Reason</h5><p>To prevent slicing, because the normal copy operations will copy only the base portion of a derived object.</p>
<h5 id="Example-bad-41"><a href="#Example-bad-41" class="headerlink" title="Example, bad"></a>Example, bad</h5><pre><code>class B &#123; // BAD: base class doesn&#39;t suppress copying
    int data;
    // ... nothing about copy operations, so uses default ...
&#125;;

class D : public B &#123;
    string more_data; // add a data member
    // ...
&#125;;

auto d = make_unique&lt;D&gt;();

// oops, slices the object; gets only d.data but drops d.more_data
auto b = make_unique&lt;B&gt;(d);
</code></pre>
<h5 id="Example-99"><a href="#Example-99" class="headerlink" title="Example"></a>Example</h5><pre><code>class B &#123; // GOOD: base class suppresses copying
public:
    B(const B&amp;) = delete;
    B&amp; operator=(const B&amp;) = delete;
    virtual unique_ptr&lt;B&gt; clone() &#123; return /* B object */; &#125;
    // ...
&#125;;

class D : public B &#123;
    string more_data; // add a data member
    unique_ptr&lt;B&gt; clone() override &#123; return /* D object */; &#125;
    // ...
&#125;;

auto d = make_unique&lt;D&gt;();
auto b = d.clone(); // ok, deep clone
</code></pre>
<h5 id="Note-133"><a href="#Note-133" class="headerlink" title="Note"></a>Note</h5><p>It’s good to return a smart pointer, but unlike with raw pointers the return type cannot be covariant (for example, <code>D::clone</code> can’t return a <code>unique_ptr&lt;D&gt;</code>. Don’t let this tempt you into returning an owning raw pointer; this is a minor drawback compared to the major robustness benefit delivered by the owning smart pointer.</p>
<h5 id="Exception-21"><a href="#Exception-21" class="headerlink" title="Exception"></a>Exception</h5><p>If you need covariant return types, return an <code>owner&lt;derived*&gt;</code>. See <a href="#Rh-copy">C.130</a>.</p>
<h5 id="Enforcement-102"><a href="#Enforcement-102" class="headerlink" title="Enforcement"></a>Enforcement</h5><p>A class with any virtual function should not have a copy constructor or copy assignment operator (compiler-generated or handwritten).</p>
<h2 id="C-other-Other-default-operation-rules"><a href="#C-other-Other-default-operation-rules" class="headerlink" title="C.other: Other default operation rules"></a>C.other: Other default operation rules</h2><p>In addition to the operations for which the language offer default implementations,<br>there are a few operations that are so foundational that it rules for their definition are needed:<br>comparisons, <code>swap</code>, and <code>hash</code>.</p>
<h3 id="C-80-Use-default-if-you-have-to-be-explicit-about-using-the-default-semantics"><a href="#C-80-Use-default-if-you-have-to-be-explicit-about-using-the-default-semantics" class="headerlink" title="C.80: Use =default if you have to be explicit about using the default semantics"></a><a name="Rc-eqdefault"></a>C.80: Use <code>=default</code> if you have to be explicit about using the default semantics</h3><h5 id="Reason-110"><a href="#Reason-110" class="headerlink" title="Reason"></a>Reason</h5><p>The compiler is more likely to get the default semantics right and you cannot implement these functions better than the compiler.</p>
<h5 id="Example-100"><a href="#Example-100" class="headerlink" title="Example"></a>Example</h5><pre><code>class Tracer &#123;
    string message;
public:
    Tracer(const string&amp; m) : message&#123;m&#125; &#123; cerr &lt;&lt; &quot;entering &quot; &lt;&lt; message &lt;&lt; &#39;\n&#39;; &#125;
    ~Tracer() &#123; cerr &lt;&lt; &quot;exiting &quot; &lt;&lt; message &lt;&lt; &#39;\n&#39;; &#125;

    Tracer(const Tracer&amp;) = default;
    Tracer&amp; operator=(const Tracer&amp;) = default;
    Tracer(Tracer&amp;&amp;) = default;
    Tracer&amp; operator=(Tracer&amp;&amp;) = default;
&#125;;
</code></pre>
<p>Because we defined the destructor, we must define the copy and move operations. The <code>= default</code> is the best and simplest way of doing that.</p>
<h5 id="Example-bad-42"><a href="#Example-bad-42" class="headerlink" title="Example, bad"></a>Example, bad</h5><pre><code>class Tracer2 &#123;
    string message;
public:
    Tracer2(const string&amp; m) : message&#123;m&#125; &#123; cerr &lt;&lt; &quot;entering &quot; &lt;&lt; message &lt;&lt; &#39;\n&#39;; &#125;
    ~Tracer2() &#123; cerr &lt;&lt; &quot;exiting &quot; &lt;&lt; message &lt;&lt; &#39;\n&#39;; &#125;

    Tracer2(const Tracer2&amp; a) : message&#123;a.message&#125; &#123;&#125;
    Tracer2&amp; operator=(const Tracer2&amp; a) &#123; message = a.message; return *this; &#125;
    Tracer2(Tracer2&amp;&amp; a) :message&#123;a.message&#125; &#123;&#125;
    Tracer2&amp; operator=(Tracer2&amp;&amp; a) &#123; message = a.message; return *this; &#125;
&#125;;
</code></pre>
<p>Writing out the bodies of the copy and move operations is verbose, tedious, and error-prone. A compiler does it better.</p>
<h5 id="Enforcement-103"><a href="#Enforcement-103" class="headerlink" title="Enforcement"></a>Enforcement</h5><p>(Moderate) The body of a special operation should not have the same accessibility and semantics as the compiler-generated version, because that would be redundant</p>
<h3 id="C-81-Use-delete-when-you-want-to-disable-default-behavior-without-wanting-an-alternative"><a href="#C-81-Use-delete-when-you-want-to-disable-default-behavior-without-wanting-an-alternative" class="headerlink" title="C.81: Use =delete when you want to disable default behavior (without wanting an alternative)"></a><a name="Rc-delete"></a>C.81: Use <code>=delete</code> when you want to disable default behavior (without wanting an alternative)</h3><h5 id="Reason-111"><a href="#Reason-111" class="headerlink" title="Reason"></a>Reason</h5><p>In a few cases, a default operation is not desirable.</p>
<h5 id="Example-101"><a href="#Example-101" class="headerlink" title="Example"></a>Example</h5><pre><code>class Immortal &#123;
public:
    ~Immortal() = delete;   // do not allow destruction
    // ...
&#125;;

void use()
&#123;
    Immortal ugh;   // error: ugh cannot be destroyed
    Immortal* p = new Immortal&#123;&#125;;
    delete p;       // error: cannot destroy *p
&#125;
</code></pre>
<h5 id="Example-102"><a href="#Example-102" class="headerlink" title="Example"></a>Example</h5><p>A <code>unique_ptr</code> can be moved, but not copied. To achieve that its copy operations are deleted. To avoid copying it is necessary to <code>=delete</code> its copy operations from lvalues:</p>
<pre><code>template &lt;class T, class D = default_delete&lt;T&gt;&gt; class unique_ptr &#123;
public:
    // ...
    constexpr unique_ptr() noexcept;
    explicit unique_ptr(pointer p) noexcept;
    // ...
    unique_ptr(unique_ptr&amp;&amp; u) noexcept;   // move constructor
    // ...
    unique_ptr(const unique_ptr&amp;) = delete; // disable copy from lvalue
    // ...
&#125;;

unique_ptr&lt;int&gt; make();   // make &quot;something&quot; and return it by moving

void f()
&#123;
    unique_ptr&lt;int&gt; pi &#123;&#125;;
    auto pi2 &#123;pi&#125;;      // error: no move constructor from lvalue
    auto pi3 &#123;make()&#125;;  // OK, move: the result of make() is an rvalue
&#125;
</code></pre>
<p>Note that deleted functions should be public.</p>
<h5 id="Enforcement-104"><a href="#Enforcement-104" class="headerlink" title="Enforcement"></a>Enforcement</h5><p>The elimination of a default operation is (should be) based on the desired semantics of the class. Consider such classes suspect, but maintain a “positive list” of classes where a human has asserted that the semantics is correct.</p>
<h3 id="C-82-Don’t-call-virtual-functions-in-constructors-and-destructors"><a href="#C-82-Don’t-call-virtual-functions-in-constructors-and-destructors" class="headerlink" title="C.82: Don’t call virtual functions in constructors and destructors"></a><a name="Rc-ctor-virtual"></a>C.82: Don’t call virtual functions in constructors and destructors</h3><h5 id="Reason-112"><a href="#Reason-112" class="headerlink" title="Reason"></a>Reason</h5><p>The function called will be that of the object constructed so far, rather than a possibly overriding function in a derived class.<br>This can be most confusing.<br>Worse, a direct or indirect call to an unimplemented pure virtual function from a constructor or destructor results in undefined behavior.</p>
<h5 id="Example-bad-43"><a href="#Example-bad-43" class="headerlink" title="Example, bad"></a>Example, bad</h5><pre><code>class Base &#123;
public:
    virtual void f() = 0;   // not implemented
    virtual void g();       // implemented with Base version
    virtual void h();       // implemented with Base version
&#125;;

class Derived : public Base &#123;
public:
    void g() override;   // provide Derived implementation
    void h() final;      // provide Derived implementation

    Derived()
    &#123;
        // BAD: attempt to call an unimplemented virtual function
        f();

        // BAD: will call Derived::g, not dispatch further virtually
        g();

        // GOOD: explicitly state intent to call only the visible version
        Derived::g();

        // ok, no qualification needed, h is final
        h();
    &#125;
&#125;;
</code></pre>
<p>Note that calling a specific explicitly qualified function is not a virtual call even if the function is <code>virtual</code>.</p>
<p><strong>See also</strong> <a href="#Rc-factory">factory functions</a> for how to achieve the effect of a call to a derived class function without risking undefined behavior.</p>
<h5 id="Note-134"><a href="#Note-134" class="headerlink" title="Note"></a>Note</h5><p>There is nothing inherently wrong with calling virtual functions from constructors and destructors.<br>The semantics of such calls is type safe.<br>However, experience shows that such calls are rarely needed, easily confuse maintainers, and become a source of errors when used by novices.</p>
<h5 id="Enforcement-105"><a href="#Enforcement-105" class="headerlink" title="Enforcement"></a>Enforcement</h5><ul>
<li>Flag calls of virtual functions from constructors and destructors.</li>
</ul>
<h3 id="C-83-For-value-like-types-consider-providing-a-noexcept-swap-function"><a href="#C-83-For-value-like-types-consider-providing-a-noexcept-swap-function" class="headerlink" title="C.83: For value-like types, consider providing a noexcept swap function"></a><a name="Rc-swap"></a>C.83: For value-like types, consider providing a <code>noexcept</code> swap function</h3><h5 id="Reason-113"><a href="#Reason-113" class="headerlink" title="Reason"></a>Reason</h5><p>A <code>swap</code> can be handy for implementing a number of idioms, from smoothly moving objects around to implementing assignment easily to providing a guaranteed commit function that enables strongly error-safe calling code. Consider using swap to implement copy assignment in terms of copy construction. See also <a href="#Re-never-fail">destructors, deallocation, and swap must never fail</a>.</p>
<h5 id="Example-good-8"><a href="#Example-good-8" class="headerlink" title="Example, good"></a>Example, good</h5><pre><code>class Foo &#123;
    // ...
public:
    void swap(Foo&amp; rhs) noexcept
    &#123;
        m1.swap(rhs.m1);
        std::swap(m2, rhs.m2);
    &#125;
private:
    Bar m1;
    int m2;
&#125;;
</code></pre>
<p>Providing a nonmember <code>swap</code> function in the same namespace as your type for callers’ convenience.</p>
<pre><code>void swap(Foo&amp; a, Foo&amp; b)
&#123;
    a.swap(b);
&#125;
</code></pre>
<h5 id="Enforcement-106"><a href="#Enforcement-106" class="headerlink" title="Enforcement"></a>Enforcement</h5><ul>
<li>(Simple) A class without virtual functions should have a <code>swap</code> member function declared.</li>
<li>(Simple) When a class has a <code>swap</code> member function, it should be declared <code>noexcept</code>.</li>
</ul>
<h3 id="C-84-A-swap-function-may-not-fail"><a href="#C-84-A-swap-function-may-not-fail" class="headerlink" title="C.84: A swap function may not fail"></a><a name="Rc-swap-fail"></a>C.84: A <code>swap</code> function may not fail</h3><h5 id="Reason-114"><a href="#Reason-114" class="headerlink" title="Reason"></a>Reason</h5><p> <code>swap</code> is widely used in ways that are assumed never to fail and programs cannot easily be written to work correctly in the presence of a failing <code>swap</code>. The standard-library containers and algorithms will not work correctly if a swap of an element type fails.</p>
<h5 id="Example-bad-44"><a href="#Example-bad-44" class="headerlink" title="Example, bad"></a>Example, bad</h5><pre><code>void swap(My_vector&amp; x, My_vector&amp; y)
&#123;
    auto tmp = x;   // copy elements
    x = y;
    y = tmp;
&#125;
</code></pre>
<p>This is not just slow, but if a memory allocation occurs for the elements in <code>tmp</code>, this <code>swap</code> may throw and would make STL algorithms fail if used with them.</p>
<h5 id="Enforcement-107"><a href="#Enforcement-107" class="headerlink" title="Enforcement"></a>Enforcement</h5><p>(Simple) When a class has a <code>swap</code> member function, it should be declared <code>noexcept</code>.</p>
<h3 id="C-85-Make-swap-noexcept"><a href="#C-85-Make-swap-noexcept" class="headerlink" title="C.85: Make swap noexcept"></a><a name="Rc-swap-noexcept"></a>C.85: Make <code>swap</code> <code>noexcept</code></h3><h5 id="Reason-115"><a href="#Reason-115" class="headerlink" title="Reason"></a>Reason</h5><p> <a href="#Rc-swap-fail">A <code>swap</code> may not fail</a>.<br>If a <code>swap</code> tries to exit with an exception, it’s a bad design error and the program had better terminate.</p>
<h5 id="Enforcement-108"><a href="#Enforcement-108" class="headerlink" title="Enforcement"></a>Enforcement</h5><p>(Simple) When a class has a <code>swap</code> member function, it should be declared <code>noexcept</code>.</p>
<h3 id="C-86-Make-symmetric-with-respect-to-operand-types-and-noexcept"><a href="#C-86-Make-symmetric-with-respect-to-operand-types-and-noexcept" class="headerlink" title="C.86: Make == symmetric with respect to operand types and noexcept"></a><a name="Rc-eq"></a>C.86: Make <code>==</code> symmetric with respect to operand types and <code>noexcept</code></h3><h5 id="Reason-116"><a href="#Reason-116" class="headerlink" title="Reason"></a>Reason</h5><p>Asymmetric treatment of operands is surprising and a source of errors where conversions are possible.<br><code>==</code> is a fundamental operations and programmers should be able to use it without fear of failure.</p>
<h5 id="Example-103"><a href="#Example-103" class="headerlink" title="Example"></a>Example</h5><pre><code>struct X &#123;
    string name;
    int number;
&#125;;

bool operator==(const X&amp; a, const X&amp; b) noexcept &#123;
    return a.name == b.name &amp;&amp; a.number == b.number;
&#125;
</code></pre>
<h5 id="Example-bad-45"><a href="#Example-bad-45" class="headerlink" title="Example, bad"></a>Example, bad</h5><pre><code>class B &#123;
    string name;
    int number;
    bool operator==(const B&amp; a) const &#123;
        return name == a.name &amp;&amp; number == a.number;
    &#125;
    // ...
&#125;;
</code></pre>
<p><code>B</code>‘s comparison accepts conversions for its second operand, but not its first.</p>
<h5 id="Note-135"><a href="#Note-135" class="headerlink" title="Note"></a>Note</h5><p>If a class has a failure state, like <code>double</code>‘s <code>NaN</code>, there is a temptation to make a comparison against the failure state throw.<br>The alternative is to make two failure states compare equal and any valid state compare false against the failure state.</p>
<h4 id="Note-136"><a href="#Note-136" class="headerlink" title="Note"></a>Note</h4><p>This rule applies to all the usual comparison operators: <code>!=</code>, <code>&lt;</code>, <code>&lt;=</code>, <code>&gt;</code>, and <code>&gt;=</code>.</p>
<h5 id="Enforcement-109"><a href="#Enforcement-109" class="headerlink" title="Enforcement"></a>Enforcement</h5><ul>
<li>Flag an <code>operator==()</code> for which the argument types differ; same for other comparison operators: <code>!=</code>, <code>&lt;</code>, <code>&lt;=</code>, <code>&gt;</code>, and <code>&gt;=</code>.</li>
<li>Flag member <code>operator==()</code>s; same for other comparison operators: <code>!=</code>, <code>&lt;</code>, <code>&lt;=</code>, <code>&gt;</code>, and <code>&gt;=</code>.</li>
</ul>
<h3 id="C-87-Beware-of-on-base-classes"><a href="#C-87-Beware-of-on-base-classes" class="headerlink" title="C.87: Beware of == on base classes"></a><a name="Rc-eq-base"></a>C.87: Beware of <code>==</code> on base classes</h3><h5 id="Reason-117"><a href="#Reason-117" class="headerlink" title="Reason"></a>Reason</h5><p>It is really hard to write a foolproof and useful <code>==</code> for a hierarchy.</p>
<h5 id="Example-bad-46"><a href="#Example-bad-46" class="headerlink" title="Example, bad"></a>Example, bad</h5><pre><code>class B &#123;
    string name;
    int number;
    virtual bool operator==(const B&amp; a) const
    &#123;
         return name == a.name &amp;&amp; number == a.number;
    &#125;
    // ...
&#125;;
</code></pre>
<p><code>B</code>‘s comparison accepts conversions for its second operand, but not its first.</p>
<pre><code>class D :B &#123;
    char character;
    virtual bool operator==(const D&amp; a) const
    &#123;
        return name == a.name &amp;&amp; number == a.number &amp;&amp; character == a.character;
    &#125;
    // ...
&#125;;

B b = ...
D d = ...
b == d;    // compares name and number, ignores d&#39;s character
d == b;    // error: no == defined
D d2;
d == d2;   // compares name, number, and character
B&amp; b2 = d2;
b2 == d;   // compares name and number, ignores d2&#39;s and d&#39;s character
</code></pre>
<p>Of course there are ways of making <code>==</code> work in a hierarchy, but the naive approaches do not scale</p>
<h4 id="Note-137"><a href="#Note-137" class="headerlink" title="Note"></a>Note</h4><p>This rule applies to all the usual comparison operators: <code>!=</code>, <code>&lt;</code>, <code>&lt;=</code>, <code>&gt;</code>, and <code>&gt;=</code>.</p>
<h5 id="Enforcement-110"><a href="#Enforcement-110" class="headerlink" title="Enforcement"></a>Enforcement</h5><ul>
<li>Flag a virtual <code>operator==()</code>; same for other comparison operators: <code>!=</code>, <code>&lt;</code>, <code>&lt;=</code>, <code>&gt;</code>, and <code>&gt;=</code>.</li>
</ul>
<h3 id="C-89-Make-a-hash-noexcept"><a href="#C-89-Make-a-hash-noexcept" class="headerlink" title="C.89: Make a hash noexcept"></a><a name="Rc-hash"></a>C.89: Make a <code>hash</code> <code>noexcept</code></h3><h5 id="Reason-118"><a href="#Reason-118" class="headerlink" title="Reason"></a>Reason</h5><p>Users of hashed containers use hash indirectly and don’t expect simple access to throw.<br>It’s a standard-library requirement.</p>
<h5 id="Example-bad-47"><a href="#Example-bad-47" class="headerlink" title="Example, bad"></a>Example, bad</h5><pre><code>template&lt;&gt;
struct hash&lt;My_type&gt; &#123;  // thoroughly bad hash specialization
    using result_type = size_t;
    using argument_type = My_type;

    size_t operator() (const My_type &amp; x) const
    &#123;
        size_t xs = x.s.size();
        if (xs &lt; 4) throw Bad_My_type&#123;&#125;;    // &quot;Nobody expects the Spanish inquisition!&quot;
        return hash&lt;size_t&gt;()(x.s.size()) ^ trim(x.s);
    &#125;
&#125;;

int main()
&#123;
    unordered_map&lt;My_type, int&gt; m;
    My_type mt&#123; &quot;asdfg&quot; &#125;;
    m[mt] = 7;
    cout &lt;&lt; m[My_type&#123; &quot;asdfg&quot; &#125;] &lt;&lt; &#39;\n&#39;;
&#125;
</code></pre>
<p>If you have to define a <code>hash</code> specialization, try simply to let it combine standard-library <code>hash</code> specializations with <code>^</code> (xor).<br>That tends to work better than “cleverness” for non-specialists.</p>
<h5 id="Enforcement-111"><a href="#Enforcement-111" class="headerlink" title="Enforcement"></a>Enforcement</h5><ul>
<li>Flag throwing <code>hash</code>es.</li>
</ul>
<h2 id="C-con-Containers-and-other-resource-handles"><a href="#C-con-Containers-and-other-resource-handles" class="headerlink" title="C.con: Containers and other resource handles"></a><a name="SS-containers"></a>C.con: Containers and other resource handles</h2><p>A container is an object holding a sequence of objects of some type; <code>std::vector</code> is the archetypical container.<br>A resource handle is a class that owns a resource; <code>std::vector</code> is the typical resource handle; its resource is its sequence of elements.</p>
<p>Summary of container rules:</p>
<ul>
<li><a href="#Rcon-stl">C.100: Follow the STL when defining a container</a></li>
<li><a href="#Rcon-val">C.101: Give a container value semantics</a></li>
<li><a href="#Rcon-move">C.102: Give a container move operations</a></li>
<li><a href="#Rcon-init">C.103: Give a container an initializer list constructor</a></li>
<li><a href="#Rcon-empty">C.104: Give a container a default constructor that sets it to empty</a></li>
<li><a href="#Rcon-val">C.105: Give a constructor and <code>Extent</code> constructor</a></li>
<li>???</li>
<li><a href="#rcon-ptr">C.109: If a resource handle has pointer semantics, provide <code>*</code> and <code>-&gt;</code></a></li>
</ul>
<p><strong>See also</strong>: <a href="#S-resource">Resources</a></p>
<h2 id="C-lambdas-Function-objects-and-lambdas"><a href="#C-lambdas-Function-objects-and-lambdas" class="headerlink" title="C.lambdas: Function objects and lambdas"></a><a name="SS-lambdas"></a>C.lambdas: Function objects and lambdas</h2><p>A function object is an object supplying an overloaded <code>()</code> so that you can call it.<br>A lambda expression (colloquially often shortened to “a lambda”) is a notation for generating a function object.<br>Function objects should be cheap to copy (and therefore <a href="#Rf-in">passed by value</a>).</p>
<p>Summary:</p>
<ul>
<li><a href="#Rf-capture-vs-overload">F.50: Use a lambda when a function won’t do (to capture local variables, or to write a local function)</a></li>
<li><a href="#Rf-reference-capture">F.52: Prefer capturing by reference in lambdas that will be used locally, including passed to algorithms</a></li>
<li><a href="#Rf-value-capture">F.53: Avoid capturing by reference in lambdas that will be used nonlocally, including returned, stored on the heap, or passed to another thread</a></li>
<li><a href="#Res-lambda-init">ES.28: Use lambdas for complex initialization, especially of <code>const</code> variables</a></li>
</ul>
<h2 id="C-hier-Class-hierarchies-OOP"><a href="#C-hier-Class-hierarchies-OOP" class="headerlink" title="C.hier: Class hierarchies (OOP)"></a><a name="SS-hier"></a>C.hier: Class hierarchies (OOP)</h2><p>A class hierarchy is constructed to represent a set of hierarchically organized concepts (only).<br>Typically base classes act as interfaces.<br>There are two major uses for hierarchies, often named implementation inheritance and interface inheritance.</p>
<p>Class hierarchy rule summary:</p>
<ul>
<li><a href="#Rh-domain">C.120: Use class hierarchies to represent concepts with inherent hierarchical structure (only)</a></li>
<li><a href="#Rh-abstract">C.121: If a base class is used as an interface, make it a pure abstract class</a></li>
<li><a href="#Rh-separation">C.122: Use abstract classes as interfaces when complete separation of interface and implementation is needed</a></li>
</ul>
<p>Designing rules for classes in a hierarchy summary:</p>
<ul>
<li><a href="#Rh-abstract-ctor">C.126: An abstract class typically doesn’t need a constructor</a></li>
<li><a href="#Rh-dtor">C.127: A class with a virtual function should have a virtual or protected destructor</a></li>
<li><a href="#Rh-override">C.128: Virtual functions should specify exactly one of <code>virtual</code>, <code>override</code>, or <code>final</code></a></li>
<li><a href="#Rh-kind">C.129: When designing a class hierarchy, distinguish between implementation inheritance and interface inheritance</a></li>
<li><a href="#Rh-copy">C.130: Redefine or prohibit copying for a base class; prefer a virtual <code>clone</code> function instead</a></li>
<li><a href="#Rh-get">C.131: Avoid trivial getters and setters</a></li>
<li><a href="#Rh-virtual">C.132: Don’t make a function <code>virtual</code> without reason</a></li>
<li><a href="#Rh-protected">C.133: Avoid <code>protected</code> data</a></li>
<li><a href="#Rh-public">C.134: Ensure all non-<code>const</code> data members have the same access level</a></li>
<li><a href="#Rh-mi-interface">C.135: Use multiple inheritance to represent multiple distinct interfaces</a></li>
<li><a href="#Rh-mi-implementation">C.136: Use multiple inheritance to represent the union of implementation attributes</a></li>
<li><a href="#Rh-vbase">C.137: Use <code>virtual</code> bases to avoid overly general base classes</a></li>
<li><a href="#Rh-using">C.138: Create an overload set for a derived class and its bases with <code>using</code></a></li>
<li><a href="#Rh-final">C.139: Use <code>final</code> sparingly</a></li>
<li><a href="#Rh-virtual-default-arg">C.140: Do not provide different default arguments for a virtual function and an overrider</a></li>
</ul>
<p>Accessing objects in a hierarchy rule summary:</p>
<ul>
<li><a href="#Rh-poly">C.145: Access polymorphic objects through pointers and references</a></li>
<li><a href="#Rh-dynamic_cast">C.146: Use <code>dynamic_cast</code> where class hierarchy navigation is unavoidable</a></li>
<li><a href="#Rh-ref-cast">C.147: Use <code>dynamic_cast</code> to a reference type when failure to find the required class is considered an error</a></li>
<li><a href="#Rh-ptr-cast">C.148: Use <code>dynamic_cast</code> to a pointer type when failure to find the required class is considered a valid alternative</a></li>
<li><a href="#Rh-smart">C.149: Use <code>unique_ptr</code> or <code>shared_ptr</code> to avoid forgetting to <code>delete</code> objects created using <code>new</code></a></li>
<li><a href="#Rh-make_unique">C.150: Use <code>make_unique()</code> to construct objects owned by <code>unique_ptr</code>s</a></li>
<li><a href="#Rh-make_shared">C.151: Use <code>make_shared()</code> to construct objects owned by <code>shared_ptr</code>s</a></li>
<li><a href="#Rh-array">C.152: Never assign a pointer to an array of derived class objects to a pointer to its base</a></li>
<li><a href="#Rh-use-virtual">C.153: Prefer virtual function to casting</a></li>
</ul>
<h3 id="C-120-Use-class-hierarchies-to-represent-concepts-with-inherent-hierarchical-structure-only"><a href="#C-120-Use-class-hierarchies-to-represent-concepts-with-inherent-hierarchical-structure-only" class="headerlink" title="C.120: Use class hierarchies to represent concepts with inherent hierarchical structure (only)"></a><a name="Rh-domain"></a>C.120: Use class hierarchies to represent concepts with inherent hierarchical structure (only)</h3><h5 id="Reason-119"><a href="#Reason-119" class="headerlink" title="Reason"></a>Reason</h5><p>Direct representation of ideas in code eases comprehension and maintenance. Make sure the idea represented in the base class exactly matches all derived types and there is not a better way to express it than using the tight coupling of inheritance.</p>
<p>Do <em>not</em> use inheritance when simply having a data member will do. Usually this means that the derived type needs to override a base virtual function or needs access to a protected member.</p>
<h5 id="Example-104"><a href="#Example-104" class="headerlink" title="Example"></a>Example</h5><pre><code>class DrawableUIElement &#123;
public:
    virtual void render() const = 0;
    // ...
&#125;;

class AbstractButton : public DrawableUIElement &#123;
public:
    virtual void onClick() = 0;
    // ...
&#125;;

class PushButton : public AbstractButton &#123;
    virtual void render() const override;
    virtual void onClick() override;
    // ...
&#125;;

class Checkbox : public AbstractButton &#123;
// ...
&#125;;
</code></pre>
<h5 id="Example-bad-48"><a href="#Example-bad-48" class="headerlink" title="Example, bad"></a>Example, bad</h5><p>Do <em>not</em> represent non-hierarchical domain concepts as class hierarchies.</p>
<pre><code>template&lt;typename T&gt;
class Container &#123;
public:
    // list operations:
    virtual T&amp; get() = 0;
    virtual void put(T&amp;) = 0;
    virtual void insert(Position) = 0;
    // ...
    // vector operations:
    virtual T&amp; operator[](int) = 0;
    virtual void sort() = 0;
    // ...
    // tree operations:
    virtual void balance() = 0;
    // ...
&#125;;
</code></pre>
<p>Here most overriding classes cannot implement most of the functions required in the interface well.<br>Thus the base class becomes an implementation burden.<br>Furthermore, the user of <code>Container</code> cannot rely on the member functions actually performing a meaningful operations reasonably efficiently;<br>it may throw an exception instead.<br>Thus users have to resort to run-time checking and/or<br>not using this (over)general interface in favor of a particular interface found by a run-time type inquiry (e.g., a <code>dynamic_cast</code>).</p>
<h5 id="Enforcement-112"><a href="#Enforcement-112" class="headerlink" title="Enforcement"></a>Enforcement</h5><ul>
<li>Look for classes with lots of members that do nothing but throw.</li>
<li>Flag every use of a nonpublic base class <code>B</code> where the derived class <code>D</code> does not override a virtual function or access a protected member in <code>B</code>, and <code>B</code> is not one of the following: empty, a template parameter or parameter pack of <code>D</code>, a class template specialized with <code>D</code>.</li>
</ul>
<h3 id="C-121-If-a-base-class-is-used-as-an-interface-make-it-a-pure-abstract-class"><a href="#C-121-If-a-base-class-is-used-as-an-interface-make-it-a-pure-abstract-class" class="headerlink" title="C.121: If a base class is used as an interface, make it a pure abstract class"></a><a name="Rh-abstract"></a>C.121: If a base class is used as an interface, make it a pure abstract class</h3><h5 id="Reason-120"><a href="#Reason-120" class="headerlink" title="Reason"></a>Reason</h5><p>A class is more stable (less brittle) if it does not contain data.<br>Interfaces should normally be composed entirely of public pure virtual functions and a default/empty virtual destructor.</p>
<h5 id="Example-105"><a href="#Example-105" class="headerlink" title="Example"></a>Example</h5><pre><code>class My_interface &#123;
public:
    // ...only pure virtual functions here ...
    virtual ~My_interface() &#123;&#125;   // or =default
&#125;;
</code></pre>
<h5 id="Example-bad-49"><a href="#Example-bad-49" class="headerlink" title="Example, bad"></a>Example, bad</h5><pre><code>class Goof &#123;
public:
    // ...only pure virtual functions here ...
    // no virtual destructor
&#125;;

class Derived : public Goof &#123;
    string s;
    // ...
&#125;;

void use()
&#123;
    unique_ptr&lt;Goof&gt; p &#123;new Derived&#123;&quot;here we go&quot;&#125;&#125;;
    f(p.get()); // use Derived through the Goof interface
    g(p.get()); // use Derived through the Goof interface
&#125; // leak
</code></pre>
<p>The <code>Derived</code> is <code>delete</code>d through its <code>Goof</code> interface, so its <code>string</code> is leaked.<br>Give <code>Goof</code> a virtual destructor and all is well.</p>
<h5 id="Enforcement-113"><a href="#Enforcement-113" class="headerlink" title="Enforcement"></a>Enforcement</h5><ul>
<li>Warn on any class that contains data members and also has an overridable (non-<code>final</code>) virtual function.</li>
</ul>
<h3 id="C-122-Use-abstract-classes-as-interfaces-when-complete-separation-of-interface-and-implementation-is-needed"><a href="#C-122-Use-abstract-classes-as-interfaces-when-complete-separation-of-interface-and-implementation-is-needed" class="headerlink" title="C.122: Use abstract classes as interfaces when complete separation of interface and implementation is needed"></a><a name="Rh-separation"></a>C.122: Use abstract classes as interfaces when complete separation of interface and implementation is needed</h3><h5 id="Reason-121"><a href="#Reason-121" class="headerlink" title="Reason"></a>Reason</h5><p>Such as on an ABI (link) boundary.</p>
<h5 id="Example-106"><a href="#Example-106" class="headerlink" title="Example"></a>Example</h5><pre><code>struct Device &#123;
    virtual ~Device() = default;
    virtual void write(span&lt;const char&gt; outbuf) = 0;
    virtual void read(span&lt;char&gt; inbuf) = 0;
&#125;;

class D1 : public Device &#123;
    // ... data ...

    void write(span&lt;const char&gt; outbuf) override;
    void read(span&lt;char&gt; inbuf) override;
&#125;;

class D2 : public Device &#123;
    // ... different data ...

    void write(span&lt;const char&gt; outbuf) override;
    void read(span&lt;char&gt; inbuf) override;
&#125;;
</code></pre>
<p>A user can now use <code>D1</code>s and <code>D2</code>s interchangeably through the interface provided by <code>Device</code>.<br>Furthermore, we can update <code>D1</code> and <code>D2</code> in a ways that are not binary compatible with older versions as long as all access goes through <code>Device</code>.</p>
<h5 id="Enforcement-114"><a href="#Enforcement-114" class="headerlink" title="Enforcement"></a>Enforcement</h5><pre><code>???
</code></pre>
<h2 id="C-hierclass-Designing-classes-in-a-hierarchy"><a href="#C-hierclass-Designing-classes-in-a-hierarchy" class="headerlink" title="C.hierclass: Designing classes in a hierarchy:"></a>C.hierclass: Designing classes in a hierarchy:</h2><h3 id="C-126-An-abstract-class-typically-doesn’t-need-a-constructor"><a href="#C-126-An-abstract-class-typically-doesn’t-need-a-constructor" class="headerlink" title="C.126: An abstract class typically doesn’t need a constructor"></a><a name="Rh-abstract-ctor"></a>C.126: An abstract class typically doesn’t need a constructor</h3><h5 id="Reason-122"><a href="#Reason-122" class="headerlink" title="Reason"></a>Reason</h5><p>An abstract class typically does not have any data for a constructor to initialize.</p>
<h5 id="Example-107"><a href="#Example-107" class="headerlink" title="Example"></a>Example</h5><pre><code>???
</code></pre>
<h5 id="Exception-22"><a href="#Exception-22" class="headerlink" title="Exception"></a>Exception</h5><ul>
<li>A base class constructor that does work, such as registering an object somewhere, may need a constructor.</li>
<li>In extremely rare cases, you might find it reasonable for an abstract class to have a bit of data shared by all derived classes<br>(e.g., use statistics data, debug information, etc.); such classes tend to have constructors. But be warned: Such classes also tend to be prone to requiring virtual inheritance.</li>
</ul>
<h5 id="Enforcement-115"><a href="#Enforcement-115" class="headerlink" title="Enforcement"></a>Enforcement</h5><p>Flag abstract classes with constructors.</p>
<h3 id="C-127-A-class-with-a-virtual-function-should-have-a-virtual-or-protected-destructor"><a href="#C-127-A-class-with-a-virtual-function-should-have-a-virtual-or-protected-destructor" class="headerlink" title="C.127: A class with a virtual function should have a virtual or protected destructor"></a><a name="Rh-dtor"></a>C.127: A class with a virtual function should have a virtual or protected destructor</h3><h5 id="Reason-123"><a href="#Reason-123" class="headerlink" title="Reason"></a>Reason</h5><p>A class with a virtual function is usually (and in general) used via a pointer to base. Usually, the last user has to call delete on a pointer to base, often via a smart pointer to base, so the destructor should be public and virtual. Less commonly, if deletion through a pointer to base is not intended to be supported, the destructor should be protected and nonvirtual; see <a href="#Rc-dtor-virtual">C.35</a>.</p>
<h5 id="Example-bad-50"><a href="#Example-bad-50" class="headerlink" title="Example, bad"></a>Example, bad</h5><pre><code>struct B &#123;
    virtual int f() = 0;
    // ... no user-written destructor, defaults to public nonvirtual ...
&#125;;

// bad: derived from a class without a virtual destructor
struct D : B &#123;
    string s &#123;&quot;default&quot;&#125;;
&#125;;

void use()
&#123;
    unique_ptr&lt;B&gt; p = make_unique&lt;D&gt;();
    // ...
&#125; // undefined behavior. May call B::~B only and leak the string
</code></pre>
<h5 id="Note-138"><a href="#Note-138" class="headerlink" title="Note"></a>Note</h5><p>There are people who don’t follow this rule because they plan to use a class only through a <code>shared_ptr</code>: <code>std::shared_ptr&lt;B&gt; p = std::make_shared&lt;D&gt;(args);</code> Here, the shared pointer will take care of deletion, so no leak will occur from an inappropriate <code>delete</code> of the base. People who do this consistently can get a false positive, but the rule is important – what if one was allocated using <code>make_unique</code>? It’s not safe unless the author of <code>B</code> ensures that it can never be misused, such as by making all constructors private and providing a factory function to enforce the allocation with <code>make_shared</code>.</p>
<h5 id="Enforcement-116"><a href="#Enforcement-116" class="headerlink" title="Enforcement"></a>Enforcement</h5><ul>
<li>A class with any virtual functions should have a destructor that is either public and virtual or else protected and nonvirtual.</li>
<li>Flag <code>delete</code> of a class with a virtual function but no virtual destructor.</li>
</ul>
<h3 id="C-128-Virtual-functions-should-specify-exactly-one-of-virtual-override-or-final"><a href="#C-128-Virtual-functions-should-specify-exactly-one-of-virtual-override-or-final" class="headerlink" title="C.128: Virtual functions should specify exactly one of virtual, override, or final"></a><a name="Rh-override"></a>C.128: Virtual functions should specify exactly one of <code>virtual</code>, <code>override</code>, or <code>final</code></h3><h5 id="Reason-124"><a href="#Reason-124" class="headerlink" title="Reason"></a>Reason</h5><p>Readability.<br>Detection of mistakes.<br>Writing explicit <code>virtual</code>, <code>override</code>, or <code>final</code> is self-documenting and enables the compiler to catch mismatch of types and/or names between base and derived classes. However, writing more than one of these three is both redundant and a potential source of errors.</p>
<p>Use <code>virtual</code> only when declaring a new virtual function. Use <code>override</code> only when declaring an overrider. Use <code>final</code> only when declaring a final overrider. If a base class destructor is declared <code>virtual</code>, one should avoid declaring derived class destructors  <code>virtual</code> or <code>override</code>. Some code base and tools might insist on <code>override</code> for destructors, but that is not the recommendation of these guidelines.</p>
<h5 id="Example-bad-51"><a href="#Example-bad-51" class="headerlink" title="Example, bad"></a>Example, bad</h5><pre><code>struct B &#123;
    void f1(int);
    virtual void f2(int) const;
    virtual void f3(int);
    // ...
&#125;;

struct D : B &#123;
    void f1(int);        // bad (hope for a warning): D::f1() hides B::f1()
    void f2(int) const;  // bad (but conventional and valid): no explicit override
    void f3(double);     // bad (hope for a warning): D::f3() hides B::f3()
    // ...
&#125;;
</code></pre>
<h5 id="Example-good-9"><a href="#Example-good-9" class="headerlink" title="Example, good"></a>Example, good</h5><pre><code>struct Better : B &#123;
    void f1(int) override;        // error (caught): D::f1() hides B::f1()
    void f2(int) const override;
    void f3(double) override;     // error (caught): D::f3() hides B::f3()
    // ...
&#125;;
</code></pre>
<h5 id="Enforcement-117"><a href="#Enforcement-117" class="headerlink" title="Enforcement"></a>Enforcement</h5><ul>
<li>Compare names in base and derived classes and flag uses of the same name that does not override.</li>
<li>Flag overrides with neither <code>override</code> nor <code>final</code>.</li>
<li>Flag function declarations that use more than one of <code>virtual</code>, <code>override</code>, and <code>final</code>.</li>
</ul>
<h3 id="C-129-When-designing-a-class-hierarchy-distinguish-between-implementation-inheritance-and-interface-inheritance"><a href="#C-129-When-designing-a-class-hierarchy-distinguish-between-implementation-inheritance-and-interface-inheritance" class="headerlink" title="C.129: When designing a class hierarchy, distinguish between implementation inheritance and interface inheritance"></a><a name="Rh-kind"></a>C.129: When designing a class hierarchy, distinguish between implementation inheritance and interface inheritance</h3><h5 id="Reason-125"><a href="#Reason-125" class="headerlink" title="Reason"></a>Reason</h5><p>Implementation details in an interface makes the interface brittle;<br>that is, makes its users vulnerable to having to recompile after changes in the implementation.<br>Data in a base class increases the complexity of implementing the base and can lead to replication of code.</p>
<h5 id="Note-139"><a href="#Note-139" class="headerlink" title="Note"></a>Note</h5><p>Definition:</p>
<ul>
<li>interface inheritance is the use of inheritance to separate users from implementations,<br>in particular to allow derived classes to be added and changed without affecting the users of base classes.</li>
<li>implementation inheritance is the use of inheritance to simplify implementation of new facilities<br>by making useful operations available for implementers of related new operations (sometimes called “programming by difference”).</li>
</ul>
<p>A pure interface class is simply a set of pure virtual functions; see <a href="#Ri-abstract">I.25</a>.</p>
<p>In early OOP (e.g., in the 1980s and 1990s), implementation inheritance and interface inheritance were often mixed<br>and bad habits die hard.<br>Even now, mixtures are not uncommon in old code bases and in old-style teaching material.</p>
<p>The importance of keeping the two kinds of inheritance increases</p>
<ul>
<li>with the size of a hierarchy (e.g., dozens of derived classes),</li>
<li>with the length of time the hierarchy is used (e.g., decades), and</li>
<li>with the number of distinct organizations in which a hierarchy is used<br>(e.g., it can be difficult to distribute an update to a base class)</li>
</ul>
<h5 id="Example-bad-52"><a href="#Example-bad-52" class="headerlink" title="Example, bad"></a>Example, bad</h5><pre><code>class Shape &#123;   // BAD, mixed interface and implementation
public:
    Shape();
    Shape(Point ce = &#123;0, 0&#125;, Color co = none): cent&#123;ce&#125;, col &#123;co&#125; &#123; /* ... */&#125;

    Point center() const &#123; return cent; &#125;
    Color color() const &#123; return col; &#125;

    virtual void rotate(int) = 0;
    virtual void move(Point p) &#123; cent = p; redraw(); &#125;

    virtual void redraw();

    // ...
private:
    Point cent;
    Color col;
&#125;;

class Circle : public Shape &#123;
public:
    Circle(Point c, int r) :Shape&#123;c&#125;, rad&#123;r&#125; &#123; /* ... */ &#125;

    // ...
private:
    int rad;
&#125;;

class Triangle : public Shape &#123;
public:
    Triangle(Point p1, Point p2, Point p3); // calculate center
    // ...
&#125;;
</code></pre>
<p>Problems:</p>
<ul>
<li>As the hierarchy grows and more data is added to <code>Shape</code>, the constructors gets harder to write and maintain.</li>
<li>Why calculate the center for the <code>Triangle</code>? we may never us it.</li>
<li>Add a data member to <code>Shape</code> (e.g., drawing style or canvas)<br>and all derived classes and all users needs to be reviewed, possibly changes, and probably recompiled.</li>
</ul>
<p>The implementation of <code>Shape::move()</code> is an example of implementation inheritance:<br>we have defined <code>move()</code> once and for all for all derived classes.<br>The more code there is in such base class member function implementations and the more data is shared by placing it in the base,<br>the more benefits we gain - and the less stable the hierarchy is.</p>
<h5 id="Example-108"><a href="#Example-108" class="headerlink" title="Example"></a>Example</h5><p>This Shape hierarchy can be rewritten using interface inheritance:</p>
<pre><code>class Shape &#123;  // pure interface
public:
    virtual Point center() const = 0;
    virtual Color color() const = 0;

    virtual void rotate(int) = 0;
    virtual void move(Point p) = 0;

    virtual void redraw() = 0;

    // ...
&#125;;
</code></pre>
<p>Note that a pure interface rarely have constructors: there is nothing to construct.</p>
<pre><code>class Circle : public Shape &#123;
public:
    Circle(Point c, int r, Color c) :cent&#123;c&#125;, rad&#123;r&#125;, col&#123;c&#125; &#123; /* ... */ &#125;

    Point center() const override &#123; return cent; &#125;
    Color color() const override &#123; return col; &#125;

    // ...
private:
    Point cent;
    int rad;
    Color col;
&#125;;
</code></pre>
<p>The interface is now less brittle, but there is more work in implementing the member functions.<br>For example, <code>center</code> has to be implemented by every class derived from <code>Shape</code>.</p>
<h5 id="Example-dual-hierarchy"><a href="#Example-dual-hierarchy" class="headerlink" title="Example, dual hierarchy"></a>Example, dual hierarchy</h5><p>How can we gain the benefit of the stable hierarchies from implementation hierarchies and the benefit of implementation reuse from implementation inheritance.<br>One popular technique is dual hierarchies.<br>There are many ways of implementing the idea of dual hierarchies; here, we use a multiple-inheritance variant.</p>
<p>First we devise a hierarchy of interface classes:</p>
<pre><code>class Shape &#123;   // pure interface
public:
    virtual Point center() const = 0;
    virtual Color color() const = 0;

    virtual void rotate(int) = 0;
    virtual void move(Point p) = 0;

    virtual void redraw() = 0;

    // ...
&#125;;

class Circle : public Shape &#123;   // pure interface
public:
    virtual int radius() = 0;
    // ...
&#125;;
</code></pre>
<p>To make this interface useful, we must provide its implementation classes (here, named equivalently, but in the <code>Impl</code> namespace):</p>
<pre><code>class Impl::Shape : public Shape &#123; // implementation
public:
    // constructors, destructor
    // ...
    Point center() const override &#123; /* ... */ &#125;
    Color color() const override &#123; /* ... */ &#125;

    void rotate(int) override &#123; /* ... */ &#125;
    void move(Point p) override &#123; /* ... */ &#125;

    void redraw() override &#123; /* ... */ &#125;

    // ...
&#125;;
</code></pre>
<p>Now <code>Shape</code> is a poor example of a class with an implementation,<br>but bear with us because this is just a simple example of a technique aimed at more complex hierarchies.</p>
<pre><code>class Impl::Circle : public Circle, public Impl::Shape &#123;   // implementation
public:
    // constructors, destructor

    int radius() override &#123; /* ... */ &#125;
    // ...
&#125;;
</code></pre>
<p>And we could extend the hierarchies by adding a Smiley class (:-)):</p>
<pre><code>class Smiley : public Circle &#123; // pure interface
public:
    // ...
&#125;;

class Impl::Smiley : public Smiley, public Impl::Circle &#123;   // implementation
public:
    // constructors, destructor
    // ...
&#125;
</code></pre>
<p>There are now two hierarchies:</p>
<ul>
<li>interface: Smiley -&gt; Circle -&gt; Shape</li>
<li>implementation: Impl::Smiley -&gt; Impl::Circle -&gt; Impl::Shape</li>
</ul>
<p>Since each implementation derived from its interface as well as its implementation base class we get a lattice (DAG):</p>
<pre><code>Smiley     -&gt;         Circle     -&gt;  Shape
  ^                     ^               ^
  |                     |               |
Impl::Smiley -&gt; Impl::Circle -&gt; Impl::Shape
</code></pre>
<p>As mentioned, this is just one way to construct a dual hierarchy.</p>
<p>The implementation hierarchy can be used directly, rather than through the abstract interface.</p>
<pre><code>void work_with_shape(Shape&amp;);

int user()
&#123;
    Impl::Smiley my_smiley&#123; /* args */ &#125;;   // create concrete shape
    // ...
    my_smiley.some_member();        // use implementation class directly
    // ...
    work_with_shape(my_smiley);     // use implementation through abstract interface
    // ...
&#125;
</code></pre>
<p>This can be useful when the implementation class has members that are not offered in the abstract interface<br>or if direct use of a member offers optimization opportunities (e.g., if an implementation member function is <code>final</code>)</p>
<h5 id="Note-140"><a href="#Note-140" class="headerlink" title="Note"></a>Note</h5><p>Another (related) technique for separating interface and implementation is <a href="#Ri-pimpl">Pimpl</a>.</p>
<h5 id="Note-141"><a href="#Note-141" class="headerlink" title="Note"></a>Note</h5><p>There is often a choice between offering common functionality as (implemented) base class functions and free-standing functions<br>(in an implementation namespace).<br>Base classes gives a shorter notation and easier access to shared data (in the base)<br>at the cost of the functionality being available only to users of the hierarchy.</p>
<h5 id="Enforcement-118"><a href="#Enforcement-118" class="headerlink" title="Enforcement"></a>Enforcement</h5><ul>
<li>Flag a derived to base conversion to a base with both data and virtual functions<br>(except for calls from a derived class member to a base class member)</li>
<li>???</li>
</ul>
<h3 id="C-130-Redefine-or-prohibit-copying-for-a-base-class-prefer-a-virtual-clone-function-instead"><a href="#C-130-Redefine-or-prohibit-copying-for-a-base-class-prefer-a-virtual-clone-function-instead" class="headerlink" title="C.130: Redefine or prohibit copying for a base class; prefer a virtual clone function instead"></a><a name="Rh-copy"></a>C.130: Redefine or prohibit copying for a base class; prefer a virtual <code>clone</code> function instead</h3><h5 id="Reason-126"><a href="#Reason-126" class="headerlink" title="Reason"></a>Reason</h5><p>Copying a base is usually slicing. If you really need copy semantics, copy deeply: Provide a virtual <code>clone</code> function that will copy the actual most-derived type and return an owning pointer to the new object, and then in derived classes return the derived type (use a covariant return type).</p>
<h5 id="Example-109"><a href="#Example-109" class="headerlink" title="Example"></a>Example</h5><pre><code>class Base &#123;
public:
    virtual owner&lt;Base*&gt; clone() = 0;
    virtual ~Base() = 0;

    Base(const Base&amp;) = delete;
    Base&amp; operator=(const Base&amp;) = delete;
&#125;;

class Derived : public Base &#123;
public:
    owner&lt;Derived*&gt; clone() override;
    virtual ~Derived() override;
&#125;;
</code></pre>
<p>Note that because of language rules, the covariant return type cannot be a smart pointer. See also <a href="#Rc-copy-virtual">C.67</a>.</p>
<h5 id="Enforcement-119"><a href="#Enforcement-119" class="headerlink" title="Enforcement"></a>Enforcement</h5><ul>
<li>Flag a class with a virtual function and a non-user-defined copy operation.</li>
<li>Flag an assignment of base class objects (objects of a class from which another has been derived).</li>
</ul>
<h3 id="C-131-Avoid-trivial-getters-and-setters"><a href="#C-131-Avoid-trivial-getters-and-setters" class="headerlink" title="C.131: Avoid trivial getters and setters"></a><a name="Rh-get"></a>C.131: Avoid trivial getters and setters</h3><h5 id="Reason-127"><a href="#Reason-127" class="headerlink" title="Reason"></a>Reason</h5><p>A trivial getter or setter adds no semantic value; the data item could just as well be <code>public</code>.</p>
<h5 id="Example-110"><a href="#Example-110" class="headerlink" title="Example"></a>Example</h5><pre><code>class Point &#123;   // Bad: verbose
    int x;
    int y;
public:
    Point(int xx, int yy) : x&#123;xx&#125;, y&#123;yy&#125; &#123; &#125;
    int get_x() const &#123; return x; &#125;
    void set_x(int xx) &#123; x = xx; &#125;
    int get_y() const &#123; return y; &#125;
    void set_y(int yy) &#123; y = yy; &#125;
    // no behavioral member functions
&#125;;
</code></pre>
<p>Consider making such a class a <code>struct</code> – that is, a behaviorless bunch of variables, all public data and no member functions.</p>
<pre><code>struct Point &#123;
    int x &#123;0&#125;;
    int y &#123;0&#125;;
&#125;;
</code></pre>
<p>Note that we can put default initializers on member variables: <a href="#Rc-initialize">C.49: Prefer initialization to assignment in constructors</a>.</p>
<h5 id="Note-142"><a href="#Note-142" class="headerlink" title="Note"></a>Note</h5><p>The key to this rule is whether the semantics of the getter/setter are trivial. While it is not a complete definition of “trivial”, consider whether there would be any difference beyond syntax if the getter/setter was a public data member instead. Examples of non-trivial semantics would be: maintaining a class invariant or converting between an internal type and an interface type.</p>
<h5 id="Enforcement-120"><a href="#Enforcement-120" class="headerlink" title="Enforcement"></a>Enforcement</h5><p>Flag multiple <code>get</code> and <code>set</code> member functions that simply access a member without additional semantics.</p>
<h3 id="C-132-Don’t-make-a-function-virtual-without-reason"><a href="#C-132-Don’t-make-a-function-virtual-without-reason" class="headerlink" title="C.132: Don’t make a function virtual without reason"></a><a name="Rh-virtual"></a>C.132: Don’t make a function <code>virtual</code> without reason</h3><h5 id="Reason-128"><a href="#Reason-128" class="headerlink" title="Reason"></a>Reason</h5><p>Redundant <code>virtual</code> increases run-time and object-code size.<br>A virtual function can be overridden and is thus open to mistakes in a derived class.<br>A virtual function ensures code replication in a templated hierarchy.</p>
<h5 id="Example-bad-53"><a href="#Example-bad-53" class="headerlink" title="Example, bad"></a>Example, bad</h5><pre><code>template&lt;class T&gt;
class Vector &#123;
public:
    // ...
    virtual int size() const &#123; return sz; &#125;   // bad: what good could a derived class do?
private:
    T* elem;   // the elements
    int sz;    // number of elements
&#125;;
</code></pre>
<p>This kind of “vector” isn’t meant to be used as a base class at all.</p>
<h5 id="Enforcement-121"><a href="#Enforcement-121" class="headerlink" title="Enforcement"></a>Enforcement</h5><ul>
<li>Flag a class with virtual functions but no derived classes.</li>
<li>Flag a class where all member functions are virtual and have implementations.</li>
</ul>
<h3 id="C-133-Avoid-protected-data"><a href="#C-133-Avoid-protected-data" class="headerlink" title="C.133: Avoid protected data"></a><a name="Rh-protected"></a>C.133: Avoid <code>protected</code> data</h3><h5 id="Reason-129"><a href="#Reason-129" class="headerlink" title="Reason"></a>Reason</h5><p><code>protected</code> data is a source of complexity and errors.<br><code>protected</code> data complicates the statement of invariants.<br><code>protected</code> data inherently violates the guidance against putting data in base classes, which usually leads to having to deal with virtual inheritance as well.</p>
<h5 id="Example-bad-54"><a href="#Example-bad-54" class="headerlink" title="Example, bad"></a>Example, bad</h5><pre><code>class Shape &#123;
public:
    // ... interface functions ...
protected:
    // data for use in derived classes:
    Color fill_color;
    Color edge_color;
    Style st;
&#125;;
</code></pre>
<p>Now it is up to every derived <code>Shape</code> to manipulate the protected data correctly.<br>This has been popular, but also a major source of maintenance problems.<br>In a large class hierarchy, the consistent use of protected data is hard to maintain because there can be a lot of code,<br>spread over a lot of classes.<br>The set of classes that can touch that data is open: anyone can derive a new class and start manipulating the protected data.<br>Often, it is not possible to examine the complete set of classes, so any change to the representation of the class becomes infeasible.<br>There is no enforced invariant for the protected data; it is much like a set of global variables.<br>The protected data has de facto become global to a large body of code.</p>
<h5 id="Note-143"><a href="#Note-143" class="headerlink" title="Note"></a>Note</h5><p>Protected data often looks tempting to enable arbitrary improvements through derivation.<br>Often, what you get is unprincipled changes and errors.<br><a href="#Rc-private">Prefer <code>private</code> data</a> with a well-specified and enforced invariant.<br>Alternative, and often better, <a href="#Rh-abstract">keep data out of any class used as an interface</a>.</p>
<h5 id="Note-144"><a href="#Note-144" class="headerlink" title="Note"></a>Note</h5><p>Protected member function can be just fine.</p>
<h5 id="Enforcement-122"><a href="#Enforcement-122" class="headerlink" title="Enforcement"></a>Enforcement</h5><p>Flag classes with <code>protected</code> data.</p>
<h3 id="C-134-Ensure-all-non-const-data-members-have-the-same-access-level"><a href="#C-134-Ensure-all-non-const-data-members-have-the-same-access-level" class="headerlink" title="C.134: Ensure all non-const data members have the same access level"></a><a name="Rh-public"></a>C.134: Ensure all non-<code>const</code> data members have the same access level</h3><h5 id="Reason-130"><a href="#Reason-130" class="headerlink" title="Reason"></a>Reason</h5><p>Prevention of logical confusion leading to errors.<br>If the non-<code>const</code> data members don’t have the same access level, the type is confused about what it’s trying to do.<br>Is it a type that maintains an invariant or simply a collection of values?</p>
<h5 id="Discussion-3"><a href="#Discussion-3" class="headerlink" title="Discussion"></a>Discussion</h5><p>The core question is: What code is responsible for maintaining a meaningful/correct value for that variable?</p>
<p>There are exactly two kinds of data members:</p>
<ul>
<li>A: Ones that don’t participate in the object’s invariant. Any combination of values for these members is valid.</li>
<li>B: Ones that do participate in the object’s invariant. Not every combination of values is meaningful (else there’d be no invariant). Therefore all code that has write access to these variables must know about the invariant, know the semantics, and know (and actively implement and enforce) the rules for keeping the values correct.</li>
</ul>
<p>Data members in category A should just be <code>public</code> (or, more rarely, <code>protected</code> if you only want derived classes to see them). They don’t need encapsulation. All code in the system might as well see and manipulate them.</p>
<p>Data members in category B should be <code>private</code> or <code>const</code>. This is because encapsulation is important. To make them non-<code>private</code> and non-<code>const</code> would mean that the object can’t control its own state: An unbounded amount of code beyond the class would need to know about the invariant and participate in maintaining it accurately – if these data members were <code>public</code>, that would be all calling code that uses the object; if they were <code>protected</code>, it would be all the code in current and future derived classes. This leads to brittle and tightly coupled code that quickly becomes a nightmare to maintain. Any code that inadvertently sets the data members to an invalid or unexpected combination of values would corrupt the object and all subsequent uses of the object.</p>
<p>Most classes are either all A or all B:</p>
<ul>
<li><em>All public</em>: If you’re writing an aggregate bundle-of-variables without an invariant across those variables, then all the variables should be <code>public</code>.<br><a href="#Rc-struct">By convention, declare such classes <code>struct</code> rather than <code>class</code></a></li>
<li><em>All private</em>: If you’re writing a type that maintains an invariant, then all the non-<code>const</code> variables should be private – it should be encapsulated.</li>
</ul>
<h5 id="Exception-23"><a href="#Exception-23" class="headerlink" title="Exception"></a>Exception</h5><p>Occasionally classes will mix A and B, usually for debug reasons. An encapsulated object may contain something like non-<code>const</code> debug instrumentation that isn’t part of the invariant and so falls into category A – it isn’t really part of the object’s value or meaningful observable state either. In that case, the A parts should be treated as A’s (made <code>public</code>, or in rarer cases <code>protected</code> if they should be visible only to derived classes) and the B parts should still be treated like B’s (<code>private</code> or <code>const</code>).</p>
<h5 id="Enforcement-123"><a href="#Enforcement-123" class="headerlink" title="Enforcement"></a>Enforcement</h5><p>Flag any class that has non-<code>const</code> data members with different access levels.</p>
<h3 id="C-135-Use-multiple-inheritance-to-represent-multiple-distinct-interfaces"><a href="#C-135-Use-multiple-inheritance-to-represent-multiple-distinct-interfaces" class="headerlink" title="C.135: Use multiple inheritance to represent multiple distinct interfaces"></a><a name="Rh-mi-interface"></a>C.135: Use multiple inheritance to represent multiple distinct interfaces</h3><h5 id="Reason-131"><a href="#Reason-131" class="headerlink" title="Reason"></a>Reason</h5><p>Not all classes will necessarily support all interfaces, and not all callers will necessarily want to deal with all operations.<br>Especially to break apart monolithic interfaces into “aspects” of behavior supported by a given derived class.</p>
<h5 id="Example-111"><a href="#Example-111" class="headerlink" title="Example"></a>Example</h5><pre><code>class iostream : public istream, public ostream &#123;   // very simplified
    // ...
&#125;;
</code></pre>
<p><code>istream</code> provides the interface to input operations; <code>ostream</code> provides the interface to output operations.<br><code>iostream</code> provides the union of the <code>istream</code> and <code>ostream</code> interfaces and the synchronization needed to allow both on a single stream.</p>
<h5 id="Note-145"><a href="#Note-145" class="headerlink" title="Note"></a>Note</h5><p>This is a very common use of inheritance because the need for multiple different interfaces to an implementation is common<br>and such interfaces are often not easily or naturally organized into a single-rooted hierarchy.</p>
<h5 id="Note-146"><a href="#Note-146" class="headerlink" title="Note"></a>Note</h5><p>Such interfaces are typically abstract classes.</p>
<h5 id="Enforcement-124"><a href="#Enforcement-124" class="headerlink" title="Enforcement"></a>Enforcement</h5><p>???</p>
<h3 id="C-136-Use-multiple-inheritance-to-represent-the-union-of-implementation-attributes"><a href="#C-136-Use-multiple-inheritance-to-represent-the-union-of-implementation-attributes" class="headerlink" title="C.136: Use multiple inheritance to represent the union of implementation attributes"></a><a name="Rh-mi-implementation"></a>C.136: Use multiple inheritance to represent the union of implementation attributes</h3><h5 id="Reason-132"><a href="#Reason-132" class="headerlink" title="Reason"></a>Reason</h5><p>Some forms of mixins have state and often operations on that state.<br>If the operations are virtual the use of inheritance is necessary, if not using inheritance can avoid boilerplate and forwarding.</p>
<h5 id="Example-112"><a href="#Example-112" class="headerlink" title="Example"></a>Example</h5><pre><code>class iostream : public istream, public ostream &#123;   // very simplified
    // ...
&#125;;
</code></pre>
<p><code>istream</code> provides the interface to input operations (and some data); <code>ostream</code> provides the interface to output operations (and some data).<br><code>iostream</code> provides the union of the <code>istream</code> and <code>ostream</code> interfaces and the synchronization needed to allow both on a single stream.</p>
<h5 id="Note-147"><a href="#Note-147" class="headerlink" title="Note"></a>Note</h5><p>This a relatively rare use because implementation can often be organized into a single-rooted hierarchy.</p>
<h5 id="Example-113"><a href="#Example-113" class="headerlink" title="Example"></a>Example</h5><p>Sometimes, an “implementation attribute” is more like a “mixin” that determine the behavior of an implementation and inject<br>members to enable the implementation of the policies it requires.<br>For example, see <code>std::enable_shared_from_this</code><br>or various bases from boost.intrusive (e.g. <code>list_base_hook</code> or <code>intrusive_ref_counter</code>).</p>
<h5 id="Enforcement-125"><a href="#Enforcement-125" class="headerlink" title="Enforcement"></a>Enforcement</h5><p>???</p>
<h3 id="C-137-Use-virtual-bases-to-avoid-overly-general-base-classes"><a href="#C-137-Use-virtual-bases-to-avoid-overly-general-base-classes" class="headerlink" title="C.137: Use virtual bases to avoid overly general base classes"></a><a name="Rh-vbase"></a>C.137: Use <code>virtual</code> bases to avoid overly general base classes</h3><h5 id="Reason-133"><a href="#Reason-133" class="headerlink" title="Reason"></a>Reason</h5><p> Allow separation of shared data and interface.<br> To avoid all shared data to being put into an ultimate base class.</p>
<h5 id="Example-114"><a href="#Example-114" class="headerlink" title="Example"></a>Example</h5><pre><code>struct Interface &#123;
    virtual void f();
    virtual int g();
    // ... no data here ...
&#125;;

class Utility &#123;  // with data
    void utility1();
    virtual void utility2();    // customization point
public:
    int x;
    int y;
&#125;;

class Derive1 : public Interface, virtual protected Utility &#123;
    // override Interface functions
    // Maybe override Utility virtual functions
    // ...
&#125;;

class Derive2 : public Interface, virtual protected Utility &#123;
    // override Interface functions
    // Maybe override Utility virtual functions
    // ...
&#125;;
</code></pre>
<p>Factoring out <code>Utility</code> makes sense if many derived classes share significant “implementation details.”</p>
<h5 id="Note-148"><a href="#Note-148" class="headerlink" title="Note"></a>Note</h5><p>Obviously, the example is too “theoretical”, but it is hard to find a <em>small</em> realistic example.<br><code>Interface</code> is the root of an <a href="#Rh-abstract">interface hierarchy</a><br>and <code>Utility</code> is the root of an <a href="#Rh-kind">implementation hierarchy</a>.<br>Here is <a href="https://www.quora.com/What-are-the-uses-and-advantages-of-virtual-base-class-in-C%2B%2B/answer/Lance-Diduck">a slightly more realistic example</a> with an explanation.</p>
<h5 id="Note-149"><a href="#Note-149" class="headerlink" title="Note"></a>Note</h5><p>Often, linearization of a hierarchy is a better solution.</p>
<h5 id="Enforcement-126"><a href="#Enforcement-126" class="headerlink" title="Enforcement"></a>Enforcement</h5><p>Flag mixed interface and implementation hierarchies.</p>
<h3 id="C-138-Create-an-overload-set-for-a-derived-class-and-its-bases-with-using"><a href="#C-138-Create-an-overload-set-for-a-derived-class-and-its-bases-with-using" class="headerlink" title="C.138: Create an overload set for a derived class and its bases with using"></a><a name="Rh-using"></a>C.138: Create an overload set for a derived class and its bases with <code>using</code></h3><h5 id="Reason-134"><a href="#Reason-134" class="headerlink" title="Reason"></a>Reason</h5><p>Without a using declaration, member functions in the derived class hide the entire inherited overload sets.</p>
<h5 id="Example-bad-55"><a href="#Example-bad-55" class="headerlink" title="Example, bad"></a>Example, bad</h5><pre><code>#include &lt;iostream&gt;
class B &#123;
public:
    virtual int f(int i) &#123; std::cout &lt;&lt; &quot;f(int): &quot;; return i; &#125;
    virtual double f(double d) &#123; std::cout &lt;&lt; &quot;f(double): &quot;; return d; &#125;
&#125;;
class D: public B &#123;
public:
    int f(int i) override &#123; std::cout &lt;&lt; &quot;f(int): &quot;; return i + 1; &#125;
&#125;;
int main()
&#123;
    D d;
    std::cout &lt;&lt; d.f(2) &lt;&lt; &#39;\n&#39;;   // prints &quot;f(int): 3&quot;
    std::cout &lt;&lt; d.f(2.3) &lt;&lt; &#39;\n&#39;; // prints &quot;f(int): 3&quot;
&#125;
</code></pre>
<h5 id="Example-good-10"><a href="#Example-good-10" class="headerlink" title="Example, good"></a>Example, good</h5><pre><code>class D: public B &#123;
public:
    int f(int i) override &#123; std::cout &lt;&lt; &quot;f(int): &quot;; return i + 1; &#125;
    using B::f; // exposes f(double)
&#125;;
</code></pre>
<h5 id="Note-150"><a href="#Note-150" class="headerlink" title="Note"></a>Note</h5><p>This issue affects both virtual and nonvirtual member functions</p>
<p>For variadic bases, C++17 introduced a variadic form of the using-declaration,</p>
<pre><code>template &lt;class... Ts&gt;
struct Overloader : Ts... &#123;
    using Ts::operator()...; // exposes operator() from every base
&#125;;
</code></pre>
<h5 id="Enforcement-127"><a href="#Enforcement-127" class="headerlink" title="Enforcement"></a>Enforcement</h5><p>Diagnose name hiding</p>
<h3 id="C-139-Use-final-sparingly"><a href="#C-139-Use-final-sparingly" class="headerlink" title="C.139: Use final sparingly"></a><a name="Rh-final"></a>C.139: Use <code>final</code> sparingly</h3><h5 id="Reason-135"><a href="#Reason-135" class="headerlink" title="Reason"></a>Reason</h5><p>Capping a hierarchy with <code>final</code> is rarely needed for logical reasons and can be damaging to the extensibility of a hierarchy.</p>
<h5 id="Example-bad-56"><a href="#Example-bad-56" class="headerlink" title="Example, bad"></a>Example, bad</h5><pre><code>class Widget &#123; /* ... */ &#125;;

// nobody will ever want to improve My_widget (or so you thought)
class My_widget final : public Widget &#123; /* ... */ &#125;;

class My_improved_widget : public My_widget &#123; /* ... */ &#125;;  // error: can&#39;t do that
</code></pre>
<h5 id="Note-151"><a href="#Note-151" class="headerlink" title="Note"></a>Note</h5><p>Not every class is meant to be a base class.<br>Most standard-library classes are examples of that (e.g., <code>std::vector</code> and <code>std::string</code> are not designed to be derived from).<br>This rule is about using <code>final</code> on classes with virtual functions meant to be interfaces for a class hierarchy.</p>
<h5 id="Note-152"><a href="#Note-152" class="headerlink" title="Note"></a>Note</h5><p>Capping an individual virtual function with <code>final</code> is error-prone as <code>final</code> can easily be overlooked when defining/overriding a set of functions.<br>Fortunately, the compiler catches such mistakes: You cannot re-declare/re-open a <code>final</code> member in a derived class.</p>
<h5 id="Note-153"><a href="#Note-153" class="headerlink" title="Note"></a>Note</h5><p>Claims of performance improvements from <code>final</code> should be substantiated.<br>Too often, such claims are based on conjecture or experience with other languages.</p>
<p>There are examples where <code>final</code> can be important for both logical and performance reasons.<br>One example is a performance-critical AST hierarchy in a compiler or language analysis tool.<br>New derived classes are not added every year and only by library implementers.<br>However, misuses are (or at least have been) far more common.</p>
<h5 id="Enforcement-128"><a href="#Enforcement-128" class="headerlink" title="Enforcement"></a>Enforcement</h5><p>Flag uses of <code>final</code>.</p>
<h2 id="C-140-Do-not-provide-different-default-arguments-for-a-virtual-function-and-an-overrider"><a href="#C-140-Do-not-provide-different-default-arguments-for-a-virtual-function-and-an-overrider" class="headerlink" title="C.140: Do not provide different default arguments for a virtual function and an overrider"></a><a name="Rh-virtual-default-arg"></a>C.140: Do not provide different default arguments for a virtual function and an overrider</h2><h5 id="Reason-136"><a href="#Reason-136" class="headerlink" title="Reason"></a>Reason</h5><p>That can cause confusion: An overrider does not inherit default arguments.</p>
<h5 id="Example-bad-57"><a href="#Example-bad-57" class="headerlink" title="Example, bad"></a>Example, bad</h5><pre><code>class Base &#123;
public:
    virtual int multiply(int value, int factor = 2) = 0;
&#125;;

class Derived : public Base &#123;
public:
    int multiply(int value, int factor = 10) override;
&#125;;

Derived d;
Base&amp; b = d;

b.multiply(10);  // these two calls will call the same function but
d.multiply(10);  // with different arguments and so different results
</code></pre>
<h5 id="Enforcement-129"><a href="#Enforcement-129" class="headerlink" title="Enforcement"></a>Enforcement</h5><p>Flag default arguments on virtual functions if they differ between base and derived declarations.</p>
<h2 id="C-hier-access-Accessing-objects-in-a-hierarchy"><a href="#C-hier-access-Accessing-objects-in-a-hierarchy" class="headerlink" title="C.hier-access: Accessing objects in a hierarchy"></a>C.hier-access: Accessing objects in a hierarchy</h2><h3 id="C-145-Access-polymorphic-objects-through-pointers-and-references"><a href="#C-145-Access-polymorphic-objects-through-pointers-and-references" class="headerlink" title="C.145: Access polymorphic objects through pointers and references"></a><a name="Rh-poly"></a>C.145: Access polymorphic objects through pointers and references</h3><h5 id="Reason-137"><a href="#Reason-137" class="headerlink" title="Reason"></a>Reason</h5><p>If you have a class with a virtual function, you don’t (in general) know which class provided the function to be used.</p>
<h5 id="Example-115"><a href="#Example-115" class="headerlink" title="Example"></a>Example</h5><pre><code>struct B &#123; int a; virtual int f(); &#125;;
struct D : B &#123; int b; int f() override; &#125;;

void use(B b)
&#123;
    D d;
    B b2 = d;   // slice
    B b3 = b;
&#125;

void use2()
&#123;
    D d;
    use(d);   // slice
&#125;
</code></pre>
<p>Both <code>d</code>s are sliced.</p>
<h5 id="Exception-24"><a href="#Exception-24" class="headerlink" title="Exception"></a>Exception</h5><p>You can safely access a named polymorphic object in the scope of its definition, just don’t slice it.</p>
<pre><code>void use3()
&#123;
    D d;
    d.f();   // OK
&#125;
</code></pre>
<h5 id="Enforcement-130"><a href="#Enforcement-130" class="headerlink" title="Enforcement"></a>Enforcement</h5><p>Flag all slicing.</p>
<h3 id="C-146-Use-dynamic-cast-where-class-hierarchy-navigation-is-unavoidable"><a href="#C-146-Use-dynamic-cast-where-class-hierarchy-navigation-is-unavoidable" class="headerlink" title="C.146: Use dynamic_cast where class hierarchy navigation is unavoidable"></a><a name="Rh-dynamic_cast"></a>C.146: Use <code>dynamic_cast</code> where class hierarchy navigation is unavoidable</h3><h5 id="Reason-138"><a href="#Reason-138" class="headerlink" title="Reason"></a>Reason</h5><p><code>dynamic_cast</code> is checked at run time.</p>
<h5 id="Example-116"><a href="#Example-116" class="headerlink" title="Example"></a>Example</h5><pre><code>struct B &#123;   // an interface
    virtual void f();
    virtual void g();
&#125;;

struct D : B &#123;   // a wider interface
    void f() override;
    virtual void h();
&#125;;

void user(B* pb)
&#123;
    if (D* pd = dynamic_cast&lt;D*&gt;(pb)) &#123;
        // ... use D&#39;s interface ...
    &#125;
    else &#123;
        // ... make do with B&#39;s interface ...
    &#125;
&#125;
</code></pre>
<p>Use of the other casts can violate type safety and cause the program to access a variable that is actually of type <code>X</code> to be accessed as if it were of an unrelated type <code>Z</code>:</p>
<pre><code>void user2(B* pb)   // bad
&#123;
    D* pd = static_cast&lt;D*&gt;(pb);    // I know that pb really points to a D; trust me
    // ... use D&#39;s interface ...
&#125;

void user3(B* pb)    // unsafe
&#123;
    if (some_condition) &#123;
        D* pd = static_cast&lt;D*&gt;(pb);   // I know that pb really points to a D; trust me
        // ... use D&#39;s interface ...
    &#125;
    else &#123;
        // ... make do with B&#39;s interface ...
    &#125;
&#125;

void f()
&#123;
    B b;
    user(&amp;b);   // OK
    user2(&amp;b);  // bad error
    user3(&amp;b);  // OK *if* the programmer got the some_condition check right
&#125;
</code></pre>
<h5 id="Note-154"><a href="#Note-154" class="headerlink" title="Note"></a>Note</h5><p>Like other casts, <code>dynamic_cast</code> is overused.<br><a href="#Rh-use-virtual">Prefer virtual functions to casting</a>.<br>Prefer <a href="#???">static polymorphism</a> to hierarchy navigation where it is possible (no run-time resolution necessary)<br>and reasonably convenient.</p>
<h5 id="Note-155"><a href="#Note-155" class="headerlink" title="Note"></a>Note</h5><p>Some people use <code>dynamic_cast</code> where a <code>typeid</code> would have been more appropriate;<br><code>dynamic_cast</code> is a general “is kind of” operation for discovering the best interface to an object,<br>whereas <code>typeid</code> is a “give me the exact type of this object” operation to discover the actual type of an object.<br>The latter is an inherently simpler operation that ought to be faster.<br>The latter (<code>typeid</code>) is easily hand-crafted if necessary (e.g., if working on a system where RTTI is – for some reason – prohibited),<br>the former (<code>dynamic_cast</code>) is far harder to implement correctly in general.</p>
<p>Consider:</p>
<pre><code>struct B &#123;
    const char* name &#123;&quot;B&quot;&#125;;
    // if pb1-&gt;id() == pb2-&gt;id() *pb1 is the same type as *pb2
    virtual const char* id() const &#123; return name; &#125;
    // ...
&#125;;

struct D : B &#123;
    const char* name &#123;&quot;D&quot;&#125;;
    const char* id() const override &#123; return name; &#125;
    // ...
&#125;;

void use()
&#123;
    B* pb1 = new B;
    B* pb2 = new D;

    cout &lt;&lt; pb1-&gt;id(); // &quot;B&quot;
    cout &lt;&lt; pb2-&gt;id(); // &quot;D&quot;


    if (pb1-&gt;id() == &quot;D&quot;) &#123;         // looks innocent
        D* pd = static_cast&lt;D*&gt;(pb1);
        // ...
    &#125;
    // ...
&#125;
</code></pre>
<p>The result of <code>pb2-&gt;id() == &quot;D&quot;</code> is actually implementation defined.<br>We added it to warn of the dangers of home-brew RTTI.<br>This code may work as expected for years, just to fail on a new machine, new compiler, or a new linker that does not unify character literals.</p>
<p>If you implement your own RTTI, be careful.</p>
<h5 id="Exception-25"><a href="#Exception-25" class="headerlink" title="Exception"></a>Exception</h5><p>If your implementation provided a really slow <code>dynamic_cast</code>, you may have to use a workaround.<br>However, all workarounds that cannot be statically resolved involve explicit casting (typically <code>static_cast</code>) and are error-prone.<br>You will basically be crafting your own special-purpose <code>dynamic_cast</code>.<br>So, first make sure that your <code>dynamic_cast</code> really is as slow as you think it is (there are a fair number of unsupported rumors about)<br>and that your use of <code>dynamic_cast</code> is really performance critical.</p>
<p>We are of the opinion that current implementations of <code>dynamic_cast</code> are unnecessarily slow.<br>For example, under suitable conditions, it is possible to perform a <code>dynamic_cast</code> in <a href="http://www.stroustrup.com/fast_dynamic_casting.pdf">fast constant time</a>.<br>However, compatibility makes changes difficult even if all agree that an effort to optimize is worthwhile.</p>
<p>In very rare cases, if you have measured that the <code>dynamic_cast</code> overhead is material, you have other means to statically guarantee that a downcast will succeed (e.g., you are using CRTP carefully), and there is no virtual inheritance involved, consider tactically resorting <code>static_cast</code> with a prominent comment and disclaimer summarizing this paragraph and that human attention is needed under maintenance because the type system can’t verify correctness. Even so, in our experience such “I know what I’m doing” situations are still a known bug source.</p>
<h5 id="Exception-26"><a href="#Exception-26" class="headerlink" title="Exception"></a>Exception</h5><p>Consider:</p>
<pre><code>template&lt;typename B&gt;
class Dx : B &#123;
    // ...
&#125;;
</code></pre>
<h5 id="Enforcement-131"><a href="#Enforcement-131" class="headerlink" title="Enforcement"></a>Enforcement</h5><ul>
<li>Flag all uses of <code>static_cast</code> for downcasts, including C-style casts that perform a <code>static_cast</code>.</li>
<li>This rule is part of the <a href="#Pro-type-downcast">type-safety profile</a>.</li>
</ul>
<h3 id="C-147-Use-dynamic-cast-to-a-reference-type-when-failure-to-find-the-required-class-is-considered-an-error"><a href="#C-147-Use-dynamic-cast-to-a-reference-type-when-failure-to-find-the-required-class-is-considered-an-error" class="headerlink" title="C.147: Use dynamic_cast to a reference type when failure to find the required class is considered an error"></a><a name="Rh-ref-cast"></a>C.147: Use <code>dynamic_cast</code> to a reference type when failure to find the required class is considered an error</h3><h5 id="Reason-139"><a href="#Reason-139" class="headerlink" title="Reason"></a>Reason</h5><p>Casting to a reference expresses that you intend to end up with a valid object, so the cast must succeed. <code>dynamic_cast</code> will then throw if it does not succeed.</p>
<h5 id="Example-117"><a href="#Example-117" class="headerlink" title="Example"></a>Example</h5><pre><code>???
</code></pre>
<h5 id="Enforcement-132"><a href="#Enforcement-132" class="headerlink" title="Enforcement"></a>Enforcement</h5><p>???</p>
<h3 id="C-148-Use-dynamic-cast-to-a-pointer-type-when-failure-to-find-the-required-class-is-considered-a-valid-alternative"><a href="#C-148-Use-dynamic-cast-to-a-pointer-type-when-failure-to-find-the-required-class-is-considered-a-valid-alternative" class="headerlink" title="C.148: Use dynamic_cast to a pointer type when failure to find the required class is considered a valid alternative"></a><a name="Rh-ptr-cast"></a>C.148: Use <code>dynamic_cast</code> to a pointer type when failure to find the required class is considered a valid alternative</h3><h5 id="Reason-140"><a href="#Reason-140" class="headerlink" title="Reason"></a>Reason</h5><p>The <code>dynamic_cast</code> conversion allows to test whether a pointer is pointing at a polymorphic object that has a given class in its hierarchy. Since failure to find the class merely returns a null value, it can be tested during run time. This allows writing code that can choose alternative paths depending on the results.</p>
<p>Contrast with <a href="#Rh-ptr-cast">C.147</a>, where failure is an error, and should not be used for conditional execution.</p>
<h5 id="Example-118"><a href="#Example-118" class="headerlink" title="Example"></a>Example</h5><p>The example below describes the <code>add</code> function of a <code>Shape_owner</code> that takes ownership of constructed <code>Shape</code> objects. The objects are also sorted into views, according to their geometric attributes.<br>In this example, <code>Shape</code> does not inherit from <code>Geometric_attributes</code>. Only its subclasses do.</p>
<pre><code>void add(Shape* const item)
&#123;
  // Ownership is always taken
  owned_shapes.emplace_back(item);

  // Check the Geometric_attributes and add the shape to none/one/some/all of the views

  if (auto even = dynamic_cast&lt;Even_sided*&gt;(item))
  &#123;
    view_of_evens.emplace_back(even);
  &#125;

  if (auto trisym = dynamic_cast&lt;Trilaterally_symmetrical*&gt;(item))
  &#123;
    view_of_trisyms.emplace_back(trisym);
  &#125;
&#125;
</code></pre>
<h5 id="Notes-3"><a href="#Notes-3" class="headerlink" title="Notes"></a>Notes</h5><p>A failure to find the required class will cause <code>dynamic_cast</code> to return a null value, and de-referencing a null-valued pointer will lead to undefined behavior.<br>Therefore the result of the <code>dynamic_cast</code> should always be treated as if it may contain a null value, and tested.</p>
<h5 id="Enforcement-133"><a href="#Enforcement-133" class="headerlink" title="Enforcement"></a>Enforcement</h5><ul>
<li>(Complex) Unless there is a null test on the result of a <code>dynamic_cast</code> of a pointer type, warn upon dereference of the pointer.</li>
</ul>
<h3 id="C-149-Use-unique-ptr-or-shared-ptr-to-avoid-forgetting-to-delete-objects-created-using-new"><a href="#C-149-Use-unique-ptr-or-shared-ptr-to-avoid-forgetting-to-delete-objects-created-using-new" class="headerlink" title="C.149: Use unique_ptr or shared_ptr to avoid forgetting to delete objects created using new"></a><a name="Rh-smart"></a>C.149: Use <code>unique_ptr</code> or <code>shared_ptr</code> to avoid forgetting to <code>delete</code> objects created using <code>new</code></h3><h5 id="Reason-141"><a href="#Reason-141" class="headerlink" title="Reason"></a>Reason</h5><p>Avoid resource leaks.</p>
<h5 id="Example-119"><a href="#Example-119" class="headerlink" title="Example"></a>Example</h5><pre><code>void use(int i)
&#123;
    auto p = new int &#123;7&#125;;           // bad: initialize local pointers with new
    auto q = make_unique&lt;int&gt;(9);   // ok: guarantee the release of the memory-allocated for 9
    if (0 &lt; i) return;              // maybe return and leak
    delete p;                       // too late
&#125;
</code></pre>
<h5 id="Enforcement-134"><a href="#Enforcement-134" class="headerlink" title="Enforcement"></a>Enforcement</h5><ul>
<li>Flag initialization of a naked pointer with the result of a <code>new</code></li>
<li>Flag <code>delete</code> of local variable</li>
</ul>
<h3 id="C-150-Use-make-unique-to-construct-objects-owned-by-unique-ptrs"><a href="#C-150-Use-make-unique-to-construct-objects-owned-by-unique-ptrs" class="headerlink" title="C.150: Use make_unique() to construct objects owned by unique_ptrs"></a><a name="Rh-make_unique"></a>C.150: Use <code>make_unique()</code> to construct objects owned by <code>unique_ptr</code>s</h3><h5 id="Reason-142"><a href="#Reason-142" class="headerlink" title="Reason"></a>Reason</h5><p> <code>make_unique</code> gives a more concise statement of the construction.<br>It also ensures exception safety in complex expressions.</p>
<h5 id="Example-120"><a href="#Example-120" class="headerlink" title="Example"></a>Example</h5><pre><code>unique_ptr&lt;Foo&gt; p &#123;new&lt;Foo&gt;&#123;7&#125;&#125;;   // OK: but repetitive

auto q = make_unique&lt;Foo&gt;(7);      // Better: no repetition of Foo

// Not exception-safe: the compiler may interleave the computations of arguments as follows:
//
// 1. allocate memory for Foo,
// 2. construct Foo,
// 3. call bar,
// 4. construct unique_ptr&lt;Foo&gt;.
//
// If bar throws, Foo will not be destroyed, and the memory-allocated for it will leak.
f(unique_ptr&lt;Foo&gt;(new Foo()), bar());

// Exception-safe: calls to functions are never interleaved.
f(make_unique&lt;Foo&gt;(), bar());
</code></pre>
<h5 id="Enforcement-135"><a href="#Enforcement-135" class="headerlink" title="Enforcement"></a>Enforcement</h5><ul>
<li>Flag the repetitive usage of template specialization list <code>&lt;Foo&gt;</code></li>
<li>Flag variables declared to be <code>unique_ptr&lt;Foo&gt;</code></li>
</ul>
<h3 id="C-151-Use-make-shared-to-construct-objects-owned-by-shared-ptrs"><a href="#C-151-Use-make-shared-to-construct-objects-owned-by-shared-ptrs" class="headerlink" title="C.151: Use make_shared() to construct objects owned by shared_ptrs"></a><a name="Rh-make_shared"></a>C.151: Use <code>make_shared()</code> to construct objects owned by <code>shared_ptr</code>s</h3><h5 id="Reason-143"><a href="#Reason-143" class="headerlink" title="Reason"></a>Reason</h5><p> <code>make_shared</code> gives a more concise statement of the construction.<br>It also gives an opportunity to eliminate a separate allocation for the reference counts, by placing the <code>shared_ptr</code>‘s use counts next to its object.</p>
<h5 id="Example-121"><a href="#Example-121" class="headerlink" title="Example"></a>Example</h5><pre><code>void test() &#123;
    // OK: but repetitive; and separate allocations for the Bar and shared_ptr&#39;s use count
    shared_ptr&lt;Bar&gt; p &#123;new&lt;Bar&gt;&#123;7&#125;&#125;;

    auto q = make_shared&lt;Bar&gt;(7);   // Better: no repetition of Bar; one object
&#125;
</code></pre>
<h5 id="Enforcement-136"><a href="#Enforcement-136" class="headerlink" title="Enforcement"></a>Enforcement</h5><ul>
<li>Flag the repetitive usage of template specialization list<code>&lt;Bar&gt;</code></li>
<li>Flag variables declared to be <code>shared_ptr&lt;Bar&gt;</code></li>
</ul>
<h3 id="C-152-Never-assign-a-pointer-to-an-array-of-derived-class-objects-to-a-pointer-to-its-base"><a href="#C-152-Never-assign-a-pointer-to-an-array-of-derived-class-objects-to-a-pointer-to-its-base" class="headerlink" title="C.152: Never assign a pointer to an array of derived class objects to a pointer to its base"></a><a name="Rh-array"></a>C.152: Never assign a pointer to an array of derived class objects to a pointer to its base</h3><h5 id="Reason-144"><a href="#Reason-144" class="headerlink" title="Reason"></a>Reason</h5><p>Subscripting the resulting base pointer will lead to invalid object access and probably to memory corruption.</p>
<h5 id="Example-122"><a href="#Example-122" class="headerlink" title="Example"></a>Example</h5><pre><code>struct B &#123; int x; &#125;;
struct D : B &#123; int y; &#125;;

void use(B*);

D a[] = &#123;&#123;1, 2&#125;, &#123;3, 4&#125;, &#123;5, 6&#125;&#125;;
B* p = a;     // bad: a decays to &amp;a[0] which is converted to a B*
p[1].x = 7;   // overwrite D[0].y

use(a);       // bad: a decays to &amp;a[0] which is converted to a B*
</code></pre>
<h5 id="Enforcement-137"><a href="#Enforcement-137" class="headerlink" title="Enforcement"></a>Enforcement</h5><ul>
<li>Flag all combinations of array decay and base to derived conversions.</li>
<li>Pass an array as a <code>span</code> rather than as a pointer, and don’t let the array name suffer a derived-to-base conversion before getting into the <code>span</code></li>
</ul>
<h3 id="C-153-Prefer-virtual-function-to-casting"><a href="#C-153-Prefer-virtual-function-to-casting" class="headerlink" title="C.153: Prefer virtual function to casting"></a><a name="Rh-use-virtual"></a>C.153: Prefer virtual function to casting</h3><h5 id="Reason-145"><a href="#Reason-145" class="headerlink" title="Reason"></a>Reason</h5><p>A virtual function call is safe, whereas casting is error-prone.<br>A virtual function call reaches the most derived function, whereas a cast may reach an intermediate class and therefore<br>give a wrong result (especially as a hierarchy is modified during maintenance).</p>
<h5 id="Example-123"><a href="#Example-123" class="headerlink" title="Example"></a>Example</h5><pre><code>???
</code></pre>
<h5 id="Enforcement-138"><a href="#Enforcement-138" class="headerlink" title="Enforcement"></a>Enforcement</h5><p>See <a href="#Rh-dynamic_cast">C.146</a> and ???</p>
<h2 id="C-over-Overloading-and-overloaded-operators"><a href="#C-over-Overloading-and-overloaded-operators" class="headerlink" title="C.over: Overloading and overloaded operators"></a><a name="SS-overload"></a>C.over: Overloading and overloaded operators</h2><p>You can overload ordinary functions, template functions, and operators.<br>You cannot overload function objects.</p>
<p>Overload rule summary:</p>
<ul>
<li><a href="#Ro-conventional">C.160: Define operators primarily to mimic conventional usage</a></li>
<li><a href="#Ro-symmetric">C.161: Use nonmember functions for symmetric operators</a></li>
<li><a href="#Ro-equivalent">C.162: Overload operations that are roughly equivalent</a></li>
<li><a href="#Ro-equivalent-2">C.163: Overload only for operations that are roughly equivalent</a></li>
<li><a href="#Ro-conversion">C.164: Avoid conversion operators</a></li>
<li><a href="#Ro-custom">C.165: Use <code>using</code> for customization points</a></li>
<li><a href="#Ro-address-of">C.166: Overload unary <code>&amp;</code> only as part of a system of smart pointers and references</a></li>
<li><a href="#Ro-overload">C.167: Use an operator for an operation with its conventional meaning</a></li>
<li><a href="#Ro-namespace">C.168: Define overloaded operators in the namespace of their operands</a></li>
<li><a href="#Ro-lambda">C.170: If you feel like overloading a lambda, use a generic lambda</a></li>
</ul>
<h3 id="C-160-Define-operators-primarily-to-mimic-conventional-usage"><a href="#C-160-Define-operators-primarily-to-mimic-conventional-usage" class="headerlink" title="C.160: Define operators primarily to mimic conventional usage"></a><a name="Ro-conventional"></a>C.160: Define operators primarily to mimic conventional usage</h3><h5 id="Reason-146"><a href="#Reason-146" class="headerlink" title="Reason"></a>Reason</h5><p>Minimize surprises.</p>
<h5 id="Example-124"><a href="#Example-124" class="headerlink" title="Example"></a>Example</h5><pre><code>class X &#123;
public:
    // ...
    X&amp; operator=(const X&amp;); // member function defining assignment
    friend bool operator==(const X&amp;, const X&amp;); // == needs access to representation
                                                // after a = b we have a == b
    // ...
&#125;;
</code></pre>
<p>Here, the conventional semantics is maintained: <a href="#SS-copy">Copies compare equal</a>.</p>
<h5 id="Example-bad-58"><a href="#Example-bad-58" class="headerlink" title="Example, bad"></a>Example, bad</h5><pre><code>X operator+(X a, X b) &#123; return a.v - b.v; &#125;   // bad: makes + subtract
</code></pre>
<h5 id="Note-156"><a href="#Note-156" class="headerlink" title="Note"></a>Note</h5><p>Nonmember operators should be either friends or defined in <a href="#Ro-namespace">the same namespace as their operands</a>.<br><a href="#Ro-symmetric">Binary operators should treat their operands equivalently</a>.</p>
<h5 id="Enforcement-139"><a href="#Enforcement-139" class="headerlink" title="Enforcement"></a>Enforcement</h5><p>Possibly impossible.</p>
<h3 id="C-161-Use-nonmember-functions-for-symmetric-operators"><a href="#C-161-Use-nonmember-functions-for-symmetric-operators" class="headerlink" title="C.161: Use nonmember functions for symmetric operators"></a><a name="Ro-symmetric"></a>C.161: Use nonmember functions for symmetric operators</h3><h5 id="Reason-147"><a href="#Reason-147" class="headerlink" title="Reason"></a>Reason</h5><p>If you use member functions, you need two.<br>Unless you use a nonmember function for (say) <code>==</code>, <code>a == b</code> and <code>b == a</code> will be subtly different.</p>
<h5 id="Example-125"><a href="#Example-125" class="headerlink" title="Example"></a>Example</h5><pre><code>bool operator==(Point a, Point b) &#123; return a.x == b.x &amp;&amp; a.y == b.y; &#125;
</code></pre>
<h5 id="Enforcement-140"><a href="#Enforcement-140" class="headerlink" title="Enforcement"></a>Enforcement</h5><p>Flag member operator functions.</p>
<h3 id="C-162-Overload-operations-that-are-roughly-equivalent"><a href="#C-162-Overload-operations-that-are-roughly-equivalent" class="headerlink" title="C.162: Overload operations that are roughly equivalent"></a><a name="Ro-equivalent"></a>C.162: Overload operations that are roughly equivalent</h3><h5 id="Reason-148"><a href="#Reason-148" class="headerlink" title="Reason"></a>Reason</h5><p>Having different names for logically equivalent operations on different argument types is confusing, leads to encoding type information in function names, and inhibits generic programming.</p>
<h5 id="Example-126"><a href="#Example-126" class="headerlink" title="Example"></a>Example</h5><p>Consider:</p>
<pre><code>void print(int a);
void print(int a, int base);
void print(const string&amp;);
</code></pre>
<p>These three functions all print their arguments (appropriately). Conversely:</p>
<pre><code>void print_int(int a);
void print_based(int a, int base);
void print_string(const string&amp;);
</code></pre>
<p>These three functions all print their arguments (appropriately). Adding to the name just introduced verbosity and inhibits generic code.</p>
<h5 id="Enforcement-141"><a href="#Enforcement-141" class="headerlink" title="Enforcement"></a>Enforcement</h5><p>???</p>
<h3 id="C-163-Overload-only-for-operations-that-are-roughly-equivalent"><a href="#C-163-Overload-only-for-operations-that-are-roughly-equivalent" class="headerlink" title="C.163: Overload only for operations that are roughly equivalent"></a><a name="Ro-equivalent-2"></a>C.163: Overload only for operations that are roughly equivalent</h3><h5 id="Reason-149"><a href="#Reason-149" class="headerlink" title="Reason"></a>Reason</h5><p>Having the same name for logically different functions is confusing and leads to errors when using generic programming.</p>
<h5 id="Example-127"><a href="#Example-127" class="headerlink" title="Example"></a>Example</h5><p>Consider:</p>
<pre><code>void open_gate(Gate&amp; g);   // remove obstacle from garage exit lane
void fopen(const char* name, const char* mode);   // open file
</code></pre>
<p>The two operations are fundamentally different (and unrelated) so it is good that their names differ. Conversely:</p>
<pre><code>void open(Gate&amp; g);   // remove obstacle from garage exit lane
void open(const char* name, const char* mode =&quot;r&quot;);   // open file
</code></pre>
<p>The two operations are still fundamentally different (and unrelated) but the names have been reduced to their (common) minimum, opening opportunities for confusion.<br>Fortunately, the type system will catch many such mistakes.</p>
<h5 id="Note-157"><a href="#Note-157" class="headerlink" title="Note"></a>Note</h5><p>Be particularly careful about common and popular names, such as <code>open</code>, <code>move</code>, <code>+</code>, and <code>==</code>.</p>
<h5 id="Enforcement-142"><a href="#Enforcement-142" class="headerlink" title="Enforcement"></a>Enforcement</h5><p>???</p>
<h3 id="C-164-Avoid-conversion-operators"><a href="#C-164-Avoid-conversion-operators" class="headerlink" title="C.164: Avoid conversion operators"></a><a name="Ro-conversion"></a>C.164: Avoid conversion operators</h3><h5 id="Reason-150"><a href="#Reason-150" class="headerlink" title="Reason"></a>Reason</h5><p>Implicit conversions can be essential (e.g., <code>double</code> to <code>int</code>) but often cause surprises (e.g., <code>String</code> to C-style string).</p>
<h5 id="Note-158"><a href="#Note-158" class="headerlink" title="Note"></a>Note</h5><p>Prefer explicitly named conversions until a serious need is demonstrated.<br>By “serious need” we mean a reason that is fundamental in the application domain (such as an integer to complex number conversion)<br>and frequently needed. Do not introduce implicit conversions (through conversion operators or non-<code>explicit</code> constructors)<br>just to gain a minor convenience.</p>
<h5 id="Example-bad-59"><a href="#Example-bad-59" class="headerlink" title="Example, bad"></a>Example, bad</h5><pre><code>class String &#123;   // handle ownership and access to a sequence of characters
    // ...
    String(czstring p); // copy from *p to *(this-&gt;elem)
    // ...
    operator zstring() &#123; return elem; &#125;
    // ...
&#125;;

void user(zstring p)
&#123;
    if (*p == &quot;&quot;) &#123;
        String s &#123;&quot;Trouble ahead!&quot;&#125;;
        // ...
        p = s;
    &#125;
    // use p
&#125;
</code></pre>
<p>The string allocated for <code>s</code> and assigned to <code>p</code> is destroyed before it can be used.</p>
<h5 id="Enforcement-143"><a href="#Enforcement-143" class="headerlink" title="Enforcement"></a>Enforcement</h5><p>Flag all conversion operators.</p>
<h3 id="C-165-Use-using-for-customization-points"><a href="#C-165-Use-using-for-customization-points" class="headerlink" title="C.165: Use using for customization points"></a><a name="Ro-custom"></a>C.165: Use <code>using</code> for customization points</h3><h5 id="Reason-151"><a href="#Reason-151" class="headerlink" title="Reason"></a>Reason</h5><p>To find function objects and functions defined in a separate namespace to “customize” a common function.</p>
<h5 id="Example-128"><a href="#Example-128" class="headerlink" title="Example"></a>Example</h5><p>Consider <code>swap</code>. It is a general (standard-library) function with a definition that will work for just about any type.<br>However, it is desirable to define specific <code>swap()</code>s for specific types.<br>For example, the general <code>swap()</code> will copy the elements of two <code>vector</code>s being swapped, whereas a good specific implementation will not copy elements at all.</p>
<pre><code>namespace N &#123;
    My_type X &#123; /* ... */ &#125;;
    void swap(X&amp;, X&amp;);   // optimized swap for N::X
    // ...
&#125;

void f1(N::X&amp; a, N::X&amp; b)
&#123;
    std::swap(a, b);   // probably not what we wanted: calls std::swap()
&#125;
</code></pre>
<p>The <code>std::swap()</code> in <code>f1()</code> does exactly what we asked it to do: it calls the <code>swap()</code> in namespace <code>std</code>.<br>Unfortunately, that’s probably not what we wanted.<br>How do we get <code>N::X</code> considered?</p>
<pre><code>void f2(N::X&amp; a, N::X&amp; b)
&#123;
    swap(a, b);   // calls N::swap
&#125;
</code></pre>
<p>But that may not be what we wanted for generic code.<br>There, we typically want the specific function if it exists and the general function if not.<br>This is done by including the general function in the lookup for the function:</p>
<pre><code>void f3(N::X&amp; a, N::X&amp; b)
&#123;
    using std::swap;  // make std::swap available
    swap(a, b);        // calls N::swap if it exists, otherwise std::swap
&#125;
</code></pre>
<h5 id="Enforcement-144"><a href="#Enforcement-144" class="headerlink" title="Enforcement"></a>Enforcement</h5><p>Unlikely, except for known customization points, such as <code>swap</code>.<br>The problem is that the unqualified and qualified lookups both have uses.</p>
<h3 id="C-166-Overload-unary-amp-only-as-part-of-a-system-of-smart-pointers-and-references"><a href="#C-166-Overload-unary-amp-only-as-part-of-a-system-of-smart-pointers-and-references" class="headerlink" title="C.166: Overload unary &amp; only as part of a system of smart pointers and references"></a><a name="Ro-address-of"></a>C.166: Overload unary <code>&amp;</code> only as part of a system of smart pointers and references</h3><h5 id="Reason-152"><a href="#Reason-152" class="headerlink" title="Reason"></a>Reason</h5><p>The <code>&amp;</code> operator is fundamental in C++.<br>Many parts of the C++ semantics assumes its default meaning.</p>
<h5 id="Example-129"><a href="#Example-129" class="headerlink" title="Example"></a>Example</h5><pre><code>class Ptr &#123; // a somewhat smart pointer
    Ptr(X* pp) :p(pp) &#123; /* check */ &#125;
    X* operator-&gt;() &#123; /* check */ return p; &#125;
    X operator[](int i);
    X operator*();
private:
    T* p;
&#125;;

class X &#123;
    Ptr operator&amp;() &#123; return Ptr&#123;this&#125;; &#125;
    // ...
&#125;;
</code></pre>
<h5 id="Note-159"><a href="#Note-159" class="headerlink" title="Note"></a>Note</h5><p>If you “mess with” operator <code>&amp;</code> be sure that its definition has matching meanings for <code>-&gt;</code>, <code>[]</code>, <code>*</code>, and <code>.</code> on the result type.<br>Note that operator <code>.</code> currently cannot be overloaded so a perfect system is impossible.<br>We hope to remedy that: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2015/n4477.pdf">http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2015/n4477.pdf</a>.<br>Note that <code>std::addressof()</code> always yields a built-in pointer.</p>
<h5 id="Enforcement-145"><a href="#Enforcement-145" class="headerlink" title="Enforcement"></a>Enforcement</h5><p>Tricky. Warn if <code>&amp;</code> is user-defined without also defining <code>-&gt;</code> for the result type.</p>
<h3 id="C-167-Use-an-operator-for-an-operation-with-its-conventional-meaning"><a href="#C-167-Use-an-operator-for-an-operation-with-its-conventional-meaning" class="headerlink" title="C.167: Use an operator for an operation with its conventional meaning"></a><a name="Ro-overload"></a>C.167: Use an operator for an operation with its conventional meaning</h3><h5 id="Reason-153"><a href="#Reason-153" class="headerlink" title="Reason"></a>Reason</h5><p>Readability. Convention. Reusability. Support for generic code</p>
<h5 id="Example-130"><a href="#Example-130" class="headerlink" title="Example"></a>Example</h5><pre><code>void cout_my_class(const My_class&amp; c) // confusing, not conventional,not generic
&#123;
    std::cout &lt;&lt; /* class members here */;
&#125;

std::ostream&amp; operator&lt;&lt;(std::ostream&amp; os, const my_class&amp; c) // OK
&#123;
    return os &lt;&lt; /* class members here */;
&#125;
</code></pre>
<p>By itself, <code>cout_my_class</code> would be OK, but it is not usable/composable with code that rely on the <code>&lt;&lt;</code> convention for output:</p>
<pre><code>My_class var &#123; /* ... */ &#125;;
// ...
cout &lt;&lt; &quot;var = &quot; &lt;&lt; var &lt;&lt; &#39;\n&#39;;
</code></pre>
<h5 id="Note-160"><a href="#Note-160" class="headerlink" title="Note"></a>Note</h5><p>There are strong and vigorous conventions for the meaning most operators, such as</p>
<ul>
<li>comparisons (<code>==</code>, <code>!=</code>, <code>&lt;</code>, <code>&lt;=</code>, <code>&gt;</code>, and <code>&gt;=</code>),</li>
<li>arithmetic operations (<code>+</code>, <code>-</code>, <code>*</code>, <code>/</code>, and <code>%</code>)</li>
<li>access operations (<code>.</code>, <code>-&gt;</code>, unary <code>*</code>, and <code>[]</code>)</li>
<li>assignment (<code>=</code>)</li>
</ul>
<p>Don’t define those unconventionally and don’t invent your own names for them.</p>
<h5 id="Enforcement-146"><a href="#Enforcement-146" class="headerlink" title="Enforcement"></a>Enforcement</h5><p>Tricky. Requires semantic insight.</p>
<h3 id="C-168-Define-overloaded-operators-in-the-namespace-of-their-operands"><a href="#C-168-Define-overloaded-operators-in-the-namespace-of-their-operands" class="headerlink" title="C.168: Define overloaded operators in the namespace of their operands"></a><a name="Ro-namespace"></a>C.168: Define overloaded operators in the namespace of their operands</h3><h5 id="Reason-154"><a href="#Reason-154" class="headerlink" title="Reason"></a>Reason</h5><p>Readability.<br>Ability for find operators using ADL.<br>Avoiding inconsistent definition in different namespaces</p>
<h5 id="Example-131"><a href="#Example-131" class="headerlink" title="Example"></a>Example</h5><pre><code>struct S &#123; &#125;;
bool operator==(S, S);   // OK: in the same namespace as S, and even next to S
S s;

bool x = (s == s);
</code></pre>
<p>This is what a default <code>==</code> would do, if we had such defaults.</p>
<h5 id="Example-132"><a href="#Example-132" class="headerlink" title="Example"></a>Example</h5><pre><code>namespace N &#123;
    struct S &#123; &#125;;
    bool operator==(S, S);   // OK: in the same namespace as S, and even next to S
&#125;

N::S s;

bool x = (s == s);  // finds N::operator==() by ADL
</code></pre>
<h5 id="Example-bad-60"><a href="#Example-bad-60" class="headerlink" title="Example, bad"></a>Example, bad</h5><pre><code>struct S &#123; &#125;;
S s;

namespace N &#123;
    S::operator!(S a) &#123; return true; &#125;
    S not_s = !s;
&#125;

namespace M &#123;
    S::operator!(S a) &#123; return false; &#125;
    S not_s = !s;
&#125;
</code></pre>
<p>Here, the meaning of <code>!s</code> differs in <code>N</code> and <code>M</code>.<br>This can be most confusing.<br>Remove the definition of <code>namespace M</code> and the confusion is replaced by an opportunity to make the mistake.</p>
<h5 id="Note-161"><a href="#Note-161" class="headerlink" title="Note"></a>Note</h5><p>If a binary operator is defined for two types that are defined in different namespaces, you cannot follow this rule.<br>For example:</p>
<pre><code>Vec::Vector operator*(const Vec::Vector&amp;, const Mat::Matrix&amp;);
</code></pre>
<p>This may be something best avoided.</p>
<h5 id="See-also-1"><a href="#See-also-1" class="headerlink" title="See also"></a>See also</h5><p>This is a special case of the rule that <a href="#Rc-helper">helper functions should be defined in the same namespace as their class</a>.</p>
<h5 id="Enforcement-147"><a href="#Enforcement-147" class="headerlink" title="Enforcement"></a>Enforcement</h5><ul>
<li>Flag operator definitions that are not it the namespace of their operands</li>
</ul>
<h3 id="C-170-If-you-feel-like-overloading-a-lambda-use-a-generic-lambda"><a href="#C-170-If-you-feel-like-overloading-a-lambda-use-a-generic-lambda" class="headerlink" title="C.170: If you feel like overloading a lambda, use a generic lambda"></a><a name="Ro-lambda"></a>C.170: If you feel like overloading a lambda, use a generic lambda</h3><h5 id="Reason-155"><a href="#Reason-155" class="headerlink" title="Reason"></a>Reason</h5><p>You cannot overload by defining two different lambdas with the same name.</p>
<h5 id="Example-133"><a href="#Example-133" class="headerlink" title="Example"></a>Example</h5><pre><code>void f(int);
void f(double);
auto f = [](char);   // error: cannot overload variable and function

auto g = [](int) &#123; /* ... */ &#125;;
auto g = [](double) &#123; /* ... */ &#125;;   // error: cannot overload variables

auto h = [](auto) &#123; /* ... */ &#125;;   // OK
</code></pre>
<h5 id="Enforcement-148"><a href="#Enforcement-148" class="headerlink" title="Enforcement"></a>Enforcement</h5><p>The compiler catches the attempt to overload a lambda.</p>
<h2 id="C-union-Unions"><a href="#C-union-Unions" class="headerlink" title="C.union: Unions"></a><a name="SS-union"></a>C.union: Unions</h2><p>A <code>union</code> is a <code>struct</code> where all members start at the same address so that it can hold only one member at a time.<br>A <code>union</code> does not keep track of which member is stored so the programmer has to get it right;<br>this is inherently error-prone, but there are ways to compensate.</p>
<p>A type that is a <code>union</code> plus an indicator of which member is currently held is called a <em>tagged union</em>, a <em>discriminated union</em>, or a <em>variant</em>.</p>
<p>Union rule summary:</p>
<ul>
<li><a href="#Ru-union">C.180: Use <code>union</code>s to save Memory</a></li>
<li><a href="#Ru-naked">C.181: Avoid “naked” <code>union</code>s</a></li>
<li><a href="#Ru-anonymous">C.182: Use anonymous <code>union</code>s to implement tagged unions</a></li>
<li><a href="#Ru-pun">C.183: Don’t use a <code>union</code> for type punning</a></li>
<li>???</li>
</ul>
<h3 id="C-180-Use-unions-to-save-memory"><a href="#C-180-Use-unions-to-save-memory" class="headerlink" title="C.180: Use unions to save memory"></a><a name="Ru-union"></a>C.180: Use <code>union</code>s to save memory</h3><h5 id="Reason-156"><a href="#Reason-156" class="headerlink" title="Reason"></a>Reason</h5><p>A <code>union</code> allows a single piece of memory to be used for different types of objects at different times.<br>Consequently, it can be used to save memory when we have several objects that are never used at the same time.</p>
<h5 id="Example-134"><a href="#Example-134" class="headerlink" title="Example"></a>Example</h5><pre><code>union Value &#123;
    int x;
    double d;
&#125;;

Value v = &#123; 123 &#125;;  // now v holds an int
cout &lt;&lt; v.x &lt;&lt; &#39;\n&#39;;    // write 123
v.d = 987.654;  // now v holds a double
cout &lt;&lt; v.d &lt;&lt; &#39;\n&#39;;    // write 987.654
</code></pre>
<p>But heed the warning: <a href="#Ru-naked">Avoid “naked” <code>union</code>s</a></p>
<h5 id="Example-135"><a href="#Example-135" class="headerlink" title="Example"></a>Example</h5><pre><code>// Short-string optimization

constexpr size_t buffer_size = 16; // Slightly larger than the size of a pointer

class Immutable_string &#123;
public:
    Immutable_string(const char* str) :
        size(strlen(str))
    &#123;
        if (size &lt; buffer_size)
            strcpy_s(string_buffer, buffer_size, str);
        else &#123;
            string_ptr = new char[size + 1];
            strcpy_s(string_ptr, size + 1, str);
        &#125;
    &#125;

    ~Immutable_string()
    &#123;
        if (size &gt;= buffer_size)
            delete string_ptr;
    &#125;

    const char* get_str() const
    &#123;
        return (size &lt; buffer_size) ? string_buffer : string_ptr;
    &#125;

private:
    // If the string is short enough, we store the string itself
    // instead of a pointer to the string.
    union &#123;
        char* string_ptr;
        char string_buffer[buffer_size];
    &#125;;

    const size_t size;
&#125;;
</code></pre>
<h5 id="Enforcement-149"><a href="#Enforcement-149" class="headerlink" title="Enforcement"></a>Enforcement</h5><p>???</p>
<h3 id="C-181-Avoid-“naked”-unions"><a href="#C-181-Avoid-“naked”-unions" class="headerlink" title="C.181: Avoid “naked” unions"></a><a name="Ru-naked"></a>C.181: Avoid “naked” <code>union</code>s</h3><h5 id="Reason-157"><a href="#Reason-157" class="headerlink" title="Reason"></a>Reason</h5><p>A <em>naked union</em> is a union without an associated indicator which member (if any) it holds,<br>so that the programmer has to keep track.<br>Naked unions are a source of type errors.</p>
<h5 id="Example-bad-61"><a href="#Example-bad-61" class="headerlink" title="Example, bad"></a>Example, bad</h5><pre><code>union Value &#123;
    int x;
    double d;
&#125;;

Value v;
v.d = 987.654;  // v holds a double
</code></pre>
<p>So far, so good, but we can easily misuse the <code>union</code>:</p>
<pre><code>cout &lt;&lt; v.x &lt;&lt; &#39;\n&#39;;    // BAD, undefined behavior: v holds a double, but we read it as an int
</code></pre>
<p>Note that the type error happened without any explicit cast.<br>When we tested that program the last value printed was <code>1683627180</code> which it the integer value for the bit pattern for <code>987.654</code>.<br>What we have here is an “invisible” type error that happens to give a result that could easily look innocent.</p>
<p>And, talking about “invisible”, this code produced no output:</p>
<pre><code>v.x = 123;
cout &lt;&lt; v.d &lt;&lt; &#39;\n&#39;;    // BAD: undefined behavior
</code></pre>
<h5 id="Alternative-6"><a href="#Alternative-6" class="headerlink" title="Alternative"></a>Alternative</h5><p>Wrap a <code>union</code> in a class together with a type field.</p>
<p>The soon-to-be-standard <code>variant</code> type (to be found in <code>&lt;variant&gt;</code>) does that for you:</p>
<pre><code>variant&lt;int, double&gt; v;
v = 123;        // v holds an int
int x = get&lt;int&gt;(v);
v = 123.456;    // v holds a double
w = get&lt;double&gt;(v);
</code></pre>
<h5 id="Enforcement-150"><a href="#Enforcement-150" class="headerlink" title="Enforcement"></a>Enforcement</h5><p>???</p>
<h3 id="C-182-Use-anonymous-unions-to-implement-tagged-unions"><a href="#C-182-Use-anonymous-unions-to-implement-tagged-unions" class="headerlink" title="C.182: Use anonymous unions to implement tagged unions"></a><a name="Ru-anonymous"></a>C.182: Use anonymous <code>union</code>s to implement tagged unions</h3><h5 id="Reason-158"><a href="#Reason-158" class="headerlink" title="Reason"></a>Reason</h5><p>A well-designed tagged union is type safe.<br>An <em>anonymous</em> union simplifies the definition of a class with a (tag, union) pair.</p>
<h5 id="Example-136"><a href="#Example-136" class="headerlink" title="Example"></a>Example</h5><p>This example is mostly borrowed from TC++PL4 pp216-218.<br>You can look there for an explanation.</p>
<p>The code is somewhat elaborate.<br>Handling a type with user-defined assignment and destructor is tricky.<br>Saving programmers from having to write such code is one reason for including <code>variant</code> in the standard.</p>
<pre><code>class Value &#123; // two alternative representations represented as a union
private:
    enum class Tag &#123; number, text &#125;;
    Tag type; // discriminant

    union &#123; // representation (note: anonymous union)
        int i;
        string s; // string has default constructor, copy operations, and destructor
    &#125;;
public:
    struct Bad_entry &#123; &#125;; // used for exceptions

    ~Value();
    Value&amp; operator=(const Value&amp;);   // necessary because of the string variant
    Value(const Value&amp;);
    // ...
    int number() const;
    string text() const;

    void set_number(int n);
    void set_text(const string&amp;);
    // ...
&#125;;

int Value::number() const
&#123;
    if (type != Tag::number) throw Bad_entry&#123;&#125;;
    return i;
&#125;

string Value::text() const
&#123;
    if (type != Tag::text) throw Bad_entry&#123;&#125;;
    return s;
&#125;

void Value::set_number(int n)
&#123;
    if (type == Tag::text) &#123;
        s.~string();      // explicitly destroy string
        type = Tag::number;
    &#125;
    i = n;
&#125;

void Value::set_text(const string&amp; ss)
&#123;
    if (type == Tag::text)
        s = ss;
    else &#123;
        new(&amp;s) string&#123;ss&#125;;   // placement new: explicitly construct string
        type = Tag::text;
    &#125;
&#125;

Value&amp; Value::operator=(const Value&amp; e)   // necessary because of the string variant
&#123;
    if (type == Tag::text &amp;&amp; e.type == Tag::text) &#123;
        s = e.s;    // usual string assignment
        return *this;
    &#125;

    if (type == Tag::text) s.~string(); // explicit destroy

    switch (e.type) &#123;
    case Tag::number:
        i = e.i;
        break;
    case Tag::text:
        new(&amp;s)(e.s);   // placement new: explicit construct
        type = e.type;
    &#125;

    return *this;
&#125;

Value::~Value()
&#123;
    if (type == Tag::text) s.~string(); // explicit destroy
&#125;
</code></pre>
<h5 id="Enforcement-151"><a href="#Enforcement-151" class="headerlink" title="Enforcement"></a>Enforcement</h5><p>???</p>
<h3 id="C-183-Don’t-use-a-union-for-type-punning"><a href="#C-183-Don’t-use-a-union-for-type-punning" class="headerlink" title="C.183: Don’t use a union for type punning"></a><a name="Ru-pun"></a>C.183: Don’t use a <code>union</code> for type punning</h3><h5 id="Reason-159"><a href="#Reason-159" class="headerlink" title="Reason"></a>Reason</h5><p>It is undefined behavior to read a <code>union</code> member with a different type from the one with which it was written.<br>Such punning is invisible, or at least harder to spot than using a named cast.<br>Type punning using a <code>union</code> is a source of errors.</p>
<h5 id="Example-bad-62"><a href="#Example-bad-62" class="headerlink" title="Example, bad"></a>Example, bad</h5><pre><code>union Pun &#123;
    int x;
    unsigned char c[sizeof(int)];
&#125;;
</code></pre>
<p>The idea of <code>Pun</code> is to be able to look at the character representation of an <code>int</code>.</p>
<pre><code>void bad(Pun&amp; u)
&#123;
    u.x = &#39;x&#39;;
    cout &lt;&lt; u.c[0] &lt;&lt; &#39;\n&#39;;     // undefined behavior
&#125;
</code></pre>
<p>If you wanted to see the bytes of an <code>int</code>, use a (named) cast:</p>
<pre><code>void if_you_must_pun(int&amp; x)
&#123;
    auto p = reinterpret_cast&lt;unsigned char*&gt;(&amp;x);
    cout &lt;&lt; p[0] &lt;&lt; &#39;\n&#39;;     // OK; better
    // ...
&#125;
</code></pre>
<p>Accessing the result of an <code>reinterpret_cast</code> to a different type from the objects declared type is defined behavior (even though <code>reinterpret_cast</code> is discouraged),<br>but at least we can see that something tricky is going on.</p>
<h5 id="Note-162"><a href="#Note-162" class="headerlink" title="Note"></a>Note</h5><p>Unfortunately, <code>union</code>s are commonly used for type punning.<br>We don’t consider “sometimes, it works as expected” a strong argument.</p>
<p>C++17 introduced a distinct type <code>std::byte</code> to facilitate operations on raw object representation.  Use that type instead of <code>unsigned char</code> or <code>char</code> for these operations.</p>
<h5 id="Enforcement-152"><a href="#Enforcement-152" class="headerlink" title="Enforcement"></a>Enforcement</h5><p>???</p>
<h1 id="Enum-Enumerations"><a href="#Enum-Enumerations" class="headerlink" title="Enum: Enumerations"></a><a name="S-enum"></a>Enum: Enumerations</h1><p>Enumerations are used to define sets of integer values and for defining types for such sets of values.<br>There are two kind of enumerations, “plain” <code>enum</code>s and <code>class enum</code>s.</p>
<p>Enumeration rule summary:</p>
<ul>
<li><a href="#Renum-macro">Enum.1: Prefer enumerations over macros</a></li>
<li><a href="#Renum-set">Enum.2: Use enumerations to represent sets of related named constants</a></li>
<li><a href="#Renum-class">Enum.3: Prefer <code>enum class</code>es over “plain” <code>enum</code>s</a></li>
<li><a href="#Renum-oper">Enum.4: Define operations on enumerations for safe and simple use</a></li>
<li><a href="#Renum-caps">Enum.5: Don’t use <code>ALL_CAPS</code> for enumerators</a></li>
<li><a href="#Renum-unnamed">Enum.6: Avoid unnamed enumerations</a></li>
<li><a href="#Renum-underlying">Enum.7: Specify the underlying type of an enumeration only when necessary</a></li>
<li><a href="#Renum-value">Enum.8: Specify enumerator values only when necessary</a></li>
</ul>
<h3 id="Enum-1-Prefer-enumerations-over-macros"><a href="#Enum-1-Prefer-enumerations-over-macros" class="headerlink" title="Enum.1: Prefer enumerations over macros"></a><a name="Renum-macro"></a>Enum.1: Prefer enumerations over macros</h3><h5 id="Reason-160"><a href="#Reason-160" class="headerlink" title="Reason"></a>Reason</h5><p>Macros do not obey scope and type rules. Also, macro names are removed during preprocessing and so usually don’t appear in tools like debuggers.</p>
<h5 id="Example-137"><a href="#Example-137" class="headerlink" title="Example"></a>Example</h5><p>First some bad old code:</p>
<pre><code>// webcolors.h (third party header)
#define RED   0xFF0000
#define GREEN 0x00FF00
#define BLUE  0x0000FF

// productinfo.h
// The following define product subtypes based on color
#define RED    0
#define PURPLE 1
#define BLUE   2

int webby = BLUE;   // webby == 2; probably not what was desired
</code></pre>
<p>Instead use an <code>enum</code>:</p>
<pre><code>enum class Web_color &#123; red = 0xFF0000, green = 0x00FF00, blue = 0x0000FF &#125;;
enum class Product_info &#123; red = 0, purple = 1, blue = 2 &#125;;

int webby = blue;   // error: be specific
Web_color webby = Web_color::blue;
</code></pre>
<p>We used an <code>enum class</code> to avoid name clashes.</p>
<h5 id="Enforcement-153"><a href="#Enforcement-153" class="headerlink" title="Enforcement"></a>Enforcement</h5><p>Flag macros that define integer values.</p>
<h3 id="Enum-2-Use-enumerations-to-represent-sets-of-related-named-constants"><a href="#Enum-2-Use-enumerations-to-represent-sets-of-related-named-constants" class="headerlink" title="Enum.2: Use enumerations to represent sets of related named constants"></a><a name="Renum-set"></a>Enum.2: Use enumerations to represent sets of related named constants</h3><h5 id="Reason-161"><a href="#Reason-161" class="headerlink" title="Reason"></a>Reason</h5><p>An enumeration shows the enumerators to be related and can be a named type.</p>
<h5 id="Example-138"><a href="#Example-138" class="headerlink" title="Example"></a>Example</h5><pre><code>enum class Web_color &#123; red = 0xFF0000, green = 0x00FF00, blue = 0x0000FF &#125;;
</code></pre>
<h5 id="Note-163"><a href="#Note-163" class="headerlink" title="Note"></a>Note</h5><p>Switching on an enumeration is common and the compiler can warn against unusual patterns of case labels. For example:</p>
<pre><code>enum class Product_info &#123; red = 0, purple = 1, blue = 2 &#125;;

void print(Product_info inf)
&#123;
    switch (inf) &#123;
    case Product_info::red: cout &lt;&lt; &quot;red&quot;; break;
    case Product_info::purple: cout &lt;&lt; &quot;purple&quot;; break;
    &#125;
&#125;
</code></pre>
<p>Such off-by-one switch`statements are often the results of an added enumerator and insufficient testing.</p>
<h5 id="Enforcement-154"><a href="#Enforcement-154" class="headerlink" title="Enforcement"></a>Enforcement</h5><ul>
<li>Flag <code>switch</code>-statements where the <code>case</code>s cover most but not all enumerators of an enumeration.</li>
<li>Flag <code>switch</code>-statements where the <code>case</code>s cover a few enumerators of an enumeration, but has no <code>default</code>.</li>
</ul>
<h3 id="Enum-3-Prefer-class-enums-over-“plain”-enums"><a href="#Enum-3-Prefer-class-enums-over-“plain”-enums" class="headerlink" title="Enum.3: Prefer class enums over “plain” enums"></a><a name="Renum-class"></a>Enum.3: Prefer class enums over “plain” enums</h3><h5 id="Reason-162"><a href="#Reason-162" class="headerlink" title="Reason"></a>Reason</h5><p>To minimize surprises: traditional enums convert to int too readily.</p>
<h5 id="Example-139"><a href="#Example-139" class="headerlink" title="Example"></a>Example</h5><pre><code>void Print_color(int color);

enum Web_color &#123; red = 0xFF0000, green = 0x00FF00, blue = 0x0000FF &#125;;
enum Product_info &#123; Red = 0, Purple = 1, Blue = 2 &#125;;

Web_color webby = Web_color::blue;

// Clearly at least one of these calls is buggy.
Print_color(webby);
Print_color(Product_info::Blue);
</code></pre>
<p>Instead use an <code>enum class</code>:</p>
<pre><code>void Print_color(int color);

enum class Web_color &#123; red = 0xFF0000, green = 0x00FF00, blue = 0x0000FF &#125;;
enum class Product_info &#123; red = 0, purple = 1, blue = 2 &#125;;

Web_color webby = Web_color::blue;
Print_color(webby);  // Error: cannot convert Web_color to int.
Print_color(Product_info::Red);  // Error: cannot convert Product_info to int.
</code></pre>
<h5 id="Enforcement-155"><a href="#Enforcement-155" class="headerlink" title="Enforcement"></a>Enforcement</h5><p>(Simple) Warn on any non-class <code>enum</code> definition.</p>
<h3 id="Enum-4-Define-operations-on-enumerations-for-safe-and-simple-use"><a href="#Enum-4-Define-operations-on-enumerations-for-safe-and-simple-use" class="headerlink" title="Enum.4: Define operations on enumerations for safe and simple use"></a><a name="Renum-oper"></a>Enum.4: Define operations on enumerations for safe and simple use</h3><h5 id="Reason-163"><a href="#Reason-163" class="headerlink" title="Reason"></a>Reason</h5><p>Convenience of use and avoidance of errors.</p>
<h5 id="Example-140"><a href="#Example-140" class="headerlink" title="Example"></a>Example</h5><pre><code>enum Day &#123; mon, tue, wed, thu, fri, sat, sun &#125;;

Day&amp; operator++(Day&amp; d)
&#123;
    return d = (d == Day::sun) ? Day::mon : static_cast&lt;Day&gt;(static_cast&lt;int&gt;(d)+1);
&#125;

Day today = Day::sat;
Day tomorrow = ++today;
</code></pre>
<p>The use of a <code>static_cast</code> is not pretty, but</p>
<pre><code>Day&amp; operator++(Day&amp; d)
&#123;
    return d = (d == Day::sun) ? Day::mon : Day&#123;++d&#125;;    // error
&#125;
</code></pre>
<p>is an infinite recursion, and writing it without a cast, using a <code>switch</code> on all cases is long-winded.</p>
<h5 id="Enforcement-156"><a href="#Enforcement-156" class="headerlink" title="Enforcement"></a>Enforcement</h5><p>Flag repeated expressions cast back into an enumeration.</p>
<h3 id="Enum-5-Don’t-use-ALL-CAPS-for-enumerators"><a href="#Enum-5-Don’t-use-ALL-CAPS-for-enumerators" class="headerlink" title="Enum.5: Don’t use ALL_CAPS for enumerators"></a><a name="Renum-caps"></a>Enum.5: Don’t use <code>ALL_CAPS</code> for enumerators</h3><h5 id="Reason-164"><a href="#Reason-164" class="headerlink" title="Reason"></a>Reason</h5><p>Avoid clashes with macros.</p>
<h5 id="Example-bad-63"><a href="#Example-bad-63" class="headerlink" title="Example, bad"></a>Example, bad</h5><pre><code> // webcolors.h (third party header)
#define RED   0xFF0000
#define GREEN 0x00FF00
#define BLUE  0x0000FF

// productinfo.h
// The following define product subtypes based on color

enum class Product_info &#123; RED, PURPLE, BLUE &#125;;   // syntax error
</code></pre>
<h5 id="Enforcement-157"><a href="#Enforcement-157" class="headerlink" title="Enforcement"></a>Enforcement</h5><p>Flag ALL_CAPS enumerators.</p>
<h3 id="Enum-6-Avoid-unnamed-enumerations"><a href="#Enum-6-Avoid-unnamed-enumerations" class="headerlink" title="Enum.6: Avoid unnamed enumerations"></a><a name="Renum-unnamed"></a>Enum.6: Avoid unnamed enumerations</h3><h5 id="Reason-165"><a href="#Reason-165" class="headerlink" title="Reason"></a>Reason</h5><p>If you can’t name an enumeration, the values are not related</p>
<h5 id="Example-bad-64"><a href="#Example-bad-64" class="headerlink" title="Example, bad"></a>Example, bad</h5><pre><code>enum &#123; red = 0xFF0000, scale = 4, is_signed = 1 &#125;;
</code></pre>
<p>Such code is not uncommon in code written before there were convenient alternative ways of specifying integer constants.</p>
<h5 id="Alternative-7"><a href="#Alternative-7" class="headerlink" title="Alternative"></a>Alternative</h5><p>Use <code>constexpr</code> values instead. For example:</p>
<pre><code>constexpr int red = 0xFF0000;
constexpr short scale = 4;
constexpr bool is_signed = true;
</code></pre>
<h5 id="Enforcement-158"><a href="#Enforcement-158" class="headerlink" title="Enforcement"></a>Enforcement</h5><p>Flag unnamed enumerations.</p>
<h3 id="Enum-7-Specify-the-underlying-type-of-an-enumeration-only-when-necessary"><a href="#Enum-7-Specify-the-underlying-type-of-an-enumeration-only-when-necessary" class="headerlink" title="Enum.7: Specify the underlying type of an enumeration only when necessary"></a><a name="Renum-underlying"></a>Enum.7: Specify the underlying type of an enumeration only when necessary</h3><h5 id="Reason-166"><a href="#Reason-166" class="headerlink" title="Reason"></a>Reason</h5><p>The default is the easiest to read and write.<br><code>int</code> is the default integer type.<br><code>int</code> is compatible with C <code>enum</code>s.</p>
<h5 id="Example-141"><a href="#Example-141" class="headerlink" title="Example"></a>Example</h5><pre><code>enum class Direction : char &#123; n, s, e, w,
                              ne, nw, se, sw &#125;;  // underlying type saves space

enum class Web_color : int32_t &#123; red   = 0xFF0000,
                                 green = 0x00FF00,
                                 blue  = 0x0000FF &#125;;  // underlying type is redundant
</code></pre>
<h5 id="Note-164"><a href="#Note-164" class="headerlink" title="Note"></a>Note</h5><p>Specifying the underlying type is necessary in forward declarations of enumerations:</p>
<pre><code>enum Flags : char;

void f(Flags);

// ....

enum flags : char &#123; /* ... */ &#125;;
</code></pre>
<h5 id="Enforcement-159"><a href="#Enforcement-159" class="headerlink" title="Enforcement"></a>Enforcement</h5><p>????</p>
<h3 id="Enum-8-Specify-enumerator-values-only-when-necessary"><a href="#Enum-8-Specify-enumerator-values-only-when-necessary" class="headerlink" title="Enum.8: Specify enumerator values only when necessary"></a><a name="Renum-value"></a>Enum.8: Specify enumerator values only when necessary</h3><h5 id="Reason-167"><a href="#Reason-167" class="headerlink" title="Reason"></a>Reason</h5><p>It’s the simplest.<br>It avoids duplicate enumerator values.<br>The default gives a consecutive set of values that is good for <code>switch</code>-statement implementations.</p>
<h5 id="Example-142"><a href="#Example-142" class="headerlink" title="Example"></a>Example</h5><pre><code>enum class Col1 &#123; red, yellow, blue &#125;;
enum class Col2 &#123; red = 1, yellow = 2, blue = 2 &#125;; // typo
enum class Month &#123; jan = 1, feb, mar, apr, may, jun,
                   jul, august, sep, oct, nov, dec &#125;; // starting with 1 is conventional
enum class Base_flag &#123; dec = 1, oct = dec &lt;&lt; 1, hex = dec &lt;&lt; 2 &#125;; // set of bits
</code></pre>
<p>Specifying values is necessary to match conventional values (e.g., <code>Month</code>)<br>and where consecutive values are undesirable (e.g., to get separate bits as in <code>Base_flag</code>).</p>
<h5 id="Enforcement-160"><a href="#Enforcement-160" class="headerlink" title="Enforcement"></a>Enforcement</h5><ul>
<li>Flag duplicate enumerator values</li>
<li>Flag explicitly specified all-consecutive enumerator values</li>
</ul>
<h1 id="R-Resource-management"><a href="#R-Resource-management" class="headerlink" title="R: Resource management"></a><a name="S-resource"></a>R: Resource management</h1><p>This section contains rules related to resources.<br>A resource is anything that must be acquired and (explicitly or implicitly) released, such as memory, file handles, sockets, and locks.<br>The reason it must be released is typically that it can be in short supply, so even delayed release may do harm.<br>The fundamental aim is to ensure that we don’t leak any resources and that we don’t hold a resource longer than we need to.<br>An entity that is responsible for releasing a resource is called an owner.</p>
<p>There are a few cases where leaks can be acceptable or even optimal:<br>If you are writing a program that simply produces an output based on an input and the amount of memory needed is proportional to the size of the input, the optimal strategy (for performance and ease of programming) is sometimes simply never to delete anything.<br>If you have enough memory to handle your largest input, leak away, but be sure to give a good error message if you are wrong.<br>Here, we ignore such cases.</p>
<ul>
<li><p>Resource management rule summary:</p>
<ul>
<li><a href="#Rr-raii">R.1: Manage resources automatically using resource handles and RAII (Resource Acquisition Is Initialization)</a></li>
<li><a href="#Rr-use-ptr">R.2: In interfaces, use raw pointers to denote individual objects (only)</a></li>
<li><a href="#Rr-ptr">R.3: A raw pointer (a <code>T*</code>) is non-owning</a></li>
<li><a href="#Rr-ref">R.4: A raw reference (a <code>T&amp;</code>) is non-owning</a></li>
<li><a href="#Rr-scoped">R.5: Prefer scoped objects, don’t heap-allocate unnecessarily</a></li>
<li><a href="#Rr-global">R.6: Avoid non-<code>const</code> global variables</a></li>
</ul>
</li>
<li><p>Allocation and deallocation rule summary:</p>
<ul>
<li><a href="#Rr-mallocfree">R.10: Avoid <code>malloc()</code> and <code>free()</code></a></li>
<li><a href="#Rr-newdelete">R.11: Avoid calling <code>new</code> and <code>delete</code> explicitly</a></li>
<li><a href="#Rr-immediate-alloc">R.12: Immediately give the result of an explicit resource allocation to a manager object</a></li>
<li><a href="#Rr-single-alloc">R.13: Perform at most one explicit resource allocation in a single expression statement</a></li>
<li><a href="#Rr-ap">R.14: ??? array vs. pointer parameter</a></li>
<li><a href="#Rr-pair">R.15: Always overload matched allocation/deallocation pairs</a></li>
</ul>
</li>
<li><p><a name="Rr-summary-smartptrs"></a>Smart pointer rule summary:</p>
<ul>
<li><a href="#Rr-owner">R.20: Use <code>unique_ptr</code> or <code>shared_ptr</code> to represent ownership</a></li>
<li><a href="#Rr-unique">R.21: Prefer <code>unique_ptr</code> over <code>shared_ptr</code> unless you need to share ownership</a></li>
<li><a href="#Rr-make_shared">R.22: Use <code>make_shared()</code> to make <code>shared_ptr</code>s</a></li>
<li><a href="#Rr-make_unique">R.23: Use <code>make_unique()</code> to make <code>unique_ptr</code>s</a></li>
<li><a href="#Rr-weak_ptr">R.24: Use <code>std::weak_ptr</code> to break cycles of <code>shared_ptr</code>s</a></li>
<li><a href="#Rr-smartptrparam">R.30: Take smart pointers as parameters only to explicitly express lifetime semantics</a></li>
<li><a href="#Rr-smart">R.31: If you have non-<code>std</code> smart pointers, follow the basic pattern from <code>std</code></a></li>
<li><a href="#Rr-uniqueptrparam">R.32: Take a <code>unique_ptr&lt;widget&gt;</code> parameter to express that a function assumes ownership of a <code>widget</code></a></li>
<li><a href="#Rr-reseat">R.33: Take a <code>unique_ptr&lt;widget&gt;&amp;</code> parameter to express that a function reseats the <code>widget</code></a></li>
<li><a href="#Rr-sharedptrparam-owner">R.34: Take a <code>shared_ptr&lt;widget&gt;</code> parameter to express that a function is part owner</a></li>
<li><a href="#Rr-sharedptrparam">R.35: Take a <code>shared_ptr&lt;widget&gt;&amp;</code> parameter to express that a function might reseat the shared pointer</a></li>
<li><a href="#Rr-sharedptrparam-const">R.36: Take a <code>const shared_ptr&lt;widget&gt;&amp;</code> parameter to express that it might retain a reference count to the object ???</a></li>
<li><a href="#Rr-smartptrget">R.37: Do not pass a pointer or reference obtained from an aliased smart pointer</a></li>
</ul>
</li>
</ul>
<h3 id="R-1-Manage-resources-automatically-using-resource-handles-and-RAII-Resource-Acquisition-Is-Initialization"><a href="#R-1-Manage-resources-automatically-using-resource-handles-and-RAII-Resource-Acquisition-Is-Initialization" class="headerlink" title="R.1: Manage resources automatically using resource handles and RAII (Resource Acquisition Is Initialization)"></a><a name="Rr-raii"></a>R.1: Manage resources automatically using resource handles and RAII (Resource Acquisition Is Initialization)</h3><h5 id="Reason-168"><a href="#Reason-168" class="headerlink" title="Reason"></a>Reason</h5><p>To avoid leaks and the complexity of manual resource management.<br>C++’s language-enforced constructor/destructor symmetry mirrors the symmetry inherent in resource acquire/release function pairs such as <code>fopen</code>/<code>fclose</code>, <code>lock</code>/<code>unlock</code>, and <code>new</code>/<code>delete</code>.<br>Whenever you deal with a resource that needs paired acquire/release function calls, encapsulate that resource in an object that enforces pairing for you – acquire the resource in its constructor, and release it in its destructor.</p>
<h5 id="Example-bad-65"><a href="#Example-bad-65" class="headerlink" title="Example, bad"></a>Example, bad</h5><p>Consider:</p>
<pre><code>void send(X* x, cstring_span destination)
&#123;
    auto port = open_port(destination);
    my_mutex.lock();
    // ...
    send(port, x);
    // ...
    my_mutex.unlock();
    close_port(port);
    delete x;
&#125;
</code></pre>
<p>In this code, you have to remember to <code>unlock</code>, <code>close_port</code>, and <code>delete</code> on all paths, and do each exactly once.<br>Further, if any of the code marked <code>...</code> throws an exception, then <code>x</code> is leaked and <code>my_mutex</code> remains locked.</p>
<h5 id="Example-143"><a href="#Example-143" class="headerlink" title="Example"></a>Example</h5><p>Consider:</p>
<pre><code>void send(unique_ptr&lt;X&gt; x, cstring_span destination)  // x owns the X
&#123;
    Port port&#123;destination&#125;;            // port owns the PortHandle
    lock_guard&lt;mutex&gt; guard&#123;my_mutex&#125;; // guard owns the lock
    // ...
    send(port, x);
    // ...
&#125; // automatically unlocks my_mutex and deletes the pointer in x
</code></pre>
<p>Now all resource cleanup is automatic, performed once on all paths whether or not there is an exception. As a bonus, the function now advertises that it takes over ownership of the pointer.</p>
<p>What is <code>Port</code>? A handy wrapper that encapsulates the resource:</p>
<pre><code>class Port &#123;
    PortHandle port;
public:
    Port(cstring_span destination) : port&#123;open_port(destination)&#125; &#123; &#125;
    ~Port() &#123; close_port(port); &#125;
    operator PortHandle() &#123; return port; &#125;

    // port handles can&#39;t usually be cloned, so disable copying and assignment if necessary
    Port(const Port&amp;) = delete;
    Port&amp; operator=(const Port&amp;) = delete;
&#125;;
</code></pre>
<h5 id="Note-165"><a href="#Note-165" class="headerlink" title="Note"></a>Note</h5><p>Where a resource is “ill-behaved” in that it isn’t represented as a class with a destructor, wrap it in a class or use <a href="#Re-finally"><code>finally</code></a></p>
<p><strong>See also</strong>: <a href="#Rr-raii">RAII</a></p>
<h3 id="R-2-In-interfaces-use-raw-pointers-to-denote-individual-objects-only"><a href="#R-2-In-interfaces-use-raw-pointers-to-denote-individual-objects-only" class="headerlink" title="R.2: In interfaces, use raw pointers to denote individual objects (only)"></a><a name="Rr-use-ptr"></a>R.2: In interfaces, use raw pointers to denote individual objects (only)</h3><h5 id="Reason-169"><a href="#Reason-169" class="headerlink" title="Reason"></a>Reason</h5><p>Arrays are best represented by a container type (e.g., <code>vector</code> (owning)) or a <code>span</code> (non-owning).<br>Such containers and views hold sufficient information to do range checking.</p>
<h5 id="Example-bad-66"><a href="#Example-bad-66" class="headerlink" title="Example, bad"></a>Example, bad</h5><pre><code>void f(int* p, int n)   // n is the number of elements in p[]
&#123;
    // ...
    p[2] = 7;   // bad: subscript raw pointer
    // ...
&#125;
</code></pre>
<p>The compiler does not read comments, and without reading other code you do not know whether <code>p</code> really points to <code>n</code> elements.<br>Use a <code>span</code> instead.</p>
<h5 id="Example-144"><a href="#Example-144" class="headerlink" title="Example"></a>Example</h5><pre><code>void g(int* p, int fmt)   // print *p using format #fmt
&#123;
    // ... uses *p and p[0] only ...
&#125;
</code></pre>
<h5 id="Exception-27"><a href="#Exception-27" class="headerlink" title="Exception"></a>Exception</h5><p>C-style strings are passed as single pointers to a zero-terminated sequence of characters.<br>Use <code>zstring</code> rather than <code>char*</code> to indicate that you rely on that convention.</p>
<h5 id="Note-166"><a href="#Note-166" class="headerlink" title="Note"></a>Note</h5><p>Many current uses of pointers to a single element could be references.<br>However, where <code>nullptr</code> is a possible value, a reference may not be a reasonable alternative.</p>
<h5 id="Enforcement-161"><a href="#Enforcement-161" class="headerlink" title="Enforcement"></a>Enforcement</h5><ul>
<li>Flag pointer arithmetic (including <code>++</code>) on a pointer that is not part of a container, view, or iterator.<br>This rule would generate a huge number of false positives if applied to an older code base.</li>
<li>Flag array names passed as simple pointers</li>
</ul>
<h3 id="R-3-A-raw-pointer-a-T-is-non-owning"><a href="#R-3-A-raw-pointer-a-T-is-non-owning" class="headerlink" title="R.3: A raw pointer (a T*) is non-owning"></a><a name="Rr-ptr"></a>R.3: A raw pointer (a <code>T*</code>) is non-owning</h3><h5 id="Reason-170"><a href="#Reason-170" class="headerlink" title="Reason"></a>Reason</h5><p>There is nothing (in the C++ standard or in most code) to say otherwise and most raw pointers are non-owning.<br>We want owning pointers identified so that we can reliably and efficiently delete the objects pointed to by owning pointers.</p>
<h5 id="Example-145"><a href="#Example-145" class="headerlink" title="Example"></a>Example</h5><pre><code>void f()
&#123;
    int* p1 = new int&#123;7&#125;;           // bad: raw owning pointer
    auto p2 = make_unique&lt;int&gt;(7);  // OK: the int is owned by a unique pointer
    // ...
&#125;
</code></pre>
<p>The <code>unique_ptr</code> protects against leaks by guaranteeing the deletion of its object (even in the presence of exceptions). The <code>T*</code> does not.</p>
<h5 id="Example-146"><a href="#Example-146" class="headerlink" title="Example"></a>Example</h5><pre><code>template&lt;typename T&gt;
class X &#123;
    // ...
public:
    T* p;   // bad: it is unclear whether p is owning or not
    T* q;   // bad: it is unclear whether q is owning or not
&#125;;
</code></pre>
<p>We can fix that problem by making ownership explicit:</p>
<pre><code>template&lt;typename T&gt;
class X2 &#123;
    // ...
public:
    owner&lt;T*&gt; p;  // OK: p is owning
    T* q;         // OK: q is not owning
&#125;;
</code></pre>
<h5 id="Exception-28"><a href="#Exception-28" class="headerlink" title="Exception"></a>Exception</h5><p>A major class of exception is legacy code, especially code that must remain compilable as C or interface with C and C-style C++ through ABIs.<br>The fact that there are billions of lines of code that violate this rule against owning <code>T*</code>s cannot be ignored.<br>We’d love to see program transformation tools turning 20-year-old “legacy” code into shiny modern code,<br>we encourage the development, deployment and use of such tools,<br>we hope the guidelines will help the development of such tools,<br>and we even contributed (and contribute) to the research and development in this area.<br>However, it will take time: “legacy code” is generated faster than we can renovate old code, and so it will be for a few years.</p>
<p>This code cannot all be rewritten (ever assuming good code transformation software), especially not soon.<br>This problem cannot be solved (at scale) by transforming all owning pointers to <code>unique_ptr</code>s and <code>shared_ptr</code>s,<br>partly because we need/use owning “raw pointers” as well as simple pointers in the implementation of our fundamental resource handles.<br>For example, common <code>vector</code> implementations have one owning pointer and two non-owning pointers.<br>Many ABIs (and essentially all interfaces to C code) use <code>T*</code>s, some of them owning.<br>Some interfaces cannot be simply annotated with <code>owner</code> because they need to remain compilable as C<br>(although this would be a rare good use for a macro, that expands to <code>owner</code> in C++ mode only).</p>
<h5 id="Note-167"><a href="#Note-167" class="headerlink" title="Note"></a>Note</h5><p><code>owner&lt;T*&gt;</code> has no default semantics beyond <code>T*</code>. It can be used without changing any code using it and without affecting ABIs.<br>It is simply a indicator to programmers and analysis tools.<br>For example, if an <code>owner&lt;T*&gt;</code> is a member of a class, that class better have a destructor that <code>delete</code>s it.</p>
<h5 id="Example-bad-67"><a href="#Example-bad-67" class="headerlink" title="Example, bad"></a>Example, bad</h5><p>Returning a (raw) pointer imposes a lifetime management uncertainty on the caller; that is, who deletes the pointed-to object?</p>
<pre><code>Gadget* make_gadget(int n)
&#123;
    auto p = new Gadget&#123;n&#125;;
    // ...
    return p;
&#125;

void caller(int n)
&#123;
    auto p = make_gadget(n);   // remember to delete p
    // ...
    delete p;
&#125;
</code></pre>
<p>In addition to suffering from the problem from <a href="#???">leak</a>, this adds a spurious allocation and deallocation operation, and is needlessly verbose. If Gadget is cheap to move out of a function (i.e., is small or has an efficient move operation), just return it “by value” (see <a href="#Rf-out">“out” return values</a>):</p>
<pre><code>Gadget make_gadget(int n)
&#123;
    Gadget g&#123;n&#125;;
    // ...
    return g;
&#125;
</code></pre>
<h5 id="Note-168"><a href="#Note-168" class="headerlink" title="Note"></a>Note</h5><p>This rule applies to factory functions.</p>
<h5 id="Note-169"><a href="#Note-169" class="headerlink" title="Note"></a>Note</h5><p>If pointer semantics are required (e.g., because the return type needs to refer to a base class of a class hierarchy (an interface)), return a “smart pointer.”</p>
<h5 id="Enforcement-162"><a href="#Enforcement-162" class="headerlink" title="Enforcement"></a>Enforcement</h5><ul>
<li>(Simple) Warn on <code>delete</code> of a raw pointer that is not an <code>owner&lt;T&gt;</code>.</li>
<li>(Moderate) Warn on failure to either <code>reset</code> or explicitly <code>delete</code> an <code>owner&lt;T&gt;</code> pointer on every code path.</li>
<li>(Simple) Warn if the return value of <code>new</code> is assigned to a raw pointer.</li>
<li>(Simple) Warn if a function returns an object that was allocated within the function but has a move constructor.<br>Suggest considering returning it by value instead.</li>
</ul>
<h3 id="R-4-A-raw-reference-a-T-amp-is-non-owning"><a href="#R-4-A-raw-reference-a-T-amp-is-non-owning" class="headerlink" title="R.4: A raw reference (a T&amp;) is non-owning"></a><a name="Rr-ref"></a>R.4: A raw reference (a <code>T&amp;</code>) is non-owning</h3><h5 id="Reason-171"><a href="#Reason-171" class="headerlink" title="Reason"></a>Reason</h5><p>There is nothing (in the C++ standard or in most code) to say otherwise and most raw references are non-owning.<br>We want owners identified so that we can reliably and efficiently delete the objects pointed to by owning pointers.</p>
<h5 id="Example-147"><a href="#Example-147" class="headerlink" title="Example"></a>Example</h5><pre><code>void f()
&#123;
    int&amp; r = *new int&#123;7&#125;;  // bad: raw owning reference
    // ...
    delete &amp;r;             // bad: violated the rule against deleting raw pointers
&#125;
</code></pre>
<p><strong>See also</strong>: <a href="#Rr-ptr">The raw pointer rule</a></p>
<h5 id="Enforcement-163"><a href="#Enforcement-163" class="headerlink" title="Enforcement"></a>Enforcement</h5><p>See <a href="#Rr-ptr">the raw pointer rule</a></p>
<h3 id="R-5-Prefer-scoped-objects-don’t-heap-allocate-unnecessarily"><a href="#R-5-Prefer-scoped-objects-don’t-heap-allocate-unnecessarily" class="headerlink" title="R.5: Prefer scoped objects, don’t heap-allocate unnecessarily"></a><a name="Rr-scoped"></a>R.5: Prefer scoped objects, don’t heap-allocate unnecessarily</h3><h5 id="Reason-172"><a href="#Reason-172" class="headerlink" title="Reason"></a>Reason</h5><p>A scoped object is a local object, a global object, or a member.<br>This implies that there is no separate allocation and deallocation cost in excess of that already used for the containing scope or object.<br>The members of a scoped object are themselves scoped and the scoped object’s constructor and destructor manage the members’ lifetimes.</p>
<h5 id="Example-148"><a href="#Example-148" class="headerlink" title="Example"></a>Example</h5><p>The following example is inefficient (because it has unnecessary allocation and deallocation), vulnerable to exception throws and returns in the <code>...</code> part (leading to leaks), and verbose:</p>
<pre><code>void f(int n)
&#123;
    auto p = new Gadget&#123;n&#125;;
    // ...
    delete p;
&#125;
</code></pre>
<p>Instead, use a local variable:</p>
<pre><code>void f(int n)
&#123;
    Gadget g&#123;n&#125;;
    // ...
&#125;
</code></pre>
<h5 id="Enforcement-164"><a href="#Enforcement-164" class="headerlink" title="Enforcement"></a>Enforcement</h5><ul>
<li>(Moderate) Warn if an object is allocated and then deallocated on all paths within a function. Suggest it should be a local <code>auto</code> stack object instead.</li>
<li>(Simple) Warn if a local <code>Unique_ptr</code> or <code>Shared_ptr</code> is not moved, copied, reassigned or <code>reset</code> before its lifetime ends.</li>
</ul>
<h3 id="R-6-Avoid-non-const-global-variables"><a href="#R-6-Avoid-non-const-global-variables" class="headerlink" title="R.6: Avoid non-const global variables"></a><a name="Rr-global"></a>R.6: Avoid non-<code>const</code> global variables</h3><h5 id="Reason-173"><a href="#Reason-173" class="headerlink" title="Reason"></a>Reason</h5><p>Global variables can be accessed from everywhere so they can introduce surprising dependencies between apparently unrelated objects.<br>They are a notable source of errors.</p>
<p><strong>Warning</strong>: The initialization of global objects is not totally ordered.<br>If you use a global object initialize it with a constant.<br>Note that it is possible to get undefined initialization order even for <code>const</code> objects.</p>
<h5 id="Exception-29"><a href="#Exception-29" class="headerlink" title="Exception"></a>Exception</h5><p>A global object is often better than a singleton.</p>
<h5 id="Exception-30"><a href="#Exception-30" class="headerlink" title="Exception"></a>Exception</h5><p>An immutable (<code>const</code>) global does not introduce the problems we try to avoid by banning global objects.</p>
<h5 id="Enforcement-165"><a href="#Enforcement-165" class="headerlink" title="Enforcement"></a>Enforcement</h5><p>(??? NM: Obviously we can warn about non-<code>const</code> statics … do we want to?)</p>
<h2 id="R-alloc-Allocation-and-deallocation"><a href="#R-alloc-Allocation-and-deallocation" class="headerlink" title="R.alloc: Allocation and deallocation"></a><a name="SS-alloc"></a>R.alloc: Allocation and deallocation</h2><h3 id="R-10-Avoid-malloc-and-free"><a href="#R-10-Avoid-malloc-and-free" class="headerlink" title="R.10: Avoid malloc() and free()"></a><a name="Rr-mallocfree"></a>R.10: Avoid <code>malloc()</code> and <code>free()</code></h3><h5 id="Reason-174"><a href="#Reason-174" class="headerlink" title="Reason"></a>Reason</h5><p> <code>malloc()</code> and <code>free()</code> do not support construction and destruction, and do not mix well with <code>new</code> and <code>delete</code>.</p>
<h5 id="Example-149"><a href="#Example-149" class="headerlink" title="Example"></a>Example</h5><pre><code>class Record &#123;
    int id;
    string name;
    // ...
&#125;;

void use()
&#123;
    // p1 may be nullptr
    // *p1 is not initialized; in particular,
    // that string isn&#39;t a string, but a string-sized bag of bits
    Record* p1 = static_cast&lt;Record*&gt;(malloc(sizeof(Record)));

    auto p2 = new Record;

    // unless an exception is thrown, *p2 is default initialized
    auto p3 = new(nothrow) Record;
    // p3 may be nullptr; if not, *p3 is default initialized

    // ...

    delete p1;    // error: cannot delete object allocated by malloc()
    free(p2);    // error: cannot free() object allocated by new
&#125;
</code></pre>
<p>In some implementations that <code>delete</code> and that <code>free()</code> might work, or maybe they will cause run-time errors.</p>
<h5 id="Exception-31"><a href="#Exception-31" class="headerlink" title="Exception"></a>Exception</h5><p>There are applications and sections of code where exceptions are not acceptable.<br>Some of the best such examples are in life-critical hard-real-time code.<br>Beware that many bans on exception use are based on superstition (bad)<br>or by concerns for older code bases with unsystematic resource management (unfortunately, but sometimes necessary).<br>In such cases, consider the <code>nothrow</code> versions of <code>new</code>.</p>
<h5 id="Enforcement-166"><a href="#Enforcement-166" class="headerlink" title="Enforcement"></a>Enforcement</h5><p>Flag explicit use of <code>malloc</code> and <code>free</code>.</p>
<h3 id="R-11-Avoid-calling-new-and-delete-explicitly"><a href="#R-11-Avoid-calling-new-and-delete-explicitly" class="headerlink" title="R.11: Avoid calling new and delete explicitly"></a><a name="Rr-newdelete"></a>R.11: Avoid calling <code>new</code> and <code>delete</code> explicitly</h3><h5 id="Reason-175"><a href="#Reason-175" class="headerlink" title="Reason"></a>Reason</h5><p>The pointer returned by <code>new</code> should belong to a resource handle (that can call <code>delete</code>).<br>If the pointer returned by <code>new</code> is assigned to a plain/naked pointer, the object can be leaked.</p>
<h5 id="Note-170"><a href="#Note-170" class="headerlink" title="Note"></a>Note</h5><p>In a large program, a naked <code>delete</code> (that is a <code>delete</code> in application code, rather than part of code devoted to resource management)<br>is a likely bug: if you have N <code>delete</code>s, how can you be certain that you don’t need N+1 or N-1?<br>The bug may be latent: it may emerge only during maintenance.<br>If you have a naked <code>new</code>, you probably need a naked <code>delete</code> somewhere, so you probably have a bug.</p>
<h5 id="Enforcement-167"><a href="#Enforcement-167" class="headerlink" title="Enforcement"></a>Enforcement</h5><p>(Simple) Warn on any explicit use of <code>new</code> and <code>delete</code>. Suggest using <code>make_unique</code> instead.</p>
<h3 id="R-12-Immediately-give-the-result-of-an-explicit-resource-allocation-to-a-manager-object"><a href="#R-12-Immediately-give-the-result-of-an-explicit-resource-allocation-to-a-manager-object" class="headerlink" title="R.12: Immediately give the result of an explicit resource allocation to a manager object"></a><a name="Rr-immediate-alloc"></a>R.12: Immediately give the result of an explicit resource allocation to a manager object</h3><h5 id="Reason-176"><a href="#Reason-176" class="headerlink" title="Reason"></a>Reason</h5><p>If you don’t, an exception or a return may lead to a leak.</p>
<h5 id="Example-bad-68"><a href="#Example-bad-68" class="headerlink" title="Example, bad"></a>Example, bad</h5><pre><code>void f(const string&amp; name)
&#123;
    FILE* f = fopen(name, &quot;r&quot;);            // open the file
    vector&lt;char&gt; buf(1024);
    auto _ = finally([f] &#123; fclose(f); &#125;);  // remember to close the file
    // ...
&#125;
</code></pre>
<p>The allocation of <code>buf</code> may fail and leak the file handle.</p>
<h5 id="Example-150"><a href="#Example-150" class="headerlink" title="Example"></a>Example</h5><pre><code>void f(const string&amp; name)
&#123;
    ifstream f&#123;name&#125;;   // open the file
    vector&lt;char&gt; buf(1024);
    // ...
&#125;
</code></pre>
<p>The use of the file handle (in <code>ifstream</code>) is simple, efficient, and safe.</p>
<h5 id="Enforcement-168"><a href="#Enforcement-168" class="headerlink" title="Enforcement"></a>Enforcement</h5><ul>
<li>Flag explicit allocations used to initialize pointers (problem: how many direct resource allocations can we recognize?)</li>
</ul>
<h3 id="R-13-Perform-at-most-one-explicit-resource-allocation-in-a-single-expression-statement"><a href="#R-13-Perform-at-most-one-explicit-resource-allocation-in-a-single-expression-statement" class="headerlink" title="R.13: Perform at most one explicit resource allocation in a single expression statement"></a><a name="Rr-single-alloc"></a>R.13: Perform at most one explicit resource allocation in a single expression statement</h3><h5 id="Reason-177"><a href="#Reason-177" class="headerlink" title="Reason"></a>Reason</h5><p>If you perform two explicit resource allocations in one statement, you could leak resources because the order of evaluation of many subexpressions, including function arguments, is unspecified.</p>
<h5 id="Example-151"><a href="#Example-151" class="headerlink" title="Example"></a>Example</h5><pre><code>void fun(shared_ptr&lt;Widget&gt; sp1, shared_ptr&lt;Widget&gt; sp2);
</code></pre>
<p>This <code>fun</code> can be called like this:</p>
<pre><code>// BAD: potential leak
fun(shared_ptr&lt;Widget&gt;(new Widget(a, b)), shared_ptr&lt;Widget&gt;(new Widget(c, d)));
</code></pre>
<p>This is exception-unsafe because the compiler may reorder the two expressions building the function’s two arguments.<br>In particular, the compiler can interleave execution of the two expressions:<br>Memory allocation (by calling <code>operator new</code>) could be done first for both objects, followed by attempts to call the two <code>Widget</code> constructors.<br>If one of the constructor calls throws an exception, then the other object’s memory will never be released!</p>
<p>This subtle problem has a simple solution: Never perform more than one explicit resource allocation in a single expression statement.<br>For example:</p>
<pre><code>shared_ptr&lt;Widget&gt; sp1(new Widget(a, b)); // Better, but messy
fun(sp1, new Widget(c, d));
</code></pre>
<p>The best solution is to avoid explicit allocation entirely use factory functions that return owning objects:</p>
<pre><code>fun(make_shared&lt;Widget&gt;(a, b), make_shared&lt;Widget&gt;(c, d)); // Best
</code></pre>
<p>Write your own factory wrapper if there is not one already.</p>
<h5 id="Enforcement-169"><a href="#Enforcement-169" class="headerlink" title="Enforcement"></a>Enforcement</h5><ul>
<li>Flag expressions with multiple explicit resource allocations (problem: how many direct resource allocations can we recognize?)</li>
</ul>
<h3 id="R-14-array-vs-pointer-parameter"><a href="#R-14-array-vs-pointer-parameter" class="headerlink" title="R.14: ??? array vs. pointer parameter"></a><a name="Rr-ap"></a>R.14: ??? array vs. pointer parameter</h3><h5 id="Reason-178"><a href="#Reason-178" class="headerlink" title="Reason"></a>Reason</h5><p>An array decays to a pointer, thereby losing its size, opening the opportunity for range errors.</p>
<h5 id="Example-152"><a href="#Example-152" class="headerlink" title="Example"></a>Example</h5><pre><code>??? what do we recommend: f(int*[]) or f(int**) ???
</code></pre>
<p><strong>Alternative</strong>: Use <code>span</code> to preserve size information.</p>
<h5 id="Enforcement-170"><a href="#Enforcement-170" class="headerlink" title="Enforcement"></a>Enforcement</h5><p>Flag <code>[]</code> parameters.</p>
<h3 id="R-15-Always-overload-matched-allocation-deallocation-pairs"><a href="#R-15-Always-overload-matched-allocation-deallocation-pairs" class="headerlink" title="R.15: Always overload matched allocation/deallocation pairs"></a><a name="Rr-pair"></a>R.15: Always overload matched allocation/deallocation pairs</h3><h5 id="Reason-179"><a href="#Reason-179" class="headerlink" title="Reason"></a>Reason</h5><p>Otherwise you get mismatched operations and chaos.</p>
<h5 id="Example-153"><a href="#Example-153" class="headerlink" title="Example"></a>Example</h5><pre><code>class X &#123;
    // ...
    void* operator new(size_t s);
    void operator delete(void*);
    // ...
&#125;;
</code></pre>
<h5 id="Note-171"><a href="#Note-171" class="headerlink" title="Note"></a>Note</h5><p>If you want memory that cannot be deallocated, <code>=delete</code> the deallocation operation.<br>Don’t leave it undeclared.</p>
<h5 id="Enforcement-171"><a href="#Enforcement-171" class="headerlink" title="Enforcement"></a>Enforcement</h5><p>Flag incomplete pairs.</p>
<h2 id="R-smart-Smart-pointers"><a href="#R-smart-Smart-pointers" class="headerlink" title="R.smart: Smart pointers"></a><a name="SS-smart"></a>R.smart: Smart pointers</h2><h3 id="R-20-Use-unique-ptr-or-shared-ptr-to-represent-ownership"><a href="#R-20-Use-unique-ptr-or-shared-ptr-to-represent-ownership" class="headerlink" title="R.20: Use unique_ptr or shared_ptr to represent ownership"></a><a name="Rr-owner"></a>R.20: Use <code>unique_ptr</code> or <code>shared_ptr</code> to represent ownership</h3><h5 id="Reason-180"><a href="#Reason-180" class="headerlink" title="Reason"></a>Reason</h5><p>They can prevent resource leaks.</p>
<h5 id="Example-154"><a href="#Example-154" class="headerlink" title="Example"></a>Example</h5><p>Consider:</p>
<pre><code>void f()
&#123;
    X x;
    X* p1 &#123; new X &#125;;              // see also ???
    unique_ptr&lt;T&gt; p2 &#123; new X &#125;;   // unique ownership; see also ???
    shared_ptr&lt;T&gt; p3 &#123; new X &#125;;   // shared ownership; see also ???
    auto p4 = make_unique&lt;X&gt;();   // unique_ownership, preferable to the explicit use &quot;new&quot;
    auto p5 = make_shared&lt;X&gt;();   // shared ownership, preferable to the explicit use &quot;new&quot;
&#125;
</code></pre>
<p>This will leak the object used to initialize <code>p1</code> (only).</p>
<h5 id="Enforcement-172"><a href="#Enforcement-172" class="headerlink" title="Enforcement"></a>Enforcement</h5><p>(Simple) Warn if the return value of <code>new</code> or a function call with return value of pointer type is assigned to a raw pointer.</p>
<h3 id="R-21-Prefer-unique-ptr-over-shared-ptr-unless-you-need-to-share-ownership"><a href="#R-21-Prefer-unique-ptr-over-shared-ptr-unless-you-need-to-share-ownership" class="headerlink" title="R.21: Prefer unique_ptr over shared_ptr unless you need to share ownership"></a><a name="Rr-unique"></a>R.21: Prefer <code>unique_ptr</code> over <code>shared_ptr</code> unless you need to share ownership</h3><h5 id="Reason-181"><a href="#Reason-181" class="headerlink" title="Reason"></a>Reason</h5><p>A <code>unique_ptr</code> is conceptually simpler and more predictable (you know when destruction happens) and faster (you don’t implicitly maintain a use count).</p>
<h5 id="Example-bad-69"><a href="#Example-bad-69" class="headerlink" title="Example, bad"></a>Example, bad</h5><p>This needlessly adds and maintains a reference count.</p>
<pre><code>void f()
&#123;
    shared_ptr&lt;Base&gt; base = make_shared&lt;Derived&gt;();
    // use base locally, without copying it -- refcount never exceeds 1
&#125; // destroy base
</code></pre>
<h5 id="Example-155"><a href="#Example-155" class="headerlink" title="Example"></a>Example</h5><p>This is more efficient:</p>
<pre><code>void f()
&#123;
    unique_ptr&lt;Base&gt; base = make_unique&lt;Derived&gt;();
    // use base locally
&#125; // destroy base
</code></pre>
<h5 id="Enforcement-173"><a href="#Enforcement-173" class="headerlink" title="Enforcement"></a>Enforcement</h5><p>(Simple) Warn if a function uses a <code>Shared_ptr</code> with an object allocated within the function, but never returns the <code>Shared_ptr</code> or passes it to a function requiring a <code>Shared_ptr&amp;</code>. Suggest using <code>unique_ptr</code> instead.</p>
<h3 id="R-22-Use-make-shared-to-make-shared-ptrs"><a href="#R-22-Use-make-shared-to-make-shared-ptrs" class="headerlink" title="R.22: Use make_shared() to make shared_ptrs"></a><a name="Rr-make_shared"></a>R.22: Use <code>make_shared()</code> to make <code>shared_ptr</code>s</h3><h5 id="Reason-182"><a href="#Reason-182" class="headerlink" title="Reason"></a>Reason</h5><p>If you first make an object and then give it to a <code>shared_ptr</code> constructor, you (most likely) do one more allocation (and later deallocation) than if you use <code>make_shared()</code> because the reference counts must be allocated separately from the object.</p>
<h5 id="Example-156"><a href="#Example-156" class="headerlink" title="Example"></a>Example</h5><p>Consider:</p>
<pre><code>shared_ptr&lt;X&gt; p1 &#123; new X&#123;2&#125; &#125;; // bad
auto p = make_shared&lt;X&gt;(2);    // good
</code></pre>
<p>The <code>make_shared()</code> version mentions <code>X</code> only once, so it is usually shorter (as well as faster) than the version with the explicit <code>new</code>.</p>
<h5 id="Enforcement-174"><a href="#Enforcement-174" class="headerlink" title="Enforcement"></a>Enforcement</h5><p>(Simple) Warn if a <code>shared_ptr</code> is constructed from the result of <code>new</code> rather than <code>make_shared</code>.</p>
<h3 id="R-23-Use-make-unique-to-make-unique-ptrs"><a href="#R-23-Use-make-unique-to-make-unique-ptrs" class="headerlink" title="R.23: Use make_unique() to make unique_ptrs"></a><a name="Rr-make_unique"></a>R.23: Use <code>make_unique()</code> to make <code>unique_ptr</code>s</h3><h5 id="Reason-183"><a href="#Reason-183" class="headerlink" title="Reason"></a>Reason</h5><p>For convenience and consistency with <code>shared_ptr</code>.</p>
<h5 id="Note-172"><a href="#Note-172" class="headerlink" title="Note"></a>Note</h5><p><code>make_unique()</code> is C++14, but widely available (as well as simple to write).</p>
<h5 id="Enforcement-175"><a href="#Enforcement-175" class="headerlink" title="Enforcement"></a>Enforcement</h5><p>(Simple) Warn if a <code>unique_ptr</code> is constructed from the result of <code>new</code> rather than <code>make_unique</code>.</p>
<h3 id="R-24-Use-std-weak-ptr-to-break-cycles-of-shared-ptrs"><a href="#R-24-Use-std-weak-ptr-to-break-cycles-of-shared-ptrs" class="headerlink" title="R.24: Use std::weak_ptr to break cycles of shared_ptrs"></a><a name="Rr-weak_ptr"></a>R.24: Use <code>std::weak_ptr</code> to break cycles of <code>shared_ptr</code>s</h3><h5 id="Reason-184"><a href="#Reason-184" class="headerlink" title="Reason"></a>Reason</h5><p> <code>shared_ptr</code>‘s rely on use counting and the use count for a cyclic structure never goes to zero, so we need a mechanism to<br>be able to destroy a cyclic structure.</p>
<h5 id="Example-157"><a href="#Example-157" class="headerlink" title="Example"></a>Example</h5><pre><code>#include &lt;memory&gt;

class bar;

class foo
&#123;
public:
  explicit foo(const std::shared_ptr&lt;bar&gt;&amp; forward_reference)
    : forward_reference_(forward_reference)
  &#123; &#125;
private:
  std::shared_ptr&lt;bar&gt; forward_reference_;
&#125;;

class bar
&#123;
public:
  explicit bar(const std::weak_ptr&lt;foo&gt;&amp; back_reference)
    : back_reference_(back_reference)
  &#123; &#125;
  void do_something()
  &#123;
    if (auto shared_back_reference = back_reference_.lock()) &#123;
      // Use *shared_back_reference
    &#125;
  &#125;
private:
  std::weak_ptr&lt;foo&gt; back_reference_;
&#125;;
</code></pre>
<h5 id="Note-173"><a href="#Note-173" class="headerlink" title="Note"></a>Note</h5><p> ??? (HS: A lot of people say “to break cycles”, while I think “temporary shared ownership” is more to the point.)<br>???(BS: breaking cycles is what you must do; temporarily sharing ownership is how you do it.<br>You could “temporarily share ownership” simply by using another <code>shared_ptr</code>.)</p>
<h5 id="Enforcement-176"><a href="#Enforcement-176" class="headerlink" title="Enforcement"></a>Enforcement</h5><p>??? probably impossible. If we could statically detect cycles, we wouldn’t need <code>weak_ptr</code></p>
<h3 id="R-30-Take-smart-pointers-as-parameters-only-to-explicitly-express-lifetime-semantics"><a href="#R-30-Take-smart-pointers-as-parameters-only-to-explicitly-express-lifetime-semantics" class="headerlink" title="R.30: Take smart pointers as parameters only to explicitly express lifetime semantics"></a><a name="Rr-smartptrparam"></a>R.30: Take smart pointers as parameters only to explicitly express lifetime semantics</h3><h5 id="Reason-185"><a href="#Reason-185" class="headerlink" title="Reason"></a>Reason</h5><p>Accepting a smart pointer to a <code>widget</code> is wrong if the function just needs the <code>widget</code> itself.<br>It should be able to accept any <code>widget</code> object, not just ones whose lifetimes are managed by a particular kind of smart pointer.<br>A function that does not manipulate lifetime should take raw pointers or references instead.</p>
<h5 id="Example-bad-70"><a href="#Example-bad-70" class="headerlink" title="Example, bad"></a>Example, bad</h5><pre><code>// callee
void f(shared_ptr&lt;widget&gt;&amp; w)
&#123;
    // ...
    use(*w); // only use of w -- the lifetime is not used at all
    // ...
&#125;;

// caller
shared_ptr&lt;widget&gt; my_widget = /* ... */;
f(my_widget);

widget stack_widget;
f(stack_widget); // error
</code></pre>
<h5 id="Example-good-11"><a href="#Example-good-11" class="headerlink" title="Example, good"></a>Example, good</h5><pre><code>// callee
void f(widget&amp; w)
&#123;
    // ...
    use(w);
    // ...
&#125;;

// caller
shared_ptr&lt;widget&gt; my_widget = /* ... */;
f(*my_widget);

widget stack_widget;
f(stack_widget); // ok -- now this works
</code></pre>
<h5 id="Enforcement-177"><a href="#Enforcement-177" class="headerlink" title="Enforcement"></a>Enforcement</h5><ul>
<li>(Simple) Warn if a function takes a parameter of a smart pointer type (that overloads <code>operator-&gt;</code> or <code>operator*</code>) that is copyable but the function only calls any of: <code>operator*</code>, <code>operator-&gt;</code> or <code>get()</code>.<br>Suggest using a <code>T*</code> or <code>T&amp;</code> instead.</li>
<li>Flag a parameter of a smart pointer type (a type that overloads <code>operator-&gt;</code> or <code>operator*</code>) that is copyable/movable but never copied/moved from in the function body, and that is never modified, and that is not passed along to another function that could do so. That means the ownership semantics are not used.<br>Suggest using a <code>T*</code> or <code>T&amp;</code> instead.</li>
</ul>
<h3 id="R-31-If-you-have-non-std-smart-pointers-follow-the-basic-pattern-from-std"><a href="#R-31-If-you-have-non-std-smart-pointers-follow-the-basic-pattern-from-std" class="headerlink" title="R.31: If you have non-std smart pointers, follow the basic pattern from std"></a><a name="Rr-smart"></a>R.31: If you have non-<code>std</code> smart pointers, follow the basic pattern from <code>std</code></h3><h5 id="Reason-186"><a href="#Reason-186" class="headerlink" title="Reason"></a>Reason</h5><p>The rules in the following section also work for other kinds of third-party and custom smart pointers and are very useful for diagnosing common smart pointer errors that cause performance and correctness problems.<br>You want the rules to work on all the smart pointers you use.</p>
<p>Any type (including primary template or specialization) that overloads unary <code>*</code> and <code>-&gt;</code> is considered a smart pointer:</p>
<ul>
<li>If it is copyable, it is recognized as a reference-counted <code>shared_ptr</code>.</li>
<li>If it is not copyable, it is recognized as a unique <code>unique_ptr</code>.</li>
</ul>
<h5 id="Example-158"><a href="#Example-158" class="headerlink" title="Example"></a>Example</h5><pre><code>// use Boost&#39;s intrusive_ptr
#include &lt;boost/intrusive_ptr.hpp&gt;
void f(boost::intrusive_ptr&lt;widget&gt; p)  // error under rule &#39;sharedptrparam&#39;
&#123;
    p-&gt;foo();
&#125;

// use Microsoft&#39;s CComPtr
#include &lt;atlbase.h&gt;
void f(CComPtr&lt;widget&gt; p)               // error under rule &#39;sharedptrparam&#39;
&#123;
    p-&gt;foo();
&#125;
</code></pre>
<p>Both cases are an error under the <a href="#Rr-smartptrparam"><code>sharedptrparam</code> guideline</a>:<br><code>p</code> is a <code>Shared_ptr</code>, but nothing about its sharedness is used here and passing it by value is a silent pessimization;<br>these functions should accept a smart pointer only if they need to participate in the widget’s lifetime management. Otherwise they should accept a <code>widget*</code>, if it can be <code>nullptr</code>. Otherwise, and ideally, the function should accept a <code>widget&amp;</code>.<br>These smart pointers match the <code>Shared_ptr</code> concept, so these guideline enforcement rules work on them out of the box and expose this common pessimization.</p>
<h3 id="R-32-Take-a-unique-ptr-lt-widget-gt-parameter-to-express-that-a-function-assumes-ownership-of-a-widget"><a href="#R-32-Take-a-unique-ptr-lt-widget-gt-parameter-to-express-that-a-function-assumes-ownership-of-a-widget" class="headerlink" title="R.32: Take a unique_ptr&lt;widget&gt; parameter to express that a function assumes ownership of a widget"></a><a name="Rr-uniqueptrparam"></a>R.32: Take a <code>unique_ptr&lt;widget&gt;</code> parameter to express that a function assumes ownership of a <code>widget</code></h3><h5 id="Reason-187"><a href="#Reason-187" class="headerlink" title="Reason"></a>Reason</h5><p>Using <code>unique_ptr</code> in this way both documents and enforces the function call’s ownership transfer.</p>
<h5 id="Example-159"><a href="#Example-159" class="headerlink" title="Example"></a>Example</h5><pre><code>void sink(unique_ptr&lt;widget&gt;); // takes ownership of the widget

void uses(widget*);            // just uses the widget
</code></pre>
<h5 id="Example-bad-71"><a href="#Example-bad-71" class="headerlink" title="Example, bad"></a>Example, bad</h5><pre><code>void thinko(const unique_ptr&lt;widget&gt;&amp;); // usually not what you want
</code></pre>
<h5 id="Enforcement-178"><a href="#Enforcement-178" class="headerlink" title="Enforcement"></a>Enforcement</h5><ul>
<li>(Simple) Warn if a function takes a <code>Unique_ptr&lt;T&gt;</code> parameter by lvalue reference and does not either assign to it or call <code>reset()</code> on it on at least one code path. Suggest taking a <code>T*</code> or <code>T&amp;</code> instead.</li>
<li>(Simple) ((Foundation)) Warn if a function takes a <code>Unique_ptr&lt;T&gt;</code> parameter by reference to <code>const</code>. Suggest taking a <code>const T*</code> or <code>const T&amp;</code> instead.</li>
</ul>
<h3 id="R-33-Take-a-unique-ptr-lt-widget-gt-amp-parameter-to-express-that-a-function-reseats-thewidget"><a href="#R-33-Take-a-unique-ptr-lt-widget-gt-amp-parameter-to-express-that-a-function-reseats-thewidget" class="headerlink" title="R.33: Take a unique_ptr&lt;widget&gt;&amp; parameter to express that a function reseats thewidget"></a><a name="Rr-reseat"></a>R.33: Take a <code>unique_ptr&lt;widget&gt;&amp;</code> parameter to express that a function reseats the<code>widget</code></h3><h5 id="Reason-188"><a href="#Reason-188" class="headerlink" title="Reason"></a>Reason</h5><p>Using <code>unique_ptr</code> in this way both documents and enforces the function call’s reseating semantics.</p>
<h5 id="Note-174"><a href="#Note-174" class="headerlink" title="Note"></a>Note</h5><p>“reseat” means “making a pointer or a smart pointer refer to a different object.”</p>
<h5 id="Example-160"><a href="#Example-160" class="headerlink" title="Example"></a>Example</h5><pre><code>void reseat(unique_ptr&lt;widget&gt;&amp;); // &quot;will&quot; or &quot;might&quot; reseat pointer
</code></pre>
<h5 id="Example-bad-72"><a href="#Example-bad-72" class="headerlink" title="Example, bad"></a>Example, bad</h5><pre><code>void thinko(const unique_ptr&lt;widget&gt;&amp;); // usually not what you want
</code></pre>
<h5 id="Enforcement-179"><a href="#Enforcement-179" class="headerlink" title="Enforcement"></a>Enforcement</h5><ul>
<li>(Simple) Warn if a function takes a <code>Unique_ptr&lt;T&gt;</code> parameter by lvalue reference and does not either assign to it or call <code>reset()</code> on it on at least one code path. Suggest taking a <code>T*</code> or <code>T&amp;</code> instead.</li>
<li>(Simple) ((Foundation)) Warn if a function takes a <code>Unique_ptr&lt;T&gt;</code> parameter by reference to <code>const</code>. Suggest taking a <code>const T*</code> or <code>const T&amp;</code> instead.</li>
</ul>
<h3 id="R-34-Take-a-shared-ptr-lt-widget-gt-parameter-to-express-that-a-function-is-part-owner"><a href="#R-34-Take-a-shared-ptr-lt-widget-gt-parameter-to-express-that-a-function-is-part-owner" class="headerlink" title="R.34: Take a shared_ptr&lt;widget&gt; parameter to express that a function is part owner"></a><a name="Rr-sharedptrparam-owner"></a>R.34: Take a <code>shared_ptr&lt;widget&gt;</code> parameter to express that a function is part owner</h3><h5 id="Reason-189"><a href="#Reason-189" class="headerlink" title="Reason"></a>Reason</h5><p>This makes the function’s ownership sharing explicit.</p>
<h5 id="Example-good-12"><a href="#Example-good-12" class="headerlink" title="Example, good"></a>Example, good</h5><pre><code>void share(shared_ptr&lt;widget&gt;);            // share -- &quot;will&quot; retain refcount

void may_share(const shared_ptr&lt;widget&gt;&amp;); // &quot;might&quot; retain refcount

void reseat(shared_ptr&lt;widget&gt;&amp;);          // &quot;might&quot; reseat ptr
</code></pre>
<h5 id="Enforcement-180"><a href="#Enforcement-180" class="headerlink" title="Enforcement"></a>Enforcement</h5><ul>
<li>(Simple) Warn if a function takes a <code>Shared_ptr&lt;T&gt;</code> parameter by lvalue reference and does not either assign to it or call <code>reset()</code> on it on at least one code path. Suggest taking a <code>T*</code> or <code>T&amp;</code> instead.</li>
<li>(Simple) ((Foundation)) Warn if a function takes a <code>Shared_ptr&lt;T&gt;</code> by value or by reference to <code>const</code> and does not copy or move it to another <code>Shared_ptr</code> on at least one code path. Suggest taking a <code>T*</code> or <code>T&amp;</code> instead.</li>
<li>(Simple) ((Foundation)) Warn if a function takes a <code>Shared_ptr&lt;T&gt;</code> by rvalue reference. Suggesting taking it by value instead.</li>
</ul>
<h3 id="R-35-Take-a-shared-ptr-lt-widget-gt-amp-parameter-to-express-that-a-function-might-reseat-the-shared-pointer"><a href="#R-35-Take-a-shared-ptr-lt-widget-gt-amp-parameter-to-express-that-a-function-might-reseat-the-shared-pointer" class="headerlink" title="R.35: Take a shared_ptr&lt;widget&gt;&amp; parameter to express that a function might reseat the shared pointer"></a><a name="Rr-sharedptrparam"></a>R.35: Take a <code>shared_ptr&lt;widget&gt;&amp;</code> parameter to express that a function might reseat the shared pointer</h3><h5 id="Reason-190"><a href="#Reason-190" class="headerlink" title="Reason"></a>Reason</h5><p>This makes the function’s reseating explicit.</p>
<h5 id="Note-175"><a href="#Note-175" class="headerlink" title="Note"></a>Note</h5><p>“reseat” means “making a reference or a smart pointer refer to a different object.”</p>
<h5 id="Example-good-13"><a href="#Example-good-13" class="headerlink" title="Example, good"></a>Example, good</h5><pre><code>void share(shared_ptr&lt;widget&gt;);            // share -- &quot;will&quot; retain refcount

void reseat(shared_ptr&lt;widget&gt;&amp;);          // &quot;might&quot; reseat ptr

void may_share(const shared_ptr&lt;widget&gt;&amp;); // &quot;might&quot; retain refcount
</code></pre>
<h5 id="Enforcement-181"><a href="#Enforcement-181" class="headerlink" title="Enforcement"></a>Enforcement</h5><ul>
<li>(Simple) Warn if a function takes a <code>Shared_ptr&lt;T&gt;</code> parameter by lvalue reference and does not either assign to it or call <code>reset()</code> on it on at least one code path. Suggest taking a <code>T*</code> or <code>T&amp;</code> instead.</li>
<li>(Simple) ((Foundation)) Warn if a function takes a <code>Shared_ptr&lt;T&gt;</code> by value or by reference to <code>const</code> and does not copy or move it to another <code>Shared_ptr</code> on at least one code path. Suggest taking a <code>T*</code> or <code>T&amp;</code> instead.</li>
<li>(Simple) ((Foundation)) Warn if a function takes a <code>Shared_ptr&lt;T&gt;</code> by rvalue reference. Suggesting taking it by value instead.</li>
</ul>
<h3 id="R-36-Take-a-const-shared-ptr-lt-widget-gt-amp-parameter-to-express-that-it-might-retain-a-reference-count-to-the-object"><a href="#R-36-Take-a-const-shared-ptr-lt-widget-gt-amp-parameter-to-express-that-it-might-retain-a-reference-count-to-the-object" class="headerlink" title="R.36: Take a const shared_ptr&lt;widget&gt;&amp; parameter to express that it might retain a reference count to the object ???"></a><a name="Rr-sharedptrparam-const"></a>R.36: Take a <code>const shared_ptr&lt;widget&gt;&amp;</code> parameter to express that it might retain a reference count to the object ???</h3><h5 id="Reason-191"><a href="#Reason-191" class="headerlink" title="Reason"></a>Reason</h5><p>This makes the function’s ??? explicit.</p>
<h5 id="Example-good-14"><a href="#Example-good-14" class="headerlink" title="Example, good"></a>Example, good</h5><pre><code>void share(shared_ptr&lt;widget&gt;);            // share -- &quot;will&quot; retain refcount

void reseat(shared_ptr&lt;widget&gt;&amp;);          // &quot;might&quot; reseat ptr

void may_share(const shared_ptr&lt;widget&gt;&amp;); // &quot;might&quot; retain refcount
</code></pre>
<h5 id="Enforcement-182"><a href="#Enforcement-182" class="headerlink" title="Enforcement"></a>Enforcement</h5><ul>
<li>(Simple) Warn if a function takes a <code>Shared_ptr&lt;T&gt;</code> parameter by lvalue reference and does not either assign to it or call <code>reset()</code> on it on at least one code path. Suggest taking a <code>T*</code> or <code>T&amp;</code> instead.</li>
<li>(Simple) ((Foundation)) Warn if a function takes a <code>Shared_ptr&lt;T&gt;</code> by value or by reference to <code>const</code> and does not copy or move it to another <code>Shared_ptr</code> on at least one code path. Suggest taking a <code>T*</code> or <code>T&amp;</code> instead.</li>
<li>(Simple) ((Foundation)) Warn if a function takes a <code>Shared_ptr&lt;T&gt;</code> by rvalue reference. Suggesting taking it by value instead.</li>
</ul>
<h3 id="R-37-Do-not-pass-a-pointer-or-reference-obtained-from-an-aliased-smart-pointer"><a href="#R-37-Do-not-pass-a-pointer-or-reference-obtained-from-an-aliased-smart-pointer" class="headerlink" title="R.37: Do not pass a pointer or reference obtained from an aliased smart pointer"></a><a name="Rr-smartptrget"></a>R.37: Do not pass a pointer or reference obtained from an aliased smart pointer</h3><h5 id="Reason-192"><a href="#Reason-192" class="headerlink" title="Reason"></a>Reason</h5><p>Violating this rule is the number one cause of losing reference counts and finding yourself with a dangling pointer.<br>Functions should prefer to pass raw pointers and references down call chains.<br>At the top of the call tree where you obtain the raw pointer or reference from a smart pointer that keeps the object alive.<br>You need to be sure that the smart pointer cannot inadvertently be reset or reassigned from within the call tree below.</p>
<h5 id="Note-176"><a href="#Note-176" class="headerlink" title="Note"></a>Note</h5><p>To do this, sometimes you need to take a local copy of a smart pointer, which firmly keeps the object alive for the duration of the function and the call tree.</p>
<h5 id="Example-161"><a href="#Example-161" class="headerlink" title="Example"></a>Example</h5><p>Consider this code:</p>
<pre><code>// global (static or heap), or aliased local ...
shared_ptr&lt;widget&gt; g_p = ...;

void f(widget&amp; w)
&#123;
    g();
    use(w);  // A
&#125;

void g()
&#123;
    g_p = ...; // oops, if this was the last shared_ptr to that widget, destroys the widget
&#125;
</code></pre>
<p>The following should not pass code review:</p>
<pre><code>void my_code()
&#123;
    // BAD: passing pointer or reference obtained from a nonlocal smart pointer
    //      that could be inadvertently reset somewhere inside f or it callees
    f(*g_p);

    // BAD: same reason, just passing it as a &quot;this&quot; pointer
     g_p-&gt;func();
&#125;
</code></pre>
<p>The fix is simple – take a local copy of the pointer to “keep a ref count” for your call tree:</p>
<pre><code>void my_code()
&#123;
    // cheap: 1 increment covers this entire function and all the call trees below us
    auto pin = g_p;

    // GOOD: passing pointer or reference obtained from a local unaliased smart pointer
    f(*pin);

    // GOOD: same reason
    pin-&gt;func();
&#125;
</code></pre>
<h5 id="Enforcement-183"><a href="#Enforcement-183" class="headerlink" title="Enforcement"></a>Enforcement</h5><ul>
<li>(Simple) Warn if a pointer or reference obtained from a smart pointer variable (<code>Unique_ptr</code> or <code>Shared_ptr</code>) that is nonlocal, or that is local but potentially aliased, is used in a function call. If the smart pointer is a <code>Shared_ptr</code> then suggest taking a local copy of the smart pointer and obtain a pointer or reference from that instead.</li>
</ul>
<h1 id="ES-Expressions-and-statements"><a href="#ES-Expressions-and-statements" class="headerlink" title="ES: Expressions and statements"></a><a name="S-expr"></a>ES: Expressions and statements</h1><p>Expressions and statements are the lowest and most direct way of expressing actions and computation. Declarations in local scopes are statements.</p>
<p>For naming, commenting, and indentation rules, see <a href="#S-naming">NL: Naming and layout</a>.</p>
<p>General rules:</p>
<ul>
<li><a href="#Res-lib">ES.1: Prefer the standard library to other libraries and to “handcrafted code”</a></li>
<li><a href="#Res-abstr">ES.2: Prefer suitable abstractions to direct use of language features</a></li>
</ul>
<p>Declaration rules:</p>
<ul>
<li><a href="#Res-scope">ES.5: Keep scopes small</a></li>
<li><a href="#Res-cond">ES.6: Declare names in for-statement initializers and conditions to limit scope</a></li>
<li><a href="#Res-name-length">ES.7: Keep common and local names short, and keep uncommon and nonlocal names longer</a></li>
<li><a href="#Res-name-similar">ES.8: Avoid similar-looking names</a></li>
<li><a href="#Res-not-CAPS">ES.9: Avoid <code>ALL_CAPS</code> names</a></li>
<li><a href="#Res-name-one">ES.10: Declare one name (only) per declaration</a></li>
<li><a href="#Res-auto">ES.11: Use <code>auto</code> to avoid redundant repetition of type names</a></li>
<li><a href="#Res-reuse">ES.12: Do not reuse names in nested scopes</a></li>
<li><a href="#Res-always">ES.20: Always initialize an object</a></li>
<li><a href="#Res-introduce">ES.21: Don’t introduce a variable (or constant) before you need to use it</a></li>
<li><a href="#Res-init">ES.22: Don’t declare a variable until you have a value to initialize it with</a></li>
<li><a href="#Res-list">ES.23: Prefer the <code>&#123;&#125;</code>-initializer syntax</a></li>
<li><a href="#Res-unique">ES.24: Use a <code>unique_ptr&lt;T&gt;</code> to hold pointers</a></li>
<li><a href="#Res-const">ES.25: Declare an object <code>const</code> or <code>constexpr</code> unless you want to modify its value later on</a></li>
<li><a href="#Res-recycle">ES.26: Don’t use a variable for two unrelated purposes</a></li>
<li><a href="#Res-stack">ES.27: Use <code>std::array</code> or <code>stack_array</code> for arrays on the stack</a></li>
<li><a href="#Res-lambda-init">ES.28: Use lambdas for complex initialization, especially of <code>const</code> variables</a></li>
<li><a href="#Res-macros">ES.30: Don’t use macros for program text manipulation</a></li>
<li><a href="#Res-macros2">ES.31: Don’t use macros for constants or “functions”</a></li>
<li><a href="#Res-ALL_CAPS">ES.32: Use <code>ALL_CAPS</code> for all macro names</a></li>
<li><a href="#Res-MACROS">ES.33: If you must use macros, give them unique names</a></li>
<li><a href="#Res-ellipses">ES.34: Don’t define a (C-style) variadic function</a></li>
</ul>
<p>Expression rules:</p>
<ul>
<li><a href="#Res-complicated">ES.40: Avoid complicated expressions</a></li>
<li><a href="#Res-parens">ES.41: If in doubt about operator precedence, parenthesize</a></li>
<li><a href="#Res-ptr">ES.42: Keep use of pointers simple and straightforward</a></li>
<li><a href="#Res-order">ES.43: Avoid expressions with undefined order of evaluation</a></li>
<li><a href="#Res-order-fct">ES.44: Don’t depend on order of evaluation of function arguments</a></li>
<li><a href="#Res-magic">ES.45: Avoid “magic constants”; use symbolic constants</a></li>
<li><a href="#Res-narrowing">ES.46: Avoid narrowing conversions</a></li>
<li><a href="#Res-nullptr">ES.47: Use <code>nullptr</code> rather than <code>0</code> or <code>NULL</code></a></li>
<li><a href="#Res-casts">ES.48: Avoid casts</a></li>
<li><a href="#Res-casts-named">ES.49: If you must use a cast, use a named cast</a></li>
<li><a href="#Res-casts-const">ES.50: Don’t cast away <code>const</code></a></li>
<li><a href="#Res-range-checking">ES.55: Avoid the need for range checking</a></li>
<li><a href="#Res-move">ES.56: Write <code>std::move()</code> only when you need to explicitly move an object to another scope</a></li>
<li><a href="#Res-new">ES.60: Avoid <code>new</code> and <code>delete</code> outside resource management functions</a></li>
<li><a href="#Res-del">ES.61: Delete arrays using <code>delete[]</code> and non-arrays using <code>delete</code></a></li>
<li><a href="#Res-arr2">ES.62: Don’t compare pointers into different arrays</a></li>
<li><a href="#Res-slice">ES.63: Don’t slice</a></li>
<li><a href="#Res-construct">ES.64: Use the <code>T&#123;e&#125;</code>notation for construction</a></li>
<li><a href="#Res-deref">ES.65: Don’t dereference an invalid pointer</a></li>
</ul>
<p>Statement rules:</p>
<ul>
<li><a href="#Res-switch-if">ES.70: Prefer a <code>switch</code>-statement to an <code>if</code>-statement when there is a choice</a></li>
<li><a href="#Res-for-range">ES.71: Prefer a range-<code>for</code>-statement to a <code>for</code>-statement when there is a choice</a></li>
<li><a href="#Res-for-while">ES.72: Prefer a <code>for</code>-statement to a <code>while</code>-statement when there is an obvious loop variable</a></li>
<li><a href="#Res-while-for">ES.73: Prefer a <code>while</code>-statement to a <code>for</code>-statement when there is no obvious loop variable</a></li>
<li><a href="#Res-for-init">ES.74: Prefer to declare a loop variable in the initializer part of a <code>for</code>-statement</a></li>
<li><a href="#Res-do">ES.75: Avoid <code>do</code>-statements</a></li>
<li><a href="#Res-goto">ES.76: Avoid <code>goto</code></a></li>
<li><a href="#Res-continue">ES.77: Minimize the use of <code>break</code> and <code>continue</code> in loops</a></li>
<li><a href="#Res-break">ES.78: Always end a non-empty <code>case</code> with a <code>break</code></a></li>
<li><a href="#Res-default">ES.79: Use <code>default</code> to handle common cases (only)</a></li>
<li><a href="#Res-noname">ES.84: Don’t (try to) declare a local variable with no name</a></li>
<li><a href="#Res-empty">ES.85: Make empty statements visible</a></li>
<li><a href="#Res-loop-counter">ES.86: Avoid modifying loop control variables inside the body of raw for-loops</a></li>
<li><a href="#Res-if">ES.87: Don’t add redundant <code>==</code> or <code>!=</code> to conditions</a></li>
</ul>
<p>Arithmetic rules:</p>
<ul>
<li><a href="#Res-mix">ES.100: Don’t mix signed and unsigned arithmetic</a></li>
<li><a href="#Res-unsigned">ES.101: Use unsigned types for bit manipulation</a></li>
<li><a href="#Res-signed">ES.102: Use signed types for arithmetic</a></li>
<li><a href="#Res-overflow">ES.103: Don’t overflow</a></li>
<li><a href="#Res-underflow">ES.104: Don’t underflow</a></li>
<li><a href="#Res-zero">ES.105: Don’t divide by zero</a></li>
<li><a href="#Res-nonnegative">ES.106: Don’t try to avoid negative values by using <code>unsigned</code></a></li>
<li><a href="#Res-subscripts">ES.107: Don’t use <code>unsigned</code> for subscripts, prefer <code>gsl::index</code></a></li>
</ul>
<h3 id="ES-1-Prefer-the-standard-library-to-other-libraries-and-to-“handcrafted-code”"><a href="#ES-1-Prefer-the-standard-library-to-other-libraries-and-to-“handcrafted-code”" class="headerlink" title="ES.1: Prefer the standard library to other libraries and to “handcrafted code”"></a><a name="Res-lib"></a>ES.1: Prefer the standard library to other libraries and to “handcrafted code”</h3><h5 id="Reason-193"><a href="#Reason-193" class="headerlink" title="Reason"></a>Reason</h5><p>Code using a library can be much easier to write than code working directly with language features, much shorter, tend to be of a higher level of abstraction, and the library code is presumably already tested.<br>The ISO C++ Standard Library is among the most widely known and best tested libraries.<br>It is available as part of all C++ Implementations.</p>
<h5 id="Example-162"><a href="#Example-162" class="headerlink" title="Example"></a>Example</h5><pre><code>auto sum = accumulate(begin(a), end(a), 0.0);   // good
</code></pre>
<p>a range version of <code>accumulate</code> would be even better:</p>
<pre><code>auto sum = accumulate(v, 0.0); // better
</code></pre>
<p>but don’t hand-code a well-known algorithm:</p>
<pre><code>int max = v.size();   // bad: verbose, purpose unstated
double sum = 0.0;
for (int i = 0; i &lt; max; ++i)
    sum = sum + v[i];
</code></pre>
<h5 id="Exception-32"><a href="#Exception-32" class="headerlink" title="Exception"></a>Exception</h5><p>Large parts of the standard library rely on dynamic allocation (free store). These parts, notably the containers but not the algorithms, are unsuitable for some hard-real-time and embedded applications. In such cases, consider providing/using similar facilities, e.g.,  a standard-library-style container implemented using a pool allocator.</p>
<h5 id="Enforcement-184"><a href="#Enforcement-184" class="headerlink" title="Enforcement"></a>Enforcement</h5><p>Not easy. ??? Look for messy loops, nested loops, long functions, absence of function calls, lack of use of non-built-in types. Cyclomatic complexity?</p>
<h3 id="ES-2-Prefer-suitable-abstractions-to-direct-use-of-language-features"><a href="#ES-2-Prefer-suitable-abstractions-to-direct-use-of-language-features" class="headerlink" title="ES.2: Prefer suitable abstractions to direct use of language features"></a><a name="Res-abstr"></a>ES.2: Prefer suitable abstractions to direct use of language features</h3><h5 id="Reason-194"><a href="#Reason-194" class="headerlink" title="Reason"></a>Reason</h5><p>A “suitable abstraction” (e.g., library or class) is closer to the application concepts than the bare language, leads to shorter and clearer code, and is likely to be better tested.</p>
<h5 id="Example-163"><a href="#Example-163" class="headerlink" title="Example"></a>Example</h5><pre><code>vector&lt;string&gt; read1(istream&amp; is)   // good
&#123;
    vector&lt;string&gt; res;
    for (string s; is &gt;&gt; s;)
        res.push_back(s);
    return res;
&#125;
</code></pre>
<p>The more traditional and lower-level near-equivalent is longer, messier, harder to get right, and most likely slower:</p>
<pre><code>char** read2(istream&amp; is, int maxelem, int maxstring, int* nread)   // bad: verbose and incomplete
&#123;
    auto res = new char*[maxelem];
    int elemcount = 0;
    while (is &amp;&amp; elemcount &lt; maxelem) &#123;
        auto s = new char[maxstring];
        is.read(s, maxstring);
        res[elemcount++] = s;
    &#125;
    nread = &amp;elemcount;
    return res;
&#125;
</code></pre>
<p>Once the checking for overflow and error handling has been added that code gets quite messy, and there is the problem remembering to <code>delete</code> the returned pointer and the C-style strings that array contains.</p>
<h5 id="Enforcement-185"><a href="#Enforcement-185" class="headerlink" title="Enforcement"></a>Enforcement</h5><p>Not easy. ??? Look for messy loops, nested loops, long functions, absence of function calls, lack of use of non-built-in types. Cyclomatic complexity?</p>
<h2 id="ES-dcl-Declarations"><a href="#ES-dcl-Declarations" class="headerlink" title="ES.dcl: Declarations"></a>ES.dcl: Declarations</h2><p>A declaration is a statement. A declaration introduces a name into a scope and may cause the construction of a named object.</p>
<h3 id="ES-5-Keep-scopes-small"><a href="#ES-5-Keep-scopes-small" class="headerlink" title="ES.5: Keep scopes small"></a><a name="Res-scope"></a>ES.5: Keep scopes small</h3><h5 id="Reason-195"><a href="#Reason-195" class="headerlink" title="Reason"></a>Reason</h5><p>Readability. Minimize resource retention. Avoid accidental misuse of value.</p>
<p><strong>Alternative formulation</strong>: Don’t declare a name in an unnecessarily large scope.</p>
<h5 id="Example-164"><a href="#Example-164" class="headerlink" title="Example"></a>Example</h5><pre><code>void use()
&#123;
    int i;    // bad: i is needlessly accessible after loop
    for (i = 0; i &lt; 20; ++i) &#123; /* ... */ &#125;
    // no intended use of i here
    for (int i = 0; i &lt; 20; ++i) &#123; /* ... */ &#125;  // good: i is local to for-loop

    if (auto pc = dynamic_cast&lt;Circle*&gt;(ps)) &#123;  // good: pc is local to if-statement
        // ... deal with Circle ...
    &#125;
    else &#123;
        // ... handle error ...
    &#125;
&#125;
</code></pre>
<h5 id="Example-bad-73"><a href="#Example-bad-73" class="headerlink" title="Example, bad"></a>Example, bad</h5><pre><code>void use(const string&amp; name)
&#123;
    string fn = name + &quot;.txt&quot;;
    ifstream is &#123;fn&#125;;
    Record r;
    is &gt;&gt; r;
    // ... 200 lines of code without intended use of fn or is ...
&#125;
</code></pre>
<p>This function is by most measure too long anyway, but the point is that the resources used by <code>fn</code> and the file handle held by <code>is</code><br>are retained for much longer than needed and that unanticipated use of <code>is</code> and <code>fn</code> could happen later in the function.<br>In this case, it might be a good idea to factor out the read:</p>
<pre><code>Record load_record(const string&amp; name)
&#123;
    string fn = name + &quot;.txt&quot;;
    ifstream is &#123;fn&#125;;
    Record r;
    is &gt;&gt; r;
    return r;
&#125;

void use(const string&amp; name)
&#123;
    Record r = load_record(name);
    // ... 200 lines of code ...
&#125;
</code></pre>
<h5 id="Enforcement-186"><a href="#Enforcement-186" class="headerlink" title="Enforcement"></a>Enforcement</h5><ul>
<li>Flag loop variable declared outside a loop and not used after the loop</li>
<li>Flag when expensive resources, such as file handles and locks are not used for N-lines (for some suitable N)</li>
</ul>
<h3 id="ES-6-Declare-names-in-for-statement-initializers-and-conditions-to-limit-scope"><a href="#ES-6-Declare-names-in-for-statement-initializers-and-conditions-to-limit-scope" class="headerlink" title="ES.6: Declare names in for-statement initializers and conditions to limit scope"></a><a name="Res-cond"></a>ES.6: Declare names in for-statement initializers and conditions to limit scope</h3><h5 id="Reason-196"><a href="#Reason-196" class="headerlink" title="Reason"></a>Reason</h5><p>Readability. Minimize resource retention.</p>
<h5 id="Example-165"><a href="#Example-165" class="headerlink" title="Example"></a>Example</h5><pre><code>void use()
&#123;
    for (string s; cin &gt;&gt; s;)
        v.push_back(s);

    for (int i = 0; i &lt; 20; ++i) &#123;   // good: i is local to for-loop
        // ...
    &#125;

    if (auto pc = dynamic_cast&lt;Circle*&gt;(ps)) &#123;   // good: pc is local to if-statement
        // ... deal with Circle ...
    &#125;
    else &#123;
        // ... handle error ...
    &#125;
&#125;
</code></pre>
<h5 id="Enforcement-187"><a href="#Enforcement-187" class="headerlink" title="Enforcement"></a>Enforcement</h5><ul>
<li>Flag loop variables declared before the loop and not used after the loop</li>
<li>(hard) Flag loop variables declared before the loop and used after the loop for an unrelated purpose.</li>
</ul>
<h5 id="C-17-example"><a href="#C-17-example" class="headerlink" title="C++17 example"></a>C++17 example</h5><p>Note: C++17 also adds <code>if</code> and <code>switch</code> initializer statements. These require C++17 support.</p>
<pre><code>map&lt;int, string&gt; mymap;

if (auto result = mymap.insert(value); result.second) &#123;
    // insert succeeded, and result is valid for this block
    use(result.first);  // ok
    // ...
&#125; // result is destroyed here
</code></pre>
<h5 id="C-17-enforcement-if-using-a-C-17-compiler"><a href="#C-17-enforcement-if-using-a-C-17-compiler" class="headerlink" title="C++17 enforcement (if using a C++17 compiler)"></a>C++17 enforcement (if using a C++17 compiler)</h5><ul>
<li>Flag selection/loop variables declared before the body and not used after the body</li>
<li>(hard) Flag selection/loop variables declared before the body and used after the body for an unrelated purpose.</li>
</ul>
<h3 id="ES-7-Keep-common-and-local-names-short-and-keep-uncommon-and-nonlocal-names-longer"><a href="#ES-7-Keep-common-and-local-names-short-and-keep-uncommon-and-nonlocal-names-longer" class="headerlink" title="ES.7: Keep common and local names short, and keep uncommon and nonlocal names longer"></a><a name="Res-name-length"></a>ES.7: Keep common and local names short, and keep uncommon and nonlocal names longer</h3><h5 id="Reason-197"><a href="#Reason-197" class="headerlink" title="Reason"></a>Reason</h5><p>Readability. Lowering the chance of clashes between unrelated non-local names.</p>
<h5 id="Example-166"><a href="#Example-166" class="headerlink" title="Example"></a>Example</h5><p>Conventional short, local names increase readability:</p>
<pre><code>template&lt;typename T&gt;    // good
void print(ostream&amp; os, const vector&lt;T&gt;&amp; v)
&#123;
    for (gsl::index i = 0; i &lt; v.size(); ++i)
        os &lt;&lt; v[i] &lt;&lt; &#39;\n&#39;;
&#125;
</code></pre>
<p>An index is conventionally called <code>i</code> and there is no hint about the meaning of the vector in this generic function, so <code>v</code> is as good name as any. Compare</p>
<pre><code>template&lt;typename Element_type&gt;   // bad: verbose, hard to read
void print(ostream&amp; target_stream, const vector&lt;Element_type&gt;&amp; current_vector)
&#123;
    for (gsl::index current_element_index = 0;
         current_element_index &lt; current_vector.size();
         ++current_element_index
    )
    target_stream &lt;&lt; current_vector[current_element_index] &lt;&lt; &#39;\n&#39;;
&#125;
</code></pre>
<p>Yes, it is a caricature, but we have seen worse.</p>
<h5 id="Example-167"><a href="#Example-167" class="headerlink" title="Example"></a>Example</h5><p>Unconventional and short non-local names obscure code:</p>
<pre><code>void use1(const string&amp; s)
&#123;
    // ...
    tt(s);   // bad: what is tt()?
    // ...
&#125;
</code></pre>
<p>Better, give non-local entities readable names:</p>
<pre><code>void use1(const string&amp; s)
&#123;
    // ...
    trim_tail(s);   // better
    // ...
&#125;
</code></pre>
<p>Here, there is a chance that the reader knows what <code>trim_tail</code> means and that the reader can remember it after looking it up.</p>
<h5 id="Example-bad-74"><a href="#Example-bad-74" class="headerlink" title="Example, bad"></a>Example, bad</h5><p>Argument names of large functions are de facto non-local and should be meaningful:</p>
<pre><code>void complicated_algorithm(vector&lt;Record&gt;&amp; vr, const vector&lt;int&gt;&amp; vi, map&lt;string, int&gt;&amp; out)
// read from events in vr (marking used Records) for the indices in
// vi placing (name, index) pairs into out
&#123;
    // ... 500 lines of code using vr, vi, and out ...
&#125;
</code></pre>
<p>We recommend keeping functions short, but that rule isn’t universally adhered to and naming should reflect that.</p>
<h5 id="Enforcement-188"><a href="#Enforcement-188" class="headerlink" title="Enforcement"></a>Enforcement</h5><p>Check length of local and non-local names. Also take function length into account.</p>
<h3 id="ES-8-Avoid-similar-looking-names"><a href="#ES-8-Avoid-similar-looking-names" class="headerlink" title="ES.8: Avoid similar-looking names"></a><a name="Res-name-similar"></a>ES.8: Avoid similar-looking names</h3><h5 id="Reason-198"><a href="#Reason-198" class="headerlink" title="Reason"></a>Reason</h5><p>Code clarity and readability. Too-similar names slow down comprehension and increase the likelihood of error.</p>
<h5 id="Example-bad-75"><a href="#Example-bad-75" class="headerlink" title="Example; bad"></a>Example; bad</h5><pre><code>if (readable(i1 + l1 + ol + o1 + o0 + ol + o1 + I0 + l0)) surprise();
</code></pre>
<h5 id="Example-bad-76"><a href="#Example-bad-76" class="headerlink" title="Example; bad"></a>Example; bad</h5><p>Do not declare a non-type with the same name as a type in the same scope. This removes the need to disambiguate with a keyword such as <code>struct</code> or <code>enum</code>. It also removes a source of errors, as <code>struct X</code> can implicitly declare <code>X</code> if lookup fails.</p>
<pre><code>struct foo &#123; int n; &#125;;
struct foo foo();       // BAD, foo is a type already in scope
struct foo x = foo();   // requires disambiguation
</code></pre>
<h5 id="Exception-33"><a href="#Exception-33" class="headerlink" title="Exception"></a>Exception</h5><p>Antique header files might declare non-types and types with the same name in the same scope.</p>
<h5 id="Enforcement-189"><a href="#Enforcement-189" class="headerlink" title="Enforcement"></a>Enforcement</h5><ul>
<li>Check names against a list of known confusing letter and digit combinations.</li>
<li>Flag a declaration of a variable, function, or enumerator that hides a class or enumeration declared in the same scope.</li>
</ul>
<h3 id="ES-9-Avoid-ALL-CAPS-names"><a href="#ES-9-Avoid-ALL-CAPS-names" class="headerlink" title="ES.9: Avoid ALL_CAPS names"></a><a name="Res-not-CAPS"></a>ES.9: Avoid <code>ALL_CAPS</code> names</h3><h5 id="Reason-199"><a href="#Reason-199" class="headerlink" title="Reason"></a>Reason</h5><p>Such names are commonly used for macros. Thus, <code>ALL_CAPS</code> name are vulnerable to unintended macro substitution.</p>
<h5 id="Example-168"><a href="#Example-168" class="headerlink" title="Example"></a>Example</h5><pre><code>// somewhere in some header:
#define NE !=

// somewhere else in some other header:
enum Coord &#123; N, NE, NW, S, SE, SW, E, W &#125;;

// somewhere third in some poor programmer&#39;s .cpp:
switch (direction) &#123;
case N:
    // ...
case NE:
    // ...
// ...
&#125;
</code></pre>
<h5 id="Note-177"><a href="#Note-177" class="headerlink" title="Note"></a>Note</h5><p>Do not use <code>ALL_CAPS</code> for constants just because constants used to be macros.</p>
<h5 id="Enforcement-190"><a href="#Enforcement-190" class="headerlink" title="Enforcement"></a>Enforcement</h5><p>Flag all uses of ALL CAPS. For older code, accept ALL CAPS for macro names and flag all non-ALL-CAPS macro names.</p>
<h3 id="ES-10-Declare-one-name-only-per-declaration"><a href="#ES-10-Declare-one-name-only-per-declaration" class="headerlink" title="ES.10: Declare one name (only) per declaration"></a><a name="Res-name-one"></a>ES.10: Declare one name (only) per declaration</h3><h5 id="Reason-200"><a href="#Reason-200" class="headerlink" title="Reason"></a>Reason</h5><p>One-declaration-per line increases readability and avoids mistakes related to<br>the C/C++ grammar. It also leaves room for a more descriptive end-of-line<br>comment.</p>
<h5 id="Example-bad-77"><a href="#Example-bad-77" class="headerlink" title="Example, bad"></a>Example, bad</h5><pre><code>char *p, c, a[7], *pp[7], **aa[10];   // yuck!
</code></pre>
<h5 id="Exception-34"><a href="#Exception-34" class="headerlink" title="Exception"></a>Exception</h5><p>A function declaration can contain several function argument declarations.</p>
<h5 id="Exception-35"><a href="#Exception-35" class="headerlink" title="Exception"></a>Exception</h5><p>A structured binding (C++17) is specifically designed to introduce several variables:</p>
<pre><code>auto [iter, inserted] = m.insert_or_assign(k, val);
if (inserted) &#123; /* new entry was inserted */ &#125;
</code></pre>
<h5 id="Example-169"><a href="#Example-169" class="headerlink" title="Example"></a>Example</h5><pre><code>template &lt;class InputIterator, class Predicate&gt;
bool any_of(InputIterator first, InputIterator last, Predicate pred);
</code></pre>
<p>or better using concepts:</p>
<pre><code>bool any_of(InputIterator first, InputIterator last, Predicate pred);
</code></pre>
<h5 id="Example-170"><a href="#Example-170" class="headerlink" title="Example"></a>Example</h5><pre><code>double scalbn(double x, int n);   // OK: x * pow(FLT_RADIX, n); FLT_RADIX is usually 2
</code></pre>
<p>or:</p>
<pre><code>double scalbn(    // better: x * pow(FLT_RADIX, n); FLT_RADIX is usually 2
    double x,     // base value
    int n         // exponent
);
</code></pre>
<p>or:</p>
<pre><code>// better: base * pow(FLT_RADIX, exponent); FLT_RADIX is usually 2
double scalbn(double base, int exponent);
</code></pre>
<h5 id="Example-171"><a href="#Example-171" class="headerlink" title="Example"></a>Example</h5><pre><code>int a = 7, b = 9, c, d = 10, e = 3;
</code></pre>
<p>In a long list of declarators is is easy to overlook an uninitialized variable.</p>
<h5 id="Enforcement-191"><a href="#Enforcement-191" class="headerlink" title="Enforcement"></a>Enforcement</h5><p>Flag variable and constant declarations with multiple declarators (e.g., <code>int* p, q;</code>)</p>
<h3 id="ES-11-Use-auto-to-avoid-redundant-repetition-of-type-names"><a href="#ES-11-Use-auto-to-avoid-redundant-repetition-of-type-names" class="headerlink" title="ES.11: Use auto to avoid redundant repetition of type names"></a><a name="Res-auto"></a>ES.11: Use <code>auto</code> to avoid redundant repetition of type names</h3><h5 id="Reason-201"><a href="#Reason-201" class="headerlink" title="Reason"></a>Reason</h5><ul>
<li>Simple repetition is tedious and error-prone.</li>
<li>When you use <code>auto</code>, the name of the declared entity is in a fixed position in the declaration, increasing readability.</li>
<li>In a template function declaration the return type can be a member type.</li>
</ul>
<h5 id="Example-172"><a href="#Example-172" class="headerlink" title="Example"></a>Example</h5><p>Consider:</p>
<pre><code>auto p = v.begin();   // vector&lt;int&gt;::iterator
auto h = t.future();
auto q = make_unique&lt;int[]&gt;(s);
auto f = [](int x)&#123; return x + 10; &#125;;
</code></pre>
<p>In each case, we save writing a longish, hard-to-remember type that the compiler already knows but a programmer could get wrong.</p>
<h5 id="Example-173"><a href="#Example-173" class="headerlink" title="Example"></a>Example</h5><pre><code>template&lt;class T&gt;
auto Container&lt;T&gt;::first() -&gt; Iterator;   // Container&lt;T&gt;::Iterator
</code></pre>
<h5 id="Exception-36"><a href="#Exception-36" class="headerlink" title="Exception"></a>Exception</h5><p>Avoid <code>auto</code> for initializer lists and in cases where you know exactly which type you want and where an initializer might require conversion.</p>
<h5 id="Example-174"><a href="#Example-174" class="headerlink" title="Example"></a>Example</h5><pre><code>auto lst = &#123; 1, 2, 3 &#125;;   // lst is an initializer list
auto x&#123;1&#125;;   // x is an int (after correction of the C++14 standard; initializer_list in C++11)
</code></pre>
<h5 id="Note-178"><a href="#Note-178" class="headerlink" title="Note"></a>Note</h5><p>When concepts become available, we can (and should) be more specific about the type we are deducing:</p>
<pre><code>// ...
ForwardIterator p = algo(x, y, z);
</code></pre>
<h5 id="Example-C-17"><a href="#Example-C-17" class="headerlink" title="Example (C++17)"></a>Example (C++17)</h5><pre><code>auto [ quotient, remainder ] = div(123456, 73);   // break out the members of the div_t result
</code></pre>
<h5 id="Enforcement-192"><a href="#Enforcement-192" class="headerlink" title="Enforcement"></a>Enforcement</h5><p>Flag redundant repetition of type names in a declaration.</p>
<h3 id="ES-12-Do-not-reuse-names-in-nested-scopes"><a href="#ES-12-Do-not-reuse-names-in-nested-scopes" class="headerlink" title="ES.12: Do not reuse names in nested scopes"></a><a name="Res-reuse"></a>ES.12: Do not reuse names in nested scopes</h3><h5 id="Reason-202"><a href="#Reason-202" class="headerlink" title="Reason"></a>Reason</h5><p>It is easy to get confused about which variable is used.<br>Can cause maintenance problems.</p>
<h5 id="Example-bad-78"><a href="#Example-bad-78" class="headerlink" title="Example, bad"></a>Example, bad</h5><pre><code>int d = 0;
// ...
if (cond) &#123;
    // ...
    d = 9;
    // ...
&#125;
else &#123;
    // ...
    int d = 7;
    // ...
    d = value_to_be_returned;
    // ...
&#125;

return d;
</code></pre>
<p>If this is a large <code>if</code>-statement, it is easy to overlook that a new <code>d</code> has been introduced in the inner scope.<br>This is a known source of bugs.<br>Sometimes such reuse of a name in an inner scope is called “shadowing”.</p>
<h5 id="Note-179"><a href="#Note-179" class="headerlink" title="Note"></a>Note</h5><p>Shadowing is primarily a problem when functions are too large and too complex.</p>
<h5 id="Example-175"><a href="#Example-175" class="headerlink" title="Example"></a>Example</h5><p>Shadowing of function arguments in the outermost block is disallowed by the language:</p>
<pre><code>void f(int x)
&#123;
    int x = 4;  // error: reuse of function argument name

    if (x) &#123;
        int x = 7;  // allowed, but bad
        // ...
    &#125;
&#125;
</code></pre>
<h5 id="Example-bad-79"><a href="#Example-bad-79" class="headerlink" title="Example, bad"></a>Example, bad</h5><p>Reuse of a member name as a local variable can also be a problem:</p>
<pre><code>struct S &#123;
    int m;
    void f(int x);
&#125;;

void S::f(int x)
&#123;
    m = 7;    // assign to member
    if (x) &#123;
        int m = 9;
        // ...
        m = 99; // assign to member
        // ...
    &#125;
&#125;
</code></pre>
<h5 id="Exception-37"><a href="#Exception-37" class="headerlink" title="Exception"></a>Exception</h5><p>We often reuse function names from a base class in a derived class:</p>
<pre><code>struct B &#123;
    void f(int);
&#125;;

struct D : B &#123;
    void f(double);
    using B::f;
&#125;;
</code></pre>
<p>This is error-prone.<br>For example, had we forgotten the using declaration, a call <code>d.f(1)</code> would not have found the <code>int</code> version of <code>f</code>.</p>
<p>??? Do we need a specific rule about shadowing/hiding in class hierarchies?</p>
<h5 id="Enforcement-193"><a href="#Enforcement-193" class="headerlink" title="Enforcement"></a>Enforcement</h5><ul>
<li>Flag reuse of a name in nested local scopes</li>
<li>Flag reuse of a member name as a local variable in a member function</li>
<li>Flag reuse of a global name as a local variable or a member name</li>
<li>Flag reuse of a base class member name in a derived class (except for function names)</li>
</ul>
<h3 id="ES-20-Always-initialize-an-object"><a href="#ES-20-Always-initialize-an-object" class="headerlink" title="ES.20: Always initialize an object"></a><a name="Res-always"></a>ES.20: Always initialize an object</h3><h5 id="Reason-203"><a href="#Reason-203" class="headerlink" title="Reason"></a>Reason</h5><p>Avoid used-before-set errors and their associated undefined behavior.<br>Avoid problems with comprehension of complex initialization.<br>Simplify refactoring.</p>
<h5 id="Example-176"><a href="#Example-176" class="headerlink" title="Example"></a>Example</h5><pre><code>void use(int arg)
&#123;
    int i;   // bad: uninitialized variable
    // ...
    i = 7;   // initialize i
&#125;
</code></pre>
<p>No, <code>i = 7</code> does not initialize <code>i</code>; it assigns to it. Also, <code>i</code> can be read in the <code>...</code> part. Better:</p>
<pre><code>void use(int arg)   // OK
&#123;
    int i = 7;   // OK: initialized
    string s;    // OK: default initialized
    // ...
&#125;
</code></pre>
<h5 id="Note-180"><a href="#Note-180" class="headerlink" title="Note"></a>Note</h5><p>The <em>always initialize</em> rule is deliberately stronger than the <em>an object must be set before used</em> language rule.<br>The latter, more relaxed rule, catches the technical bugs, but:</p>
<ul>
<li>It leads to less readable code</li>
<li>It encourages people to declare names in greater than necessary scopes</li>
<li>It leads to harder to read code</li>
<li>It leads to logic bugs by encouraging complex code</li>
<li>It hampers refactoring</li>
</ul>
<p>The <em>always initialize</em> rule is a style rule aimed to improve maintainability as well as a rule protecting against used-before-set errors.</p>
<h5 id="Example-177"><a href="#Example-177" class="headerlink" title="Example"></a>Example</h5><p>Here is an example that is often considered to demonstrate the need for a more relaxed rule for initialization</p>
<pre><code>widget i;    // &quot;widget&quot; a type that&#39;s expensive to initialize, possibly a large POD
widget j;

if (cond) &#123;  // bad: i and j are initialized &quot;late&quot;
    i = f1();
    j = f2();
&#125;
else &#123;
    i = f3();
    j = f4();
&#125;
</code></pre>
<p>This cannot trivially be rewritten to initialize <code>i</code> and <code>j</code> with initializers.<br>Note that for types with a default constructor, attempting to postpone initialization simply leads to a default initialization followed by an assignment.<br>A popular reason for such examples is “efficiency”, but a compiler that can detect whether we made a used-before-set error can also eliminate any redundant double initialization.</p>
<p>Assuming that there is a logical connection between <code>i</code> and <code>j</code>, that connection should probably be expressed in code:</p>
<pre><code>pair&lt;widget, widget&gt; make_related_widgets(bool x)
&#123;
    return (x) ? &#123;f1(), f2()&#125; : &#123;f3(), f4() &#125;;
&#125;

auto [i, j] = make_related_widgets(cond);    // C++17
</code></pre>
<h5 id="Note-181"><a href="#Note-181" class="headerlink" title="Note"></a>Note</h5><p>Complex initialization has been popular with clever programmers for decades.<br>It has also been a major source of errors and complexity.<br>Many such errors are introduced during maintenance years after the initial implementation.</p>
<h5 id="Example-178"><a href="#Example-178" class="headerlink" title="Example"></a>Example</h5><p>This rule covers member variables.</p>
<pre><code>class X &#123;
public:
    X(int i, int ci) : m2&#123;i&#125;, cm2&#123;ci&#125; &#123;&#125;
    // ...

private:
    int m1 = 7;
    int m2;
    int m3;

    const int cm1 = 7;
    const int cm2;
    const int cm3;
&#125;;
</code></pre>
<p>The compiler will flag the uninitialized <code>cm3</code> because it is a <code>const</code>, but it will not catch the lack of initialization of <code>m3</code>.<br>Usually, a rare spurious member initialization is worth the absence of errors from lack of initialization and often an optimizer<br>can eliminate a redundant initialization (e.g., an initialization that occurs immediately before an assignment).</p>
<h5 id="Exception-38"><a href="#Exception-38" class="headerlink" title="Exception"></a>Exception</h5><p>If you are declaring an object that is just about to be initialized from input, initializing it would cause a double initialization.<br>However, beware that this may leave uninitialized data beyond the input – and that has been a fertile source of errors and security breaches:</p>
<pre><code>constexpr int max = 8 * 1024;
int buf[max];         // OK, but suspicious: uninitialized
f.read(buf, max);
</code></pre>
<p>The cost of initializing that array could be significant in some situations.<br>However, such examples do tend to leave uninitialized variables accessible, so they should be treated with suspicion.</p>
<pre><code>constexpr int max = 8 * 1024;
int buf[max] = &#123;&#125;;   // zero all elements; better in some situations
f.read(buf, max);
</code></pre>
<p>When feasible use a library function that is known not to overflow. For example:</p>
<pre><code>string s;   // s is default initialized to &quot;&quot;
cin &gt;&gt; s;   // s expands to hold the string
</code></pre>
<p>Don’t consider simple variables that are targets for input operations exceptions to this rule:</p>
<pre><code>int i;   // bad
// ...
cin &gt;&gt; i;
</code></pre>
<p>In the not uncommon case where the input target and the input operation get separated (as they should not) the possibility of used-before-set opens up.</p>
<pre><code>int i2 = 0;   // better
// ...
cin &gt;&gt; i2;
</code></pre>
<p>A good optimizer should know about input operations and eliminate the redundant operation.</p>
<h5 id="Example-179"><a href="#Example-179" class="headerlink" title="Example"></a>Example</h5><p>Using an <code>uninitialized</code> or sentinel value is a symptom of a problem and not a<br>solution:</p>
<pre><code>widget i = uninit;  // bad
widget j = uninit;

// ...
use(i);         // possibly used before set
// ...

if (cond) &#123;     // bad: i and j are initialized &quot;late&quot;
    i = f1();
    j = f2();
&#125;
else &#123;
    i = f3();
    j = f4();
&#125;
</code></pre>
<p>Now the compiler cannot even simply detect a used-before-set. Further, we’ve introduced complexity in the state space for widget: which operations are valid on an <code>uninit</code> widget and which are not?</p>
<h5 id="Note-182"><a href="#Note-182" class="headerlink" title="Note"></a>Note</h5><p>Sometimes, a lambda can be used as an initializer to avoid an uninitialized variable:</p>
<pre><code>error_code ec;
Value v = [&amp;] &#123;
    auto p = get_value();   // get_value() returns a pair&lt;error_code, Value&gt;
    ec = p.first;
    return p.second;
&#125;();
</code></pre>
<p>or maybe:</p>
<pre><code>Value v = [] &#123;
    auto p = get_value();   // get_value() returns a pair&lt;error_code, Value&gt;
    if (p.first) throw Bad_value&#123;p.first&#125;;
    return p.second;
&#125;();
</code></pre>
<p><strong>See also</strong>: <a href="#Res-lambda-init">ES.28</a></p>
<h5 id="Enforcement-194"><a href="#Enforcement-194" class="headerlink" title="Enforcement"></a>Enforcement</h5><ul>
<li>Flag every uninitialized variable.<br>Don’t flag variables of user-defined types with default constructors.</li>
<li>Check that an uninitialized buffer is written into <em>immediately</em> after declaration.<br>Passing an uninitialized variable as a reference to non-<code>const</code> argument can be assumed to be a write into the variable.</li>
</ul>
<h3 id="ES-21-Don’t-introduce-a-variable-or-constant-before-you-need-to-use-it"><a href="#ES-21-Don’t-introduce-a-variable-or-constant-before-you-need-to-use-it" class="headerlink" title="ES.21: Don’t introduce a variable (or constant) before you need to use it"></a><a name="Res-introduce"></a>ES.21: Don’t introduce a variable (or constant) before you need to use it</h3><h5 id="Reason-204"><a href="#Reason-204" class="headerlink" title="Reason"></a>Reason</h5><p>Readability. To limit the scope in which the variable can be used.</p>
<h5 id="Example-180"><a href="#Example-180" class="headerlink" title="Example"></a>Example</h5><pre><code>int x = 7;
// ... no use of x here ...
++x;
</code></pre>
<h5 id="Enforcement-195"><a href="#Enforcement-195" class="headerlink" title="Enforcement"></a>Enforcement</h5><p>Flag declarations that are distant from their first use.</p>
<h3 id="ES-22-Don’t-declare-a-variable-until-you-have-a-value-to-initialize-it-with"><a href="#ES-22-Don’t-declare-a-variable-until-you-have-a-value-to-initialize-it-with" class="headerlink" title="ES.22: Don’t declare a variable until you have a value to initialize it with"></a><a name="Res-init"></a>ES.22: Don’t declare a variable until you have a value to initialize it with</h3><h5 id="Reason-205"><a href="#Reason-205" class="headerlink" title="Reason"></a>Reason</h5><p>Readability. Limit the scope in which a variable can be used. Don’t risk used-before-set. Initialization is often more efficient than assignment.</p>
<h5 id="Example-bad-80"><a href="#Example-bad-80" class="headerlink" title="Example, bad"></a>Example, bad</h5><pre><code>string s;
// ... no use of s here ...
s = &quot;what a waste&quot;;
</code></pre>
<h5 id="Example-bad-81"><a href="#Example-bad-81" class="headerlink" title="Example, bad"></a>Example, bad</h5><pre><code>SomeLargeType var;   // ugly CaMeLcAsEvArIaBlE

if (cond)   // some non-trivial condition
    Set(&amp;var);
else if (cond2 || !cond3) &#123;
    var = Set2(3.14);
&#125;
else &#123;
    var = 0;
    for (auto&amp; e : something)
        var += e;
&#125;

// use var; that this isn&#39;t done too early can be enforced statically with only control flow
</code></pre>
<p>This would be fine if there was a default initialization for <code>SomeLargeType</code> that wasn’t too expensive.<br>Otherwise, a programmer might very well wonder if every possible path through the maze of conditions has been covered.<br>If not, we have a “use before set” bug. This is a maintenance trap.</p>
<p>For initializers of moderate complexity, including for <code>const</code> variables, consider using a lambda to express the initializer; see <a href="#Res-lambda-init">ES.28</a>.</p>
<h5 id="Enforcement-196"><a href="#Enforcement-196" class="headerlink" title="Enforcement"></a>Enforcement</h5><ul>
<li>Flag declarations with default initialization that are assigned to before they are first read.</li>
<li>Flag any complicated computation after an uninitialized variable and before its use.</li>
</ul>
<h3 id="ES-23-Prefer-the-initializer-syntax"><a href="#ES-23-Prefer-the-initializer-syntax" class="headerlink" title="ES.23: Prefer the {} initializer syntax"></a><a name="Res-list"></a>ES.23: Prefer the <code>&#123;&#125;</code> initializer syntax</h3><h5 id="Reason-206"><a href="#Reason-206" class="headerlink" title="Reason"></a>Reason</h5><p>The rules for <code>&#123;&#125;</code> initialization are simpler, more general, less ambiguous, and safer than for other forms of initialization.</p>
<h5 id="Example-181"><a href="#Example-181" class="headerlink" title="Example"></a>Example</h5><pre><code>int x &#123;f(99)&#125;;
vector&lt;int&gt; v = &#123;1, 2, 3, 4, 5, 6&#125;;
</code></pre>
<h5 id="Exception-39"><a href="#Exception-39" class="headerlink" title="Exception"></a>Exception</h5><p>For containers, there is a tradition for using <code>&#123;...&#125;</code> for a list of elements and <code>(...)</code> for sizes:</p>
<pre><code>vector&lt;int&gt; v1(10);    // vector of 10 elements with the default value 0
vector&lt;int&gt; v2 &#123;10&#125;;   // vector of 1 element with the value 10
</code></pre>
<h5 id="Note-183"><a href="#Note-183" class="headerlink" title="Note"></a>Note</h5><p><code>&#123;&#125;</code>-initializers do not allow narrowing conversions.</p>
<h5 id="Example-182"><a href="#Example-182" class="headerlink" title="Example"></a>Example</h5><pre><code>int x &#123;7.9&#125;;   // error: narrowing
int y = 7.9;   // OK: y becomes 7. Hope for a compiler warning
</code></pre>
<h5 id="Note-184"><a href="#Note-184" class="headerlink" title="Note"></a>Note</h5><p><code>&#123;&#125;</code> initialization can be used for all initialization; other forms of initialization can’t:</p>
<pre><code>auto p = new vector&lt;int&gt; &#123;1, 2, 3, 4, 5&#125;;   // initialized vector
D::D(int a, int b) :m&#123;a, b&#125; &#123;   // member initializer (e.g., m might be a pair)
    // ...
&#125;;
X var &#123;&#125;;   // initialize var to be empty
struct S &#123;
    int m &#123;7&#125;;   // default initializer for a member
    // ...
&#125;;
</code></pre>
<h5 id="Note-185"><a href="#Note-185" class="headerlink" title="Note"></a>Note</h5><p>Initialization of a variable declared using <code>auto</code> with a single value, e.g., <code>&#123;v&#125;</code>, had surprising results until C++17.<br>The C++17 rules are somewhat less surprising:</p>
<pre><code>auto x1 &#123;7&#125;;        // x1 is an int with the value 7
auto x2 = &#123;7&#125;;  // x2 is an initializer_list&lt;int&gt; with an element 7

auto x11 &#123;7, 8&#125;;    // error: two initializers
auto x22 = &#123;7, 8&#125;;  // x2 is an initializer_list&lt;int&gt; with elements 7 and 8
</code></pre>
<p>So use <code>=&#123;...&#125;</code> if you really want an <code>initializer_list&lt;T&gt;</code></p>
<pre><code>auto fib10 = &#123;1, 1, 2, 3, 5, 8, 13, 21, 34, 55&#125;;   // fib10 is a list
</code></pre>
<h5 id="Note-186"><a href="#Note-186" class="headerlink" title="Note"></a>Note</h5><p>Old habits die hard, so this rule is hard to apply consistently, especially as there are so many cases where <code>=</code> is innocent.</p>
<h5 id="Example-183"><a href="#Example-183" class="headerlink" title="Example"></a>Example</h5><pre><code>template&lt;typename T&gt;
void f()
&#123;
    T x1(1);    // T initialized with 1
    T x0();     // bad: function declaration (often a mistake)

    T y1 &#123;1&#125;;   // T initialized with 1
    T y0 &#123;&#125;;    // default initialized T
    // ...
&#125;
</code></pre>
<p><strong>See also</strong>: <a href="#???">Discussion</a></p>
<h5 id="Enforcement-197"><a href="#Enforcement-197" class="headerlink" title="Enforcement"></a>Enforcement</h5><p>Tricky.</p>
<ul>
<li>Don’t flag uses of <code>=</code> for simple initializers.</li>
<li>Look for <code>=</code> after <code>auto</code> has been seen.</li>
</ul>
<h3 id="ES-24-Use-a-unique-ptr-lt-T-gt-to-hold-pointers"><a href="#ES-24-Use-a-unique-ptr-lt-T-gt-to-hold-pointers" class="headerlink" title="ES.24: Use a unique_ptr&lt;T&gt; to hold pointers"></a><a name="Res-unique"></a>ES.24: Use a <code>unique_ptr&lt;T&gt;</code> to hold pointers</h3><h5 id="Reason-207"><a href="#Reason-207" class="headerlink" title="Reason"></a>Reason</h5><p>Using <code>std::unique_ptr</code> is the simplest way to avoid leaks. It is reliable, it<br>makes the type system do much of the work to validate ownership safety, it<br>increases readability, and it has zero or near zero run-time cost.</p>
<h5 id="Example-184"><a href="#Example-184" class="headerlink" title="Example"></a>Example</h5><pre><code>void use(bool leak)
&#123;
    auto p1 = make_unique&lt;int&gt;(7);   // OK
    int* p2 = new int&#123;7&#125;;            // bad: might leak
    // ... no assignment to p2 ...
    if (leak) return;
    // ... no assignment to p2 ...
    vector&lt;int&gt; v(7);
    v.at(7) = 0;                    // exception thrown
    // ...
&#125;
</code></pre>
<p>If <code>leak == true</code> the object pointed to by <code>p2</code> is leaked and the object pointed to by <code>p1</code> is not.<br>The same is the case when <code>at()</code> throws.</p>
<h5 id="Enforcement-198"><a href="#Enforcement-198" class="headerlink" title="Enforcement"></a>Enforcement</h5><p>Look for raw pointers that are targets of <code>new</code>, <code>malloc()</code>, or functions that may return such pointers.</p>
<h3 id="ES-25-Declare-an-object-const-or-constexpr-unless-you-want-to-modify-its-value-later-on"><a href="#ES-25-Declare-an-object-const-or-constexpr-unless-you-want-to-modify-its-value-later-on" class="headerlink" title="ES.25: Declare an object const or constexpr unless you want to modify its value later on"></a><a name="Res-const"></a>ES.25: Declare an object <code>const</code> or <code>constexpr</code> unless you want to modify its value later on</h3><h5 id="Reason-208"><a href="#Reason-208" class="headerlink" title="Reason"></a>Reason</h5><p>That way you can’t change the value by mistake. That way may offer the compiler optimization opportunities.</p>
<h5 id="Example-185"><a href="#Example-185" class="headerlink" title="Example"></a>Example</h5><pre><code>void f(int n)
&#123;
    const int bufmax = 2 * n + 2;  // good: we can&#39;t change bufmax by accident
    int xmax = n;                  // suspicious: is xmax intended to change?
    // ...
&#125;
</code></pre>
<h5 id="Enforcement-199"><a href="#Enforcement-199" class="headerlink" title="Enforcement"></a>Enforcement</h5><p>Look to see if a variable is actually mutated, and flag it if<br>not. Unfortunately, it may be impossible to detect when a non-<code>const</code> was not<br><em>intended</em> to vary (vs when it merely did not vary).</p>
<h3 id="ES-26-Don’t-use-a-variable-for-two-unrelated-purposes"><a href="#ES-26-Don’t-use-a-variable-for-two-unrelated-purposes" class="headerlink" title="ES.26: Don’t use a variable for two unrelated purposes"></a><a name="Res-recycle"></a>ES.26: Don’t use a variable for two unrelated purposes</h3><h5 id="Reason-209"><a href="#Reason-209" class="headerlink" title="Reason"></a>Reason</h5><p>Readability and safety.</p>
<h5 id="Example-bad-82"><a href="#Example-bad-82" class="headerlink" title="Example, bad"></a>Example, bad</h5><pre><code>void use()
&#123;
    int i;
    for (i = 0; i &lt; 20; ++i) &#123; /* ... */ &#125;
    for (i = 0; i &lt; 200; ++i) &#123; /* ... */ &#125; // bad: i recycled
&#125;
</code></pre>
<h5 id="Note-187"><a href="#Note-187" class="headerlink" title="Note"></a>Note</h5><p>As an optimization, you may want to reuse a buffer as a scratch pad, but even then prefer to limit the variable’s scope as much as possible and be careful not to cause bugs from data left in a recycled buffer as this is a common source of security bugs.</p>
<pre><code>void write_to_file() &#123;
    std::string buffer;             // to avoid reallocations on every loop iteration
    for (auto&amp; o : objects)
    &#123;
        // First part of the work.
        generate_first_String(buffer, o);
        write_to_file(buffer);

        // Second part of the work.
        generate_second_string(buffer, o);
        write_to_file(buffer);

        // etc...
    &#125;
&#125;
</code></pre>
<h5 id="Enforcement-200"><a href="#Enforcement-200" class="headerlink" title="Enforcement"></a>Enforcement</h5><p>Flag recycled variables.</p>
<h3 id="ES-27-Use-std-array-or-stack-array-for-arrays-on-the-stack"><a href="#ES-27-Use-std-array-or-stack-array-for-arrays-on-the-stack" class="headerlink" title="ES.27: Use std::array or stack_array for arrays on the stack"></a><a name="Res-stack"></a>ES.27: Use <code>std::array</code> or <code>stack_array</code> for arrays on the stack</h3><h5 id="Reason-210"><a href="#Reason-210" class="headerlink" title="Reason"></a>Reason</h5><p>They are readable and don’t implicitly convert to pointers.<br>They are not confused with non-standard extensions of built-in arrays.</p>
<h5 id="Example-bad-83"><a href="#Example-bad-83" class="headerlink" title="Example, bad"></a>Example, bad</h5><pre><code>const int n = 7;
int m = 9;

void f()
&#123;
    int a1[n];
    int a2[m];   // error: not ISO C++
    // ...
&#125;
</code></pre>
<h5 id="Note-188"><a href="#Note-188" class="headerlink" title="Note"></a>Note</h5><p>The definition of <code>a1</code> is legal C++ and has always been.<br>There is a lot of such code.<br>It is error-prone, though, especially when the bound is non-local.<br>Also, it is a “popular” source of errors (buffer overflow, pointers from array decay, etc.).<br>The definition of <code>a2</code> is C but not C++ and is considered a security risk</p>
<h5 id="Example-186"><a href="#Example-186" class="headerlink" title="Example"></a>Example</h5><pre><code>const int n = 7;
int m = 9;

void f()
&#123;
    array&lt;int, n&gt; a1;
    stack_array&lt;int&gt; a2(m);
    // ...
&#125;
</code></pre>
<h5 id="Enforcement-201"><a href="#Enforcement-201" class="headerlink" title="Enforcement"></a>Enforcement</h5><ul>
<li>Flag arrays with non-constant bounds (C-style VLAs)</li>
<li>Flag arrays with non-local constant bounds</li>
</ul>
<h3 id="ES-28-Use-lambdas-for-complex-initialization-especially-of-const-variables"><a href="#ES-28-Use-lambdas-for-complex-initialization-especially-of-const-variables" class="headerlink" title="ES.28: Use lambdas for complex initialization, especially of const variables"></a><a name="Res-lambda-init"></a>ES.28: Use lambdas for complex initialization, especially of <code>const</code> variables</h3><h5 id="Reason-211"><a href="#Reason-211" class="headerlink" title="Reason"></a>Reason</h5><p>It nicely encapsulates local initialization, including cleaning up scratch variables needed only for the initialization, without needing to create a needless nonlocal yet nonreusable function. It also works for variables that should be <code>const</code> but only after some initialization work.</p>
<h5 id="Example-bad-84"><a href="#Example-bad-84" class="headerlink" title="Example, bad"></a>Example, bad</h5><pre><code>widget x;   // should be const, but:
for (auto i = 2; i &lt;= N; ++i) &#123;          // this could be some
    x += some_obj.do_something_with(i);  // arbitrarily long code
&#125;                                        // needed to initialize x
// from here, x should be const, but we can&#39;t say so in code in this style
</code></pre>
<h5 id="Example-good-15"><a href="#Example-good-15" class="headerlink" title="Example, good"></a>Example, good</h5><pre><code>const widget x = [&amp;]&#123;
    widget val;                                // assume that widget has a default constructor
    for (auto i = 2; i &lt;= N; ++i) &#123;            // this could be some
        val += some_obj.do_something_with(i);  // arbitrarily long code
    &#125;                                          // needed to initialize x
    return val;
&#125;();
</code></pre>
<h5 id="Example-187"><a href="#Example-187" class="headerlink" title="Example"></a>Example</h5><pre><code>string var = [&amp;]&#123;
    if (!in) return &quot;&quot;;   // default
    string s;
    for (char c : in &gt;&gt; c)
        s += toupper(c);
    return s;
&#125;(); // note ()
</code></pre>
<p>If at all possible, reduce the conditions to a simple set of alternatives (e.g., an <code>enum</code>) and don’t mix up selection and initialization.</p>
<h5 id="Enforcement-202"><a href="#Enforcement-202" class="headerlink" title="Enforcement"></a>Enforcement</h5><p>Hard. At best a heuristic. Look for an uninitialized variable followed by a loop assigning to it.</p>
<h3 id="ES-30-Don’t-use-macros-for-program-text-manipulation"><a href="#ES-30-Don’t-use-macros-for-program-text-manipulation" class="headerlink" title="ES.30: Don’t use macros for program text manipulation"></a><a name="Res-macros"></a>ES.30: Don’t use macros for program text manipulation</h3><h5 id="Reason-212"><a href="#Reason-212" class="headerlink" title="Reason"></a>Reason</h5><p>Macros are a major source of bugs.<br>Macros don’t obey the usual scope and type rules.<br>Macros ensure that the human reader sees something different from what the compiler sees.<br>Macros complicate tool building.</p>
<h5 id="Example-bad-85"><a href="#Example-bad-85" class="headerlink" title="Example, bad"></a>Example, bad</h5><pre><code>#define Case break; case   /* BAD */
</code></pre>
<p>This innocuous-looking macro makes a single lower case <code>c</code> instead of a <code>C</code> into a bad flow-control bug.</p>
<h5 id="Note-189"><a href="#Note-189" class="headerlink" title="Note"></a>Note</h5><p>This rule does not ban the use of macros for “configuration control” use in <code>#ifdef</code>s, etc.</p>
<h5 id="Enforcement-203"><a href="#Enforcement-203" class="headerlink" title="Enforcement"></a>Enforcement</h5><p>Scream when you see a macro that isn’t just used for source control (e.g., <code>#ifdef</code>)</p>
<h3 id="ES-31-Don’t-use-macros-for-constants-or-“functions”"><a href="#ES-31-Don’t-use-macros-for-constants-or-“functions”" class="headerlink" title="ES.31: Don’t use macros for constants or “functions”"></a><a name="Res-macros2"></a>ES.31: Don’t use macros for constants or “functions”</h3><h5 id="Reason-213"><a href="#Reason-213" class="headerlink" title="Reason"></a>Reason</h5><p>Macros are a major source of bugs.<br>Macros don’t obey the usual scope and type rules.<br>Macros don’t obey the usual rules for argument passing.<br>Macros ensure that the human reader sees something different from what the compiler sees.<br>Macros complicate tool building.</p>
<h5 id="Example-bad-86"><a href="#Example-bad-86" class="headerlink" title="Example, bad"></a>Example, bad</h5><pre><code>#define PI 3.14
#define SQUARE(a, b) (a * b)
</code></pre>
<p>Even if we hadn’t left a well-known bug in <code>SQUARE</code> there are much better behaved alternatives; for example:</p>
<pre><code>constexpr double pi = 3.14;
template&lt;typename T&gt; T square(T a, T b) &#123; return a * b; &#125;
</code></pre>
<h5 id="Enforcement-204"><a href="#Enforcement-204" class="headerlink" title="Enforcement"></a>Enforcement</h5><p>Scream when you see a macro that isn’t just used for source control (e.g., <code>#ifdef</code>)</p>
<h3 id="ES-32-Use-ALL-CAPS-for-all-macro-names"><a href="#ES-32-Use-ALL-CAPS-for-all-macro-names" class="headerlink" title="ES.32: Use ALL_CAPS for all macro names"></a><a name="Res-ALL_CAPS"></a>ES.32: Use <code>ALL_CAPS</code> for all macro names</h3><h5 id="Reason-214"><a href="#Reason-214" class="headerlink" title="Reason"></a>Reason</h5><p>Convention. Readability. Distinguishing macros.</p>
<h5 id="Example-188"><a href="#Example-188" class="headerlink" title="Example"></a>Example</h5><pre><code>#define forever for (;;)   /* very BAD */

#define FOREVER for (;;)   /* Still evil, but at least visible to humans */
</code></pre>
<h5 id="Enforcement-205"><a href="#Enforcement-205" class="headerlink" title="Enforcement"></a>Enforcement</h5><p>Scream when you see a lower case macro.</p>
<h3 id="ES-33-If-you-must-use-macros-give-them-unique-names"><a href="#ES-33-If-you-must-use-macros-give-them-unique-names" class="headerlink" title="ES.33: If you must use macros, give them unique names"></a><a name="Res-MACROS"></a>ES.33: If you must use macros, give them unique names</h3><h5 id="Reason-215"><a href="#Reason-215" class="headerlink" title="Reason"></a>Reason</h5><p>Macros do not obey scope rules.</p>
<h5 id="Example-189"><a href="#Example-189" class="headerlink" title="Example"></a>Example</h5><pre><code>#define MYCHAR        /* BAD, will eventually clash with someone else&#39;s MYCHAR*/

#define ZCORP_CHAR    /* Still evil, but less likely to clash */
</code></pre>
<h5 id="Note-190"><a href="#Note-190" class="headerlink" title="Note"></a>Note</h5><p>Avoid macros if you can: <a href="#Res-macros">ES.30</a>, <a href="#Res-macros2">ES.31</a>, and <a href="#Res-ALL_CAPS">ES.32</a>.<br>However, there are billions of lines of code littered with macros and a long tradition for using and overusing macros.<br>If you are forced to use macros, use long names and supposedly unique prefixes (e.g., your organization’s name) to lower the likelihood of a clash.</p>
<h5 id="Enforcement-206"><a href="#Enforcement-206" class="headerlink" title="Enforcement"></a>Enforcement</h5><p>Warn against short macro names.</p>
<h3 id="ES-34-Don’t-define-a-C-style-variadic-function"><a href="#ES-34-Don’t-define-a-C-style-variadic-function" class="headerlink" title=" ES.34: Don’t define a (C-style) variadic function"></a><a name="Res-ellipses"></a> ES.34: Don’t define a (C-style) variadic function</h3><h5 id="Reason-216"><a href="#Reason-216" class="headerlink" title="Reason"></a>Reason</h5><p>Not type safe.<br>Requires messy cast-and-macro-laden code to get working right.</p>
<h5 id="Example-190"><a href="#Example-190" class="headerlink" title="Example"></a>Example</h5><pre><code>#include &lt;cstdarg&gt;

// &quot;severity&quot; followed by a zero-terminated list of char*s; write the C-style strings to cerr
void error(int severity ...)
&#123;
    va_list ap;             // a magic type for holding arguments
    va_start(ap, severity); // arg startup: &quot;severity&quot; is the first argument of error()

    for (;;) &#123;
        // treat the next var as a char*; no checking: a cast in disguise
        char* p = va_arg(ap, char*);
        if (!p) break;
        cerr &lt;&lt; p &lt;&lt; &#39; &#39;;
    &#125;

    va_end(ap);             // arg cleanup (don&#39;t forget this)

    cerr &lt;&lt; &#39;\n&#39;;
    if (severity) exit(severity);
&#125;

void use()
&#123;
    error(7, &quot;this&quot;, &quot;is&quot;, &quot;an&quot;, &quot;error&quot;, nullptr);
    error(7); // crash
    error(7, &quot;this&quot;, &quot;is&quot;, &quot;an&quot;, &quot;error&quot;);  // crash
    const char* is = &quot;is&quot;;
    string an = &quot;an&quot;;
    error(7, &quot;this&quot;, &quot;is&quot;, an, &quot;error&quot;); // crash
&#125;
</code></pre>
<p><strong>Alternative</strong>: Overloading. Templates. Variadic templates.<br>    #include <iostream></p>
<pre><code>void error(int severity)
&#123;
    std::cerr &lt;&lt; &#39;\n&#39;;
    std::exit(severity);
&#125;

template &lt;typename T, typename... Ts&gt;
constexpr void error(int severity, T head, Ts... tail)
&#123;
    std::cerr &lt;&lt; head;
    error(severity, tail...);
&#125;

void use()
&#123;
    error(7); // No crash!
    error(5, &quot;this&quot;, &quot;is&quot;, &quot;not&quot;, &quot;an&quot;, &quot;error&quot;); // No crash!

    std::string an = &quot;an&quot;;
    error(7, &quot;this&quot;, &quot;is&quot;, &quot;not&quot;, an, &quot;error&quot;); // No crash!

    error(5, &quot;oh&quot;, &quot;no&quot;, nullptr); // Compile error! No need for nullptr.
&#125;
</code></pre>
<h5 id="Note-191"><a href="#Note-191" class="headerlink" title="Note"></a>Note</h5><p>This is basically the way <code>printf</code> is implemented.</p>
<h5 id="Enforcement-207"><a href="#Enforcement-207" class="headerlink" title="Enforcement"></a>Enforcement</h5><ul>
<li>Flag definitions of C-style variadic functions.</li>
<li>Flag <code>#include &lt;cstdarg&gt;</code> and <code>#include &lt;stdarg.h&gt;</code></li>
</ul>
<h2 id="ES-expr-Expressions"><a href="#ES-expr-Expressions" class="headerlink" title="ES.expr: Expressions"></a>ES.expr: Expressions</h2><p>Expressions manipulate values.</p>
<h3 id="ES-40-Avoid-complicated-expressions"><a href="#ES-40-Avoid-complicated-expressions" class="headerlink" title="ES.40: Avoid complicated expressions"></a><a name="Res-complicated"></a>ES.40: Avoid complicated expressions</h3><h5 id="Reason-217"><a href="#Reason-217" class="headerlink" title="Reason"></a>Reason</h5><p>Complicated expressions are error-prone.</p>
<h5 id="Example-191"><a href="#Example-191" class="headerlink" title="Example"></a>Example</h5><pre><code>// bad: assignment hidden in subexpression
while ((c = getc()) != -1)

// bad: two non-local variables assigned in a sub-expressions
while ((cin &gt;&gt; c1, cin &gt;&gt; c2), c1 == c2)

// better, but possibly still too complicated
for (char c1, c2; cin &gt;&gt; c1 &gt;&gt; c2 &amp;&amp; c1 == c2;)

// OK: if i and j are not aliased
int x = ++i + ++j;

// OK: if i != j and i != k
v[i] = v[j] + v[k];

// bad: multiple assignments &quot;hidden&quot; in subexpressions
x = a + (b = f()) + (c = g()) * 7;

// bad: relies on commonly misunderstood precedence rules
x = a &amp; b + c * d &amp;&amp; e ^ f == 7;

// bad: undefined behavior
x = x++ + x++ + ++x;
</code></pre>
<p>Some of these expressions are unconditionally bad (e.g., they rely on undefined behavior). Others are simply so complicated and/or unusual that even good programmers could misunderstand them or overlook a problem when in a hurry.</p>
<h5 id="Note-192"><a href="#Note-192" class="headerlink" title="Note"></a>Note</h5><p>C++17 tightens up the rules for the order of evaluation<br>(left-to-right except right-to-left in assignments, and the order of evaluation of function arguments is unspecified; <a href="#Res-order">see ES.43</a>),<br>but that doesn’t change the fact that complicated expressions are potentially confusing.</p>
<h5 id="Note-193"><a href="#Note-193" class="headerlink" title="Note"></a>Note</h5><p>A programmer should know and use the basic rules for expressions.</p>
<h5 id="Example-192"><a href="#Example-192" class="headerlink" title="Example"></a>Example</h5><pre><code>x = k * y + z;             // OK

auto t1 = k * y;           // bad: unnecessarily verbose
x = t1 + z;

if (0 &lt;= x &amp;&amp; x &lt; max)   // OK

auto t1 = 0 &lt;= x;        // bad: unnecessarily verbose
auto t2 = x &lt; max;
if (t1 &amp;&amp; t2)            // ...
</code></pre>
<h5 id="Enforcement-208"><a href="#Enforcement-208" class="headerlink" title="Enforcement"></a>Enforcement</h5><p>Tricky. How complicated must an expression be to be considered complicated? Writing computations as statements with one operation each is also confusing. Things to consider:</p>
<ul>
<li>side effects: side effects on multiple non-local variables (for some definition of non-local) can be suspect, especially if the side effects are in separate subexpressions</li>
<li>writes to aliased variables</li>
<li>more than N operators (and what should N be?)</li>
<li>reliance of subtle precedence rules</li>
<li>uses undefined behavior (can we catch all undefined behavior?)</li>
<li>implementation defined behavior?</li>
<li>???</li>
</ul>
<h3 id="ES-41-If-in-doubt-about-operator-precedence-parenthesize"><a href="#ES-41-If-in-doubt-about-operator-precedence-parenthesize" class="headerlink" title="ES.41: If in doubt about operator precedence, parenthesize"></a><a name="Res-parens"></a>ES.41: If in doubt about operator precedence, parenthesize</h3><h5 id="Reason-218"><a href="#Reason-218" class="headerlink" title="Reason"></a>Reason</h5><p>Avoid errors. Readability. Not everyone has the operator table memorized.</p>
<h5 id="Example-193"><a href="#Example-193" class="headerlink" title="Example"></a>Example</h5><pre><code>const unsigned int flag = 2;
unsigned int a = flag;

if (a &amp; flag != 0)  // bad: means a&amp;(flag != 0)
</code></pre>
<p>Note: We recommend that programmers know their precedence table for the arithmetic operations, the logical operations, but consider mixing bitwise logical operations with other operators in need of parentheses.</p>
<pre><code>if ((a &amp; flag) != 0)  // OK: works as intended
</code></pre>
<h5 id="Note-194"><a href="#Note-194" class="headerlink" title="Note"></a>Note</h5><p>You should know enough not to need parentheses for:</p>
<pre><code>if (a &lt; 0 || a &lt;= max) &#123;
    // ...
&#125;
</code></pre>
<h5 id="Enforcement-209"><a href="#Enforcement-209" class="headerlink" title="Enforcement"></a>Enforcement</h5><ul>
<li>Flag combinations of bitwise-logical operators and other operators.</li>
<li>Flag assignment operators not as the leftmost operator.</li>
<li>???</li>
</ul>
<h3 id="ES-42-Keep-use-of-pointers-simple-and-straightforward"><a href="#ES-42-Keep-use-of-pointers-simple-and-straightforward" class="headerlink" title="ES.42: Keep use of pointers simple and straightforward"></a><a name="Res-ptr"></a>ES.42: Keep use of pointers simple and straightforward</h3><h5 id="Reason-219"><a href="#Reason-219" class="headerlink" title="Reason"></a>Reason</h5><p>Complicated pointer manipulation is a major source of errors.</p>
<h5 id="Note-195"><a href="#Note-195" class="headerlink" title="Note"></a>Note</h5><p>Use <code>gsl::span</code> instead.<br>Pointers should <a href="#Ri-array">only refer to single objects</a>.<br>Pointer arithmetic is fragile and easy to get wrong, the source of many, many bad bugs and security violations.<br><code>span</code> is a bounds-checked, safe type for accessing arrays of data.<br>Access into an array with known bounds using a constant as a subscript can be validated by the compiler.</p>
<h5 id="Example-bad-87"><a href="#Example-bad-87" class="headerlink" title="Example, bad"></a>Example, bad</h5><pre><code>void f(int* p, int count)
&#123;
    if (count &lt; 2) return;

    int* q = p + 1;    // BAD

    ptrdiff_t d;
    int n;
    d = (p - &amp;n);      // OK
    d = (q - p);       // OK

    int n = *p++;      // BAD

    if (count &lt; 6) return;

    p[4] = 1;          // BAD

    p[count - 1] = 2;  // BAD

    use(&amp;p[0], 3);     // BAD
&#125;
</code></pre>
<h5 id="Example-good-16"><a href="#Example-good-16" class="headerlink" title="Example, good"></a>Example, good</h5><pre><code>void f(span&lt;int&gt; a) // BETTER: use span in the function declaration
&#123;
    if (a.size() &lt; 2) return;

    int n = a[0];      // OK

    span&lt;int&gt; q = a.subspan(1); // OK

    if (a.size() &lt; 6) return;

    a[4] = 1;          // OK

    a[count - 1] = 2;  // OK

    use(a.data(), 3);  // OK
&#125;
</code></pre>
<h5 id="Note-196"><a href="#Note-196" class="headerlink" title="Note"></a>Note</h5><p>Subscripting with a variable is difficult for both tools and humans to validate as safe.<br><code>span</code> is a run-time bounds-checked, safe type for accessing arrays of data.<br><code>at()</code> is another alternative that ensures single accesses are bounds-checked.<br>If iterators are needed to access an array, use the iterators from a <code>span</code> constructed over the array.</p>
<h5 id="Example-bad-88"><a href="#Example-bad-88" class="headerlink" title="Example, bad"></a>Example, bad</h5><pre><code>void f(array&lt;int, 10&gt; a, int pos)
&#123;
    a[pos / 2] = 1; // BAD
    a[pos - 1] = 2; // BAD
    a[-1] = 3;    // BAD (but easily caught by tools) -- no replacement, just don&#39;t do this
    a[10] = 4;    // BAD (but easily caught by tools) -- no replacement, just don&#39;t do this
&#125;
</code></pre>
<h5 id="Example-good-17"><a href="#Example-good-17" class="headerlink" title="Example, good"></a>Example, good</h5><p>Use a <code>span</code>:</p>
<pre><code>void f1(span&lt;int, 10&gt; a, int pos) // A1: Change parameter type to use span
&#123;
    a[pos / 2] = 1; // OK
    a[pos - 1] = 2; // OK
&#125;

void f2(array&lt;int, 10&gt; arr, int pos) // A2: Add local span and use that
&#123;
    span&lt;int&gt; a = &#123;arr, pos&#125;;
    a[pos / 2] = 1; // OK
    a[pos - 1] = 2; // OK
&#125;
</code></pre>
<p>Use a <code>at()</code>:</p>
<pre><code>void f3(array&lt;int, 10&gt; a, int pos) // ALTERNATIVE B: Use at() for access
&#123;
    at(a, pos / 2) = 1; // OK
    at(a, pos - 1) = 2; // OK
&#125;
</code></pre>
<h5 id="Example-bad-89"><a href="#Example-bad-89" class="headerlink" title="Example, bad"></a>Example, bad</h5><pre><code>void f()
&#123;
    int arr[COUNT];
    for (int i = 0; i &lt; COUNT; ++i)
        arr[i] = i; // BAD, cannot use non-constant indexer
&#125;
</code></pre>
<h5 id="Example-good-18"><a href="#Example-good-18" class="headerlink" title="Example, good"></a>Example, good</h5><p>Use a <code>span</code>:</p>
<pre><code>void f1()
&#123;
    int arr[COUNT];
    span&lt;int&gt; av = arr;
    for (int i = 0; i &lt; COUNT; ++i)
        av[i] = i;
&#125;
</code></pre>
<p>Use a <code>span</code> and range-<code>for</code>:</p>
<pre><code>void f1a()
&#123;
     int arr[COUNT];
     span&lt;int, COUNT&gt; av = arr;
     int i = 0;
     for (auto&amp; e : av)
         e = i++;
&#125;
</code></pre>
<p>Use <code>at()</code> for access:</p>
<pre><code>void f2()
&#123;
    int arr[COUNT];
    for (int i = 0; i &lt; COUNT; ++i)
        at(arr, i) = i;
&#125;
</code></pre>
<p>Use a range-<code>for</code>:</p>
<pre><code>void f3()
&#123;
    int arr[COUNT];
    for (auto&amp; e : arr)
         e = i++;
&#125;
</code></pre>
<h5 id="Note-197"><a href="#Note-197" class="headerlink" title="Note"></a>Note</h5><p>Tooling can offer rewrites of array accesses that involve dynamic index expressions to use <code>at()</code> instead:</p>
<pre><code>static int a[10];

void f(int i, int j)
&#123;
    a[i + j] = 12;      // BAD, could be rewritten as ...
    at(a, i + j) = 12;  // OK -- bounds-checked
&#125;
</code></pre>
<h5 id="Example-194"><a href="#Example-194" class="headerlink" title="Example"></a>Example</h5><p>Turning an array into a pointer (as the language does essentially always) removes opportunities for checking, so avoid it</p>
<pre><code>void g(int* p);

void f()
&#123;
    int a[5];
    g(a);        // BAD: are we trying to pass an array?
    g(&amp;a[0]);    // OK: passing one object
&#125;
</code></pre>
<p>If you want to pass an array, say so:</p>
<pre><code>void g(int* p, size_t length);  // old (dangerous) code

void g1(span&lt;int&gt; av); // BETTER: get g() changed.

void f2()
&#123;
    int a[5];
    span&lt;int&gt; av = a;

    g(av.data(), av.size());   // OK, if you have no choice
    g1(a);                     // OK -- no decay here, instead use implicit span ctor
&#125;
</code></pre>
<h5 id="Enforcement-210"><a href="#Enforcement-210" class="headerlink" title="Enforcement"></a>Enforcement</h5><ul>
<li>Flag any arithmetic operation on an expression of pointer type that results in a value of pointer type.</li>
<li>Flag any indexing expression on an expression or variable of array type (either static array or <code>std::array</code>) where the indexer is not a compile-time constant expression with a value between <code>0</code> or and the upper bound of the array.</li>
<li>Flag any expression that would rely on implicit conversion of an array type to a pointer type.</li>
</ul>
<p>This rule is part of the <a href="#SS-bounds">bounds-safety profile</a>.</p>
<h3 id="ES-43-Avoid-expressions-with-undefined-order-of-evaluation"><a href="#ES-43-Avoid-expressions-with-undefined-order-of-evaluation" class="headerlink" title="ES.43: Avoid expressions with undefined order of evaluation"></a><a name="Res-order"></a>ES.43: Avoid expressions with undefined order of evaluation</h3><h5 id="Reason-220"><a href="#Reason-220" class="headerlink" title="Reason"></a>Reason</h5><p>You have no idea what such code does. Portability.<br>Even if it does something sensible for you, it may do something different on another compiler (e.g., the next release of your compiler) or with a different optimizer setting.</p>
<h5 id="Note-198"><a href="#Note-198" class="headerlink" title="Note"></a>Note</h5><p>C++17 tightens up the rules for the order of evaluation:<br>left-to-right except right-to-left in assignments, and the order of evaluation of function arguments is unspecified.</p>
<p>However, remember that your code may be compiled with a pre-C++17 compiler (e.g., through cut-and-paste) so don’t be too clever.</p>
<h5 id="Example-195"><a href="#Example-195" class="headerlink" title="Example"></a>Example</h5><pre><code>v[i] = ++i;   //  the result is undefined
</code></pre>
<p>A good rule of thumb is that you should not read a value twice in an expression where you write to it.</p>
<h5 id="Enforcement-211"><a href="#Enforcement-211" class="headerlink" title="Enforcement"></a>Enforcement</h5><p>Can be detected by a good analyzer.</p>
<h3 id="ES-44-Don’t-depend-on-order-of-evaluation-of-function-arguments"><a href="#ES-44-Don’t-depend-on-order-of-evaluation-of-function-arguments" class="headerlink" title="ES.44: Don’t depend on order of evaluation of function arguments"></a><a name="Res-order-fct"></a>ES.44: Don’t depend on order of evaluation of function arguments</h3><h5 id="Reason-221"><a href="#Reason-221" class="headerlink" title="Reason"></a>Reason</h5><p>Because that order is unspecified.</p>
<h5 id="Note-199"><a href="#Note-199" class="headerlink" title="Note"></a>Note</h5><p>C++17 tightens up the rules for the order of evaluation, but the order of evaluation of function arguments is still unspecified.</p>
<h5 id="Example-196"><a href="#Example-196" class="headerlink" title="Example"></a>Example</h5><pre><code>int i = 0;
f(++i, ++i);
</code></pre>
<p>The call will most likely be <code>f(0, 1)</code> or <code>f(1, 0)</code>, but you don’t know which.<br>Technically, the behavior is undefined.<br>In C++17, this code does not have undefined behavior, but it is still not specified which argument is evaluated first.</p>
<h5 id="Example-197"><a href="#Example-197" class="headerlink" title="Example"></a>Example</h5><p>Overloaded operators can lead to order of evaluation problems:</p>
<pre><code>f1()-&gt;m(f2());          // m(f1(), f2())
cout &lt;&lt; f1() &lt;&lt; f2();   // operator&lt;&lt;(operator&lt;&lt;(cout, f1()), f2())
</code></pre>
<p>In C++17, these examples work as expected (left to right) and assignments are evaluated right to left (just as =’s binding is right-to-left)</p>
<pre><code>f1() = f2();    // undefined behavior in C++14; in C++17, f2() is evaluated before f1()
</code></pre>
<h5 id="Enforcement-212"><a href="#Enforcement-212" class="headerlink" title="Enforcement"></a>Enforcement</h5><p>Can be detected by a good analyzer.</p>
<h3 id="ES-45-Avoid-“magic-constants”-use-symbolic-constants"><a href="#ES-45-Avoid-“magic-constants”-use-symbolic-constants" class="headerlink" title="ES.45: Avoid “magic constants”; use symbolic constants"></a><a name="Res-magic"></a>ES.45: Avoid “magic constants”; use symbolic constants</h3><h5 id="Reason-222"><a href="#Reason-222" class="headerlink" title="Reason"></a>Reason</h5><p>Unnamed constants embedded in expressions are easily overlooked and often hard to understand:</p>
<h5 id="Example-198"><a href="#Example-198" class="headerlink" title="Example"></a>Example</h5><pre><code>for (int m = 1; m &lt;= 12; ++m)   // don&#39;t: magic constant 12
    cout &lt;&lt; month[m] &lt;&lt; &#39;\n&#39;;
</code></pre>
<p>No, we don’t all know that there are 12 months, numbered 1..12, in a year. Better:</p>
<pre><code>// months are indexed 1..12
constexpr int first_month = 1;
constexpr int last_month = 12;

for (int m = first_month; m &lt;= last_month; ++m)   // better
    cout &lt;&lt; month[m] &lt;&lt; &#39;\n&#39;;
</code></pre>
<p>Better still, don’t expose constants:</p>
<pre><code>for (auto m : month)
    cout &lt;&lt; m &lt;&lt; &#39;\n&#39;;
</code></pre>
<h5 id="Enforcement-213"><a href="#Enforcement-213" class="headerlink" title="Enforcement"></a>Enforcement</h5><p>Flag literals in code. Give a pass to <code>0</code>, <code>1</code>, <code>nullptr</code>, <code>\n</code>, <code>&quot;&quot;</code>, and others on a positive list.</p>
<h3 id="ES-46-Avoid-lossy-narrowing-truncating-arithmetic-conversions"><a href="#ES-46-Avoid-lossy-narrowing-truncating-arithmetic-conversions" class="headerlink" title="ES.46: Avoid lossy (narrowing, truncating) arithmetic conversions"></a><a name="Res-narrowing"></a>ES.46: Avoid lossy (narrowing, truncating) arithmetic conversions</h3><h5 id="Reason-223"><a href="#Reason-223" class="headerlink" title="Reason"></a>Reason</h5><p>A narrowing conversion destroys information, often unexpectedly so.</p>
<h5 id="Example-bad-90"><a href="#Example-bad-90" class="headerlink" title="Example, bad"></a>Example, bad</h5><p>A key example is basic narrowing:</p>
<pre><code>double d = 7.9;
int i = d;    // bad: narrowing: i becomes 7
i = (int) d;  // bad: we&#39;re going to claim this is still not explicit enough

void f(int x, long y, double d)
&#123;
    char c1 = x;   // bad: narrowing
    char c2 = y;   // bad: narrowing
    char c3 = d;   // bad: narrowing
&#125;
</code></pre>
<h5 id="Note-200"><a href="#Note-200" class="headerlink" title="Note"></a>Note</h5><p>The guideline support library offers a <code>narrow_cast</code> operation for specifying that narrowing is acceptable and a <code>narrow</code> (“narrow if”) that throws an exception if a narrowing would throw away information:</p>
<pre><code>i = narrow_cast&lt;int&gt;(d);   // OK (you asked for it): narrowing: i becomes 7
i = narrow&lt;int&gt;(d);        // OK: throws narrowing_error
</code></pre>
<p>We also include lossy arithmetic casts, such as from a negative floating point type to an unsigned integral type:</p>
<pre><code>double d = -7.9;
unsigned u = 0;

u = d;                          // BAD
u = narrow_cast&lt;unsigned&gt;(d);   // OK (you asked for it): u becomes 0
u = narrow&lt;unsigned&gt;(d);        // OK: throws narrowing_error
</code></pre>
<h5 id="Enforcement-214"><a href="#Enforcement-214" class="headerlink" title="Enforcement"></a>Enforcement</h5><p>A good analyzer can detect all narrowing conversions. However, flagging all narrowing conversions will lead to a lot of false positives. Suggestions:</p>
<ul>
<li>flag all floating-point to integer conversions (maybe only <code>float</code>-&gt;<code>char</code> and <code>double</code>-&gt;<code>int</code>. Here be dragons! we need data)</li>
<li>flag all <code>long</code>-&gt;<code>char</code> (I suspect <code>int</code>-&gt;<code>char</code> is very common. Here be dragons! we need data)</li>
<li>consider narrowing conversions for function arguments especially suspect</li>
</ul>
<h3 id="ES-47-Use-nullptr-rather-than-0-or-NULL"><a href="#ES-47-Use-nullptr-rather-than-0-or-NULL" class="headerlink" title="ES.47: Use nullptr rather than 0 or NULL"></a><a name="Res-nullptr"></a>ES.47: Use <code>nullptr</code> rather than <code>0</code> or <code>NULL</code></h3><h5 id="Reason-224"><a href="#Reason-224" class="headerlink" title="Reason"></a>Reason</h5><p>Readability. Minimize surprises: <code>nullptr</code> cannot be confused with an<br><code>int</code>. <code>nullptr</code> also has a well-specified (very restrictive) type, and thus<br>works in more scenarios where type deduction might do the wrong thing on <code>NULL</code><br>or <code>0</code>.</p>
<h5 id="Example-199"><a href="#Example-199" class="headerlink" title="Example"></a>Example</h5><p>Consider:</p>
<pre><code>void f(int);
void f(char*);
f(0);         // call f(int)
f(nullptr);   // call f(char*)
</code></pre>
<h5 id="Enforcement-215"><a href="#Enforcement-215" class="headerlink" title="Enforcement"></a>Enforcement</h5><p>Flag uses of <code>0</code> and <code>NULL</code> for pointers. The transformation may be helped by simple program transformation.</p>
<h3 id="ES-48-Avoid-casts"><a href="#ES-48-Avoid-casts" class="headerlink" title="ES.48: Avoid casts"></a><a name="Res-casts"></a>ES.48: Avoid casts</h3><h5 id="Reason-225"><a href="#Reason-225" class="headerlink" title="Reason"></a>Reason</h5><p>Casts are a well-known source of errors. Make some optimizations unreliable.</p>
<h5 id="Example-bad-91"><a href="#Example-bad-91" class="headerlink" title="Example, bad"></a>Example, bad</h5><pre><code>double d = 2;
auto p = (long*)&amp;d;
auto q = (long long*)&amp;d;
cout &lt;&lt; d &lt;&lt; &#39; &#39; &lt;&lt; *p &lt;&lt; &#39; &#39; &lt;&lt; *q &lt;&lt; &#39;\n&#39;;
</code></pre>
<p>What would you think this fragment prints? The result is at best implementation defined. I got</p>
<pre><code>2 0 4611686018427387904
</code></pre>
<p>Adding</p>
<pre><code>*q = 666;
cout &lt;&lt; d &lt;&lt; &#39; &#39; &lt;&lt; *p &lt;&lt; &#39; &#39; &lt;&lt; *q &lt;&lt; &#39;\n&#39;;
</code></pre>
<p>I got</p>
<pre><code>3.29048e-321 666 666
</code></pre>
<p>Surprised? I’m just glad I didn’t crash the program.</p>
<h5 id="Note-201"><a href="#Note-201" class="headerlink" title="Note"></a>Note</h5><p>Programmers who write casts typically assume that they know what they are doing,<br>or that writing a cast makes the program “easier to read”.<br>In fact, they often disable the general rules for using values.<br>Overload resolution and template instantiation usually pick the right function if there is a right function to pick.<br>If there is not, maybe there ought to be, rather than applying a local fix (cast).</p>
<h5 id="Note-202"><a href="#Note-202" class="headerlink" title="Note"></a>Note</h5><p>Casts are necessary in a systems programming language.  For example, how else<br>would we get the address of a device register into a pointer?  However, casts<br>are seriously overused as well as a major source of errors.</p>
<h5 id="Note-203"><a href="#Note-203" class="headerlink" title="Note"></a>Note</h5><p>If you feel the need for a lot of casts, there may be a fundamental design problem.</p>
<h5 id="Exception-40"><a href="#Exception-40" class="headerlink" title="Exception"></a>Exception</h5><p>Casting to <code>(void)</code> is the Standard-sanctioned way to turn off <code>[[nodiscard]]</code> warnings. If you are calling a function with a <code>[[nodiscard]]</code> return and you deliberately want to discard the result, first think hard about whether that is really a good idea (there is usually a good reason the author of the function or of the return type used <code>[[nodiscard]]</code> in the first place), but if you still think it’s appropriate and your code reviewer agrees, write <code>(void)</code> to turn off the warning.</p>
<h5 id="Alternatives-1"><a href="#Alternatives-1" class="headerlink" title="Alternatives"></a>Alternatives</h5><p>Casts are widely (mis) used. Modern C++ has rules and constructs that eliminate the need for casts in many contexts, such as</p>
<ul>
<li>Use templates</li>
<li>Use <code>std::variant</code></li>
<li>Rely on the well-defined, safe, implicit conversions between pointer types</li>
</ul>
<h5 id="Enforcement-216"><a href="#Enforcement-216" class="headerlink" title="Enforcement"></a>Enforcement</h5><ul>
<li>Force the elimination of C-style casts, except on a function with a <code>[[nodiscard]]</code> return</li>
<li>Warn if there are many functional style casts (there is an obvious problem in quantifying ‘many’)</li>
<li>The <a href="#Pro-type-reinterpretcast">type profile</a> bans <code>reinterpret_cast</code>.</li>
<li>Warn against <a href="#Pro-type-identitycast">identity casts</a> between pointer types, where the source and target types are the same (#Pro-type-identitycast)</li>
<li>Warn if a pointer cast could be <a href="#Pro-type-implicitpointercast">implicit</a></li>
</ul>
<h3 id="ES-49-If-you-must-use-a-cast-use-a-named-cast"><a href="#ES-49-If-you-must-use-a-cast-use-a-named-cast" class="headerlink" title="ES.49: If you must use a cast, use a named cast"></a><a name="Res-casts-named"></a>ES.49: If you must use a cast, use a named cast</h3><h5 id="Reason-226"><a href="#Reason-226" class="headerlink" title="Reason"></a>Reason</h5><p>Readability. Error avoidance.<br>Named casts are more specific than a C-style or functional cast, allowing the compiler to catch some errors.</p>
<p>The named casts are:</p>
<ul>
<li><code>static_cast</code></li>
<li><code>const_cast</code></li>
<li><code>reinterpret_cast</code></li>
<li><code>dynamic_cast</code></li>
<li><code>std::move</code>         // <code>move(x)</code> is an rvalue reference to <code>x</code></li>
<li><code>std::forward</code>      // <code>forward(x)</code> is an rvalue reference to <code>x</code></li>
<li><code>gsl::narrow_cast</code>  // <code>narrow_cast&lt;T&gt;(x)</code> is <code>static_cast&lt;T&gt;(x)</code></li>
<li><code>gsl::narrow</code>       // <code>narrow&lt;T&gt;(x)</code> is <code>static_cast&lt;T&gt;(x)</code> if <code>static_cast&lt;T&gt;(x) == x</code> or it throws <code>narrowing_error</code></li>
</ul>
<h5 id="Example-200"><a href="#Example-200" class="headerlink" title="Example"></a>Example</h5><pre><code>class B &#123; /* ... */ &#125;;
class D &#123; /* ... */ &#125;;

template&lt;typename D&gt; D* upcast(B* pb)
&#123;
    D* pd0 = pb;                        // error: no implicit conversion from B* to D*
    D* pd1 = (D*)pb;                    // legal, but what is done?
    D* pd2 = static_cast&lt;D*&gt;(pb);       // error: D is not derived from B
    D* pd3 = reinterpret_cast&lt;D*&gt;(pb);  // OK: on your head be it!
    D* pd4 = dynamic_cast&lt;D*&gt;(pb);      // OK: return nullptr
    // ...
&#125;
</code></pre>
<p>The example was synthesized from real-world bugs where <code>D</code> used to be derived from <code>B</code>, but someone refactored the hierarchy.<br>The C-style cast is dangerous because it can do any kind of conversion, depriving us of any protection from mistakes (now or in the future).</p>
<h5 id="Note-204"><a href="#Note-204" class="headerlink" title="Note"></a>Note</h5><p>When converting between types with no information loss (e.g. from <code>float</code> to<br><code>double</code> or <code>int64</code> from <code>int32</code>), brace initialization may be used instead.</p>
<pre><code>double d &#123;some_float&#125;;
int64_t i &#123;some_int32&#125;;
</code></pre>
<p>This makes it clear that the type conversion was intended and also prevents<br>conversions between types that might result in loss of precision. (It is a<br>compilation error to try to initialize a <code>float</code> from a <code>double</code> in this fashion,<br>for example.)</p>
<h5 id="Note-205"><a href="#Note-205" class="headerlink" title="Note"></a>Note</h5><p><code>reinterpret_cast</code> can be essential, but the essential uses (e.g., turning a machine address into pointer) are not type safe:</p>
<pre><code>auto p = reinterpret_cast&lt;Device_register&gt;(0x800);  // inherently dangerous
</code></pre>
<h5 id="Enforcement-217"><a href="#Enforcement-217" class="headerlink" title="Enforcement"></a>Enforcement</h5><ul>
<li>Flag C-style and functional casts.</li>
<li>The <a href="#Pro-type-reinterpretcast">type profile</a> bans <code>reinterpret_cast</code>.</li>
<li>The <a href="#Pro-type-arithmeticcast">type profile</a> warns when using <code>static_cast</code> between arithmetic types.</li>
</ul>
<h3 id="ES-50-Don’t-cast-away-const"><a href="#ES-50-Don’t-cast-away-const" class="headerlink" title="ES.50: Don’t cast away const"></a><a name="Res-casts-const"></a>ES.50: Don’t cast away <code>const</code></h3><h5 id="Reason-227"><a href="#Reason-227" class="headerlink" title="Reason"></a>Reason</h5><p>It makes a lie out of <code>const</code>.<br>If the variable is actually declared <code>const</code>, the result of “casting away <code>const</code>“ is undefined behavior.</p>
<h5 id="Example-bad-92"><a href="#Example-bad-92" class="headerlink" title="Example, bad"></a>Example, bad</h5><pre><code>void f(const int&amp; i)
&#123;
    const_cast&lt;int&amp;&gt;(i) = 42;   // BAD
&#125;

static int i = 0;
static const int j = 0;

f(i); // silent side effect
f(j); // undefined behavior
</code></pre>
<h5 id="Example-201"><a href="#Example-201" class="headerlink" title="Example"></a>Example</h5><p>Sometimes, you may be tempted to resort to <code>const_cast</code> to avoid code duplication, such as when two accessor functions that differ only in <code>const</code>-ness have similar implementations. For example:</p>
<pre><code>class Bar;

class Foo &#123;
public:
    // BAD, duplicates logic
    Bar&amp; get_bar() &#123;
        /* complex logic around getting a non-const reference to my_bar */
    &#125;

    const Bar&amp; get_bar() const &#123;
        /* same complex logic around getting a const reference to my_bar */
    &#125;
private:
    Bar my_bar;
&#125;;
</code></pre>
<p>Instead, prefer to share implementations. Normally, you can just have the non-<code>const</code> function call the <code>const</code> function. However, when there is complex logic this can lead to the following pattern that still resorts to a <code>const_cast</code>:</p>
<pre><code>class Foo &#123;
public:
    // not great, non-const calls const version but resorts to const_cast
    Bar&amp; get_bar() &#123;
        return const_cast&lt;Bar&amp;&gt;(static_cast&lt;const Foo&amp;&gt;(*this).get_bar());
    &#125;
    const Bar&amp; get_bar() const &#123;
        /* the complex logic around getting a const reference to my_bar */
    &#125;
private:
    Bar my_bar;
&#125;;
</code></pre>
<p>Although this pattern is safe when applied correctly, because the caller must have had a non-<code>const</code> object to begin with, it’s not ideal because the safety is hard to enforce automatically as a checker rule.</p>
<p>Instead, prefer to put the common code in a common helper function – and make it a template so that it deduces <code>const</code>. This doesn’t use any <code>const_cast</code> at all:</p>
<pre><code>class Foo &#123;
public:                         // good
          Bar&amp; get_bar()       &#123; return get_bar_impl(*this); &#125;
    const Bar&amp; get_bar() const &#123; return get_bar_impl(*this); &#125;
private:
    Bar my_bar;

    template&lt;class T&gt;           // good, deduces whether T is const or non-const
    static auto get_bar_impl(T&amp; t) -&gt; decltype(t.get_bar())
        &#123; /* the complex logic around getting a possibly-const reference to my_bar */ &#125;
&#125;;
</code></pre>
<h5 id="Exception-41"><a href="#Exception-41" class="headerlink" title="Exception"></a>Exception</h5><p>You may need to cast away <code>const</code> when calling <code>const</code>-incorrect functions.<br>Prefer to wrap such functions in inline <code>const</code>-correct wrappers to encapsulate the cast in one place.</p>
<h5 id="Example-202"><a href="#Example-202" class="headerlink" title="Example"></a>Example</h5><p>Sometimes, “cast away <code>const</code>“ is to allow the updating of some transient information of an otherwise immutable object.<br>Examples are caching, memoization, and precomputation.<br>Such examples are often handled as well or better using <code>mutable</code> or an indirection than with a <code>const_cast</code>.</p>
<p>Consider keeping previously computed results around for a costly operation:</p>
<pre><code>int compute(int x); // compute a value for x; assume this to be costly

class Cache &#123;   // some type implementing a cache for an int-&gt;int operation
public:
    pair&lt;bool, int&gt; find(int x) const;   // is there a value for x?
    void set(int x, int v);             // make y the value for x
    // ...
private:
    // ...
&#125;;

class X &#123;
public:
    int get_val(int x)
    &#123;
        auto p = cache.find(x);
        if (p.first) return p.second;
        int val = compute(x);
        cache.set(x, val); // insert value for x
        return val;
    &#125;
    // ...
private:
    Cache cache;
&#125;;
</code></pre>
<p>Here, <code>get_val()</code> is logically constant, so we would like to make it a <code>const</code> member.<br>To do this we still need to mutate <code>cache</code>, so people sometimes resort to a <code>const_cast</code>:</p>
<pre><code>class X &#123;   // Suspicious solution based on casting
public:
    int get_val(int x) const
    &#123;
        auto p = cache.find(x);
        if (p.first) return p.second;
        int val = compute(x);
        const_cast&lt;Cache&amp;&gt;(cache).set(x, val);   // ugly
        return val;
    &#125;
    // ...
private:
    Cache cache;
&#125;;
</code></pre>
<p>Fortunately, there is a better solution:<br>State that <code>cache</code> is mutable even for a <code>const</code> object:</p>
<pre><code>class X &#123;   // better solution
public:
    int get_val(int x) const
    &#123;
        auto p = cache.find(x);
        if (p.first) return p.second;
        int val = compute(x);
        cache.set(x, val);
        return val;
    &#125;
    // ...
private:
    mutable Cache cache;
&#125;;
</code></pre>
<p>An alternative solution would to store a pointer to the <code>cache</code>:</p>
<pre><code>class X &#123;   // OK, but slightly messier solution
public:
    int get_val(int x) const
    &#123;
        auto p = cache-&gt;find(x);
        if (p.first) return p.second;
        int val = compute(x);
        cache-&gt;set(x, val);
        return val;
    &#125;
    // ...
private:
    unique_ptr&lt;Cache&gt; cache;
&#125;;
</code></pre>
<p>That solution is the most flexible, but requires explicit construction and destruction of <code>*cache</code><br>(most likely in the constructor and destructor of <code>X</code>).</p>
<p>In any variant, we must guard against data races on the <code>cache</code> in multi-threaded code, possibly using a <code>std::mutex</code>.</p>
<h5 id="Enforcement-218"><a href="#Enforcement-218" class="headerlink" title="Enforcement"></a>Enforcement</h5><ul>
<li>Flag <code>const_cast</code>s.</li>
<li>This rule is part of the <a href="#Pro-type-constcast">type-safety profile</a> for the related Profile.</li>
</ul>
<h3 id="ES-55-Avoid-the-need-for-range-checking"><a href="#ES-55-Avoid-the-need-for-range-checking" class="headerlink" title="ES.55: Avoid the need for range checking"></a><a name="Res-range-checking"></a>ES.55: Avoid the need for range checking</h3><h5 id="Reason-228"><a href="#Reason-228" class="headerlink" title="Reason"></a>Reason</h5><p>Constructs that cannot overflow do not overflow (and usually run faster):</p>
<h5 id="Example-203"><a href="#Example-203" class="headerlink" title="Example"></a>Example</h5><pre><code>for (auto&amp; x : v)      // print all elements of v
    cout &lt;&lt; x &lt;&lt; &#39;\n&#39;;

auto p = find(v, x);   // find x in v
</code></pre>
<h5 id="Enforcement-219"><a href="#Enforcement-219" class="headerlink" title="Enforcement"></a>Enforcement</h5><p>Look for explicit range checks and heuristically suggest alternatives.</p>
<h3 id="ES-56-Write-std-move-only-when-you-need-to-explicitly-move-an-object-to-another-scope"><a href="#ES-56-Write-std-move-only-when-you-need-to-explicitly-move-an-object-to-another-scope" class="headerlink" title="ES.56: Write std::move() only when you need to explicitly move an object to another scope"></a><a name="Res-move"></a>ES.56: Write <code>std::move()</code> only when you need to explicitly move an object to another scope</h3><h5 id="Reason-229"><a href="#Reason-229" class="headerlink" title="Reason"></a>Reason</h5><p>We move, rather than copy, to avoid duplication and for improved performance.</p>
<p>A move typically leaves behind an empty object (<a href="#Rc-move-semantic">C.64</a>), which can be surprising or even dangerous, so we try to avoid moving from lvalues (they might be accessed later).</p>
<h5 id="Notes-4"><a href="#Notes-4" class="headerlink" title="Notes"></a>Notes</h5><p>Moving is done implicitly when the source is an rvalue (e.g., value in a <code>return</code> treatment or a function result), so don’t pointlessly complicate code in those cases by writing <code>move</code> explicitly. Instead, write short functions that return values, and both the function’s return and the caller’s accepting of the return will be optimized naturally.</p>
<p>In general, following the guidelines in this document (including not making variables’ scopes needlessly large, writing short functions that return values, returning local variables) help eliminate most need for explicit <code>std::move</code>.</p>
<p>Explicit <code>move</code> is needed to explicitly move an object to another scope, notably to pass it to a “sink” function and in the implementations of the move operations themselves (move constructor, move assignment operator) and swap operations.</p>
<h5 id="Example-bad-93"><a href="#Example-bad-93" class="headerlink" title="Example, bad"></a>Example, bad</h5><pre><code>void sink(X&amp;&amp; x);   // sink takes ownership of x

void user()
&#123;
    X x;
    // error: cannot bind an lvalue to a rvalue reference
    sink(x);
    // OK: sink takes the contents of x, x must now be assumed to be empty
    sink(std::move(x));

    // ...

    // probably a mistake
    use(x);
&#125;
</code></pre>
<p>Usually, a <code>std::move()</code> is used as an argument to a <code>&amp;&amp;</code> parameter.<br>And after you do that, assume the object has been moved from (see <a href="#Rc-move-semantic">C.64</a>) and don’t read its state again until you first set it to a new value.</p>
<pre><code>void f() &#123;
    string s1 = &quot;supercalifragilisticexpialidocious&quot;;

    string s2 = s1;             // ok, takes a copy
    assert(s1 == &quot;supercalifragilisticexpialidocious&quot;);  // ok

    // bad, if you want to keep using s1&#39;s value
    string s3 = move(s1);

    // bad, assert will likely fail, s1 likely changed
    assert(s1 == &quot;supercalifragilisticexpialidocious&quot;);
&#125;
</code></pre>
<h5 id="Example-204"><a href="#Example-204" class="headerlink" title="Example"></a>Example</h5><pre><code>void sink(unique_ptr&lt;widget&gt; p);  // pass ownership of p to sink()

void f() &#123;
    auto w = make_unique&lt;widget&gt;();
    // ...
    sink(std::move(w));               // ok, give to sink()
    // ...
    sink(w);    // Error: unique_ptr is carefully designed so that you cannot copy it
&#125;
</code></pre>
<h5 id="Notes-5"><a href="#Notes-5" class="headerlink" title="Notes"></a>Notes</h5><p><code>std::move()</code> is a cast to <code>&amp;&amp;</code> in disguise; it doesn’t itself move anything, but marks a named object as a candidate that can be moved from.<br>The language already knows the common cases where objects can be moved from, especially when returning values from functions, so don’t complicate code with redundant <code>std::move()</code>‘s.</p>
<p>Never write <code>std::move()</code> just because you’ve heard “it’s more efficient.”<br>In general, don’t believe claims of “efficiency” without data (???).<br>In general, don’t complicate your code without reason (??)</p>
<h5 id="Example-bad-94"><a href="#Example-bad-94" class="headerlink" title="Example, bad"></a>Example, bad</h5><pre><code>vector&lt;int&gt; make_vector() &#123;
    vector&lt;int&gt; result;
    // ... load result with data
    return std::move(result);       // bad; just write &quot;return result;&quot;
&#125;
</code></pre>
<p>Never write <code>return move(local_variable);</code>, because the language already knows the variable is a move candidate.<br>Writing <code>move</code> in this code won’t help, and can actually be detrimental because on some compilers it interferes with RVO (the return value optimization) by creating an additional reference alias to the local variable.</p>
<h5 id="Example-bad-95"><a href="#Example-bad-95" class="headerlink" title="Example, bad"></a>Example, bad</h5><pre><code>vector&lt;int&gt; v = std::move(make_vector());   // bad; the std::move is entirely redundant
</code></pre>
<p>Never write <code>move</code> on a returned value such as <code>x = move(f());</code> where <code>f</code> returns by value.<br>The language already knows that a returned value is a temporary object that can be moved from.</p>
<h5 id="Example-205"><a href="#Example-205" class="headerlink" title="Example"></a>Example</h5><pre><code>void mover(X&amp;&amp; x) &#123;
    call_something(std::move(x));         // ok
    call_something(std::forward&lt;X&gt;(x));   // bad, don&#39;t std::forward an rvalue reference
    call_something(x);                    // suspicious, why not std::move?
&#125;

template&lt;class T&gt;
void forwarder(T&amp;&amp; t) &#123;
    call_something(std::move(t));         // bad, don&#39;t std::move a forwarding reference
    call_something(std::forward&lt;T&gt;(t));   // ok
    call_something(t);                    // suspicious, why not std::forward?
&#125;
</code></pre>
<h5 id="Enforcement-220"><a href="#Enforcement-220" class="headerlink" title="Enforcement"></a>Enforcement</h5><ul>
<li>Flag use of <code>std::move(x)</code> where <code>x</code> is an rvalue or the language will already treat it as an rvalue, including <code>return std::move(local_variable);</code> and <code>std::move(f())</code> on a function that returns by value.</li>
<li>Flag functions taking an <code>S&amp;&amp;</code> parameter if there is no <code>const S&amp;</code> overload to take care of lvalues.</li>
<li>Flag a <code>std::move</code>s argument passed to a parameter, except when the parameter type is one of the following: an <code>X&amp;&amp;</code> rvalue reference; a <code>T&amp;&amp;</code> forwarding reference where <code>T</code> is a template parameter type; or by value and the type is move-only.</li>
<li>Flag when <code>std::move</code> is applied to a forwarding reference (<code>T&amp;&amp;</code> where <code>T</code> is a template parameter type). Use <code>std::forward</code> instead.</li>
<li>Flag when <code>std::move</code> is applied to other than an rvalue reference. (More general case of the previous rule to cover the non-forwarding cases.)</li>
<li>Flag when <code>std::forward</code> is applied to an rvalue reference (<code>X&amp;&amp;</code> where <code>X</code> is a concrete type). Use <code>std::move</code> instead.</li>
<li>Flag when <code>std::forward</code> is applied to other than a forwarding reference. (More general case of the previous rule to cover the non-moving cases.)</li>
<li>Flag when an object is potentially moved from and the next operation is a <code>const</code> operation; there should first be an intervening non-<code>const</code> operation, ideally assignment, to first reset the object’s value.</li>
</ul>
<h3 id="ES-60-Avoid-new-and-delete-outside-resource-management-functions"><a href="#ES-60-Avoid-new-and-delete-outside-resource-management-functions" class="headerlink" title="ES.60: Avoid new and delete outside resource management functions"></a><a name="Res-new"></a>ES.60: Avoid <code>new</code> and <code>delete</code> outside resource management functions</h3><h5 id="Reason-230"><a href="#Reason-230" class="headerlink" title="Reason"></a>Reason</h5><p>Direct resource management in application code is error-prone and tedious.</p>
<h5 id="Note-206"><a href="#Note-206" class="headerlink" title="Note"></a>Note</h5><p>also known as “No naked <code>new</code>!”</p>
<h5 id="Example-bad-96"><a href="#Example-bad-96" class="headerlink" title="Example, bad"></a>Example, bad</h5><pre><code>void f(int n)
&#123;
    auto p = new X[n];   // n default constructed Xs
    // ...
    delete[] p;
&#125;
</code></pre>
<p>There can be code in the <code>...</code> part that causes the <code>delete</code> never to happen.</p>
<p><strong>See also</strong>: <a href="#S-resource">R: Resource management</a></p>
<h5 id="Enforcement-221"><a href="#Enforcement-221" class="headerlink" title="Enforcement"></a>Enforcement</h5><p>Flag naked <code>new</code>s and naked <code>delete</code>s.</p>
<h3 id="ES-61-Delete-arrays-using-delete-and-non-arrays-using-delete"><a href="#ES-61-Delete-arrays-using-delete-and-non-arrays-using-delete" class="headerlink" title="ES.61: Delete arrays using delete[] and non-arrays using delete"></a><a name="Res-del"></a>ES.61: Delete arrays using <code>delete[]</code> and non-arrays using <code>delete</code></h3><h5 id="Reason-231"><a href="#Reason-231" class="headerlink" title="Reason"></a>Reason</h5><p>That’s what the language requires and mistakes can lead to resource release errors and/or memory corruption.</p>
<h5 id="Example-bad-97"><a href="#Example-bad-97" class="headerlink" title="Example, bad"></a>Example, bad</h5><pre><code>void f(int n)
&#123;
    auto p = new X[n];   // n default constructed Xs
    // ...
    delete p;   // error: just delete the object p, rather than delete the array p[]
&#125;
</code></pre>
<h5 id="Note-207"><a href="#Note-207" class="headerlink" title="Note"></a>Note</h5><p>This example not only violates the <a href="#Res-new">no naked <code>new</code> rule</a> as in the previous example, it has many more problems.</p>
<h5 id="Enforcement-222"><a href="#Enforcement-222" class="headerlink" title="Enforcement"></a>Enforcement</h5><ul>
<li>if the <code>new</code> and the <code>delete</code> is in the same scope, mistakes can be flagged.</li>
<li>if the <code>new</code> and the <code>delete</code> are in a constructor/destructor pair, mistakes can be flagged.</li>
</ul>
<h3 id="ES-62-Don’t-compare-pointers-into-different-arrays"><a href="#ES-62-Don’t-compare-pointers-into-different-arrays" class="headerlink" title="ES.62: Don’t compare pointers into different arrays"></a><a name="Res-arr2"></a>ES.62: Don’t compare pointers into different arrays</h3><h5 id="Reason-232"><a href="#Reason-232" class="headerlink" title="Reason"></a>Reason</h5><p>The result of doing so is undefined.</p>
<h5 id="Example-bad-98"><a href="#Example-bad-98" class="headerlink" title="Example, bad"></a>Example, bad</h5><pre><code>void f(int n)
&#123;
    int a1[7];
    int a2[9];
    if (&amp;a1[5] &lt; &amp;a2[7]) &#123;&#125;       // bad: undefined
    if (0 &lt; &amp;a1[5] - &amp;a2[7]) &#123;&#125;   // bad: undefined
&#125;
</code></pre>
<h5 id="Note-208"><a href="#Note-208" class="headerlink" title="Note"></a>Note</h5><p>This example has many more problems.</p>
<h5 id="Enforcement-223"><a href="#Enforcement-223" class="headerlink" title="Enforcement"></a>Enforcement</h5><p>???</p>
<h3 id="ES-63-Don’t-slice"><a href="#ES-63-Don’t-slice" class="headerlink" title="ES.63: Don’t slice"></a><a name="Res-slice"></a>ES.63: Don’t slice</h3><h5 id="Reason-233"><a href="#Reason-233" class="headerlink" title="Reason"></a>Reason</h5><p>Slicing – that is, copying only part of an object using assignment or initialization – most often leads to errors because<br>the object was meant to be considered as a whole.<br>In the rare cases where the slicing was deliberate the code can be surprising.</p>
<h5 id="Example-206"><a href="#Example-206" class="headerlink" title="Example"></a>Example</h5><pre><code>class Shape &#123; /* ... */ &#125;;
class Circle : public Shape &#123; /* ... */ Point c; int r; &#125;;

Circle c &#123;&#123;0, 0&#125;, 42&#125;;
    Shape s &#123;c&#125;;    // copy Shape part of Circle

The result will be meaningless because the center and radius will not be copied from `c` into `s`.
The first defense against this is to [define the base class `Shape` not to allow this](#Rc-copy-virtual).

##### Alternative

If you mean to slice, define an explicit operation to do so.
This saves readers from confusion.
For example:

    class Smiley : public Circle &#123;
        public:
        Circle copy_circle();
        // ...
    &#125;;
    
    Smiley sm &#123; /* ... */ &#125;;
    Circle c1 &#123;sm&#125;;  // ideally prevented by the definition of Circle
    Circle c2 &#123;sm.copy_circle()&#125;;

##### Enforcement

Warn against slicing.

### <a name="Res-construct"></a>ES.64: Use the `T&#123;e&#125;`notation for construction

##### Reason

The `T&#123;e&#125;` construction syntax makes it explicit that construction is desired.
The `T&#123;e&#125;` construction syntax doesn't allow narrowing.
`T&#123;e&#125;` is the only safe and general expression for constructing a value of type `T` from an expression `e`.
The casts notations `T(e)` and `(T)e` are neither safe nor general.

##### Example

For built-in types, the construction notation protects against narrowing and reinterpretation

    void use(char ch, int i, double d, char* p, long long lng)
    &#123;
        int x1 = int&#123;ch&#125;;     // OK, but redundant
        int x2 = int&#123;d&#125;;      // error: double->int narrowing; use a cast if you need to
        int x3 = int&#123;p&#125;;      // error: pointer to->int; use a reinterpret_cast if you really need to
        int x4 = int&#123;lng&#125;;    // error: long long->int narrowing; use a cast if you need to
    
        int y1 = int(ch);     // OK, but redundant
        int y2 = int(d);      // bad: double->int narrowing; use a cast if you need to
        int y3 = int(p);      // bad: pointer to->int; use a reinterpret_cast if you really need to
        int y4 = int(lng);    // bad: long->int narrowing; use a cast if you need to
    
        int z1 = (int)ch;     // OK, but redundant
        int z2 = (int)d;      // bad: double->int narrowing; use a cast if you need to
        int z3 = (int)p;      // bad: pointer to->int; use a reinterpret_cast if you really need to
        int z4 = (int)lng;    // bad: long long->int narrowing; use a cast if you need to
    &#125;

The integer to/from pointer conversions are implementation defined when using the `T(e)` or `(T)e` notations, and non-portable
between platforms with different integer and pointer sizes.

##### Note

[Avoid casts](#Res-casts) (explicit type conversion) and if you must [prefer named casts](#Res-casts-named).

##### Note

When unambiguous, the `T` can be left out of `T&#123;e&#125;`.

    complex<double> f(complex<double>);
    
    auto z = f(&#123;2*pi, 1&#125;);

##### Note

The construction notation is the most general [initializer notation](#Res-list).

##### Exception

`std::vector` and other containers were defined before we had `&#123;&#125;` as a notation for construction.
Consider:

    vector<string> vs &#123;10&#125;;                           // ten empty strings
    vector<int> vi1 &#123;1, 2, 3, 4, 5, 6, 7, 8, 9, 10&#125;;  // ten elements 1..10
    vector<int> vi2 &#123;10&#125;;                             // one element with the value 10

How do we get a `vector` of 10 default initialized `int`s?

    vector<int> v3(10); // ten elements with value 0

The use of `()` rather than `&#123;&#125;` for number of elements is conventional (going back to the early 1980s), hard to change, but still
a design error: for a container where the element type can be confused with the number of elements, we have an ambiguity that
must be resolved.
The conventional resolution is to interpret `&#123;10&#125;` as a list of one element and use `(10)` to distinguish a size.

This mistake need not be repeated in new code.
We can define a type to represent the number of elements:

    struct Count &#123; int n; &#125;;
    
    template<typename T>
    class Vector &#123;
    public:
        Vector(Count n);                     // n default-initialized elements
        Vector(initializer_list<T> init);    // init.size() elements
        // ...
    &#125;;
    
    Vector<int> v1&#123;10&#125;;
    Vector<int> v2&#123;Count&#123;10&#125;&#125;;
Vector&lt;Count&gt; v3&#123;Count&#123;10&#125;&#125;;    // yes, there is still a very minor problem
</code></pre>
<p>The main problem left is to find a suitable name for <code>Count</code>.</p>
<h5 id="Enforcement-224"><a href="#Enforcement-224" class="headerlink" title="Enforcement"></a>Enforcement</h5><p>Flag the C-style <code>(T)e</code> and functional-style <code>T(e)</code> casts.</p>
<h3 id="ES-65-Don’t-dereference-an-invalid-pointer"><a href="#ES-65-Don’t-dereference-an-invalid-pointer" class="headerlink" title="ES.65: Don’t dereference an invalid pointer"></a><a name="Res-deref"></a>ES.65: Don’t dereference an invalid pointer</h3><h5 id="Reason-234"><a href="#Reason-234" class="headerlink" title="Reason"></a>Reason</h5><p>Dereferencing an invalid pointer, such as <code>nullptr</code>, is undefined behavior, typically leading to immediate crashes,<br>wrong results, or memory corruption.</p>
<h5 id="Note-209"><a href="#Note-209" class="headerlink" title="Note"></a>Note</h5><p>This rule is an obvious and well-known language rule, but can be hard to follow.<br>It takes good coding style, library support, and static analysis to eliminate violations without major overhead.<br>This is a major part of the discussion of <a href="#Stroustrup15">C++’s resource- and type-safety model</a>.</p>
<p><strong>See also</strong>:</p>
<ul>
<li>Use <a href="#Rr-raii">RAII</a> to avoid lifetime problems.</li>
<li>Use <a href="#Rf-unique_ptr">unique_ptr</a> to avoid lifetime problems.</li>
<li>Use <a href="#Rf-shared_ptr">shared_ptr</a> to avoid lifetime problems.</li>
<li>Use <a href="#Rf-ptr-ref">references</a> when <code>nullptr</code> isn’t a possibility.</li>
<li>Use <a href="#Rf-not_null">not_null</a> to catch unexpected <code>nullptr</code> early.</li>
<li>Use the <a href="#SS-bounds">bounds profile</a> to avoid range errors.</li>
</ul>
<h5 id="Example-207"><a href="#Example-207" class="headerlink" title="Example"></a>Example</h5><pre><code>void f()
&#123;
    int x = 0;
    int* p = &amp;x;

    if (condition()) &#123;
        int y = 0;
        p = &amp;y;
    &#125; // invalidates p

    *p = 42;            // BAD, p might be invalid if the branch was taken
&#125;
</code></pre>
<p>To resolve the problem, either extend the lifetime of the object the pointer is intended to refer to, or shorten the lifetime of the pointer (move the dereference to before the pointed-to object’s lifetime ends).</p>
<pre><code>void f1()
&#123;
    int x = 0;
    int* p = &amp;x;

    int y = 0;
    if (condition()) &#123;
        p = &amp;y;
    &#125;

    *p = 42;            // OK, p points to x or y and both are still in scope
&#125;
</code></pre>
<p>Unfortunately, most invalid pointer problems are harder to spot and harder to fix.</p>
<h5 id="Example-208"><a href="#Example-208" class="headerlink" title="Example"></a>Example</h5><pre><code>void f(int* p)
&#123;
    int x = *p; // BAD: how do we know that p is valid?
&#125;
</code></pre>
<p>There is a huge amount of such code.<br>Most works – after lots of testing – but in isolation it is impossible to tell whether <code>p</code> could be the <code>nullptr</code>.<br>Consequently, this is also a major source of errors.<br>There are many approaches to dealing with this potential problem:</p>
<pre><code>void f1(int* p) // deal with nullptr
&#123;
    if (!p) &#123;
        // deal with nullptr (allocate, return, throw, make p point to something, whatever
    &#125;
    int x = *p;
&#125;
</code></pre>
<p>There are two potential problems with testing for <code>nullptr</code>:</p>
<ul>
<li>it is not always obvious what to do what to do if we find <code>nullptr</code></li>
<li>the test can be redundant and/or relatively expensive</li>
<li>it is not obvious if the test is to protect against a violation or part of the required logic.</li>
</ul>
<pre><code>void f2(int* p) // state that p is not supposed to be nullptr
&#123;
    assert(p);
    int x = *p;
&#125;
</code></pre>
<p>This would carry a cost only when the assertion checking was enabled and would give a compiler/analyzer useful information.<br>This would work even better if/when C++ gets direct support for contracts:</p>
<pre><code>void f3(int* p) // state that p is not supposed to be nullptr
    [[expects: p]]
&#123;
    int x = *p;
&#125;
</code></pre>
<p>Alternatively, we could use <code>gsl::not_null</code> to ensure that <code>p</code> is not the <code>nullptr</code>.</p>
<pre><code>void f(not_null&lt;int*&gt; p)
&#123;
    int x = *p;
&#125;
</code></pre>
<p>These remedies take care of <code>nullptr</code> only.<br>Remember that there are other ways of getting an invalid pointer.</p>
<h5 id="Example-209"><a href="#Example-209" class="headerlink" title="Example"></a>Example</h5><pre><code>void f(int* p)  // old code, doesn&#39;t use owner
&#123;
    delete p;
&#125;

void g()        // old code: uses naked new
&#123;
    auto q = new int&#123;7&#125;;
    f(q);
    int x = *q; // BAD: dereferences invalid pointer
&#125;
</code></pre>
<h5 id="Example-210"><a href="#Example-210" class="headerlink" title="Example"></a>Example</h5><pre><code>void f()
&#123;
    vector&lt;int&gt; v(10);
    int* p = &amp;v[5];
    v.push_back(99); // could reallocate v&#39;s elements
    int x = *p; // BAD: dereferences potentially invalid pointer
&#125;
</code></pre>
<h5 id="Enforcement-225"><a href="#Enforcement-225" class="headerlink" title="Enforcement"></a>Enforcement</h5><p>This rule is part of the <a href="#SS-lifetime">lifetime safety profile</a></p>
<ul>
<li>Flag a dereference of a pointer that points to an object that has gone out of scope</li>
<li>Flag a dereference of a pointer that may have been invalidated by assigning a <code>nullptr</code></li>
<li>Flag a dereference of a pointer that may have been invalidated by a <code>delete</code></li>
<li>Flag a dereference to a pointer to a container element that may have been invalidated by dereference</li>
</ul>
<h2 id="ES-stmt-Statements"><a href="#ES-stmt-Statements" class="headerlink" title="ES.stmt: Statements"></a>ES.stmt: Statements</h2><p>Statements control the flow of control (except for function calls and exception throws, which are expressions).</p>
<h3 id="ES-70-Prefer-a-switch-statement-to-an-if-statement-when-there-is-a-choice"><a href="#ES-70-Prefer-a-switch-statement-to-an-if-statement-when-there-is-a-choice" class="headerlink" title="ES.70: Prefer a switch-statement to an if-statement when there is a choice"></a><a name="Res-switch-if"></a>ES.70: Prefer a <code>switch</code>-statement to an <code>if</code>-statement when there is a choice</h3><h5 id="Reason-235"><a href="#Reason-235" class="headerlink" title="Reason"></a>Reason</h5><ul>
<li>Readability.</li>
<li>Efficiency: A <code>switch</code> compares against constants and is usually better optimized than a series of tests in an <code>if</code>-<code>then</code>-<code>else</code> chain.</li>
<li>A <code>switch</code> enables some heuristic consistency checking. For example, have all values of an <code>enum</code> been covered? If not, is there a <code>default</code>?</li>
</ul>
<h5 id="Example-211"><a href="#Example-211" class="headerlink" title="Example"></a>Example</h5><pre><code>void use(int n)
&#123;
    switch (n) &#123;   // good
    case 0:   // ...
    case 7:   // ...
    &#125;
&#125;
</code></pre>
<p>rather than:</p>
<pre><code>void use2(int n)
&#123;
    if (n == 0)   // bad: if-then-else chain comparing against a set of constants
        // ...
    else if (n == 7)
        // ...
&#125;
</code></pre>
<h5 id="Enforcement-226"><a href="#Enforcement-226" class="headerlink" title="Enforcement"></a>Enforcement</h5><p>Flag <code>if</code>-<code>then</code>-<code>else</code> chains that check against constants (only).</p>
<h3 id="ES-71-Prefer-a-range-for-statement-to-a-for-statement-when-there-is-a-choice"><a href="#ES-71-Prefer-a-range-for-statement-to-a-for-statement-when-there-is-a-choice" class="headerlink" title="ES.71: Prefer a range-for-statement to a for-statement when there is a choice"></a><a name="Res-for-range"></a>ES.71: Prefer a range-<code>for</code>-statement to a <code>for</code>-statement when there is a choice</h3><h5 id="Reason-236"><a href="#Reason-236" class="headerlink" title="Reason"></a>Reason</h5><p>Readability. Error prevention. Efficiency.</p>
<h5 id="Example-212"><a href="#Example-212" class="headerlink" title="Example"></a>Example</h5><pre><code>for (gsl::index i = 0; i &lt; v.size(); ++i)   // bad
        cout &lt;&lt; v[i] &lt;&lt; &#39;\n&#39;;

for (auto p = v.begin(); p != v.end(); ++p)   // bad
    cout &lt;&lt; *p &lt;&lt; &#39;\n&#39;;

for (auto&amp; x : v)    // OK
    cout &lt;&lt; x &lt;&lt; &#39;\n&#39;;

for (gsl::index i = 1; i &lt; v.size(); ++i) // touches two elements: can&#39;t be a range-for
    cout &lt;&lt; v[i] + v[i - 1] &lt;&lt; &#39;\n&#39;;

for (gsl::index i = 0; i &lt; v.size(); ++i) // possible side effect: can&#39;t be a range-for
    cout &lt;&lt; f(v, &amp;v[i]) &lt;&lt; &#39;\n&#39;;

for (gsl::index i = 0; i &lt; v.size(); ++i) &#123; // body messes with loop variable: can&#39;t be a range-for
    if (i % 2 == 0)
        continue;   // skip even elements
    else
        cout &lt;&lt; v[i] &lt;&lt; &#39;\n&#39;;
&#125;
</code></pre>
<p>A human or a good static analyzer may determine that there really isn’t a side effect on <code>v</code> in <code>f(v, &amp;v[i])</code> so that the loop can be rewritten.</p>
<p>“Messing with the loop variable” in the body of a loop is typically best avoided.</p>
<h5 id="Note-210"><a href="#Note-210" class="headerlink" title="Note"></a>Note</h5><p>Don’t use expensive copies of the loop variable of a range-<code>for</code> loop:</p>
<pre><code>for (string s : vs) // ...
</code></pre>
<p>This will copy each elements of <code>vs</code> into <code>s</code>. Better:</p>
<pre><code>for (string&amp; s : vs) // ...
</code></pre>
<p>Better still, if the loop variable isn’t modified or copied:</p>
<pre><code>for (const string&amp; s : vs) // ...
</code></pre>
<h5 id="Enforcement-227"><a href="#Enforcement-227" class="headerlink" title="Enforcement"></a>Enforcement</h5><p>Look at loops, if a traditional loop just looks at each element of a sequence, and there are no side effects on what it does with the elements, rewrite the loop to a ranged-<code>for</code> loop.</p>
<h3 id="ES-72-Prefer-a-for-statement-to-a-while-statement-when-there-is-an-obvious-loop-variable"><a href="#ES-72-Prefer-a-for-statement-to-a-while-statement-when-there-is-an-obvious-loop-variable" class="headerlink" title="ES.72: Prefer a for-statement to a while-statement when there is an obvious loop variable"></a><a name="Res-for-while"></a>ES.72: Prefer a <code>for</code>-statement to a <code>while</code>-statement when there is an obvious loop variable</h3><h5 id="Reason-237"><a href="#Reason-237" class="headerlink" title="Reason"></a>Reason</h5><p>Readability: the complete logic of the loop is visible “up front”. The scope of the loop variable can be limited.</p>
<h5 id="Example-213"><a href="#Example-213" class="headerlink" title="Example"></a>Example</h5><pre><code>for (gsl::index i = 0; i &lt; vec.size(); i++) &#123;
    // do work
&#125;
</code></pre>
<h5 id="Example-bad-99"><a href="#Example-bad-99" class="headerlink" title="Example, bad"></a>Example, bad</h5><pre><code>int i = 0;
while (i &lt; vec.size()) &#123;
    // do work
    i++;
&#125;
</code></pre>
<h5 id="Enforcement-228"><a href="#Enforcement-228" class="headerlink" title="Enforcement"></a>Enforcement</h5><p>???</p>
<h3 id="ES-73-Prefer-a-while-statement-to-a-for-statement-when-there-is-no-obvious-loop-variable"><a href="#ES-73-Prefer-a-while-statement-to-a-for-statement-when-there-is-no-obvious-loop-variable" class="headerlink" title="ES.73: Prefer a while-statement to a for-statement when there is no obvious loop variable"></a><a name="Res-while-for"></a>ES.73: Prefer a <code>while</code>-statement to a <code>for</code>-statement when there is no obvious loop variable</h3><h5 id="Reason-238"><a href="#Reason-238" class="headerlink" title="Reason"></a>Reason</h5><p>Readability.</p>
<h5 id="Example-214"><a href="#Example-214" class="headerlink" title="Example"></a>Example</h5><pre><code>int events = 0;
for (; wait_for_event(); ++events) &#123;  // bad, confusing
    // ...
&#125;
</code></pre>
<p>The “event loop” is misleading because the <code>events</code> counter has nothing to do with the loop condition (<code>wait_for_event()</code>).<br>Better</p>
<pre><code>int events = 0;
while (wait_for_event()) &#123;      // better
    ++events;
    // ...
&#125;
</code></pre>
<h5 id="Enforcement-229"><a href="#Enforcement-229" class="headerlink" title="Enforcement"></a>Enforcement</h5><p>Flag actions in <code>for</code>-initializers and <code>for</code>-increments that do not relate to the <code>for</code>-condition.</p>
<h3 id="ES-74-Prefer-to-declare-a-loop-variable-in-the-initializer-part-of-a-for-statement"><a href="#ES-74-Prefer-to-declare-a-loop-variable-in-the-initializer-part-of-a-for-statement" class="headerlink" title="ES.74: Prefer to declare a loop variable in the initializer part of a for-statement"></a><a name="Res-for-init"></a>ES.74: Prefer to declare a loop variable in the initializer part of a <code>for</code>-statement</h3><h5 id="Reason-239"><a href="#Reason-239" class="headerlink" title="Reason"></a>Reason</h5><p>Limit the loop variable visibility to the scope of the loop.<br>Avoid using the loop variable for other purposes after the loop.</p>
<h5 id="Example-215"><a href="#Example-215" class="headerlink" title="Example"></a>Example</h5><pre><code>for (int i = 0; i &lt; 100; ++i) &#123;   // GOOD: i var is visible only inside the loop
    // ...
&#125;
</code></pre>
<h5 id="Example-don’t-2"><a href="#Example-don’t-2" class="headerlink" title="Example, don’t"></a>Example, don’t</h5><pre><code>int j;                            // BAD: j is visible outside the loop
for (j = 0; j &lt; 100; ++j) &#123;
    // ...
&#125;
// j is still visible here and isn&#39;t needed
</code></pre>
<p><strong>See also</strong>: <a href="#Res-recycle">Don’t use a variable for two unrelated purposes</a></p>
<h5 id="Example-216"><a href="#Example-216" class="headerlink" title="Example"></a>Example</h5><pre><code>for (string s; cin &gt;&gt; s; ) &#123;
    cout &lt;&lt; s &lt;&lt; &#39;\n&#39;;
&#125;
</code></pre>
<h5 id="Enforcement-230"><a href="#Enforcement-230" class="headerlink" title="Enforcement"></a>Enforcement</h5><p>Warn when a variable modified inside the <code>for</code>-statement is declared outside the loop and not being used outside the loop.</p>
<p><strong>Discussion</strong>: Scoping the loop variable to the loop body also helps code optimizers greatly. Recognizing that the induction variable<br>is only accessible in the loop body unblocks optimizations such as hoisting, strength reduction, loop-invariant code motion, etc.</p>
<h3 id="ES-75-Avoid-do-statements"><a href="#ES-75-Avoid-do-statements" class="headerlink" title="ES.75: Avoid do-statements"></a><a name="Res-do"></a>ES.75: Avoid <code>do</code>-statements</h3><h5 id="Reason-240"><a href="#Reason-240" class="headerlink" title="Reason"></a>Reason</h5><p>Readability, avoidance of errors.<br>The termination condition is at the end (where it can be overlooked) and the condition is not checked the first time through.</p>
<h5 id="Example-217"><a href="#Example-217" class="headerlink" title="Example"></a>Example</h5><pre><code>int x;
do &#123;
    cin &gt;&gt; x;
    // ...
&#125; while (x &lt; 0);
</code></pre>
<h5 id="Note-211"><a href="#Note-211" class="headerlink" title="Note"></a>Note</h5><p>Yes, there are genuine examples where a <code>do</code>-statement is a clear statement of a solution, but also many bugs.</p>
<h5 id="Enforcement-231"><a href="#Enforcement-231" class="headerlink" title="Enforcement"></a>Enforcement</h5><p>Flag <code>do</code>-statements.</p>
<h3 id="ES-76-Avoid-goto"><a href="#ES-76-Avoid-goto" class="headerlink" title="ES.76: Avoid goto"></a><a name="Res-goto"></a>ES.76: Avoid <code>goto</code></h3><h5 id="Reason-241"><a href="#Reason-241" class="headerlink" title="Reason"></a>Reason</h5><p>Readability, avoidance of errors. There are better control structures for humans; <code>goto</code> is for machine generated code.</p>
<h5 id="Exception-42"><a href="#Exception-42" class="headerlink" title="Exception"></a>Exception</h5><p>Breaking out of a nested loop.<br>In that case, always jump forwards.</p>
<pre><code>for (int i = 0; i &lt; imax; ++i)
    for (int j = 0; j &lt; jmax; ++j) &#123;
        if (a[i][j] &gt; elem_max) goto finished;
        // ...
    &#125;
finished:
// ...
</code></pre>
<h5 id="Example-bad-100"><a href="#Example-bad-100" class="headerlink" title="Example, bad"></a>Example, bad</h5><p>There is a fair amount of use of the C goto-exit idiom:</p>
<pre><code>void f()
&#123;
    // ...
        goto exit;
    // ...
        goto exit;
    // ...
exit:
    // ... common cleanup code ...
&#125;
</code></pre>
<p>This is an ad-hoc simulation of destructors.<br>Declare your resources with handles with destructors that clean up.<br>If for some reason you cannot handle all cleanup with destructors for the variables used,<br>consider <code>gsl::finally()</code> as a cleaner and more reliable alternative to <code>goto exit</code></p>
<h5 id="Enforcement-232"><a href="#Enforcement-232" class="headerlink" title="Enforcement"></a>Enforcement</h5><ul>
<li>Flag <code>goto</code>. Better still flag all <code>goto</code>s that do not jump from a nested loop to the statement immediately after a nest of loops.</li>
</ul>
<h3 id="ES-77-Minimize-the-use-of-break-and-continue-in-loops"><a href="#ES-77-Minimize-the-use-of-break-and-continue-in-loops" class="headerlink" title="ES.77: Minimize the use of break and continue in loops"></a><a name="Res-continue"></a>ES.77: Minimize the use of <code>break</code> and <code>continue</code> in loops</h3><h5 id="Reason-242"><a href="#Reason-242" class="headerlink" title="Reason"></a>Reason</h5><p> In a non-trivial loop body, it is easy to overlook a <code>break</code> or a <code>continue</code>.</p>
<p> A <code>break</code> in a loop has a dramatically different meaning than a <code>break</code> in a <code>switch</code>-statement<br> (and you can have <code>switch</code>-statement in a loop and a loop in a <code>switch</code>-case).</p>
<h5 id="Example-218"><a href="#Example-218" class="headerlink" title="Example"></a>Example</h5><pre><code>???
</code></pre>
<h5 id="Alternative-8"><a href="#Alternative-8" class="headerlink" title="Alternative"></a>Alternative</h5><p>Often, a loop that requires a <code>break</code> is a good candidate for a function (algorithm), in which case the <code>break</code> becomes a <code>return</code>.</p>
<pre><code>???
</code></pre>
<p>Often. a loop that uses <code>continue</code> can equivalently and as clearly be expressed by an <code>if</code>-statement.</p>
<pre><code>???
</code></pre>
<h5 id="Note-212"><a href="#Note-212" class="headerlink" title="Note"></a>Note</h5><p>If you really need to break out a loop, a <code>break</code> is typically better than alternatives such as <a href="#Res-loop-counter">modifying the loop variable</a> or a <a href="#Res-goto"><code>goto</code></a>:</p>
<h5 id="Enforcement-233"><a href="#Enforcement-233" class="headerlink" title="Enforcement"></a>Enforcement</h5><p>???</p>
<h3 id="ES-78-Always-end-a-non-empty-case-with-a-break"><a href="#ES-78-Always-end-a-non-empty-case-with-a-break" class="headerlink" title="ES.78: Always end a non-empty case with a break"></a><a name="Res-break"></a>ES.78: Always end a non-empty <code>case</code> with a <code>break</code></h3><h5 id="Reason-243"><a href="#Reason-243" class="headerlink" title="Reason"></a>Reason</h5><p> Accidentally leaving out a <code>break</code> is a fairly common bug.<br> A deliberate fallthrough is a maintenance hazard.</p>
<h5 id="Example-219"><a href="#Example-219" class="headerlink" title="Example"></a>Example</h5><pre><code>switch (eventType) &#123;
case Information:
    update_status_bar();
    break;
case Warning:
    write_event_log();
    // Bad - implicit fallthrough
case Error:
    display_error_window();
    break;
&#125;
</code></pre>
<p>It is easy to overlook the fallthrough. Be explicit:</p>
<pre><code>switch (eventType) &#123;
case Information:
    update_status_bar();
    break;
case Warning:
    write_event_log();
    // fallthrough
case Error:
    display_error_window();
    break;
&#125;
</code></pre>
<p>In C++17, use a <code>[[fallthrough]]</code> annotation:</p>
<pre><code>switch (eventType) &#123;
case Information:
    update_status_bar();
    break;
case Warning:
    write_event_log();
    [[fallthrough]];        // C++17
case Error:
    display_error_window();
    break;
&#125;
</code></pre>
<h5 id="Note-213"><a href="#Note-213" class="headerlink" title="Note"></a>Note</h5><p>Multiple case labels of a single statement is OK:</p>
<pre><code>switch (x) &#123;
case &#39;a&#39;:
case &#39;b&#39;:
case &#39;f&#39;:
    do_something(x);
    break;
&#125;
</code></pre>
<h5 id="Enforcement-234"><a href="#Enforcement-234" class="headerlink" title="Enforcement"></a>Enforcement</h5><p>Flag all fallthroughs from non-empty <code>case</code>s.</p>
<h3 id="ES-79-Use-default-to-handle-common-cases-only"><a href="#ES-79-Use-default-to-handle-common-cases-only" class="headerlink" title="ES.79: Use default to handle common cases (only)"></a><a name="Res-default"></a>ES.79: Use <code>default</code> to handle common cases (only)</h3><h5 id="Reason-244"><a href="#Reason-244" class="headerlink" title="Reason"></a>Reason</h5><p> Code clarity.<br> Improved opportunities for error detection.</p>
<h5 id="Example-220"><a href="#Example-220" class="headerlink" title="Example"></a>Example</h5><pre><code>enum E &#123; a, b, c , d &#125;;

void f1(E x)
&#123;
    switch (x) &#123;
    case a:
        do_something();
        break;
    case b:
        do_something_else();
        break;
    default:
        take_the_default_action();
        break;
    &#125;
&#125;
</code></pre>
<p>Here it is clear that there is a default action and that cases <code>a</code> and <code>b</code> are special.</p>
<h5 id="Example-221"><a href="#Example-221" class="headerlink" title="Example"></a>Example</h5><p>But what if there is no default action and you mean to handle only specific cases?<br>In that case, have an empty default or else it is impossible to know if you meant to handle all cases:</p>
<pre><code>void f2(E x)
&#123;
    switch (x) &#123;
    case a:
        do_something();
        break;
    case b:
        do_something_else();
        break;
    default:
        // do nothing for the rest of the cases
        break;
    &#125;
&#125;
</code></pre>
<p>If you leave out the <code>default</code>, a maintainer and/or a compiler may reasonably assume that you intended to handle all cases:</p>
<pre><code>void f2(E x)
&#123;
    switch (x) &#123;
    case a:
        do_something();
        break;
    case b:
    case c:
        do_something_else();
        break;
    &#125;
&#125;
</code></pre>
<p>Did you forget case <code>d</code> or deliberately leave it out?<br>Forgetting a case typically happens when a case is added to an enumeration and the person doing so fails to add it to every<br>switch over the enumerators.</p>
<h5 id="Enforcement-235"><a href="#Enforcement-235" class="headerlink" title="Enforcement"></a>Enforcement</h5><p>Flag <code>switch</code>-statements over an enumeration that don’t handle all enumerators and do not have a <code>default</code>.<br>This may yield too many false positives in some code bases; if so, flag only <code>switch</code>es that handle most but not all cases<br>(that was the strategy of the very first C++ compiler).</p>
<h3 id="ES-84-Don’t-try-to-declare-a-local-variable-with-no-name"><a href="#ES-84-Don’t-try-to-declare-a-local-variable-with-no-name" class="headerlink" title="ES.84: Don’t (try to) declare a local variable with no name"></a><a name="Res-noname"></a>ES.84: Don’t (try to) declare a local variable with no name</h3><h5 id="Reason-245"><a href="#Reason-245" class="headerlink" title="Reason"></a>Reason</h5><p>There is no such thing.<br>What looks to a human like a variable without a name is to the compiler a statement consisting of a temporary that immediately goes out of scope.<br>To avoid unpleasant surprises.</p>
<h5 id="Example-bad-101"><a href="#Example-bad-101" class="headerlink" title="Example, bad"></a>Example, bad</h5><pre><code>void f()
&#123;
    lock&lt;mutex&gt;&#123;mx&#125;;   // Bad
    // ...
&#125;
</code></pre>
<p>This declares an unnamed <code>lock</code> object that immediately goes out of scope at the point of the semicolon.<br>This is not an uncommon mistake.<br>In particular, this particular example can lead to hard-to find race conditions.<br>There are exceedingly clever uses of this “idiom”, but they are far rarer than the mistakes.</p>
<h5 id="Note-214"><a href="#Note-214" class="headerlink" title="Note"></a>Note</h5><p>Unnamed function arguments are fine.</p>
<h5 id="Enforcement-236"><a href="#Enforcement-236" class="headerlink" title="Enforcement"></a>Enforcement</h5><p>Flag statements that are just a temporary</p>
<h3 id="ES-85-Make-empty-statements-visible"><a href="#ES-85-Make-empty-statements-visible" class="headerlink" title="ES.85: Make empty statements visible"></a><a name="Res-empty"></a>ES.85: Make empty statements visible</h3><h5 id="Reason-246"><a href="#Reason-246" class="headerlink" title="Reason"></a>Reason</h5><p>Readability.</p>
<h5 id="Example-222"><a href="#Example-222" class="headerlink" title="Example"></a>Example</h5><pre><code>for (i = 0; i &lt; max; ++i);   // BAD: the empty statement is easily overlooked
v[i] = f(v[i]);

for (auto x : v) &#123;           // better
    // nothing
&#125;
v[i] = f(v[i]);
</code></pre>
<h5 id="Enforcement-237"><a href="#Enforcement-237" class="headerlink" title="Enforcement"></a>Enforcement</h5><p>Flag empty statements that are not blocks and don’t contain comments.</p>
<h3 id="ES-86-Avoid-modifying-loop-control-variables-inside-the-body-of-raw-for-loops"><a href="#ES-86-Avoid-modifying-loop-control-variables-inside-the-body-of-raw-for-loops" class="headerlink" title="ES.86: Avoid modifying loop control variables inside the body of raw for-loops"></a><a name="Res-loop-counter"></a>ES.86: Avoid modifying loop control variables inside the body of raw for-loops</h3><h5 id="Reason-247"><a href="#Reason-247" class="headerlink" title="Reason"></a>Reason</h5><p>The loop control up front should enable correct reasoning about what is happening inside the loop. Modifying loop counters in both the iteration-expression and inside the body of the loop is a perennial source of surprises and bugs.</p>
<h5 id="Example-223"><a href="#Example-223" class="headerlink" title="Example"></a>Example</h5><pre><code>for (int i = 0; i &lt; 10; ++i) &#123;
    // no updates to i -- ok
&#125;

for (int i = 0; i &lt; 10; ++i) &#123;
    //
    if (/* something */) ++i; // BAD
    //
&#125;

bool skip = false;
for (int i = 0; i &lt; 10; ++i) &#123;
    if (skip) &#123; skip = false; continue; &#125;
    //
    if (/* something */) skip = true;  // Better: using two variable for two concepts.
    //
&#125;
</code></pre>
<h5 id="Enforcement-238"><a href="#Enforcement-238" class="headerlink" title="Enforcement"></a>Enforcement</h5><p>Flag variables that are potentially updated (have a non-<code>const</code> use) in both the loop control iteration-expression and the loop body.</p>
<h3 id="ES-87-Don’t-add-redundant-or-to-conditions"><a href="#ES-87-Don’t-add-redundant-or-to-conditions" class="headerlink" title="ES.87: Don’t add redundant == or != to conditions"></a><a name="Res-if"></a>ES.87: Don’t add redundant <code>==</code> or <code>!=</code> to conditions</h3><h5 id="Reason-248"><a href="#Reason-248" class="headerlink" title="Reason"></a>Reason</h5><p>Doing so avoids verbosity and eliminates some opportunities for mistakes.<br>Helps make style consistent and conventional.</p>
<h5 id="Example-224"><a href="#Example-224" class="headerlink" title="Example"></a>Example</h5><p>By definition, a condition in an <code>if</code>-statement, <code>while</code>-statement, or a <code>for</code>-statement selects between <code>true</code> and <code>false</code>.<br>A numeric value is compared to <code>0</code> and a pointer value to <code>nullptr</code>.</p>
<pre><code>// These all mean &quot;if `p` is not `nullptr`&quot;
if (p) &#123; ... &#125;            // good
if (p != 0) &#123; ... &#125;       // redundant `!=0`; bad: don&#39;t use 0 for pointers
if (p != nullptr) &#123; ... &#125; // redundant `!=nullptr`, not recommended
</code></pre>
<p>Often, <code>if (p)</code> is read as “if <code>p</code> is valid” which is a direct expression of the programmers intent,<br>whereas <code>if (p != nullptr)</code> would be a long-winded workaround.</p>
<h5 id="Example-225"><a href="#Example-225" class="headerlink" title="Example"></a>Example</h5><p>This rule is especially useful when a declaration is used as a condition</p>
<pre><code>if (auto pc = dynamic_cast&lt;Circle&gt;(ps)) &#123; ... &#125; // execute is ps points to a kind of Circle, good

if (auto pc = dynamic_cast&lt;Circle&gt;(ps); pc != nullptr) &#123; ... &#125; // not recommended
</code></pre>
<h5 id="Example-226"><a href="#Example-226" class="headerlink" title="Example"></a>Example</h5><p>Note that implicit conversions to bool are applied in conditions.<br>For example:</p>
<pre><code>for (string s; cin &gt;&gt; s; ) v.push_back(s);
</code></pre>
<p>This invokes <code>istream</code>‘s <code>operator bool()</code>.</p>
<h5 id="Note-215"><a href="#Note-215" class="headerlink" title="Note"></a>Note</h5><p>Explicit comparison of an integer to <code>0</code> is in general not redundant.<br>The reason is that (as opposed to pointers and Booleans) an integer often has more than two reasonable values.<br>Furthermore <code>0</code> (zero) is often used to indicate success.<br>Consequently, it is best to be specific about the comparison.</p>
<pre><code>void f(int i)
&#123;
    if (i)            // suspect
    // ...
    if (i == success) // possibly better
    // ...
&#125;
</code></pre>
<p>Always remember that an integer can have more than two values.</p>
<h5 id="Example-bad-102"><a href="#Example-bad-102" class="headerlink" title="Example, bad"></a>Example, bad</h5><p>It has been noted that</p>
<pre><code>if(strcmp(p1, p2)) &#123; ... &#125;   // are the two C-style strings equal? (mistake!)
</code></pre>
<p>is a common beginners error.<br>If you use C-style strings, you must know the <code>&lt;cstring&gt;</code> functions well.<br>Being verbose and writing</p>
<pre><code>if(strcmp(p1, p2) != 0) &#123; ... &#125;   // are the two C-style strings equal? (mistake!)
</code></pre>
<p>would not in itself save you.</p>
<h5 id="Note-216"><a href="#Note-216" class="headerlink" title="Note"></a>Note</h5><p>The opposite condition is most easily expressed using a negation:</p>
<pre><code>// These all mean &quot;if `p` is `nullptr`&quot;
if (!p) &#123; ... &#125;           // good
if (p == 0) &#123; ... &#125;       // redundant `== 0`; bad: don&#39;t use `0` for pointers
if (p == nullptr) &#123; ... &#125; // redundant `== nullptr`, not recommended
</code></pre>
<h5 id="Enforcement-239"><a href="#Enforcement-239" class="headerlink" title="Enforcement"></a>Enforcement</h5><p>Easy, just check for redundant use of <code>!=</code> and <code>==</code> in conditions.</p>
<h2 id="Arithmetic"><a href="#Arithmetic" class="headerlink" title="Arithmetic"></a><a name="SS-numbers"></a>Arithmetic</h2><h3 id="ES-100-Don’t-mix-signed-and-unsigned-arithmetic"><a href="#ES-100-Don’t-mix-signed-and-unsigned-arithmetic" class="headerlink" title="ES.100: Don’t mix signed and unsigned arithmetic"></a><a name="Res-mix"></a>ES.100: Don’t mix signed and unsigned arithmetic</h3><h5 id="Reason-249"><a href="#Reason-249" class="headerlink" title="Reason"></a>Reason</h5><p>Avoid wrong results.</p>
<h5 id="Example-227"><a href="#Example-227" class="headerlink" title="Example"></a>Example</h5><pre><code>int x = -3;
unsigned int y = 7;

cout &lt;&lt; x - y &lt;&lt; &#39;\n&#39;;  // unsigned result, possibly 4294967286
cout &lt;&lt; x + y &lt;&lt; &#39;\n&#39;;  // unsigned result: 4
cout &lt;&lt; x * y &lt;&lt; &#39;\n&#39;;  // unsigned result, possibly 4294967275
</code></pre>
<p>It is harder to spot the problem in more realistic examples.</p>
<h5 id="Note-217"><a href="#Note-217" class="headerlink" title="Note"></a>Note</h5><p>Unfortunately, C++ uses signed integers for array subscripts and the standard library uses unsigned integers for container subscripts.<br>This precludes consistency. Use <code>gsl::index</code> for subscripts; <a href="#Res-subscripts">see ES.107</a>.</p>
<h5 id="Enforcement-240"><a href="#Enforcement-240" class="headerlink" title="Enforcement"></a>Enforcement</h5><ul>
<li>Compilers already know and sometimes warn.</li>
<li>(To avoid noise) Do not flag on a mixed signed/unsigned comparison where one of the arguments is <code>sizeof</code> or a call to container <code>.size()</code> and the other is <code>ptrdiff_t</code>.</li>
</ul>
<h3 id="ES-101-Use-unsigned-types-for-bit-manipulation"><a href="#ES-101-Use-unsigned-types-for-bit-manipulation" class="headerlink" title="ES.101: Use unsigned types for bit manipulation"></a><a name="Res-unsigned"></a>ES.101: Use unsigned types for bit manipulation</h3><h5 id="Reason-250"><a href="#Reason-250" class="headerlink" title="Reason"></a>Reason</h5><p>Unsigned types support bit manipulation without surprises from sign bits.</p>
<h5 id="Example-228"><a href="#Example-228" class="headerlink" title="Example"></a>Example</h5><pre><code>unsigned char x = 0b1010&#39;1010;
unsigned char y = ~x;   // y == 0b0101&#39;0101;
</code></pre>
<h5 id="Note-218"><a href="#Note-218" class="headerlink" title="Note"></a>Note</h5><p>Unsigned types can also be useful for modulo arithmetic.<br>However, if you want modulo arithmetic add<br>comments as necessary noting the reliance on wraparound behavior, as such code<br>can be surprising for many programmers.</p>
<h5 id="Enforcement-241"><a href="#Enforcement-241" class="headerlink" title="Enforcement"></a>Enforcement</h5><ul>
<li>Just about impossible in general because of the use of unsigned subscripts in the standard library</li>
<li>???</li>
</ul>
<h3 id="ES-102-Use-signed-types-for-arithmetic"><a href="#ES-102-Use-signed-types-for-arithmetic" class="headerlink" title="ES.102: Use signed types for arithmetic"></a><a name="Res-signed"></a>ES.102: Use signed types for arithmetic</h3><h5 id="Reason-251"><a href="#Reason-251" class="headerlink" title="Reason"></a>Reason</h5><p>Because most arithmetic is assumed to be signed;<br><code>x - y</code> yields a negative number when <code>y &gt; x</code> except in the rare cases where you really want modulo arithmetic.</p>
<h5 id="Example-229"><a href="#Example-229" class="headerlink" title="Example"></a>Example</h5><p>Unsigned arithmetic can yield surprising results if you are not expecting it.<br>This is even more true for mixed signed and unsigned arithmetic.</p>
<pre><code>template&lt;typename T, typename T2&gt;
T subtract(T x, T2 y)
&#123;
    return x - y;
&#125;

void test()
&#123;
    int s = 5;
    unsigned int us = 5;
    cout &lt;&lt; subtract(s, 7) &lt;&lt; &#39;\n&#39;;       // -2
    cout &lt;&lt; subtract(us, 7u) &lt;&lt; &#39;\n&#39;;     // 4294967294
    cout &lt;&lt; subtract(s, 7u) &lt;&lt; &#39;\n&#39;;      // -2
    cout &lt;&lt; subtract(us, 7) &lt;&lt; &#39;\n&#39;;      // 4294967294
    cout &lt;&lt; subtract(s, us + 2) &lt;&lt; &#39;\n&#39;;  // -2
    cout &lt;&lt; subtract(us, s + 2) &lt;&lt; &#39;\n&#39;;  // 4294967294
&#125;
</code></pre>
<p>Here we have been very explicit about what’s happening,<br>but if you had seen <code>us - (s + 2)</code> or <code>s += 2; ...; us - s</code>, would you reliably have suspected that the result would print as <code>4294967294</code>?</p>
<h5 id="Exception-43"><a href="#Exception-43" class="headerlink" title="Exception"></a>Exception</h5><p>Use unsigned types if you really want modulo arithmetic - add<br>comments as necessary noting the reliance on overflow behavior, as such code<br>is going to be surprising for many programmers.</p>
<h5 id="Example-230"><a href="#Example-230" class="headerlink" title="Example"></a>Example</h5><p>The standard library uses unsigned types for subscripts.<br>The built-in array uses signed types for subscripts.<br>This makes surprises (and bugs) inevitable.</p>
<pre><code>int a[10];
for (int i = 0; i &lt; 10; ++i) a[i] = i;
vector&lt;int&gt; v(10);
// compares signed to unsigned; some compilers warn, but we should not
for (gsl::index i = 0; i &lt; v.size(); ++i) v[i] = i;

int a2[-2];         // error: negative size

// OK, but the number of ints (4294967294) is so large that we should get an exception
vector&lt;int&gt; v2(-2);
</code></pre>
<p> Use <code>gsl::index</code> for subscripts; <a href="#Res-subscripts">see ES.107</a>.</p>
<h5 id="Enforcement-242"><a href="#Enforcement-242" class="headerlink" title="Enforcement"></a>Enforcement</h5><ul>
<li>Flag mixed signed and unsigned arithmetic</li>
<li>Flag results of unsigned arithmetic assigned to or printed as signed.</li>
<li>Flag unsigned literals (e.g. <code>-2</code>) used as container subscripts.</li>
<li>(To avoid noise) Do not flag on a mixed signed/unsigned comparison where one of the arguments is <code>sizeof</code> or a call to container <code>.size()</code> and the other is <code>ptrdiff_t</code>.</li>
</ul>
<h3 id="ES-103-Don’t-overflow"><a href="#ES-103-Don’t-overflow" class="headerlink" title="ES.103: Don’t overflow"></a><a name="Res-overflow"></a>ES.103: Don’t overflow</h3><h5 id="Reason-252"><a href="#Reason-252" class="headerlink" title="Reason"></a>Reason</h5><p>Overflow usually makes your numeric algorithm meaningless.<br>Incrementing a value beyond a maximum value can lead to memory corruption and undefined behavior.</p>
<h5 id="Example-bad-103"><a href="#Example-bad-103" class="headerlink" title="Example, bad"></a>Example, bad</h5><pre><code>int a[10];
a[10] = 7;   // bad

int n = 0;
while (n++ &lt; 10)
    a[n - 1] = 9; // bad (twice)
</code></pre>
<h5 id="Example-bad-104"><a href="#Example-bad-104" class="headerlink" title="Example, bad"></a>Example, bad</h5><pre><code>int n = numeric_limits&lt;int&gt;::max();
int m = n + 1;   // bad
</code></pre>
<h5 id="Example-bad-105"><a href="#Example-bad-105" class="headerlink" title="Example, bad"></a>Example, bad</h5><pre><code>int area(int h, int w) &#123; return h * w; &#125;

auto a = area(10&#39;000&#39;000, 100&#39;000&#39;000);   // bad
</code></pre>
<h5 id="Exception-44"><a href="#Exception-44" class="headerlink" title="Exception"></a>Exception</h5><p>Use unsigned types if you really want modulo arithmetic.</p>
<p><strong>Alternative</strong>: For critical applications that can afford some overhead, use a range-checked integer and/or floating-point type.</p>
<h5 id="Enforcement-243"><a href="#Enforcement-243" class="headerlink" title="Enforcement"></a>Enforcement</h5><p>???</p>
<h3 id="ES-104-Don’t-underflow"><a href="#ES-104-Don’t-underflow" class="headerlink" title="ES.104: Don’t underflow"></a><a name="Res-underflow"></a>ES.104: Don’t underflow</h3><h5 id="Reason-253"><a href="#Reason-253" class="headerlink" title="Reason"></a>Reason</h5><p>Decrementing a value beyond a minimum value can lead to memory corruption and undefined behavior.</p>
<h5 id="Example-bad-106"><a href="#Example-bad-106" class="headerlink" title="Example, bad"></a>Example, bad</h5><pre><code>int a[10];
a[-2] = 7;   // bad

int n = 101;
while (n--)
    a[n - 1] = 9;   // bad (twice)
</code></pre>
<h5 id="Exception-45"><a href="#Exception-45" class="headerlink" title="Exception"></a>Exception</h5><p>Use unsigned types if you really want modulo arithmetic.</p>
<h5 id="Enforcement-244"><a href="#Enforcement-244" class="headerlink" title="Enforcement"></a>Enforcement</h5><p>???</p>
<h3 id="ES-105-Don’t-divide-by-zero"><a href="#ES-105-Don’t-divide-by-zero" class="headerlink" title="ES.105: Don’t divide by zero"></a><a name="Res-zero"></a>ES.105: Don’t divide by zero</h3><h5 id="Reason-254"><a href="#Reason-254" class="headerlink" title="Reason"></a>Reason</h5><p>The result is undefined and probably a crash.</p>
<h5 id="Note-219"><a href="#Note-219" class="headerlink" title="Note"></a>Note</h5><p>This also applies to <code>%</code>.</p>
<h5 id="Example-bad-107"><a href="#Example-bad-107" class="headerlink" title="Example; bad"></a>Example; bad</h5><pre><code>double divide(int a, int b) &#123;
    // BAD, should be checked (e.g., in a precondition)
    return a / b;
&#125;
</code></pre>
<h5 id="Example-good-19"><a href="#Example-good-19" class="headerlink" title="Example; good"></a>Example; good</h5><pre><code>double divide(int a, int b) &#123;
    // good, address via precondition (and replace with contracts once C++ gets them)
    Expects(b != 0);
    return a / b;
&#125;

double divide(int a, int b) &#123;
    // good, address via check
    return b ? a / b : quiet_NaN&lt;double&gt;();
&#125;
</code></pre>
<p><strong>Alternative</strong>: For critical applications that can afford some overhead, use a range-checked integer and/or floating-point type.</p>
<h5 id="Enforcement-245"><a href="#Enforcement-245" class="headerlink" title="Enforcement"></a>Enforcement</h5><ul>
<li>Flag division by an integral value that could be zero</li>
</ul>
<h3 id="ES-106-Don’t-try-to-avoid-negative-values-by-using-unsigned"><a href="#ES-106-Don’t-try-to-avoid-negative-values-by-using-unsigned" class="headerlink" title="ES.106: Don’t try to avoid negative values by using unsigned"></a><a name="Res-nonnegative"></a>ES.106: Don’t try to avoid negative values by using <code>unsigned</code></h3><h5 id="Reason-255"><a href="#Reason-255" class="headerlink" title="Reason"></a>Reason</h5><p>Choosing <code>unsigned</code> implies many changes to the usual behavior of integers, including modulo arithmetic,<br>can suppress warnings related to overflow,<br>and opens the door for errors related to signed/unsigned mixes.<br>Using <code>unsigned</code> doesn’t actually eliminate the possibility of negative values.</p>
<h5 id="Example-231"><a href="#Example-231" class="headerlink" title="Example"></a>Example</h5><pre><code>unsigned int u1 = -2;   // Valid: the value of u1 is 4294967294
int i1 = -2;
unsigned int u2 = i1;   // Valid: the value of u2 is 4294967294
int i2 = u2;            // Valid: the value of i2 is -2
</code></pre>
<p>These problems with such (perfectly legal) constructs are hard to spot in real code and are the source of many real-world errors.<br>Consider:</p>
<pre><code>unsigned area(unsigned height, unsigned width) &#123; return height*width; &#125; // [see also](#Ri-expects)
// ...
int height;
cin &gt;&gt; height;
auto a = area(height, 2);   // if the input is -2 a becomes 4294967292
</code></pre>
<p>Remember that <code>-1</code> when assigned to an <code>unsigned int</code> becomes the largest <code>unsigned int</code>.<br>Also, since unsigned arithmetic is modulo arithmetic the multiplication didn’t overflow, it wrapped around.</p>
<h5 id="Example-232"><a href="#Example-232" class="headerlink" title="Example"></a>Example</h5><pre><code>unsigned max = 100000;    // &quot;accidental typo&quot;, I mean to say 10&#39;000
unsigned short x = 100;
while (x &lt; max) x += 100; // infinite loop
</code></pre>
<p>Had <code>x</code> been a signed <code>short</code>, we could have warned about the undefined behavior upon overflow.</p>
<h5 id="Alternatives-2"><a href="#Alternatives-2" class="headerlink" title="Alternatives"></a>Alternatives</h5><ul>
<li>use signed integers and check for <code>x &gt;= 0</code></li>
<li>use a positive integer type</li>
<li>use an integer subrange type</li>
<li><code>Assert(-1 &lt; x)</code></li>
</ul>
<p>For example</p>
<pre><code>struct Positive &#123;
    int val;
    Positive(int x) :val&#123;x&#125; &#123; Assert(0 &lt; x); &#125;
    operator int() &#123; return val; &#125;
&#125;;

int f(Positive arg) &#123; return arg; &#125;

int r1 = f(2);
int r2 = f(-2);  // throws
</code></pre>
<h5 id="Note-220"><a href="#Note-220" class="headerlink" title="Note"></a>Note</h5><p>???</p>
<h5 id="Enforcement-246"><a href="#Enforcement-246" class="headerlink" title="Enforcement"></a>Enforcement</h5><p>Hard: there is a lot of code using <code>unsigned</code> and we don’t offer a practical positive number type.</p>
<h3 id="ES-107-Don’t-use-unsigned-for-subscripts-prefer-gsl-index"><a href="#ES-107-Don’t-use-unsigned-for-subscripts-prefer-gsl-index" class="headerlink" title="ES.107: Don’t use unsigned for subscripts, prefer gsl::index"></a><a name="Res-subscripts"></a>ES.107: Don’t use <code>unsigned</code> for subscripts, prefer <code>gsl::index</code></h3><h5 id="Reason-256"><a href="#Reason-256" class="headerlink" title="Reason"></a>Reason</h5><p>To avoid signed/unsigned confusion.<br>To enable better optimization.<br>To enable better error detection.<br>To avoid the pitfalls with <code>auto</code> and <code>int</code>.</p>
<h5 id="Example-bad-108"><a href="#Example-bad-108" class="headerlink" title="Example, bad"></a>Example, bad</h5><pre><code>vector&lt;int&gt; vec = /*...*/;

for (int i = 0; i &lt; vec.size(); i += 2)                    // may not be big enough
    cout &lt;&lt; vec[i] &lt;&lt; &#39;\n&#39;;
for (unsigned i = 0; i &lt; vec.size(); i += 2)               // risk wraparound
    cout &lt;&lt; vec[i] &lt;&lt; &#39;\n&#39;;
for (auto i = 0; i &lt; vec.size(); i += 2)                   // may not be big enough
    cout &lt;&lt; vec[i] &lt;&lt; &#39;\n&#39;;
for (vector&lt;int&gt;::size_type i = 0; i &lt; vec.size(); i += 2) // verbose
    cout &lt;&lt; vec[i] &lt;&lt; &#39;\n&#39;;
for (auto i = vec.size()-1; i &gt;= 0; i -= 2)                // bug
    cout &lt;&lt; vec[i] &lt;&lt; &#39;\n&#39;;
for (int i = vec.size()-1; i &gt;= 0; i -= 2)                 // may not be big enough
    cout &lt;&lt; vec[i] &lt;&lt; &#39;\n&#39;;
</code></pre>
<h5 id="Example-good-20"><a href="#Example-good-20" class="headerlink" title="Example, good"></a>Example, good</h5><pre><code>vector&lt;int&gt; vec = /*...*/;

for (gsl::index i = 0; i &lt; vec.size(); i += 2)             // ok
    cout &lt;&lt; vec[i] &lt;&lt; &#39;\n&#39;;
for (gsl::index i = vec.size()-1; i &gt;= 0; i -= 2)          // ok
    cout &lt;&lt; vec[i] &lt;&lt; &#39;\n&#39;;
</code></pre>
<h5 id="Note-221"><a href="#Note-221" class="headerlink" title="Note"></a>Note</h5><p>The built-in array uses signed subscripts.<br>The standard-library containers use unsigned subscripts.<br>Thus, no perfect and fully compatible solution is possible (unless and until the standard-library containers change to use signed subscripts someday in the future).<br>Given the known problems with unsigned and signed/unsigned mixtures, better stick to (signed) integers of a sufficient size, which is guaranteed by <code>gsl::index</code>.</p>
<h5 id="Example-233"><a href="#Example-233" class="headerlink" title="Example"></a>Example</h5><pre><code>template&lt;typename T&gt;
struct My_container &#123;
public:
    // ...
    T&amp; operator[](gsl::index i);    // not unsigned
    // ...
&#125;;
</code></pre>
<h5 id="Example-234"><a href="#Example-234" class="headerlink" title="Example"></a>Example</h5><pre><code>??? demonstrate improved code generation and potential for error detection ???
</code></pre>
<h5 id="Alternatives-3"><a href="#Alternatives-3" class="headerlink" title="Alternatives"></a>Alternatives</h5><p>Alternatives for users</p>
<ul>
<li>use algorithms</li>
<li>use range-for</li>
<li>use iterators/pointers</li>
</ul>
<h5 id="Enforcement-247"><a href="#Enforcement-247" class="headerlink" title="Enforcement"></a>Enforcement</h5><ul>
<li>Very tricky as long as the standard-library containers get it wrong.</li>
<li>(To avoid noise) Do not flag on a mixed signed/unsigned comparison where one of the arguments is <code>sizeof</code> or a call to container <code>.size()</code> and the other is <code>ptrdiff_t</code>.</li>
</ul>
<h1 id="Per-Performance"><a href="#Per-Performance" class="headerlink" title="Per: Performance"></a><a name="S-performance"></a>Per: Performance</h1><p>??? should this section be in the main guide???</p>
<p>This section contains rules for people who need high performance or low-latency.<br>That is, these are rules that relate to how to use as little time and as few resources as possible to achieve a task in a predictably short time.<br>The rules in this section are more restrictive and intrusive than what is needed for many (most) applications.<br>Do not blindly try to follow them in general code: achieving the goals of low latency requires extra work.</p>
<p>Performance rule summary:</p>
<ul>
<li><a href="#Rper-reason">Per.1: Don’t optimize without reason</a></li>
<li><a href="#Rper-Knuth">Per.2: Don’t optimize prematurely</a></li>
<li><a href="#Rper-critical">Per.3: Don’t optimize something that’s not performance critical</a></li>
<li><a href="#Rper-simple">Per.4: Don’t assume that complicated code is necessarily faster than simple code</a></li>
<li><a href="#Rper-low">Per.5: Don’t assume that low-level code is necessarily faster than high-level code</a></li>
<li><a href="#Rper-measure">Per.6: Don’t make claims about performance without measurements</a></li>
<li><a href="#Rper-efficiency">Per.7: Design to enable optimization</a></li>
<li><a href="#Rper-type">Per.10: Rely on the static type system</a></li>
<li><a href="#Rper-Comp">Per.11: Move computation from run time to compile time</a></li>
<li><a href="#Rper-alias">Per.12: Eliminate redundant aliases</a></li>
<li><a href="#Rper-indirect">Per.13: Eliminate redundant indirections</a></li>
<li><a href="#Rper-alloc">Per.14: Minimize the number of allocations and deallocations</a></li>
<li><a href="#Rper-alloc0">Per.15: Do not allocate on a critical branch</a></li>
<li><a href="#Rper-compact">Per.16: Use compact data structures</a></li>
<li><a href="#Rper-struct">Per.17: Declare the most used member of a time-critical struct first</a></li>
<li><a href="#Rper-space">Per.18: Space is time</a></li>
<li><a href="#Rper-access">Per.19: Access memory predictably</a></li>
<li><a href="#Rper-context">Per.30: Avoid context switches on the critical path</a></li>
</ul>
<h3 id="Per-1-Don’t-optimize-without-reason"><a href="#Per-1-Don’t-optimize-without-reason" class="headerlink" title="Per.1: Don’t optimize without reason"></a><a name="Rper-reason"></a>Per.1: Don’t optimize without reason</h3><h5 id="Reason-257"><a href="#Reason-257" class="headerlink" title="Reason"></a>Reason</h5><p>If there is no need for optimization, the main result of the effort will be more errors and higher maintenance costs.</p>
<h5 id="Note-222"><a href="#Note-222" class="headerlink" title="Note"></a>Note</h5><p>Some people optimize out of habit or because it’s fun.</p>
<p>???</p>
<h3 id="Per-2-Don’t-optimize-prematurely"><a href="#Per-2-Don’t-optimize-prematurely" class="headerlink" title="Per.2: Don’t optimize prematurely"></a><a name="Rper-Knuth"></a>Per.2: Don’t optimize prematurely</h3><h5 id="Reason-258"><a href="#Reason-258" class="headerlink" title="Reason"></a>Reason</h5><p>Elaborately optimized code is usually larger and harder to change than unoptimized code.</p>
<p>???</p>
<h3 id="Per-3-Don’t-optimize-something-that’s-not-performance-critical"><a href="#Per-3-Don’t-optimize-something-that’s-not-performance-critical" class="headerlink" title="Per.3: Don’t optimize something that’s not performance critical"></a><a name="Rper-critical"></a>Per.3: Don’t optimize something that’s not performance critical</h3><h5 id="Reason-259"><a href="#Reason-259" class="headerlink" title="Reason"></a>Reason</h5><p>Optimizing a non-performance-critical part of a program has no effect on system performance.</p>
<h5 id="Note-223"><a href="#Note-223" class="headerlink" title="Note"></a>Note</h5><p>If your program spends most of its time waiting for the web or for a human, optimization of in-memory computation is probably useless.</p>
<p>Put another way: If your program spends 4% of its processing time doing<br>computation A and 40% of its time doing computation B, a 50% improvement on A is<br>only as impactful as a 5% improvement on B. (If you don’t even know how much<br>time is spent on A or B, see <a href="#Rper-reason">Per.1</a> and <a
href="#Rper-Knuth">Per.2</a>.)</p>
<h3 id="Per-4-Don’t-assume-that-complicated-code-is-necessarily-faster-than-simple-code"><a href="#Per-4-Don’t-assume-that-complicated-code-is-necessarily-faster-than-simple-code" class="headerlink" title="Per.4: Don’t assume that complicated code is necessarily faster than simple code"></a><a name="Rper-simple"></a>Per.4: Don’t assume that complicated code is necessarily faster than simple code</h3><h5 id="Reason-260"><a href="#Reason-260" class="headerlink" title="Reason"></a>Reason</h5><p>Simple code can be very fast. Optimizers sometimes do marvels with simple code</p>
<h5 id="Example-good-21"><a href="#Example-good-21" class="headerlink" title="Example, good"></a>Example, good</h5><pre><code>// clear expression of intent, fast execution

vector&lt;uint8_t&gt; v(100000);

for (auto&amp; c : v)
    c = ~c;
</code></pre>
<h5 id="Example-bad-109"><a href="#Example-bad-109" class="headerlink" title="Example, bad"></a>Example, bad</h5><pre><code>// intended to be faster, but is actually slower

vector&lt;uint8_t&gt; v(100000);

for (size_t i = 0; i &lt; v.size(); i += sizeof(uint64_t))
&#123;
    uint64_t&amp; quad_word = *reinterpret_cast&lt;uint64_t*&gt;(&amp;v[i]);
    quad_word = ~quad_word;
&#125;
</code></pre>
<h5 id="Note-224"><a href="#Note-224" class="headerlink" title="Note"></a>Note</h5><p>???</p>
<p>???</p>
<h3 id="Per-5-Don’t-assume-that-low-level-code-is-necessarily-faster-than-high-level-code"><a href="#Per-5-Don’t-assume-that-low-level-code-is-necessarily-faster-than-high-level-code" class="headerlink" title="Per.5: Don’t assume that low-level code is necessarily faster than high-level code"></a><a name="Rper-low"></a>Per.5: Don’t assume that low-level code is necessarily faster than high-level code</h3><h5 id="Reason-261"><a href="#Reason-261" class="headerlink" title="Reason"></a>Reason</h5><p>Low-level code sometimes inhibits optimizations. Optimizers sometimes do marvels with high-level code.</p>
<h5 id="Note-225"><a href="#Note-225" class="headerlink" title="Note"></a>Note</h5><p>???</p>
<p>???</p>
<h3 id="Per-6-Don’t-make-claims-about-performance-without-measurements"><a href="#Per-6-Don’t-make-claims-about-performance-without-measurements" class="headerlink" title="Per.6: Don’t make claims about performance without measurements"></a><a name="Rper-measure"></a>Per.6: Don’t make claims about performance without measurements</h3><h5 id="Reason-262"><a href="#Reason-262" class="headerlink" title="Reason"></a>Reason</h5><p>The field of performance is littered with myth and bogus folklore.<br>Modern hardware and optimizers defy naive assumptions; even experts are regularly surprised.</p>
<h5 id="Note-226"><a href="#Note-226" class="headerlink" title="Note"></a>Note</h5><p>Getting good performance measurements can be hard and require specialized tools.</p>
<h5 id="Note-227"><a href="#Note-227" class="headerlink" title="Note"></a>Note</h5><p>A few simple microbenchmarks using Unix <code>time</code> or the standard-library <code>&lt;chrono&gt;</code> can help dispel the most obvious myths.<br>If you can’t measure your complete system accurately, at least try to measure a few of your key operations and algorithms.<br>A profiler can help tell you which parts of your system are performance critical.<br>Often, you will be surprised.</p>
<p>???</p>
<h3 id="Per-7-Design-to-enable-optimization"><a href="#Per-7-Design-to-enable-optimization" class="headerlink" title="Per.7: Design to enable optimization"></a><a name="Rper-efficiency"></a>Per.7: Design to enable optimization</h3><h5 id="Reason-263"><a href="#Reason-263" class="headerlink" title="Reason"></a>Reason</h5><p>Because we often need to optimize the initial design.<br>Because a design that ignore the possibility of later improvement is hard to change.</p>
<h5 id="Example-235"><a href="#Example-235" class="headerlink" title="Example"></a>Example</h5><p>From the C (and C++) standard:</p>
<pre><code>void qsort (void* base, size_t num, size_t size, int (*compar)(const void*, const void*));
</code></pre>
<p>When did you even want to sort memory?<br>Really, we sort sequences of elements, typically stored in containers.<br>A call to <code>qsort</code> throws away much useful information (e.g., the element type), forces the user to repeat information<br>already known (e.g., the element size), and forces the user to write extra code (e.g., a function to compare <code>double</code>s).<br>This implies added work for the programmer, is error-prone, and deprives the compiler of information needed for optimization.</p>
<pre><code>double data[100];
// ... fill a ...

// 100 chunks of memory of sizeof(double) starting at
// address data using the order defined by compare_doubles
qsort(data, 100, sizeof(double), compare_doubles);
</code></pre>
<p>From the point of view of interface design is that <code>qsort</code> throws away useful information.</p>
<p>We can do better (in C++98)</p>
<pre><code>template&lt;typename Iter&gt;
    void sort(Iter b, Iter e);  // sort [b:e)

sort(data, data + 100);
</code></pre>
<p>Here, we use the compiler’s knowledge about the size of the array, the type of elements, and how to compare <code>double</code>s.</p>
<p>With C++11 plus <a href="#SS-concepts">concepts</a>, we can do better still</p>
<pre><code>// Sortable specifies that c must be a
// random-access sequence of elements comparable with &lt;
void sort(Sortable&amp; c);

sort(c);
</code></pre>
<p>The key is to pass sufficient information for a good implementation to be chosen.<br>In this, the <code>sort</code> interfaces shown here still have a weakness:<br>They implicitly rely on the element type having less-than (<code>&lt;</code>) defined.<br>To complete the interface, we need a second version that accepts a comparison criteria:</p>
<pre><code>// compare elements of c using p
void sort(Sortable&amp; c, Predicate&lt;Value_type&lt;Sortable&gt;&gt; p);
</code></pre>
<p>The standard-library specification of <code>sort</code> offers those two versions,<br>but the semantics is expressed in English rather than code using concepts.</p>
<h5 id="Note-228"><a href="#Note-228" class="headerlink" title="Note"></a>Note</h5><p>Premature optimization is said to be <a href="#Rper-Knuth">the root of all evil</a>, but that’s not a reason to despise performance.<br>It is never premature to consider what makes a design amenable to improvement, and improved performance is a commonly desired improvement.<br>Aim to build a set of habits that by default results in efficient, maintainable, and optimizable code.<br>In particular, when you write a function that is not a one-off implementation detail, consider</p>
<ul>
<li>Information passing:<br>Prefer clean <a href="#S-interfaces">interfaces</a> carrying sufficient information for later improvement of implementation.<br>Note that information flows into and out of an implementation through the interfaces we provide.</li>
<li>Compact data: By default, <a href="#Rper-compact">use compact data</a>, such as <code>std::vector</code> and <a href="#Rper-access">access it in a systematic fashion</a>.<br>If you think you need a linked structure, try to craft the interface so that this structure isn’t seen by users.</li>
<li>Function argument passing and return:<br>Distinguish between mutable and non-mutable data.<br>Don’t impose a resource management burden on your users.<br>Don’t impose spurious run-time indirections on your users.<br>Use <a href="#Rf-conventional">conventional ways</a> of passing information through an interface;<br>unconventional and/or “optimized” ways of passing data can seriously complicate later reimplementation.</li>
<li>Abstraction:<br>Don’t overgeneralize; a design that tries to cater for every possible use (and misuse) and defers every design decision for later<br>(using compile-time or run-time indirections) is usually a complicated, bloated, hard-to-understand mess.<br>Generalize from concrete examples, preserving performance as we generalize.<br>Do not generalize based on mere speculation about future needs.<br>The ideal is zero-overhead generalization.</li>
<li>Libraries:<br>Use libraries with good interfaces.<br>If no library is available build one yourself and imitate the interface style from a good library.<br>The <a href="#S-stdlib">standard library</a> is a good first place to look for inspiration.</li>
<li>Isolation:<br>Isolate your code from messy and/or old-style code by providing an interface of your choosing to it.<br>This is sometimes called “providing a wrapper” for the useful/necessary but messy code.<br>Don’t let bad designs “bleed into” your code.</li>
</ul>
<h5 id="Example-236"><a href="#Example-236" class="headerlink" title="Example"></a>Example</h5><p>Consider:</p>
<pre><code>template &lt;class ForwardIterator, class T&gt;
bool binary_search(ForwardIterator first, ForwardIterator last, const T&amp; val);
</code></pre>
<p><code>binary_search(begin(c), end(c), 7)</code> will tell you whether <code>7</code> is in <code>c</code> or not.<br>However, it will not tell you where that <code>7</code> is or whether there are more than one <code>7</code>.</p>
<p>Sometimes, just passing the minimal amount of information back (here, <code>true</code> or <code>false</code>) is sufficient, but a good interface passes<br>needed information back to the caller. Therefore, the standard library also offers</p>
<pre><code>template &lt;class ForwardIterator, class T&gt;
ForwardIterator lower_bound(ForwardIterator first, ForwardIterator last, const T&amp; val);
</code></pre>
<p><code>lower_bound</code> returns an iterator to the first match if any, otherwise to the first element greater than <code>val</code>, or <code>last</code> if no such element is found.</p>
<p>However, <code>lower_bound</code> still doesn’t return enough information for all uses, so the standard library also offers</p>
<pre><code>template &lt;class ForwardIterator, class T&gt;
pair&lt;ForwardIterator, ForwardIterator&gt;
equal_range(ForwardIterator first, ForwardIterator last, const T&amp; val);
</code></pre>
<p><code>equal_range</code> returns a <code>pair</code> of iterators specifying the first and one beyond last match.</p>
<pre><code>auto r = equal_range(begin(c), end(c), 7);
for (auto p = r.first(); p != r.second(), ++p)
    cout &lt;&lt; *p &lt;&lt; &#39;\n&#39;;
</code></pre>
<p>Obviously, these three interfaces are implemented by the same basic code.<br>They are simply three ways of presenting the basic binary search algorithm to users,<br>ranging from the simplest (“make simple things simple!”)<br>to returning complete, but not always needed, information (“don’t hide useful information”).<br>Naturally, crafting such a set of interfaces requires experience and domain knowledge.</p>
<h5 id="Note-229"><a href="#Note-229" class="headerlink" title="Note"></a>Note</h5><p>Do not simply craft the interface to match the first implementation and the first use case you think of.<br>Once your first initial implementation is complete, review it; once you deploy it, mistakes will be hard to remedy.</p>
<h5 id="Note-230"><a href="#Note-230" class="headerlink" title="Note"></a>Note</h5><p>A need for efficiency does not imply a need for <a href="#Rper-low">low-level code</a>.<br>High-level code does not imply slow or bloated.</p>
<h5 id="Note-231"><a href="#Note-231" class="headerlink" title="Note"></a>Note</h5><p>Things have costs.<br>Don’t be paranoid about costs (modern computers really are very fast),<br>but have a rough idea of the order of magnitude of cost of what you use.<br>For example, have a rough idea of the cost of<br>a memory access,<br>a function call,<br>a string comparison,<br>a system call,<br>a disk access,<br>and a message through a network.</p>
<h5 id="Note-232"><a href="#Note-232" class="headerlink" title="Note"></a>Note</h5><p>If you can only think of one implementation, you probably don’t have something for which you can devise a stable interface.<br>Maybe, it is just an implementation detail - not every piece of code needs a stable interface - but pause and consider.<br>One question that can be useful is<br>“what interface would be needed if this operation should be implemented using multiple threads? be vectorized?”</p>
<h5 id="Note-233"><a href="#Note-233" class="headerlink" title="Note"></a>Note</h5><p>This rule does not contradict the <a href="#Rper-Knuth">Don’t optimize prematurely</a> rule.<br>It complements it encouraging developers enable later - appropriate and non-premature - optimization, if and where needed.</p>
<h5 id="Enforcement-248"><a href="#Enforcement-248" class="headerlink" title="Enforcement"></a>Enforcement</h5><p>Tricky.<br>Maybe looking for <code>void*</code> function arguments will find examples of interfaces that hinder later optimization.</p>
<h3 id="Per-10-Rely-on-the-static-type-system"><a href="#Per-10-Rely-on-the-static-type-system" class="headerlink" title="Per.10: Rely on the static type system"></a><a name="Rper-type"></a>Per.10: Rely on the static type system</h3><h5 id="Reason-264"><a href="#Reason-264" class="headerlink" title="Reason"></a>Reason</h5><p>Type violations, weak types (e.g. <code>void*</code>s), and low-level code (e.g., manipulation of sequences as individual bytes) make the job of the optimizer much harder. Simple code often optimizes better than hand-crafted complex code.</p>
<p>???</p>
<h3 id="Per-11-Move-computation-from-run-time-to-compile-time"><a href="#Per-11-Move-computation-from-run-time-to-compile-time" class="headerlink" title="Per.11: Move computation from run time to compile time"></a><a name="Rper-Comp"></a>Per.11: Move computation from run time to compile time</h3><h5 id="Reason-265"><a href="#Reason-265" class="headerlink" title="Reason"></a>Reason</h5><p>To decrease code size and run time.<br>To avoid data races by using constants.<br>To catch errors at compile time (and thus eliminate the need for error-handling code).</p>
<h5 id="Example-237"><a href="#Example-237" class="headerlink" title="Example"></a>Example</h5><pre><code>double square(double d) &#123; return d*d; &#125;
static double s2 = square(2);    // old-style: dynamic initialization

constexpr double ntimes(double d, int n)   // assume 0 &lt;= n
&#123;
        double m = 1;
        while (n--) m *= d;
        return m;
&#125;
constexpr double s3 &#123;ntimes(2, 3)&#125;;  // modern-style: compile-time initialization
</code></pre>
<p>Code like the initialization of <code>s2</code> isn’t uncommon, especially for initialization that’s a bit more complicated than <code>square()</code>.<br>However, compared to the initialization of <code>s3</code> there are two problems:</p>
<ul>
<li>we suffer the overhead of a function call at run time</li>
<li><code>s2</code> just might be accessed by another thread before the initialization happens.</li>
</ul>
<p>Note: you can’t have a data race on a constant.</p>
<h5 id="Example-238"><a href="#Example-238" class="headerlink" title="Example"></a>Example</h5><p>Consider a popular technique for providing a handle for storing small objects in the handle itself and larger ones on the heap.</p>
<pre><code>constexpr int on_stack_max = 20;

template&lt;typename T&gt;
struct Scoped &#123;     // store a T in Scoped
        // ...
    T obj;
&#125;;

template&lt;typename T&gt;
struct On_heap &#123;    // store a T on the free store
        // ...
        T* objp;
&#125;;

template&lt;typename T&gt;
using Handle = typename std::conditional&lt;(sizeof(T) &lt;= on_stack_max),
                    Scoped&lt;T&gt;,      // first alternative
                    On_heap&lt;T&gt;      // second alternative
               &gt;::type;

void f()
&#123;
    Handle&lt;double&gt; v1;                   // the double goes on the stack
    Handle&lt;std::array&lt;double, 200&gt;&gt; v2;  // the array goes on the free store
    // ...
&#125;
</code></pre>
<p>Assume that <code>Scoped</code> and <code>On_heap</code> provide compatible user interfaces.<br>Here we compute the optimal type to use at compile time.<br>There are similar techniques for selecting the optimal function to call.</p>
<h5 id="Note-234"><a href="#Note-234" class="headerlink" title="Note"></a>Note</h5><p>The ideal is {not} to try execute everything at compile time.<br>Obviously, most computations depend on inputs so they can’t be moved to compile time,<br>but beyond that logical constraint is the fact that complex compile-time computation can seriously increase compile times<br>and complicate debugging.<br>It is even possible to slow down code by compile-time computation.<br>This is admittedly rare, but by factoring out a general computation into separate optimal sub-calculations it is possible to render the instruction cache less effective.</p>
<h5 id="Enforcement-249"><a href="#Enforcement-249" class="headerlink" title="Enforcement"></a>Enforcement</h5><ul>
<li>Look for simple functions that might be constexpr (but are not).</li>
<li>Look for functions called with all constant-expression arguments.</li>
<li>Look for macros that could be constexpr.</li>
</ul>
<h3 id="Per-12-Eliminate-redundant-aliases"><a href="#Per-12-Eliminate-redundant-aliases" class="headerlink" title="Per.12: Eliminate redundant aliases"></a><a name="Rper-alias"></a>Per.12: Eliminate redundant aliases</h3><p>???</p>
<h3 id="Per-13-Eliminate-redundant-indirections"><a href="#Per-13-Eliminate-redundant-indirections" class="headerlink" title="Per.13: Eliminate redundant indirections"></a><a name="Rper-indirect"></a>Per.13: Eliminate redundant indirections</h3><p>???</p>
<h3 id="Per-14-Minimize-the-number-of-allocations-and-deallocations"><a href="#Per-14-Minimize-the-number-of-allocations-and-deallocations" class="headerlink" title="Per.14: Minimize the number of allocations and deallocations"></a><a name="Rper-alloc"></a>Per.14: Minimize the number of allocations and deallocations</h3><p>???</p>
<h3 id="Per-15-Do-not-allocate-on-a-critical-branch"><a href="#Per-15-Do-not-allocate-on-a-critical-branch" class="headerlink" title="Per.15: Do not allocate on a critical branch"></a><a name="Rper-alloc0"></a>Per.15: Do not allocate on a critical branch</h3><p>???</p>
<h3 id="Per-16-Use-compact-data-structures"><a href="#Per-16-Use-compact-data-structures" class="headerlink" title="Per.16: Use compact data structures"></a><a name="Rper-compact"></a>Per.16: Use compact data structures</h3><h5 id="Reason-266"><a href="#Reason-266" class="headerlink" title="Reason"></a>Reason</h5><p>Performance is typically dominated by memory access times.</p>
<p>???</p>
<h3 id="Per-17-Declare-the-most-used-member-of-a-time-critical-struct-first"><a href="#Per-17-Declare-the-most-used-member-of-a-time-critical-struct-first" class="headerlink" title="Per.17: Declare the most used member of a time-critical struct first"></a><a name="Rper-struct"></a>Per.17: Declare the most used member of a time-critical struct first</h3><p>???</p>
<h3 id="Per-18-Space-is-time"><a href="#Per-18-Space-is-time" class="headerlink" title="Per.18: Space is time"></a><a name="Rper-space"></a>Per.18: Space is time</h3><h5 id="Reason-267"><a href="#Reason-267" class="headerlink" title="Reason"></a>Reason</h5><p>Performance is typically dominated by memory access times.</p>
<p>???</p>
<h3 id="Per-19-Access-memory-predictably"><a href="#Per-19-Access-memory-predictably" class="headerlink" title="Per.19: Access memory predictably"></a><a name="Rper-access"></a>Per.19: Access memory predictably</h3><h5 id="Reason-268"><a href="#Reason-268" class="headerlink" title="Reason"></a>Reason</h5><p>Performance is very sensitive to cache performance and cache algorithms favor simple (usually linear) access to adjacent data.</p>
<h5 id="Example-239"><a href="#Example-239" class="headerlink" title="Example"></a>Example</h5><pre><code>int matrix[rows][cols];

// bad
for (int c = 0; c &lt; cols; ++c)
    for (int r = 0; r &lt; rows; ++r)
        sum += matrix[r][c];

// good
for (int r = 0; r &lt; rows; ++r)
    for (int c = 0; c &lt; cols; ++c)
        sum += matrix[r][c];
</code></pre>
<h3 id="Per-30-Avoid-context-switches-on-the-critical-path"><a href="#Per-30-Avoid-context-switches-on-the-critical-path" class="headerlink" title="Per.30: Avoid context switches on the critical path"></a><a name="Rper-context"></a>Per.30: Avoid context switches on the critical path</h3><p>???</p>
<h1 id="CP-Concurrency-and-parallelism"><a href="#CP-Concurrency-and-parallelism" class="headerlink" title="CP: Concurrency and parallelism"></a><a name="S-concurrency"></a>CP: Concurrency and parallelism</h1><p>We often want our computers to do many tasks at the same time (or at least make them appear to do them at the same time).<br>The reasons for doing so varies (e.g., wanting to wait for many events using only a single processor, processing many data streams simultaneously, or utilizing many hardware facilities)<br>and so does the basic facilities for expressing concurrency and parallelism.<br>Here, we articulate a few general principles and rules for using the ISO standard C++ facilities for expressing basic concurrency and parallelism.</p>
<p>The core machine support for concurrent and parallel programming is the thread.<br>Threads allow you to run multiple instances of your program independently, while sharing<br>the same memory. Concurrent programming is tricky for many reasons, most<br>importantly that it is undefined behavior to read data in one thread after it<br>was written by another thread, if there is no proper synchronization between<br>those threads. Making existing single-threaded code execute concurrently can be<br>as trivial as adding <code>std::async</code> or <code>std::thread</code> strategically, or it can<br>necessitate a full rewrite, depending on whether the original code was written<br>in a thread-friendly way.</p>
<p>The concurrency/parallelism rules in this document are designed with three goals<br>in mind:</p>
<ul>
<li>To help you write code that is amenable to being used in a threaded<br>environment</li>
<li>To show clean, safe ways to use the threading primitives offered by the<br>standard library</li>
<li>To offer guidance on what to do when concurrency and parallelism aren’t giving<br>you the performance gains you need</li>
</ul>
<p>It is also important to note that concurrency in C++ is an unfinished<br>story. C++11 introduced many core concurrency primitives, C++14 improved on<br>them, and it seems that there is much interest in making the writing of<br>concurrent programs in C++ even easier. We expect some of the library-related<br>guidance here to change significantly over time.</p>
<p>This section needs a lot of work (obviously).<br>Please note that we start with rules for relative non-experts.<br>Real experts must wait a bit;<br>contributions are welcome,<br>but please think about the majority of programmers who are struggling to get their concurrent programs correct and performant.</p>
<p>Concurrency and parallelism rule summary:</p>
<ul>
<li><a href="#Rconc-multi">CP.1: Assume that your code will run as part of a multi-threaded program</a></li>
<li><a href="#Rconc-races">CP.2: Avoid data races</a></li>
<li><a href="#Rconc-data">CP.3: Minimize explicit sharing of writable data</a></li>
<li><a href="#Rconc-task">CP.4: Think in terms of tasks, rather than threads</a></li>
<li><a href="#Rconc-volatile">CP.8: Don’t try to use <code>volatile</code> for synchronization</a></li>
<li><a href="#Rconc-tools">CP.9: Whenever feasible use tools to validate your concurrent code</a></li>
</ul>
<p><strong>See also</strong>:</p>
<ul>
<li><a href="#SScp-con">CP.con: Concurrency</a></li>
<li><a href="#SScp-par">CP.par: Parallelism</a></li>
<li><a href="#SScp-mess">CP.mess: Message passing</a></li>
<li><a href="#SScp-vec">CP.vec: Vectorization</a></li>
<li><a href="#SScp-free">CP.free: Lock-free programming</a></li>
<li><a href="#SScp-etc">CP.etc: Etc. concurrency rules</a></li>
</ul>
<h3 id="CP-1-Assume-that-your-code-will-run-as-part-of-a-multi-threaded-program"><a href="#CP-1-Assume-that-your-code-will-run-as-part-of-a-multi-threaded-program" class="headerlink" title="CP.1: Assume that your code will run as part of a multi-threaded program"></a><a name="Rconc-multi"></a>CP.1: Assume that your code will run as part of a multi-threaded program</h3><h5 id="Reason-269"><a href="#Reason-269" class="headerlink" title="Reason"></a>Reason</h5><p>It is hard to be certain that concurrency isn’t used now or will be sometime in the future.<br>Code gets reused.<br>Libraries using threads may be used from some other part of the program.<br>Note that this applies most urgently to library code and least urgently to stand-alone applications.<br>However, thanks to the magic of cut-and-paste, code fragments can turn up in unexpected places.</p>
<h5 id="Example-240"><a href="#Example-240" class="headerlink" title="Example"></a>Example</h5><pre><code>double cached_computation(double x)
&#123;
    static double cached_x = 0.0;
    static double cached_result = COMPUTATION_OF_ZERO;
    double result;

    if (cached_x == x)
        return cached_result;
    result = computation(x);
    cached_x = x;
    cached_result = result;
    return result;
&#125;
</code></pre>
<p>Although <code>cached_computation</code> works perfectly in a single-threaded environment, in a multi-threaded environment the two <code>static</code> variables result in data races and thus undefined behavior.</p>
<p>There are several ways that this example could be made safe for a multi-threaded environment:</p>
<ul>
<li>Delegate concurrency concerns upwards to the caller.</li>
<li>Mark the <code>static</code> variables as <code>thread_local</code> (which might make caching less effective).</li>
<li>Implement concurrency control, for example, protecting the two <code>static</code> variables with a <code>static</code> lock (which might reduce performance).</li>
<li>Have the caller provide the memory to be used for the cache, thereby delegating both memory allocation and concurrency concerns upwards to the caller.</li>
<li>Refuse to build and/or run in a multi-threaded environment.</li>
<li>Provide two implementations, one which is used in single-threaded environments and another which is used in multi-threaded environments.</li>
</ul>
<h5 id="Exception-46"><a href="#Exception-46" class="headerlink" title="Exception"></a>Exception</h5><p>Code that is never run in a multi-threaded environment.</p>
<p>Be careful: there are many examples where code that was “known” to never run in a multi-threaded program<br>was run as part of a multi-threaded program. Often years later.<br>Typically, such programs lead to a painful effort to remove data races.<br>Therefore, code that is never intended to run in a multi-threaded environment should be clearly labeled as such and ideally come with compile or run-time enforcement mechanisms to catch those usage bugs early.</p>
<h3 id="CP-2-Avoid-data-races"><a href="#CP-2-Avoid-data-races" class="headerlink" title="CP.2: Avoid data races"></a><a name="Rconc-races"></a>CP.2: Avoid data races</h3><h5 id="Reason-270"><a href="#Reason-270" class="headerlink" title="Reason"></a>Reason</h5><p>Unless you do, nothing is guaranteed to work and subtle errors will persist.</p>
<h5 id="Note-235"><a href="#Note-235" class="headerlink" title="Note"></a>Note</h5><p>In a nutshell, if two threads can access the same object concurrently (without synchronization), and at least one is a writer (performing a non-<code>const</code> operation), you have a data race.<br>For further information of how to use synchronization well to eliminate data races, please consult a good book about concurrency.</p>
<h5 id="Example-bad-110"><a href="#Example-bad-110" class="headerlink" title="Example, bad"></a>Example, bad</h5><p>There are many examples of data races that exist, some of which are running in<br>production software at this very moment. One very simple example:</p>
<pre><code>int get_id() &#123;
  static int id = 1;
  return id++;
&#125;
</code></pre>
<p>The increment here is an example of a data race. This can go wrong in many ways,<br>including:</p>
<ul>
<li>Thread A loads the value of <code>id</code>, the OS context switches A out for some<br>period, during which other threads create hundreds of IDs. Thread A is then<br>allowed to run again, and <code>id</code> is written back to that location as A’s read of<br><code>id</code> plus one.</li>
<li>Thread A and B load <code>id</code> and increment it simultaneously.  They both get the<br>same ID.</li>
</ul>
<p>Local static variables are a common source of data races.</p>
<h5 id="Example-bad-111"><a href="#Example-bad-111" class="headerlink" title="Example, bad:"></a>Example, bad:</h5><pre><code>void f(fstream&amp;  fs, regex pat)
&#123;
    array&lt;double, max&gt; buf;
    int sz = read_vec(fs, buf, max);            // read from fs into buf
    gsl::span&lt;double&gt; s &#123;buf&#125;;
    // ...
    auto h1 = async([&amp;]&#123; sort(par, s); &#125;);     // spawn a task to sort
    // ...
    auto h2 = async([&amp;]&#123; return find_all(buf, sz, pat); &#125;);   // spawn a task to find matches
    // ...
&#125;
</code></pre>
<p>Here, we have a (nasty) data race on the elements of <code>buf</code> (<code>sort</code> will both read and write).<br>All data races are nasty.<br>Here, we managed to get a data race on data on the stack.<br>Not all data races are as easy to spot as this one.</p>
<h5 id="Example-bad-112"><a href="#Example-bad-112" class="headerlink" title="Example, bad:"></a>Example, bad:</h5><pre><code>// code not controlled by a lock

unsigned val;

if (val &lt; 5) &#123;
    // ... other thread can change val here ...
    switch (val) &#123;
    case 0: // ...
    case 1: // ...
    case 2: // ...
    case 3: // ...
    case 4: // ...
    &#125;
&#125;
</code></pre>
<p>Now, a compiler that does not know that <code>val</code> can change will  most likely implement that <code>switch</code> using a jump table with five entries.<br>Then, a <code>val</code> outside the <code>[0..4]</code> range will cause a jump to an address that could be anywhere in the program, and execution would proceed there.<br>Really, “all bets are off” if you get a data race.<br>Actually, it can be worse still: by looking at the generated code you may be able to determine where the stray jump will go for a given value;<br>this can be a security risk.</p>
<h5 id="Enforcement-250"><a href="#Enforcement-250" class="headerlink" title="Enforcement"></a>Enforcement</h5><p>Some is possible, do at least something.<br>There are commercial and open-source tools that try to address this problem,<br>but be aware that solutions have costs and blind spots.<br>Static tools often have many false positives and run-time tools often have a significant cost.<br>We hope for better tools.<br>Using multiple tools can catch more problems than a single one.</p>
<p>There are other ways you can mitigate the chance of data races:</p>
<ul>
<li>Avoid global data</li>
<li>Avoid <code>static</code> variables</li>
<li>More use of value types on the stack (and don’t pass pointers around too much)</li>
<li>More use of immutable data (literals, <code>constexpr</code>, and <code>const</code>)</li>
</ul>
<h3 id="CP-3-Minimize-explicit-sharing-of-writable-data"><a href="#CP-3-Minimize-explicit-sharing-of-writable-data" class="headerlink" title="CP.3: Minimize explicit sharing of writable data"></a><a name="Rconc-data"></a>CP.3: Minimize explicit sharing of writable data</h3><h5 id="Reason-271"><a href="#Reason-271" class="headerlink" title="Reason"></a>Reason</h5><p>If you don’t share writable data, you can’t have a data race.<br>The less sharing you do, the less chance you have to forget to synchronize access (and get data races).<br>The less sharing you do, the less chance you have to wait on a lock (so performance can improve).</p>
<h5 id="Example-241"><a href="#Example-241" class="headerlink" title="Example"></a>Example</h5><pre><code>bool validate(const vector&lt;Reading&gt;&amp;);
Graph&lt;Temp_node&gt; temperature_gradiants(const vector&lt;Reading&gt;&amp;);
Image altitude_map(const vector&lt;Reading&gt;&amp;);
// ...

void process_readings(const vector&lt;Reading&gt;&amp; surface_readings)
&#123;
    auto h1 = async([&amp;] &#123; if (!validate(surface_readings)) throw Invalid_data&#123;&#125;; &#125;);
    auto h2 = async([&amp;] &#123; return temperature_gradiants(surface_readings); &#125;);
    auto h3 = async([&amp;] &#123; return altitude_map(surface_readings); &#125;);
    // ...
    h1.get();
    auto v2 = h2.get();
    auto v3 = h3.get();
    // ...
&#125;
</code></pre>
<p>Without those <code>const</code>s, we would have to review every asynchronously invoked function for potential data races on <code>surface_readings</code>.<br>Making <code>surface_readings</code> be <code>const</code> (with respect to this function) allow reasoning using only the function body.</p>
<h5 id="Note-236"><a href="#Note-236" class="headerlink" title="Note"></a>Note</h5><p>Immutable data can be safely and efficiently shared.<br>No locking is needed: You can’t have a data race on a constant.<br>See also <a href="#SScp-mess">CP.mess: Message Passing</a> and <a href="#Rconc-data-by-value">CP.31: prefer pass by value</a>.</p>
<h5 id="Enforcement-251"><a href="#Enforcement-251" class="headerlink" title="Enforcement"></a>Enforcement</h5><p>???</p>
<h3 id="CP-4-Think-in-terms-of-tasks-rather-than-threads"><a href="#CP-4-Think-in-terms-of-tasks-rather-than-threads" class="headerlink" title="CP.4: Think in terms of tasks, rather than threads"></a><a name="Rconc-task"></a>CP.4: Think in terms of tasks, rather than threads</h3><h5 id="Reason-272"><a href="#Reason-272" class="headerlink" title="Reason"></a>Reason</h5><p>A <code>thread</code> is an implementation concept, a way of thinking about the machine.<br>A task is an application notion, something you’d like to do, preferably concurrently with other tasks.<br>Application concepts are easier to reason about.</p>
<h5 id="Example-242"><a href="#Example-242" class="headerlink" title="Example"></a>Example</h5><pre><code>void some_fun() &#123;
    std::string  msg, msg2;
    std::thread publisher([&amp;] &#123; msg = &quot;Hello&quot;; &#125;);       // bad: less expressive
                                                         //      and more error-prone
    auto pubtask = std::async([&amp;] &#123; msg2 = &quot;Hello&quot;; &#125;);  // OK
    // ...
    publisher.join();
&#125;
</code></pre>
<h5 id="Note-237"><a href="#Note-237" class="headerlink" title="Note"></a>Note</h5><p>With the exception of <code>async()</code>, the standard-library facilities are low-level, machine-oriented, threads-and-lock level.<br>This is a necessary foundation, but we have to try to raise the level of abstraction: for productivity, for reliability, and for performance.<br>This is a potent argument for using higher level, more applications-oriented libraries (if possibly, built on top of standard-library facilities).</p>
<h5 id="Enforcement-252"><a href="#Enforcement-252" class="headerlink" title="Enforcement"></a>Enforcement</h5><p>???</p>
<h3 id="CP-8-Don’t-try-to-use-volatile-for-synchronization"><a href="#CP-8-Don’t-try-to-use-volatile-for-synchronization" class="headerlink" title="CP.8: Don’t try to use volatile for synchronization"></a><a name="Rconc-volatile"></a>CP.8: Don’t try to use <code>volatile</code> for synchronization</h3><h5 id="Reason-273"><a href="#Reason-273" class="headerlink" title="Reason"></a>Reason</h5><p>In C++, unlike some other languages, <code>volatile</code> does not provide atomicity, does not synchronize between threads,<br>and does not prevent instruction reordering (neither compiler nor hardware).<br>It simply has nothing to do with concurrency.</p>
<h5 id="Example-bad-113"><a href="#Example-bad-113" class="headerlink" title="Example, bad:"></a>Example, bad:</h5><pre><code>int free_slots = max_slots; // current source of memory for objects

Pool* use()
&#123;
    if (int n = free_slots--) return &amp;pool[n];
&#125;
</code></pre>
<p>Here we have a problem:<br>This is perfectly good code in a single-threaded program, but have two threads execute this and<br>there is a race condition on <code>free_slots</code> so that two threads might get the same value and <code>free_slots</code>.<br>That’s (obviously) a bad data race, so people trained in other languages may try to fix it like this:</p>
<pre><code>volatile int free_slots = max_slots; // current source of memory for objects

Pool* use()
&#123;
    if (int n = free_slots--) return &amp;pool[n];
&#125;
</code></pre>
<p>This has no effect on synchronization: The data race is still there!</p>
<p>The C++ mechanism for this is <code>atomic</code> types:</p>
<pre><code>atomic&lt;int&gt; free_slots = max_slots; // current source of memory for objects

Pool* use()
&#123;
    if (int n = free_slots--) return &amp;pool[n];
&#125;
</code></pre>
<p>Now the <code>--</code> operation is atomic,<br>rather than a read-increment-write sequence where another thread might get in-between the individual operations.</p>
<h5 id="Alternative-9"><a href="#Alternative-9" class="headerlink" title="Alternative"></a>Alternative</h5><p>Use <code>atomic</code> types where you might have used <code>volatile</code> in some other language.<br>Use a <code>mutex</code> for more complicated examples.</p>
<h5 id="See-also-2"><a href="#See-also-2" class="headerlink" title="See also"></a>See also</h5><p><a href="#Rconc-volatile2">(rare) proper uses of <code>volatile</code></a></p>
<h3 id="CP-9-Whenever-feasible-use-tools-to-validate-your-concurrent-code"><a href="#CP-9-Whenever-feasible-use-tools-to-validate-your-concurrent-code" class="headerlink" title="CP.9: Whenever feasible use tools to validate your concurrent code"></a><a name="Rconc-tools"></a>CP.9: Whenever feasible use tools to validate your concurrent code</h3><p>Experience shows that concurrent code is exceptionally hard to get right<br>and that compile-time checking, run-time checks, and testing are less effective at finding concurrency errors<br>than they are at finding errors in sequential code.<br>Subtle concurrency errors can have dramatically bad effects, including memory corruption and deadlocks.</p>
<h5 id="Example-243"><a href="#Example-243" class="headerlink" title="Example"></a>Example</h5><pre><code>???
</code></pre>
<h5 id="Note-238"><a href="#Note-238" class="headerlink" title="Note"></a>Note</h5><p>Thread safety is challenging, often getting the better of experienced programmers: tooling is an important strategy to mitigate those risks.<br>There are many tools “out there”, both commercial and open-source tools, both research and production tools.<br>Unfortunately people’s needs and constraints differ so dramatically that we cannot make specific recommendations,<br>but we can mention:</p>
<ul>
<li><p>Static enforcement tools: both <a href="http://clang.llvm.org/docs/ThreadSafetyAnalysis.html">clang</a><br>and some older versions of <a href="https://gcc.gnu.org/wiki/ThreadSafetyAnnotation">GCC</a><br>have some support for static annotation of thread safety properties.<br>Consistent use of this technique turns many classes of thread-safety errors into compile-time errors.<br>The annotations are generally local (marking a particular member variable as guarded by a particular mutex),<br>and are usually easy to learn. However, as with many static tools, it can often present false negatives;<br>cases that should have been caught but were allowed.</p>
</li>
<li><p>dynamic enforcement tools: Clang’s <a href="http://clang.llvm.org/docs/ThreadSanitizer.html">Thread Sanitizer</a> (aka TSAN)<br>is a powerful example of dynamic tools: it changes the build and execution of your program to add bookkeeping on memory access,<br>absolutely identifying data races in a given execution of your binary.<br>The cost for this is both memory (5-10x in most cases) and CPU slowdown (2-20x).<br>Dynamic tools like this are best when applied to integration tests, canary pushes, or unittests that operate on multiple threads.<br>Workload matters: When TSAN identifies a problem, it is effectively always an actual data race,<br>but it can only identify races seen in a given execution.</p>
</li>
</ul>
<h5 id="Enforcement-253"><a href="#Enforcement-253" class="headerlink" title="Enforcement"></a>Enforcement</h5><p>It is up to an application builder to choose which support tools are valuable for a particular applications.</p>
<h2 id="CP-con-Concurrency"><a href="#CP-con-Concurrency" class="headerlink" title="CP.con: Concurrency"></a><a name="SScp-con"></a>CP.con: Concurrency</h2><p>This section focuses on relatively ad-hoc uses of multiple threads communicating through shared data.</p>
<ul>
<li>For parallel algorithms, see <a href="#SScp-par">parallelism</a></li>
<li>For inter-task communication without explicit sharing, see <a href="#SScp-mess">messaging</a></li>
<li>For vector parallel code, see <a href="#SScp-vec">vectorization</a></li>
<li>For lock-free programming, see <a href="#SScp-free">lock free</a></li>
</ul>
<p>Concurrency rule summary:</p>
<ul>
<li><a href="#Rconc-raii">CP.20: Use RAII, never plain <code>lock()</code>/<code>unlock()</code></a></li>
<li><a href="#Rconc-lock">CP.21: Use <code>std::lock()</code> or <code>std::scoped_lock</code> to acquire multiple <code>mutex</code>es</a></li>
<li><a href="#Rconc-unknown">CP.22: Never call unknown code while holding a lock (e.g., a callback)</a></li>
<li><a href="#Rconc-join">CP.23: Think of a joining <code>thread</code> as a scoped container</a></li>
<li><a href="#Rconc-detach">CP.24: Think of a <code>thread</code> as a global container</a></li>
<li><a href="#Rconc-joining_thread">CP.25: Prefer <code>gsl::joining_thread</code> over <code>std::thread</code></a></li>
<li><a href="#Rconc-detached_thread">CP.26: Don’t <code>detach()</code> a thread</a></li>
<li><a href="#Rconc-data-by-value">CP.31: Pass small amounts of data between threads by value, rather than by reference or pointer</a></li>
<li><a href="#Rconc-shared">CP.32: To share ownership between unrelated <code>thread</code>s use <code>shared_ptr</code></a></li>
<li><a href="#Rconc-switch">CP.40: Minimize context switching</a></li>
<li><a href="#Rconc-create">CP.41: Minimize thread creation and destruction</a></li>
<li><a href="#Rconc-wait">CP.42: Don’t <code>wait</code> without a condition</a></li>
<li><a href="#Rconc-time">CP.43: Minimize time spent in a critical section</a></li>
<li><a href="#Rconc-name">CP.44: Remember to name your <code>lock_guard</code>s and <code>unique_lock</code>s</a></li>
<li><a href="#Rconc-mutex">CP.50: Define a <code>mutex</code> together with the data it guards. Use <code>synchronized_value&lt;T&gt;</code> where possible</a></li>
<li>??? when to use a spinlock</li>
<li>??? when to use <code>try_lock()</code></li>
<li>??? when to prefer <code>lock_guard</code> over <code>unique_lock</code></li>
<li>??? Time multiplexing</li>
<li>??? when/how to use <code>new thread</code></li>
</ul>
<h3 id="CP-20-Use-RAII-never-plain-lock-unlock"><a href="#CP-20-Use-RAII-never-plain-lock-unlock" class="headerlink" title="CP.20: Use RAII, never plain lock()/unlock()"></a><a name="Rconc-raii"></a>CP.20: Use RAII, never plain <code>lock()</code>/<code>unlock()</code></h3><h5 id="Reason-274"><a href="#Reason-274" class="headerlink" title="Reason"></a>Reason</h5><p>Avoids nasty errors from unreleased locks.</p>
<h5 id="Example-bad-114"><a href="#Example-bad-114" class="headerlink" title="Example, bad"></a>Example, bad</h5><pre><code>mutex mtx;

void do_stuff()
&#123;
    mtx.lock();
    // ... do stuff ...
    mtx.unlock();
&#125;
</code></pre>
<p>Sooner or later, someone will forget the <code>mtx.unlock()</code>, place a <code>return</code> in the <code>... do stuff ...</code>, throw an exception, or something.</p>
<pre><code>mutex mtx;

void do_stuff()
&#123;
    unique_lock&lt;mutex&gt; lck &#123;mtx&#125;;
    // ... do stuff ...
&#125;
</code></pre>
<h5 id="Enforcement-254"><a href="#Enforcement-254" class="headerlink" title="Enforcement"></a>Enforcement</h5><p>Flag calls of member <code>lock()</code> and <code>unlock()</code>.  ???</p>
<h3 id="CP-21-Use-std-lock-or-std-scoped-lock-to-acquire-multiple-mutexes"><a href="#CP-21-Use-std-lock-or-std-scoped-lock-to-acquire-multiple-mutexes" class="headerlink" title="CP.21: Use std::lock() or std::scoped_lock to acquire multiple mutexes"></a><a name="Rconc-lock"></a>CP.21: Use <code>std::lock()</code> or <code>std::scoped_lock</code> to acquire multiple <code>mutex</code>es</h3><h5 id="Reason-275"><a href="#Reason-275" class="headerlink" title="Reason"></a>Reason</h5><p>To avoid deadlocks on multiple <code>mutex</code>es.</p>
<h5 id="Example-244"><a href="#Example-244" class="headerlink" title="Example"></a>Example</h5><p>This is asking for deadlock:</p>
<pre><code>// thread 1
lock_guard&lt;mutex&gt; lck1(m1);
lock_guard&lt;mutex&gt; lck2(m2);

// thread 2
lock_guard&lt;mutex&gt; lck2(m2);
lock_guard&lt;mutex&gt; lck1(m1);
</code></pre>
<p>Instead, use <code>lock()</code>:</p>
<pre><code>// thread 1
lock(m1, m2);
lock_guard&lt;mutex&gt; lck1(m1, adopt_lock);
lock_guard&lt;mutex&gt; lck2(m2, adopt_lock);

// thread 2
lock(m2, m1);
lock_guard&lt;mutex&gt; lck2(m2, adopt_lock);
lock_guard&lt;mutex&gt; lck1(m1, adopt_lock);
</code></pre>
<p>or (better, but C++17 only):</p>
<pre><code>// thread 1
scoped_lock&lt;mutex, mutex&gt; lck1(m1, m2);

// thread 2
scoped_lock&lt;mutex, mutex&gt; lck2(m2, m1);
</code></pre>
<p>Here, the writers of <code>thread1</code> and <code>thread2</code> are still not agreeing on the order of the <code>mutex</code>es, but order no longer matters.</p>
<h5 id="Note-239"><a href="#Note-239" class="headerlink" title="Note"></a>Note</h5><p>In real code, <code>mutex</code>es are rarely named to conveniently remind the programmer of an intended relation and intended order of acquisition.<br>In real code, <code>mutex</code>es are not always conveniently acquired on consecutive lines.</p>
<p>In C++17 it’s possible to write plain</p>
<pre><code>lock_guard lck1(m1, adopt_lock);
</code></pre>
<p>and have the <code>mutex</code> type deduced.</p>
<h5 id="Enforcement-255"><a href="#Enforcement-255" class="headerlink" title="Enforcement"></a>Enforcement</h5><p>Detect the acquisition of multiple <code>mutex</code>es.<br>This is undecidable in general, but catching common simple examples (like the one above) is easy.</p>
<h3 id="CP-22-Never-call-unknown-code-while-holding-a-lock-e-g-a-callback"><a href="#CP-22-Never-call-unknown-code-while-holding-a-lock-e-g-a-callback" class="headerlink" title="CP.22: Never call unknown code while holding a lock (e.g., a callback)"></a><a name="Rconc-unknown"></a>CP.22: Never call unknown code while holding a lock (e.g., a callback)</h3><h5 id="Reason-276"><a href="#Reason-276" class="headerlink" title="Reason"></a>Reason</h5><p>If you don’t know what a piece of code does, you are risking deadlock.</p>
<h5 id="Example-245"><a href="#Example-245" class="headerlink" title="Example"></a>Example</h5><pre><code>void do_this(Foo* p)
&#123;
    lock_guard&lt;mutex&gt; lck &#123;my_mutex&#125;;
    // ... do something ...
    p-&gt;act(my_data);
    // ...
&#125;
</code></pre>
<p>If you don’t know what <code>Foo::act</code> does (maybe it is a virtual function invoking a derived class member of a class not yet written),<br>it may call <code>do_this</code> (recursively) and cause a deadlock on <code>my_mutex</code>.<br>Maybe it will lock on a different mutex and not return in a reasonable time, causing delays to any code calling <code>do_this</code>.</p>
<h5 id="Example-246"><a href="#Example-246" class="headerlink" title="Example"></a>Example</h5><p>A common example of the “calling unknown code” problem is a call to a function that tries to gain locked access to the same object.<br>Such problem can often be solved by using a <code>recursive_mutex</code>. For example:</p>
<pre><code>recursive_mutex my_mutex;

template&lt;typename Action&gt;
void do_something(Action f)
&#123;
    unique_lock&lt;recursive_mutex&gt; lck &#123;my_mutex&#125;;
    // ... do something ...
    f(this);    // f will do something to *this
    // ...
&#125;
</code></pre>
<p>If, as it is likely, <code>f()</code> invokes operations on <code>*this</code>, we must make sure that the object’s invariant holds before the call.</p>
<h5 id="Enforcement-256"><a href="#Enforcement-256" class="headerlink" title="Enforcement"></a>Enforcement</h5><ul>
<li>Flag calling a virtual function with a non-recursive <code>mutex</code> held</li>
<li>Flag calling a callback with a non-recursive <code>mutex</code> held</li>
</ul>
<h3 id="CP-23-Think-of-a-joining-thread-as-a-scoped-container"><a href="#CP-23-Think-of-a-joining-thread-as-a-scoped-container" class="headerlink" title="CP.23: Think of a joining thread as a scoped container"></a><a name="Rconc-join"></a>CP.23: Think of a joining <code>thread</code> as a scoped container</h3><h5 id="Reason-277"><a href="#Reason-277" class="headerlink" title="Reason"></a>Reason</h5><p>To maintain pointer safety and avoid leaks, we need to consider what pointers are used by a <code>thread</code>.<br>If a <code>thread</code> joins, we can safely pass pointers to objects in the scope of the <code>thread</code> and its enclosing scopes.</p>
<h5 id="Example-247"><a href="#Example-247" class="headerlink" title="Example"></a>Example</h5><pre><code>void f(int* p)
&#123;
    // ...
    *p = 99;
    // ...
&#125;
int glob = 33;

void some_fct(int* p)
&#123;
    int x = 77;
    joining_thread t0(f, &amp;x);           // OK
    joining_thread t1(f, p);            // OK
    joining_thread t2(f, &amp;glob);        // OK
    auto q = make_unique&lt;int&gt;(99);
    joining_thread t3(f, q.get());      // OK
    // ...
&#125;
</code></pre>
<p>A <code>gsl::joining_thread</code> is a <code>std::thread</code> with a destructor that joins and that cannot be <code>detached()</code>.<br>By “OK” we mean that the object will be in scope (“live”) for as long as a <code>thread</code> can use the pointer to it.<br>The fact that <code>thread</code>s run concurrently doesn’t affect the lifetime or ownership issues here;<br>these <code>thread</code>s can be seen as just a function object called from <code>some_fct</code>.</p>
<h5 id="Enforcement-257"><a href="#Enforcement-257" class="headerlink" title="Enforcement"></a>Enforcement</h5><p>Ensure that <code>joining_thread</code>s don’t <code>detach()</code>.<br>After that, the usual lifetime and ownership (for local objects) enforcement applies.</p>
<h3 id="CP-24-Think-of-a-thread-as-a-global-container"><a href="#CP-24-Think-of-a-thread-as-a-global-container" class="headerlink" title="CP.24: Think of a thread as a global container"></a><a name="Rconc-detach"></a>CP.24: Think of a <code>thread</code> as a global container</h3><h5 id="Reason-278"><a href="#Reason-278" class="headerlink" title="Reason"></a>Reason</h5><p>To maintain pointer safety and avoid leaks, we need to consider what pointers are used by a <code>thread</code>.<br>If a <code>thread</code> is detached, we can safely pass pointers to static and free store objects (only).</p>
<h5 id="Example-248"><a href="#Example-248" class="headerlink" title="Example"></a>Example</h5><pre><code>void f(int* p)
&#123;
    // ...
    *p = 99;
    // ...
&#125;

int glob = 33;

void some_fct(int* p)
&#123;
    int x = 77;
    std::thread t0(f, &amp;x);           // bad
    std::thread t1(f, p);            // bad
    std::thread t2(f, &amp;glob);        // OK
    auto q = make_unique&lt;int&gt;(99);
    std::thread t3(f, q.get());      // bad
    // ...
    t0.detach();
    t1.detach();
    t2.detach();
    t3.detach();
    // ...
&#125;
</code></pre>
<p>By “OK” we mean that the object will be in scope (“live”) for as long as a <code>thread</code> can use the pointers to it.<br>By “bad” we mean that a <code>thread</code> may use a pointer after the pointed-to object is destroyed.<br>The fact that <code>thread</code>s run concurrently doesn’t affect the lifetime or ownership issues here;<br>these <code>thread</code>s can be seen as just a function object called from <code>some_fct</code>.</p>
<h5 id="Note-240"><a href="#Note-240" class="headerlink" title="Note"></a>Note</h5><p>Even objects with static storage duration can be problematic if used from detached threads: if the<br>thread continues until the end of the program, it might be running concurrently with the destruction<br>of objects with static storage duration, and thus accesses to such objects might race.</p>
<h5 id="Note-241"><a href="#Note-241" class="headerlink" title="Note"></a>Note</h5><p>This rule is redundant if you <a href="#Rconc-detached_thread">don’t <code>detach()</code></a> and <a href="#Rconc-joining_thread">use <code>gsl::joining_thread</code></a>.<br>However, converting code to follow those guidelines could be difficult and even impossible for third-party libraries.<br>In such cases, the rule becomes essential for lifetime safety and type safety.</p>
<p>In general, it is undecidable whether a <code>detach()</code> is executed for a <code>thread</code>, but simple common cases are easily detected.<br>If we cannot prove that a <code>thread</code> does not <code>detach()</code>, we must assume that it does and that it outlives the scope in which it was constructed;<br>After that, the usual lifetime and ownership (for global objects) enforcement applies.</p>
<h5 id="Enforcement-258"><a href="#Enforcement-258" class="headerlink" title="Enforcement"></a>Enforcement</h5><p>Flag attempts to pass local variables to a thread that might <code>detach()</code>.</p>
<h3 id="CP-25-Prefer-gsl-joining-thread-over-std-thread"><a href="#CP-25-Prefer-gsl-joining-thread-over-std-thread" class="headerlink" title="CP.25: Prefer gsl::joining_thread over std::thread"></a><a name="Rconc-joining_thread"></a>CP.25: Prefer <code>gsl::joining_thread</code> over <code>std::thread</code></h3><h5 id="Reason-279"><a href="#Reason-279" class="headerlink" title="Reason"></a>Reason</h5><p>A <code>joining_thread</code> is a thread that joins at the end of its scope.<br>Detached threads are hard to monitor.<br>It is harder to ensure absence of errors in detached threads (and potentially detached threads)</p>
<h5 id="Example-bad-115"><a href="#Example-bad-115" class="headerlink" title="Example, bad"></a>Example, bad</h5><pre><code>void f() &#123; std::cout &lt;&lt; &quot;Hello &quot;; &#125;

struct F &#123;
    void operator()() &#123; std::cout &lt;&lt; &quot;parallel world &quot;; &#125;
&#125;;

int main()
&#123;
    std::thread t1&#123;f&#125;;      // f() executes in separate thread
    std::thread t2&#123;F()&#125;;    // F()() executes in separate thread
&#125;  // spot the bugs
</code></pre>
<h5 id="Example-249"><a href="#Example-249" class="headerlink" title="Example"></a>Example</h5><pre><code>void f() &#123; std::cout &lt;&lt; &quot;Hello &quot;; &#125;

struct F &#123;
    void operator()() &#123; std::cout &lt;&lt; &quot;parallel world &quot;; &#125;
&#125;;

int main()
&#123;
    std::thread t1&#123;f&#125;;      // f() executes in separate thread
    std::thread t2&#123;F()&#125;;    // F()() executes in separate thread

    t1.join();
    t2.join();
&#125;  // one bad bug left
</code></pre>
<h5 id="Example-bad-116"><a href="#Example-bad-116" class="headerlink" title="Example, bad"></a>Example, bad</h5><p>The code determining whether to <code>join()</code> or <code>detach()</code> may be complicated and even decided in the thread of functions called from it or functions called by the function that creates a thread:</p>
<pre><code>void tricky(thread* t, int n)
&#123;
    // ...
    if (is_odd(n))
        t-&gt;detach();
    // ...
&#125;

void use(int n)
&#123;
    thread t &#123; tricky, this, n &#125;;
    // ...
    // ... should I join here? ...
&#125;
</code></pre>
<p>This seriously complicates lifetime analysis, and in not too unlikely cases makes lifetime analysis impossible.<br>This implies that we cannot safely refer to local objects in <code>use()</code> from the thread or refer to local objects in the thread from <code>use()</code>.</p>
<h5 id="Note-242"><a href="#Note-242" class="headerlink" title="Note"></a>Note</h5><p>Make “immortal threads” globals, put them in an enclosing scope, or put them on the free store rather than <code>detach()</code>.<br><a href="#Rconc-detached_thread">don’t <code>detach</code></a>.</p>
<h5 id="Note-243"><a href="#Note-243" class="headerlink" title="Note"></a>Note</h5><p>Because of old code and third party libraries using <code>std::thread</code> this rule can be hard to introduce.</p>
<h5 id="Enforcement-259"><a href="#Enforcement-259" class="headerlink" title="Enforcement"></a>Enforcement</h5><p>Flag uses of <code>std::thread</code>:</p>
<ul>
<li>Suggest use of <code>gsl::joining_thread</code>.</li>
<li>Suggest <a href="#Rconc-detached_thread">“exporting ownership”</a> to an enclosing scope if it detaches.</li>
<li>Seriously warn if it is not obvious whether if joins of detaches.</li>
</ul>
<h3 id="CP-26-Don’t-detach-a-thread"><a href="#CP-26-Don’t-detach-a-thread" class="headerlink" title="CP.26: Don’t detach() a thread"></a><a name="Rconc-detached_thread"></a>CP.26: Don’t <code>detach()</code> a thread</h3><h5 id="Reason-280"><a href="#Reason-280" class="headerlink" title="Reason"></a>Reason</h5><p>Often, the need to outlive the scope of its creation is inherent in the <code>thread</code>s task,<br>but implementing that idea by <code>detach</code> makes it harder to monitor and communicate with the detached thread.<br>In particular, it is harder (though not impossible) to ensure that the thread completed as expected or lives for as long as expected.</p>
<h5 id="Example-250"><a href="#Example-250" class="headerlink" title="Example"></a>Example</h5><pre><code>void heartbeat();

void use()
&#123;
    std::thread t(heartbeat);             // don&#39;t join; heartbeat is meant to run forever
    t.detach();
    // ...
&#125;
</code></pre>
<p>This is a reasonable use of a thread, for which <code>detach()</code> is commonly used.<br>There are problems, though.<br>How do we monitor the detached thread to see if it is alive?<br>Something might go wrong with the heartbeat, and losing a heartbeat can be very serious in a system for which it is needed.<br>So, we need to communicate with the heartbeat thread<br>(e.g., through a stream of messages or notification events using a <code>condition_variable</code>).</p>
<p>An alternative, and usually superior solution is to control its lifetime by placing it in a scope outside its point of creation (or activation).<br>For example:</p>
<pre><code>void heartbeat();

gsl::joining_thread t(heartbeat);             // heartbeat is meant to run &quot;forever&quot;
</code></pre>
<p>This heartbeat will (barring error, hardware problems, etc.) run for as long as the program does.</p>
<p>Sometimes, we need to separate the point of creation from the point of ownership:</p>
<pre><code>void heartbeat();

unique_ptr&lt;gsl::joining_thread&gt; tick_tock &#123;nullptr&#125;;

void use()
&#123;
    // heartbeat is meant to run as long as tick_tock lives
    tick_tock = make_unique&lt;gsl::joining_thread&gt;(heartbeat);
    // ...
&#125;
</code></pre>
<h4 id="Enforcement-260"><a href="#Enforcement-260" class="headerlink" title="Enforcement"></a>Enforcement</h4><p>Flag <code>detach()</code>.</p>
<h3 id="CP-31-Pass-small-amounts-of-data-between-threads-by-value-rather-than-by-reference-or-pointer"><a href="#CP-31-Pass-small-amounts-of-data-between-threads-by-value-rather-than-by-reference-or-pointer" class="headerlink" title="CP.31: Pass small amounts of data between threads by value, rather than by reference or pointer"></a><a name="Rconc-data-by-value"></a>CP.31: Pass small amounts of data between threads by value, rather than by reference or pointer</h3><h5 id="Reason-281"><a href="#Reason-281" class="headerlink" title="Reason"></a>Reason</h5><p>Copying a small amount of data is cheaper to copy and access than to share it using some locking mechanism.<br>Copying naturally gives unique ownership (simplifies code) and eliminates the possibility of data races.</p>
<h5 id="Note-244"><a href="#Note-244" class="headerlink" title="Note"></a>Note</h5><p>Defining “small amount” precisely is impossible.</p>
<h5 id="Example-251"><a href="#Example-251" class="headerlink" title="Example"></a>Example</h5><pre><code>string modify1(string);
void modify2(string&amp;);

void fct(string&amp; s)
&#123;
    auto res = async(modify1, s);
    async(modify2, s);
&#125;
</code></pre>
<p>The call of <code>modify1</code> involves copying two <code>string</code> values; the call of <code>modify2</code> does not.<br>On the other hand, the implementation of <code>modify1</code> is exactly as we would have written it for single-threaded code,<br>whereas the implementation of <code>modify2</code> will need some form of locking to avoid data races.<br>If the string is short (say 10 characters), the call of <code>modify1</code> can be surprisingly fast;<br>essentially all the cost is in the <code>thread</code> switch. If the string is long (say 1,000,000 characters), copying it twice<br>is probably not a good idea.</p>
<p>Note that this argument has nothing to do with <code>async</code> as such. It applies equally to considerations about whether to use<br>message passing or shared memory.</p>
<h5 id="Enforcement-261"><a href="#Enforcement-261" class="headerlink" title="Enforcement"></a>Enforcement</h5><p>???</p>
<h3 id="CP-32-To-share-ownership-between-unrelated-threads-use-shared-ptr"><a href="#CP-32-To-share-ownership-between-unrelated-threads-use-shared-ptr" class="headerlink" title="CP.32: To share ownership between unrelated threads use shared_ptr"></a><a name="Rconc-shared"></a>CP.32: To share ownership between unrelated <code>thread</code>s use <code>shared_ptr</code></h3><h5 id="Reason-282"><a href="#Reason-282" class="headerlink" title="Reason"></a>Reason</h5><p>If threads are unrelated (that is, not known to be in the same scope or one within the lifetime of the other)<br>and they need to share free store memory that needs to be deleted, a <code>shared_ptr</code> (or equivalent) is the only<br>safe way to ensure proper deletion.</p>
<h5 id="Example-252"><a href="#Example-252" class="headerlink" title="Example"></a>Example</h5><pre><code>???
</code></pre>
<h5 id="Note-245"><a href="#Note-245" class="headerlink" title="Note"></a>Note</h5><ul>
<li>A static object (e.g. a global) can be shared because it is not owned in the sense that some thread is responsible for its deletion.</li>
<li>An object on free store that is never to be deleted can be shared.</li>
<li>An object owned by one thread can be safely shared with another as long as that second thread doesn’t outlive the owner.</li>
</ul>
<h5 id="Enforcement-262"><a href="#Enforcement-262" class="headerlink" title="Enforcement"></a>Enforcement</h5><p>???</p>
<h3 id="CP-40-Minimize-context-switching"><a href="#CP-40-Minimize-context-switching" class="headerlink" title="CP.40: Minimize context switching"></a><a name="Rconc-switch"></a>CP.40: Minimize context switching</h3><h5 id="Reason-283"><a href="#Reason-283" class="headerlink" title="Reason"></a>Reason</h5><p>Context switches are expensive.</p>
<h5 id="Example-253"><a href="#Example-253" class="headerlink" title="Example"></a>Example</h5><pre><code>???
</code></pre>
<h5 id="Enforcement-263"><a href="#Enforcement-263" class="headerlink" title="Enforcement"></a>Enforcement</h5><p>???</p>
<h3 id="CP-41-Minimize-thread-creation-and-destruction"><a href="#CP-41-Minimize-thread-creation-and-destruction" class="headerlink" title="CP.41: Minimize thread creation and destruction"></a><a name="Rconc-create"></a>CP.41: Minimize thread creation and destruction</h3><h5 id="Reason-284"><a href="#Reason-284" class="headerlink" title="Reason"></a>Reason</h5><p>Thread creation is expensive.</p>
<h5 id="Example-254"><a href="#Example-254" class="headerlink" title="Example"></a>Example</h5><pre><code>void worker(Message m)
&#123;
    // process
&#125;

void master(istream&amp; is)
&#123;
    for (Message m; is &gt;&gt; m; )
        run_list.push_back(new thread(worker, m));
&#125;
</code></pre>
<p>This spawns a <code>thread</code> per message, and the <code>run_list</code> is presumably managed to destroy those tasks once they are finished.</p>
<p>Instead, we could have a set of pre-created worker threads processing the messages</p>
<pre><code>Sync_queue&lt;Message&gt; work;

void master(istream&amp; is)
&#123;
    for (Message m; is &gt;&gt; m; )
        work.put(m);
&#125;

void worker()
&#123;
    for (Message m; m = work.get(); ) &#123;
        // process
    &#125;
&#125;

void workers()  // set up worker threads (specifically 4 worker threads)
&#123;
    joining_thread w1 &#123;worker&#125;;
    joining_thread w2 &#123;worker&#125;;
    joining_thread w3 &#123;worker&#125;;
    joining_thread w4 &#123;worker&#125;;
&#125;
</code></pre>
<h5 id="Note-246"><a href="#Note-246" class="headerlink" title="Note"></a>Note</h5><p>If your system has a good thread pool, use it.<br>If your system has a good message queue, use it.</p>
<h5 id="Enforcement-264"><a href="#Enforcement-264" class="headerlink" title="Enforcement"></a>Enforcement</h5><p>???</p>
<h3 id="CP-42-Don’t-wait-without-a-condition"><a href="#CP-42-Don’t-wait-without-a-condition" class="headerlink" title="CP.42: Don’t wait without a condition"></a><a name="Rconc-wait"></a>CP.42: Don’t <code>wait</code> without a condition</h3><h5 id="Reason-285"><a href="#Reason-285" class="headerlink" title="Reason"></a>Reason</h5><p>A <code>wait</code> without a condition can miss a wakeup or wake up simply to find that there is no work to do.</p>
<h5 id="Example-bad-117"><a href="#Example-bad-117" class="headerlink" title="Example, bad"></a>Example, bad</h5><pre><code>std::condition_variable cv;
std::mutex mx;

void thread1()
&#123;
    while (true) &#123;
        // do some work ...
        std::unique_lock&lt;std::mutex&gt; lock(mx);
        cv.notify_one();    // wake other thread
    &#125;
&#125;

void thread2()
&#123;
    while (true) &#123;
        std::unique_lock&lt;std::mutex&gt; lock(mx);
        cv.wait(lock);    // might block forever
        // do work ...
    &#125;
&#125;
</code></pre>
<p>Here, if some other <code>thread</code> consumes <code>thread1</code>‘s notification, <code>thread2</code> can wait forever.</p>
<h5 id="Example-255"><a href="#Example-255" class="headerlink" title="Example"></a>Example</h5><pre><code>template&lt;typename T&gt;
class Sync_queue &#123;
public:
    void put(const T&amp; val);
    void put(T&amp;&amp; val);
    void get(T&amp; val);
private:
    mutex mtx;
    condition_variable cond;    // this controls access
    list&lt;T&gt; q;
&#125;;

template&lt;typename T&gt;
void Sync_queue&lt;T&gt;::put(const T&amp; val)
&#123;
    lock_guard&lt;mutex&gt; lck(mtx);
    q.push_back(val);
    cond.notify_one();
&#125;

template&lt;typename T&gt;
void Sync_queue&lt;T&gt;::get(T&amp; val)
&#123;
    unique_lock&lt;mutex&gt; lck(mtx);
    cond.wait(lck, [this]&#123; return !q.empty(); &#125;);    // prevent spurious wakeup
    val = q.front();
    q.pop_front();
&#125;
</code></pre>
<p>Now if the queue is empty when a thread executing <code>get()</code> wakes up (e.g., because another thread has gotten to <code>get()</code> before it),<br>it will immediately go back to sleep, waiting.</p>
<h5 id="Enforcement-265"><a href="#Enforcement-265" class="headerlink" title="Enforcement"></a>Enforcement</h5><p>Flag all <code>wait</code>s without conditions.</p>
<h3 id="CP-43-Minimize-time-spent-in-a-critical-section"><a href="#CP-43-Minimize-time-spent-in-a-critical-section" class="headerlink" title="CP.43: Minimize time spent in a critical section"></a><a name="Rconc-time"></a>CP.43: Minimize time spent in a critical section</h3><h5 id="Reason-286"><a href="#Reason-286" class="headerlink" title="Reason"></a>Reason</h5><p>The less time is spent with a <code>mutex</code> taken, the less chance that another <code>thread</code> has to wait,<br>and <code>thread</code> suspension and resumption are expensive.</p>
<h5 id="Example-256"><a href="#Example-256" class="headerlink" title="Example"></a>Example</h5><pre><code>void do_something() // bad
&#123;
    unique_lock&lt;mutex&gt; lck(my_lock);
    do0();  // preparation: does not need lock
    do1();  // transaction: needs locking
    do2();  // cleanup: does not need locking
&#125;
</code></pre>
<p>Here, we are holding the lock for longer than necessary:<br>We should not have taken the lock before we needed it and should have released it again before starting the cleanup.<br>We could rewrite this to</p>
<pre><code>void do_something() // bad
&#123;
    do0();  // preparation: does not need lock
    my_lock.lock();
    do1();  // transaction: needs locking
    my_lock.unlock();
    do2();  // cleanup: does not need locking
&#125;
</code></pre>
<p>But that compromises safety and violates the <a href="#Rconc-raii">use RAII</a> rule.<br>Instead, add a block for the critical section:</p>
<pre><code>void do_something() // OK
&#123;
    do0();  // preparation: does not need lock
    &#123;
        unique_lock&lt;mutex&gt; lck(my_lock);
        do1();  // transaction: needs locking
    &#125;
    do2();  // cleanup: does not need locking
&#125;
</code></pre>
<h5 id="Enforcement-266"><a href="#Enforcement-266" class="headerlink" title="Enforcement"></a>Enforcement</h5><p>Impossible in general.<br>Flag “naked” <code>lock()</code> and <code>unlock()</code>.</p>
<h3 id="CP-44-Remember-to-name-your-lock-guards-and-unique-locks"><a href="#CP-44-Remember-to-name-your-lock-guards-and-unique-locks" class="headerlink" title="CP.44: Remember to name your lock_guards and unique_locks"></a><a name="Rconc-name"></a>CP.44: Remember to name your <code>lock_guard</code>s and <code>unique_lock</code>s</h3><h5 id="Reason-287"><a href="#Reason-287" class="headerlink" title="Reason"></a>Reason</h5><p>An unnamed local objects is a temporary that immediately goes out of scope.</p>
<h5 id="Example-257"><a href="#Example-257" class="headerlink" title="Example"></a>Example</h5><pre><code>unique_lock&lt;mutex&gt;(m1);
lock_guard&lt;mutex&gt; &#123;m2&#125;;
lock(m1, m2);
</code></pre>
<p>This looks innocent enough, but it isn’t.</p>
<h5 id="Enforcement-267"><a href="#Enforcement-267" class="headerlink" title="Enforcement"></a>Enforcement</h5><p>Flag all unnamed <code>lock_guard</code>s and <code>unique_lock</code>s.</p>
<h3 id="CP-50-Define-a-mutex-together-with-the-data-it-guards-Use-synchronized-value-lt-T-gt-where-possible"><a href="#CP-50-Define-a-mutex-together-with-the-data-it-guards-Use-synchronized-value-lt-T-gt-where-possible" class="headerlink" title="CP.50: Define a mutex together with the data it guards. Use synchronized_value&lt;T&gt; where possible"></a><a name="Rconc-mutex"></a>CP.50: Define a <code>mutex</code> together with the data it guards. Use <code>synchronized_value&lt;T&gt;</code> where possible</h3><h5 id="Reason-288"><a href="#Reason-288" class="headerlink" title="Reason"></a>Reason</h5><p>It should be obvious to a reader that the data is to be guarded and how. This decreases the chance of the wrong mutex being locked, or the mutex not being locked.</p>
<p>Using a <code>synchronized_value&lt;T&gt;</code> ensures that the data has a mutex, and the right mutex is locked when the data is accessed.<br>See the <a href="http://wg21.link/p0290">WG21 proposal</a>) to add <code>synchronized_value</code> to a future TS or revision of the C++ standard.</p>
<h5 id="Example-258"><a href="#Example-258" class="headerlink" title="Example"></a>Example</h5><pre><code>struct Record &#123;
    std::mutex m;   // take this mutex before accessing other members
    // ...
&#125;;

class MyClass &#123;
    struct DataRecord &#123;
       // ...
    &#125;;
    synchronized_value&lt;DataRecord&gt; data; // Protect the data with a mutex
&#125;;
</code></pre>
<h5 id="Enforcement-268"><a href="#Enforcement-268" class="headerlink" title="Enforcement"></a>Enforcement</h5><p>??? Possible?</p>
<h2 id="CP-par-Parallelism"><a href="#CP-par-Parallelism" class="headerlink" title="CP.par: Parallelism"></a><a name="SScp-par"></a>CP.par: Parallelism</h2><p>By “parallelism” we refer to performing a task (more or less) simultaneously (“in parallel with”) on many data items.</p>
<p>Parallelism rule summary:</p>
<ul>
<li>???</li>
<li>???</li>
<li>Where appropriate, prefer the standard-library parallel algorithms</li>
<li>Use algorithms that are designed for parallelism, not algorithms with unnecessary dependency on linear evaluation</li>
</ul>
<h2 id="CP-mess-Message-passing"><a href="#CP-mess-Message-passing" class="headerlink" title="CP.mess: Message passing"></a><a name="SScp-mess"></a>CP.mess: Message passing</h2><p>The standard-library facilities are quite low-level, focused on the needs of close-to the hardware critical programming using <code>thread</code>s, <code>mutex</code>es, <code>atomic</code> types, etc.<br>Most people shouldn’t work at this level: it’s error-prone and development is slow.<br>If possible, use a higher level facility: messaging libraries, parallel algorithms, and vectorization.<br>This section looks at passing messages so that a programmer doesn’t have to do explicit synchronization.</p>
<p>Message passing rules summary:</p>
<ul>
<li><a href="#Rconc-future">CP.60: Use a <code>future</code> to return a value from a concurrent task</a></li>
<li><a href="#Rconc-async">CP.61: Use a <code>async()</code> to spawn a concurrent task</a></li>
<li>message queues</li>
<li>messaging libraries</li>
</ul>
<p>???? should there be a “use X rather than <code>std::async</code>“ where X is something that would use a better specified thread pool?</p>
<p>??? Is <code>std::async</code> worth using in light of future (and even existing, as libraries) parallelism facilities? What should the guidelines recommend if someone wants to parallelize, e.g., <code>std::accumulate</code> (with the additional precondition of commutativity), or merge sort?</p>
<h3 id="CP-60-Use-a-future-to-return-a-value-from-a-concurrent-task"><a href="#CP-60-Use-a-future-to-return-a-value-from-a-concurrent-task" class="headerlink" title="CP.60: Use a future to return a value from a concurrent task"></a><a name="Rconc-future"></a>CP.60: Use a <code>future</code> to return a value from a concurrent task</h3><h5 id="Reason-289"><a href="#Reason-289" class="headerlink" title="Reason"></a>Reason</h5><p>A <code>future</code> preserves the usual function call return semantics for asynchronous tasks.<br>The is no explicit locking and both correct (value) return and error (exception) return are handled simply.</p>
<h5 id="Example-259"><a href="#Example-259" class="headerlink" title="Example"></a>Example</h5><pre><code>???
</code></pre>
<h5 id="Note-247"><a href="#Note-247" class="headerlink" title="Note"></a>Note</h5><p>???</p>
<h5 id="Enforcement-269"><a href="#Enforcement-269" class="headerlink" title="Enforcement"></a>Enforcement</h5><p>???</p>
<h3 id="CP-61-Use-a-async-to-spawn-a-concurrent-task"><a href="#CP-61-Use-a-async-to-spawn-a-concurrent-task" class="headerlink" title="CP.61: Use a async() to spawn a concurrent task"></a><a name="Rconc-async"></a>CP.61: Use a <code>async()</code> to spawn a concurrent task</h3><h5 id="Reason-290"><a href="#Reason-290" class="headerlink" title="Reason"></a>Reason</h5><p>A <code>future</code> preserves the usual function call return semantics for asynchronous tasks.<br>The is no explicit locking and both correct (value) return and error (exception) return are handled simply.</p>
<h5 id="Example-260"><a href="#Example-260" class="headerlink" title="Example"></a>Example</h5><pre><code>???
</code></pre>
<h5 id="Note-248"><a href="#Note-248" class="headerlink" title="Note"></a>Note</h5><p>Unfortunately, <code>async()</code> is not perfect.<br>For example, there is no guarantee that a thread pool is used to minimize thread construction.<br>In fact, most current <code>async()</code> implementations don’t.<br>However, <code>async()</code> is simple and logically correct so until something better comes along<br>and unless you really need to optimize for many asynchronous tasks, stick with <code>async()</code>.</p>
<h5 id="Enforcement-270"><a href="#Enforcement-270" class="headerlink" title="Enforcement"></a>Enforcement</h5><p>???</p>
<h2 id="CP-vec-Vectorization"><a href="#CP-vec-Vectorization" class="headerlink" title="CP.vec: Vectorization"></a><a name="SScp-vec"></a>CP.vec: Vectorization</h2><p>Vectorization is a technique for executing a number of tasks concurrently without introducing explicit synchronization.<br>An operation is simply applied to elements of a data structure (a vector, an array, etc.) in parallel.<br>Vectorization has the interesting property of often requiring no non-local changes to a program.<br>However, vectorization works best with simple data structures and with algorithms specifically crafted to enable it.</p>
<p>Vectorization rule summary:</p>
<ul>
<li>???</li>
<li>???</li>
</ul>
<h2 id="CP-free-Lock-free-programming"><a href="#CP-free-Lock-free-programming" class="headerlink" title="CP.free: Lock-free programming"></a><a name="SScp-free"></a>CP.free: Lock-free programming</h2><p>Synchronization using <code>mutex</code>es and <code>condition_variable</code>s can be relatively expensive.<br>Furthermore, it can lead to deadlock.<br>For performance and to eliminate the possibility of deadlock, we sometimes have to use the tricky low-level “lock-free” facilities<br>that rely on briefly gaining exclusive (“atomic”) access to memory.<br>Lock-free programming is also used to implement higher-level concurrency mechanisms, such as <code>thread</code>s and <code>mutex</code>es.</p>
<p>Lock-free programming rule summary:</p>
<ul>
<li><a href="#Rconc-lockfree">CP.100: Don’t use lock-free programming unless you absolutely have to</a></li>
<li><a href="#Rconc-distrust">CP.101: Distrust your hardware/compiler combination</a></li>
<li><a href="#Rconc-literature">CP.102: Carefully study the literature</a></li>
<li>how/when to use atomics</li>
<li>avoid starvation</li>
<li>use a lock-free data structure rather than hand-crafting specific lock-free access</li>
<li><a href="#Rconc-double">CP.110: Do not write your own double-checked locking for initialization</a></li>
<li><a href="#Rconc-double-pattern">CP.111: Use a conventional pattern if you really need double-checked locking</a></li>
<li>how/when to compare and swap</li>
</ul>
<h3 id="CP-100-Don’t-use-lock-free-programming-unless-you-absolutely-have-to"><a href="#CP-100-Don’t-use-lock-free-programming-unless-you-absolutely-have-to" class="headerlink" title="CP.100: Don’t use lock-free programming unless you absolutely have to"></a><a name="Rconc-lockfree"></a>CP.100: Don’t use lock-free programming unless you absolutely have to</h3><h5 id="Reason-291"><a href="#Reason-291" class="headerlink" title="Reason"></a>Reason</h5><p>It’s error-prone and requires expert level knowledge of language features, machine architecture, and data structures.</p>
<h5 id="Example-bad-118"><a href="#Example-bad-118" class="headerlink" title="Example, bad"></a>Example, bad</h5><pre><code>extern atomic&lt;Link*&gt; head;        // the shared head of a linked list

Link* nh = new Link(data, nullptr);    // make a link ready for insertion
Link* h = head.load();                 // read the shared head of the list

do &#123;
    if (h-&gt;data &lt;= data) break;        // if so, insert elsewhere
    nh-&gt;next = h;                      // next element is the previous head
&#125; while (!head.compare_exchange_weak(h, nh));    // write nh to head or to h
</code></pre>
<p>Spot the bug.<br>It would be really hard to find through testing.<br>Read up on the ABA problem.</p>
<h5 id="Exception-47"><a href="#Exception-47" class="headerlink" title="Exception"></a>Exception</h5><p><a href="#???">Atomic variables</a> can be used simply and safely, as long as you are using the sequentially consistent memory model (memory_order_seq_cst), which is the default.</p>
<h5 id="Note-249"><a href="#Note-249" class="headerlink" title="Note"></a>Note</h5><p>Higher-level concurrency mechanisms, such as <code>thread</code>s and <code>mutex</code>es are implemented using lock-free programming.</p>
<p><strong>Alternative</strong>: Use lock-free data structures implemented by others as part of some library.</p>
<h3 id="CP-101-Distrust-your-hardware-compiler-combination"><a href="#CP-101-Distrust-your-hardware-compiler-combination" class="headerlink" title="CP.101: Distrust your hardware/compiler combination"></a><a name="Rconc-distrust"></a>CP.101: Distrust your hardware/compiler combination</h3><h5 id="Reason-292"><a href="#Reason-292" class="headerlink" title="Reason"></a>Reason</h5><p>The low-level hardware interfaces used by lock-free programming are among the hardest to implement well and among<br>the areas where the most subtle portability problems occur.<br>If you are doing lock-free programming for performance, you need to check for regressions.</p>
<h5 id="Note-250"><a href="#Note-250" class="headerlink" title="Note"></a>Note</h5><p>Instruction reordering (static and dynamic) makes it hard for us to think effectively at this level (especially if you use relaxed memory models).<br>Experience, (semi)formal models and model checking can be useful.<br>Testing - often to an extreme extent - is essential.<br>“Don’t fly too close to the sun.”</p>
<h5 id="Enforcement-271"><a href="#Enforcement-271" class="headerlink" title="Enforcement"></a>Enforcement</h5><p>Have strong rules for re-testing in place that covers any change in hardware, operating system, compiler, and libraries.</p>
<h3 id="CP-102-Carefully-study-the-literature"><a href="#CP-102-Carefully-study-the-literature" class="headerlink" title="CP.102: Carefully study the literature"></a><a name="Rconc-literature"></a>CP.102: Carefully study the literature</h3><h5 id="Reason-293"><a href="#Reason-293" class="headerlink" title="Reason"></a>Reason</h5><p>With the exception of atomics and a few use standard patterns, lock-free programming is really an expert-only topic.<br>Become an expert before shipping lock-free code for others to use.</p>
<h5 id="References"><a href="#References" class="headerlink" title="References"></a>References</h5><ul>
<li>Anthony Williams: C++ concurrency in action. Manning Publications.</li>
<li>Boehm, Adve, You Don’t Know Jack About Shared Variables or Memory Models , Communications of the ACM, Feb 2012.</li>
<li>Boehm, “Threads Basics”, HPL TR 2009-259.</li>
<li>Adve, Boehm, “Memory Models: A Case for Rethinking Parallel Languages and Hardware”, Communications of the ACM, August 2010.</li>
<li>Boehm, Adve, “Foundations of the C++ Concurrency Memory Model”, PLDI 08.</li>
<li>Mark Batty, Scott Owens, Susmit Sarkar, Peter Sewell, and Tjark Weber, “Mathematizing C++ Concurrency”, POPL 2011.</li>
<li>Damian Dechev, Peter Pirkelbauer, and Bjarne Stroustrup: Understanding and Effectively Preventing the ABA Problem in Descriptor-based Lock-free Designs. 13th IEEE Computer Society ISORC 2010 Symposium. May 2010.</li>
<li>Damian Dechev and Bjarne Stroustrup: Scalable Non-blocking Concurrent Objects for Mission Critical Code. ACM OOPSLA’09. October 2009</li>
<li>Damian Dechev, Peter Pirkelbauer, Nicolas Rouquette, and Bjarne Stroustrup: Semantically Enhanced Containers for Concurrent Real-Time Systems. Proc. 16th Annual IEEE International Conference and Workshop on the Engineering of Computer Based Systems (IEEE ECBS). April 2009.</li>
</ul>
<h3 id="CP-110-Do-not-write-your-own-double-checked-locking-for-initialization"><a href="#CP-110-Do-not-write-your-own-double-checked-locking-for-initialization" class="headerlink" title="CP.110: Do not write your own double-checked locking for initialization"></a><a name="Rconc-double"></a>CP.110: Do not write your own double-checked locking for initialization</h3><h5 id="Reason-294"><a href="#Reason-294" class="headerlink" title="Reason"></a>Reason</h5><p>Since C++11, static local variables are now initialized in a thread-safe way. When combined with the RAII pattern, static local variables can replace the need for writing your own double-checked locking for initialization. std::call_once can also achieve the same purpose. Use either static local variables of C++11 or std::call_once instead of writing your own double-checked locking for initialization.</p>
<h5 id="Example-261"><a href="#Example-261" class="headerlink" title="Example"></a>Example</h5><p>Example with std::call_once.</p>
<pre><code>void f()
&#123;
    static std::once_flag my_once_flag;
    std::call_once(my_once_flag, []()
    &#123;
        // do this only once
    &#125;);
    // ...
&#125;
</code></pre>
<p>Example with thread-safe static local variables of C++11.</p>
<pre><code>void f()
&#123;
    // Assuming the compiler is compliant with C++11
    static My_class my_object; // Constructor called only once
    // ...
&#125;

class My_class
&#123;
public:
    My_class()
    &#123;
        // do this only once
    &#125;
&#125;;
</code></pre>
<h5 id="Enforcement-272"><a href="#Enforcement-272" class="headerlink" title="Enforcement"></a>Enforcement</h5><p>??? Is it possible to detect the idiom?</p>
<h3 id="CP-111-Use-a-conventional-pattern-if-you-really-need-double-checked-locking"><a href="#CP-111-Use-a-conventional-pattern-if-you-really-need-double-checked-locking" class="headerlink" title="CP.111: Use a conventional pattern if you really need double-checked locking"></a><a name="Rconc-double-pattern"></a>CP.111: Use a conventional pattern if you really need double-checked locking</h3><h5 id="Reason-295"><a href="#Reason-295" class="headerlink" title="Reason"></a>Reason</h5><p>Double-checked locking is easy to mess up. If you really need to write your own double-checked locking, in spite of the rules <a href="#Rconc-double">CP.110: Do not write your own double-checked locking for initialization</a> and <a href="#Rconc-lockfree">CP.100: Don’t use lock-free programming unless you absolutely have to</a>, then do it in a conventional pattern.</p>
<p>The uses of the double-checked locking pattern that are not in violation of <a href="#Rconc-double">CP.110: Do not write your own double-checked locking for initialization</a> arise when a non-thread-safe action is both hard and rare, and there exists a fast thread-safe test that can be used to guarantee that the action is not needed, but cannot be used to guarantee the converse.</p>
<h5 id="Example-bad-119"><a href="#Example-bad-119" class="headerlink" title="Example, bad"></a>Example, bad</h5><p>The use of volatile does not make the first check thread-safe, see also <a href="#Rconc-volatile2">CP.200: Use <code>volatile</code> only to talk to non-C++ memory</a></p>
<pre><code>mutex action_mutex;
volatile bool action_needed;

if (action_needed) &#123;
    std::lock_guard&lt;std::mutex&gt; lock(action_mutex);
    if (action_needed) &#123;
        take_action();
        action_needed = false;
    &#125;
&#125;
</code></pre>
<h5 id="Example-good-22"><a href="#Example-good-22" class="headerlink" title="Example, good"></a>Example, good</h5><pre><code>mutex action_mutex;
atomic&lt;bool&gt; action_needed;

if (action_needed) &#123;
    std::lock_guard&lt;std::mutex&gt; lock(action_mutex);
    if (action_needed) &#123;
        take_action();
        action_needed = false;
    &#125;
&#125;
</code></pre>
<p>Fine-tuned memory order may be beneficial where acquire load is more efficient than sequentially-consistent load</p>
<pre><code>mutex action_mutex;
atomic&lt;bool&gt; action_needed;

if (action_needed.load(memory_order_acquire)) &#123;
    lock_guard&lt;std::mutex&gt; lock(action_mutex);
    if (action_needed.load(memory_order_relaxed)) &#123;
        take_action();
        action_needed.store(false, memory_order_release);
    &#125;
&#125;
</code></pre>
<h5 id="Enforcement-273"><a href="#Enforcement-273" class="headerlink" title="Enforcement"></a>Enforcement</h5><p>??? Is it possible to detect the idiom?</p>
<h2 id="CP-etc-Etc-concurrency-rules"><a href="#CP-etc-Etc-concurrency-rules" class="headerlink" title="CP.etc: Etc. concurrency rules"></a><a name="SScp-etc"></a>CP.etc: Etc. concurrency rules</h2><p>These rules defy simple categorization:</p>
<ul>
<li><a href="#Rconc-volatile2">CP.200: Use <code>volatile</code> only to talk to non-C++ memory</a></li>
<li><a href="#Rconc-signal">CP.201: ??? Signals</a></li>
</ul>
<h3 id="CP-200-Use-volatile-only-to-talk-to-non-C-memory"><a href="#CP-200-Use-volatile-only-to-talk-to-non-C-memory" class="headerlink" title="CP.200: Use volatile only to talk to non-C++ memory"></a><a name="Rconc-volatile2"></a>CP.200: Use <code>volatile</code> only to talk to non-C++ memory</h3><h5 id="Reason-296"><a href="#Reason-296" class="headerlink" title="Reason"></a>Reason</h5><p><code>volatile</code> is used to refer to objects that are shared with “non-C++” code or hardware that does not follow the C++ memory model.</p>
<h5 id="Example-262"><a href="#Example-262" class="headerlink" title="Example"></a>Example</h5><pre><code>const volatile long clock;
</code></pre>
<p>This describes a register constantly updated by a clock circuit.<br><code>clock</code> is <code>volatile</code> because its value will change without any action from the C++ program that uses it.<br>For example, reading <code>clock</code> twice will often yield two different values, so the optimizer had better not optimize away the second read in this code:</p>
<pre><code>long t1 = clock;
// ... no use of clock here ...
long t2 = clock;
</code></pre>
<p><code>clock</code> is <code>const</code> because the program should not try to write to <code>clock</code>.</p>
<h5 id="Note-251"><a href="#Note-251" class="headerlink" title="Note"></a>Note</h5><p>Unless you are writing the lowest level code manipulating hardware directly, consider <code>volatile</code> an esoteric feature that is best avoided.</p>
<h5 id="Example-263"><a href="#Example-263" class="headerlink" title="Example"></a>Example</h5><p>Usually C++ code receives <code>volatile</code> memory that is owned Elsewhere (hardware or another language):</p>
<pre><code>int volatile* vi = get_hardware_memory_location();
    // note: we get a pointer to someone else&#39;s memory here
    // volatile says &quot;treat this with extra respect&quot;
</code></pre>
<p>Sometimes C++ code allocates the <code>volatile</code> memory and shares it with “elsewhere” (hardware or another language) by deliberately escaping a pointer:</p>
<pre><code>static volatile long vl;
please_use_this(&amp;vl);   // escape a reference to this to &quot;elsewhere&quot; (not C++)
</code></pre>
<h5 id="Example-bad-120"><a href="#Example-bad-120" class="headerlink" title="Example; bad"></a>Example; bad</h5><p><code>volatile</code> local variables are nearly always wrong – how can they be shared with other languages or hardware if they’re ephemeral?<br>The same applies almost as strongly to member variables, for the same reason.</p>
<pre><code>void f() &#123;
    volatile int i = 0; // bad, volatile local variable
    // etc.
&#125;

class My_type &#123;
    volatile int i = 0; // suspicious, volatile member variable
    // etc.
&#125;;
</code></pre>
<h5 id="Note-252"><a href="#Note-252" class="headerlink" title="Note"></a>Note</h5><p>In C++, unlike in some other languages, <code>volatile</code> has <a href="#Rconc-volatile">nothing to do with synchronization</a>.</p>
<h5 id="Enforcement-274"><a href="#Enforcement-274" class="headerlink" title="Enforcement"></a>Enforcement</h5><ul>
<li>Flag <code>volatile T</code> local and member variables; almost certainly you intended to use <code>atomic&lt;T&gt;</code> instead.</li>
<li>???</li>
</ul>
<h3 id="CP-201-Signals"><a href="#CP-201-Signals" class="headerlink" title="CP.201: ??? Signals"></a><a name="Rconc-signal"></a>CP.201: ??? Signals</h3><p>???UNIX signal handling???. May be worth reminding how little is async-signal-safe, and how to communicate with a signal handler (best is probably “not at all”)</p>
<h1 id="E-Error-handling"><a href="#E-Error-handling" class="headerlink" title="E: Error handling"></a><a name="S-errors"></a>E: Error handling</h1><p>Error handling involves:</p>
<ul>
<li>Detecting an error</li>
<li>Transmitting information about an error to some handler code</li>
<li>Preserve the state of a program in a valid state</li>
<li>Avoid resource leaks</li>
</ul>
<p>It is not possible to recover from all errors. If recovery from an error is not possible, it is important to quickly “get out” in a well-defined way. A strategy for error handling must be simple, or it becomes a source of even worse errors.  Untested and rarely executed error-handling code is itself the source of many bugs.</p>
<p>The rules are designed to help avoid several kinds of errors:</p>
<ul>
<li>Type violations (e.g., misuse of <code>union</code>s and casts)</li>
<li>Resource leaks (including memory leaks)</li>
<li>Bounds errors</li>
<li>Lifetime errors (e.g., accessing an object after is has been <code>delete</code>d)</li>
<li>Complexity errors (logical errors made likely by overly complex expression of ideas)</li>
<li>Interface errors (e.g., an unexpected value is passed through an interface)</li>
</ul>
<p>Error-handling rule summary:</p>
<ul>
<li><p><a href="#Re-design">E.1: Develop an error-handling strategy early in a design</a></p>
</li>
<li><p><a href="#Re-throw">E.2: Throw an exception to signal that a function can’t perform its assigned task</a></p>
</li>
<li><p><a href="#Re-errors">E.3: Use exceptions for error handling only</a></p>
</li>
<li><p><a href="#Re-design-invariants">E.4: Design your error-handling strategy around invariants</a></p>
</li>
<li><p><a href="#Re-invariant">E.5: Let a constructor establish an invariant, and throw if it cannot</a></p>
</li>
<li><p><a href="#Re-raii">E.6: Use RAII to prevent leaks</a></p>
</li>
<li><p><a href="#Re-precondition">E.7: State your preconditions</a></p>
</li>
<li><p><a href="#Re-postcondition">E.8: State your postconditions</a></p>
</li>
<li><p><a href="#Re-noexcept">E.12: Use <code>noexcept</code> when exiting a function because of a <code>throw</code> is impossible or unacceptable</a></p>
</li>
<li><p><a href="#Re-never-throw">E.13: Never throw while being the direct owner of an object</a></p>
</li>
<li><p><a href="#Re-exception-types">E.14: Use purpose-designed user-defined types as exceptions (not built-in types)</a></p>
</li>
<li><p><a href="#Re-exception-ref">E.15: Catch exceptions from a hierarchy by reference</a></p>
</li>
<li><p><a href="#Re-never-fail">E.16: Destructors, deallocation, and <code>swap</code> must never fail</a></p>
</li>
<li><p><a href="#Re-not-always">E.17: Don’t try to catch every exception in every function</a></p>
</li>
<li><p><a href="#Re-catch">E.18: Minimize the use of explicit <code>try</code>/<code>catch</code></a></p>
</li>
<li><p><a href="#Re-finally">E.19: Use a <code>final_action</code> object to express cleanup if no suitable resource handle is available</a></p>
</li>
<li><p><a href="#Re-no-throw-raii">E.25: If you can’t throw exceptions, simulate RAII for resource management</a></p>
</li>
<li><p><a href="#Re-no-throw-crash">E.26: If you can’t throw exceptions, consider failing fast</a></p>
</li>
<li><p><a href="#Re-no-throw-codes">E.27: If you can’t throw exceptions, use error codes systematically</a></p>
</li>
<li><p><a href="#Re-no-throw">E.28: Avoid error handling based on global state (e.g. <code>errno</code>)</a></p>
</li>
<li><p><a href="#Re-specifications">E.30: Don’t use exception specifications</a></p>
</li>
<li><p><a href="#Re_catch">E.31: Properly order your <code>catch</code>-clauses</a></p>
</li>
</ul>
<h3 id="E-1-Develop-an-error-handling-strategy-early-in-a-design"><a href="#E-1-Develop-an-error-handling-strategy-early-in-a-design" class="headerlink" title="E.1: Develop an error-handling strategy early in a design"></a><a name="Re-design"></a>E.1: Develop an error-handling strategy early in a design</h3><h5 id="Reason-297"><a href="#Reason-297" class="headerlink" title="Reason"></a>Reason</h5><p>A consistent and complete strategy for handling errors and resource leaks is hard to retrofit into a system.</p>
<h3 id="E-2-Throw-an-exception-to-signal-that-a-function-can’t-perform-its-assigned-task"><a href="#E-2-Throw-an-exception-to-signal-that-a-function-can’t-perform-its-assigned-task" class="headerlink" title="E.2: Throw an exception to signal that a function can’t perform its assigned task"></a><a name="Re-throw"></a>E.2: Throw an exception to signal that a function can’t perform its assigned task</h3><h5 id="Reason-298"><a href="#Reason-298" class="headerlink" title="Reason"></a>Reason</h5><p>To make error handling systematic, robust, and non-repetitive.</p>
<h5 id="Example-264"><a href="#Example-264" class="headerlink" title="Example"></a>Example</h5><pre><code>struct Foo &#123;
    vector&lt;Thing&gt; v;
    File_handle f;
    string s;
&#125;;

void use()
&#123;
    Foo bar &#123;&#123;Thing&#123;1&#125;, Thing&#123;2&#125;, Thing&#123;monkey&#125;&#125;, &#123;&quot;my_file&quot;, &quot;r&quot;&#125;, &quot;Here we go!&quot;&#125;;
    // ...
&#125;
</code></pre>
<p>Here, <code>vector</code> and <code>string</code>s constructors may not be able to allocate sufficient memory for their elements, <code>vector</code>s constructor may not be able copy the <code>Thing</code>s in its initializer list, and <code>File_handle</code> may not be able to open the required file.<br>In each case, they throw an exception for <code>use()</code>‘s caller to handle.<br>If <code>use()</code> could handle the failure to construct <code>bar</code> it can take control using <code>try</code>/<code>catch</code>.<br>In either case, <code>Foo</code>‘s constructor correctly destroys constructed members before passing control to whatever tried to create a <code>Foo</code>.<br>Note that there is no return value that could contain an error code.</p>
<p>The <code>File_handle</code> constructor might be defined like this:</p>
<pre><code>File_handle::File_handle(const string&amp; name, const string&amp; mode)
    :f&#123;fopen(name.c_str(), mode.c_str())&#125;
&#123;
    if (!f)
        throw runtime_error&#123;&quot;File_handle: could not open &quot; + name + &quot; as &quot; + mode&#125;;
&#125;
</code></pre>
<h5 id="Note-253"><a href="#Note-253" class="headerlink" title="Note"></a>Note</h5><p>It is often said that exceptions are meant to signal exceptional events and failures.<br>However, that’s a bit circular because “what is exceptional?”<br>Examples:</p>
<ul>
<li>A precondition that cannot be met</li>
<li>A constructor that cannot construct an object (failure to establish its class’s <a href="#Rc-struct">invariant</a>)</li>
<li>An out-of-range error (e.g., <code>v[v.size()] = 7</code>)</li>
<li>Inability to acquire a resource (e.g., the network is down)</li>
</ul>
<p>In contrast, termination of an ordinary loop is not exceptional.<br>Unless the loop was meant to be infinite, termination is normal and expected.</p>
<h5 id="Note-254"><a href="#Note-254" class="headerlink" title="Note"></a>Note</h5><p>Don’t use a <code>throw</code> as simply an alternative way of returning a value from a function.</p>
<h5 id="Exception-48"><a href="#Exception-48" class="headerlink" title="Exception"></a>Exception</h5><p>Some systems, such as hard-real-time systems require a guarantee that an action is taken in a (typically short) constant maximum time known before execution starts. Such systems can use exceptions only if there is tool support for accurately predicting the maximum time to recover from a <code>throw</code>.</p>
<p><strong>See also</strong>: <a href="#Re-raii">RAII</a></p>
<p><strong>See also</strong>: <a href="#Sd-noexcept">discussion</a></p>
<h5 id="Note-255"><a href="#Note-255" class="headerlink" title="Note"></a>Note</h5><p>Before deciding that you cannot afford or don’t like exception-based error handling, have a look at the <a href="#Re-no-throw-raii">alternatives</a>;<br>they have their own complexities and problems.<br>Also, as far as possible, measure before making claims about efficiency.</p>
<h3 id="E-3-Use-exceptions-for-error-handling-only"><a href="#E-3-Use-exceptions-for-error-handling-only" class="headerlink" title="E.3: Use exceptions for error handling only"></a><a name="Re-errors"></a>E.3: Use exceptions for error handling only</h3><h5 id="Reason-299"><a href="#Reason-299" class="headerlink" title="Reason"></a>Reason</h5><p>To keep error handling separated from “ordinary code.”<br>C++ implementations tend to be optimized based on the assumption that exceptions are rare.</p>
<h5 id="Example-don’t-3"><a href="#Example-don’t-3" class="headerlink" title="Example, don’t"></a>Example, don’t</h5><pre><code>// don&#39;t: exception not used for error handling
int find_index(vector&lt;string&gt;&amp; vec, const string&amp; x)
&#123;
    try &#123;
        for (gsl::index i = 0; i &lt; vec.size(); ++i)
            if (vec[i] == x) throw i;  // found x
    &#125; catch (int i) &#123;
        return i;
    &#125;
    return -1;   // not found
&#125;
</code></pre>
<p>This is more complicated and most likely runs much slower than the obvious alternative.<br>There is nothing exceptional about finding a value in a <code>vector</code>.</p>
<h5 id="Enforcement-275"><a href="#Enforcement-275" class="headerlink" title="Enforcement"></a>Enforcement</h5><p>Would need to be heuristic.<br>Look for exception values “leaked” out of <code>catch</code> clauses.</p>
<h3 id="E-4-Design-your-error-handling-strategy-around-invariants"><a href="#E-4-Design-your-error-handling-strategy-around-invariants" class="headerlink" title="E.4: Design your error-handling strategy around invariants"></a><a name="Re-design-invariants"></a>E.4: Design your error-handling strategy around invariants</h3><h5 id="Reason-300"><a href="#Reason-300" class="headerlink" title="Reason"></a>Reason</h5><p>To use an object it must be in a valid state (defined formally or informally by an invariant) and to recover from an error every object not destroyed must be in a valid state.</p>
<h5 id="Note-256"><a href="#Note-256" class="headerlink" title="Note"></a>Note</h5><p>An <a href="#Rc-struct">invariant</a> is logical condition for the members of an object that a constructor must establish for the public member functions to assume.</p>
<h5 id="Enforcement-276"><a href="#Enforcement-276" class="headerlink" title="Enforcement"></a>Enforcement</h5><p>???</p>
<h3 id="E-5-Let-a-constructor-establish-an-invariant-and-throw-if-it-cannot"><a href="#E-5-Let-a-constructor-establish-an-invariant-and-throw-if-it-cannot" class="headerlink" title="E.5: Let a constructor establish an invariant, and throw if it cannot"></a><a name="Re-invariant"></a>E.5: Let a constructor establish an invariant, and throw if it cannot</h3><h5 id="Reason-301"><a href="#Reason-301" class="headerlink" title="Reason"></a>Reason</h5><p>Leaving an object without its invariant established is asking for trouble.<br>Not all member functions can be called.</p>
<h5 id="Example-265"><a href="#Example-265" class="headerlink" title="Example"></a>Example</h5><pre><code>class Vector &#123;  // very simplified vector of doubles
    // if elem != nullptr then elem points to sz doubles
public:
    Vector() : elem&#123;nullptr&#125;, sz&#123;0&#125;&#123;&#125;
    Vector(int s) : elem&#123;new double[s]&#125;, sz&#123;s&#125; &#123; /* initialize elements */ &#125;
    ~Vector() &#123; delete [] elem; &#125;
    double&amp; operator[](int s) &#123; return elem[s]; &#125;
    // ...
private:
    owner&lt;double*&gt; elem;
    int sz;
&#125;;
</code></pre>
<p>The class invariant - here stated as a comment - is established by the constructors.<br><code>new</code> throws if it cannot allocate the required memory.<br>The operators, notably the subscript operator, relies on the invariant.</p>
<p><strong>See also</strong>: <a href="#Rc-throw">If a constructor cannot construct a valid object, throw an exception</a></p>
<h5 id="Enforcement-277"><a href="#Enforcement-277" class="headerlink" title="Enforcement"></a>Enforcement</h5><p>Flag classes with <code>private</code> state without a constructor (public, protected, or private).</p>
<h3 id="E-6-Use-RAII-to-prevent-leaks"><a href="#E-6-Use-RAII-to-prevent-leaks" class="headerlink" title="E.6: Use RAII to prevent leaks"></a><a name="Re-raii"></a>E.6: Use RAII to prevent leaks</h3><h5 id="Reason-302"><a href="#Reason-302" class="headerlink" title="Reason"></a>Reason</h5><p>Leaks are typically unacceptable.<br>Manual resource release is error-prone.<br>RAII (“Resource Acquisition Is Initialization”) is the simplest, most systematic way of preventing leaks.</p>
<h5 id="Example-266"><a href="#Example-266" class="headerlink" title="Example"></a>Example</h5><pre><code>void f1(int i)   // Bad: possibly leak
&#123;
    int* p = new int[12];
    // ...
    if (i &lt; 17) throw Bad&#123;&quot;in f()&quot;, i&#125;;
    // ...
&#125;
</code></pre>
<p>We could carefully release the resource before the throw:</p>
<pre><code>void f2(int i)   // Clumsy and error-prone: explicit release
&#123;
    int* p = new int[12];
    // ...
    if (i &lt; 17) &#123;
        delete[] p;
        throw Bad&#123;&quot;in f()&quot;, i&#125;;
    &#125;
    // ...
&#125;
</code></pre>
<p>This is verbose. In larger code with multiple possible <code>throw</code>s explicit releases become repetitive and error-prone.</p>
<pre><code>void f3(int i)   // OK: resource management done by a handle (but see below)
&#123;
    auto p = make_unique&lt;int[]&gt;(12);
    // ...
    if (i &lt; 17) throw Bad&#123;&quot;in f()&quot;, i&#125;;
    // ...
&#125;
</code></pre>
<p>Note that this works even when the <code>throw</code> is implicit because it happened in a called function:</p>
<pre><code>void f4(int i)   // OK: resource management done by a handle (but see below)
&#123;
    auto p = make_unique&lt;int[]&gt;(12);
    // ...
    helper(i);   // may throw
    // ...
&#125;
</code></pre>
<p>Unless you really need pointer semantics, use a local resource object:</p>
<pre><code>void f5(int i)   // OK: resource management done by local object
&#123;
    vector&lt;int&gt; v(12);
    // ...
    helper(i);   // may throw
    // ...
&#125;
</code></pre>
<p>That’s even simpler and safer, and often more efficient.</p>
<h5 id="Note-257"><a href="#Note-257" class="headerlink" title="Note"></a>Note</h5><p>If there is no obvious resource handle and for some reason defining a proper RAII object/handle is infeasible,<br>as a last resort, cleanup actions can be represented by a <a href="#Re-finally"><code>final_action</code></a> object.</p>
<h5 id="Note-258"><a href="#Note-258" class="headerlink" title="Note"></a>Note</h5><p>But what do we do if we are writing a program where exceptions cannot be used?<br>First challenge that assumption; there are many anti-exceptions myths around.<br>We know of only a few good reasons:</p>
<ul>
<li>We are on a system so small that the exception support would eat up most of our 2K memory.</li>
<li>We are in a hard-real-time system and we don’t have tools that guarantee us that an exception is handled within the required time.</li>
<li>We are in a system with tons of legacy code using lots of pointers in difficult-to-understand ways<br>(in particular without a recognizable ownership strategy) so that exceptions could cause leaks.</li>
<li>Our implementation of the C++ exception mechanisms is unreasonably poor<br>(slow, memory consuming, failing to work correctly for dynamically linked libraries, etc.).<br>Complain to your implementation purveyor; if no user complains, no improvement will happen.</li>
<li>We get fired if we challenge our manager’s ancient wisdom.</li>
</ul>
<p>Only the first of these reasons is fundamental, so whenever possible, use exceptions to implement RAII, or design your RAII objects to never fail.<br>When exceptions cannot be used, simulate RAII.<br>That is, systematically check that objects are valid after construction and still release all resources in the destructor.<br>One strategy is to add a <code>valid()</code> operation to every resource handle:</p>
<pre><code>void f()
&#123;
    vector&lt;string&gt; vs(100);   // not std::vector: valid() added
    if (!vs.valid()) &#123;
        // handle error or exit
    &#125;

    ifstream fs(&quot;foo&quot;);   // not std::ifstream: valid() added
    if (!fs.valid()) &#123;
        // handle error or exit
    &#125;

    // ...
&#125; // destructors clean up as usual
</code></pre>
<p>Obviously, this increases the size of the code, doesn’t allow for implicit propagation of “exceptions” (<code>valid()</code> checks), and <code>valid()</code> checks can be forgotten.<br>Prefer to use exceptions.</p>
<p><strong>See also</strong>: <a href="#Se-noexcept">Use of <code>noexcept</code></a></p>
<h5 id="Enforcement-278"><a href="#Enforcement-278" class="headerlink" title="Enforcement"></a>Enforcement</h5><p>???</p>
<h3 id="E-7-State-your-preconditions"><a href="#E-7-State-your-preconditions" class="headerlink" title="E.7: State your preconditions"></a><a name="Re-precondition"></a>E.7: State your preconditions</h3><h5 id="Reason-303"><a href="#Reason-303" class="headerlink" title="Reason"></a>Reason</h5><p>To avoid interface errors.</p>
<p><strong>See also</strong>: <a href="#Ri-pre">precondition rule</a></p>
<h3 id="E-8-State-your-postconditions"><a href="#E-8-State-your-postconditions" class="headerlink" title="E.8: State your postconditions"></a><a name="Re-postcondition"></a>E.8: State your postconditions</h3><h5 id="Reason-304"><a href="#Reason-304" class="headerlink" title="Reason"></a>Reason</h5><p>To avoid interface errors.</p>
<p><strong>See also</strong>: <a href="#Ri-post">postcondition rule</a></p>
<h3 id="E-12-Use-noexcept-when-exiting-a-function-because-of-a-throw-is-impossible-or-unacceptable"><a href="#E-12-Use-noexcept-when-exiting-a-function-because-of-a-throw-is-impossible-or-unacceptable" class="headerlink" title="E.12: Use noexcept when exiting a function because of a throw is impossible or unacceptable"></a><a name="Re-noexcept"></a>E.12: Use <code>noexcept</code> when exiting a function because of a <code>throw</code> is impossible or unacceptable</h3><h5 id="Reason-305"><a href="#Reason-305" class="headerlink" title="Reason"></a>Reason</h5><p>To make error handling systematic, robust, and efficient.</p>
<h5 id="Example-267"><a href="#Example-267" class="headerlink" title="Example"></a>Example</h5><pre><code>double compute(double d) noexcept
&#123;
    return log(sqrt(d &lt;= 0 ? 1 : d));
&#125;
</code></pre>
<p>Here, we know that <code>compute</code> will not throw because it is composed out of operations that don’t throw.<br>By declaring <code>compute</code> to be <code>noexcept</code>, we give the compiler and human readers information that can make it easier for them to understand and manipulate <code>compute</code>.</p>
<h5 id="Note-259"><a href="#Note-259" class="headerlink" title="Note"></a>Note</h5><p>Many standard-library functions are <code>noexcept</code> including all the standard-library functions “inherited” from the C Standard Library.</p>
<h5 id="Example-268"><a href="#Example-268" class="headerlink" title="Example"></a>Example</h5><pre><code>vector&lt;double&gt; munge(const vector&lt;double&gt;&amp; v) noexcept
&#123;
    vector&lt;double&gt; v2(v.size());
    // ... do something ...
&#125;
</code></pre>
<p>The <code>noexcept</code> here states that I am not willing or able to handle the situation where I cannot construct the local <code>vector</code>.<br>That is, I consider memory exhaustion a serious design error (on par with hardware failures) so that I’m willing to crash the program if it happens.</p>
<h5 id="Note-260"><a href="#Note-260" class="headerlink" title="Note"></a>Note</h5><p>Do not use traditional <a href="#Re-specifications">exception-specifications</a>.</p>
<h5 id="See-also-3"><a href="#See-also-3" class="headerlink" title="See also"></a>See also</h5><p><a href="#Sd-noexcept">discussion</a>.</p>
<h3 id="E-13-Never-throw-while-being-the-direct-owner-of-an-object"><a href="#E-13-Never-throw-while-being-the-direct-owner-of-an-object" class="headerlink" title="E.13: Never throw while being the direct owner of an object"></a><a name="Re-never-throw"></a>E.13: Never throw while being the direct owner of an object</h3><h5 id="Reason-306"><a href="#Reason-306" class="headerlink" title="Reason"></a>Reason</h5><p>That would be a leak.</p>
<h5 id="Example-269"><a href="#Example-269" class="headerlink" title="Example"></a>Example</h5><pre><code>void leak(int x)   // don&#39;t: may leak
&#123;
    auto p = new int&#123;7&#125;;
    if (x &lt; 0) throw Get_me_out_of_here&#123;&#125;;  // may leak *p
    // ...
    delete p;   // we may never get here
&#125;
</code></pre>
<p>One way of avoiding such problems is to use resource handles consistently:</p>
<pre><code>void no_leak(int x)
&#123;
    auto p = make_unique&lt;int&gt;(7);
    if (x &lt; 0) throw Get_me_out_of_here&#123;&#125;;  // will delete *p if necessary
    // ...
    // no need for delete p
&#125;
</code></pre>
<p>Another solution (often better) would be to use a local variable to eliminate explicit use of pointers:</p>
<pre><code>void no_leak_simplified(int x)
&#123;
    vector&lt;int&gt; v(7);
    // ...
&#125;
</code></pre>
<h5 id="Note-261"><a href="#Note-261" class="headerlink" title="Note"></a>Note</h5><p>If you have local “things” that requires cleanup, but is not represented by an object with a destructor, such cleanup must<br>also be done before a <code>throw</code>.<br>Sometimes, <a href="#Re-finally"><code>finally()</code></a> can make such unsystematic cleanup a bit more manageable.</p>
<h3 id="E-14-Use-purpose-designed-user-defined-types-as-exceptions-not-built-in-types"><a href="#E-14-Use-purpose-designed-user-defined-types-as-exceptions-not-built-in-types" class="headerlink" title="E.14: Use purpose-designed user-defined types as exceptions (not built-in types)"></a><a name="Re-exception-types"></a>E.14: Use purpose-designed user-defined types as exceptions (not built-in types)</h3><h5 id="Reason-307"><a href="#Reason-307" class="headerlink" title="Reason"></a>Reason</h5><p>A user-defined type is unlikely to clash with other people’s exceptions.</p>
<h5 id="Example-270"><a href="#Example-270" class="headerlink" title="Example"></a>Example</h5><pre><code>void my_code()
&#123;
    // ...
    throw Moonphase_error&#123;&#125;;
    // ...
&#125;

void your_code()
&#123;
    try &#123;
        // ...
        my_code();
        // ...
    &#125;
    catch(const Bufferpool_exhausted&amp;) &#123;
        // ...
    &#125;
&#125;
</code></pre>
<h5 id="Example-don’t-4"><a href="#Example-don’t-4" class="headerlink" title="Example, don’t"></a>Example, don’t</h5><pre><code>void my_code()     // Don&#39;t
&#123;
    // ...
    throw 7;       // 7 means &quot;moon in the 4th quarter&quot;
    // ...
&#125;

void your_code()   // Don&#39;t
&#123;
    try &#123;
        // ...
        my_code();
        // ...
    &#125;
    catch(int i) &#123;  // i == 7 means &quot;input buffer too small&quot;
        // ...
    &#125;
&#125;
</code></pre>
<h5 id="Note-262"><a href="#Note-262" class="headerlink" title="Note"></a>Note</h5><p>The standard-library classes derived from <code>exception</code> should be used only as base classes or for exceptions that require only “generic” handling. Like built-in types, their use could clash with other people’s use of them.</p>
<h5 id="Example-don’t-5"><a href="#Example-don’t-5" class="headerlink" title="Example, don’t"></a>Example, don’t</h5><pre><code>void my_code()   // Don&#39;t
&#123;
    // ...
    throw runtime_error&#123;&quot;moon in the 4th quarter&quot;&#125;;
    // ...
&#125;

void your_code()   // Don&#39;t
&#123;
    try &#123;
        // ...
        my_code();
        // ...
    &#125;
    catch(const runtime_error&amp;) &#123;   // runtime_error means &quot;input buffer too small&quot;
        // ...
    &#125;
&#125;
</code></pre>
<p><strong>See also</strong>: <a href="#Sd-???">Discussion</a></p>
<h5 id="Enforcement-279"><a href="#Enforcement-279" class="headerlink" title="Enforcement"></a>Enforcement</h5><p>Catch <code>throw</code> and <code>catch</code> of a built-in type. Maybe warn about <code>throw</code> and <code>catch</code> using a standard-library <code>exception</code> type. Obviously, exceptions derived from the <code>std::exception</code> hierarchy are fine.</p>
<h3 id="E-15-Catch-exceptions-from-a-hierarchy-by-reference"><a href="#E-15-Catch-exceptions-from-a-hierarchy-by-reference" class="headerlink" title="E.15: Catch exceptions from a hierarchy by reference"></a><a name="Re-exception-ref"></a>E.15: Catch exceptions from a hierarchy by reference</h3><h5 id="Reason-308"><a href="#Reason-308" class="headerlink" title="Reason"></a>Reason</h5><p>To prevent slicing.</p>
<h5 id="Example-271"><a href="#Example-271" class="headerlink" title="Example"></a>Example</h5><pre><code>void f()
&#123;
    try &#123;
        // ...
    &#125;
    catch (exception e) &#123;   // don&#39;t: may slice
        // ...
    &#125;
&#125;
</code></pre>
<p>Instead, use a reference:</p>
<pre><code>catch (exception&amp; e) &#123; /* ... */ &#125;
</code></pre>
<p>of - typically better still - a <code>const</code> reference:</p>
<pre><code>catch (const exception&amp; e) &#123; /* ... */ &#125;
</code></pre>
<p>Most handlers do not modify their exception and in general we <a href="#Res-const">recommend use of <code>const</code></a>.</p>
<h5 id="Note-263"><a href="#Note-263" class="headerlink" title="Note"></a>Note</h5><p>To rethrow a caught exception use <code>throw;</code> not <code>throw e;</code>. Using <code>throw e;</code> would throw a new copy of <code>e</code> (sliced to the static type <code>std::exception</code>) instead of rethrowing the original exception of type <code>std::runtime_error</code>. (But keep <a href="https://github.com/isocpp/CppCoreGuidelines/blob/master/CppCoreGuidelines.md#Re-not-always">Don’t try to catch every exception in every function</a> and <a href="https://github.com/isocpp/CppCoreGuidelines/blob/master/CppCoreGuidelines.md#Re-catch">Minimize the use of explicit <code>try</code>/<code>catch</code></a> in mind.)</p>
<h5 id="Enforcement-280"><a href="#Enforcement-280" class="headerlink" title="Enforcement"></a>Enforcement</h5><p>Flag by-value exceptions if their types are part of a hierarchy (could require whole-program analysis to be perfect).</p>
<h3 id="E-16-Destructors-deallocation-and-swap-must-never-fail"><a href="#E-16-Destructors-deallocation-and-swap-must-never-fail" class="headerlink" title="E.16: Destructors, deallocation, and swap must never fail"></a><a name="Re-never-fail"></a>E.16: Destructors, deallocation, and <code>swap</code> must never fail</h3><h5 id="Reason-309"><a href="#Reason-309" class="headerlink" title="Reason"></a>Reason</h5><p>We don’t know how to write reliable programs if a destructor, a swap, or a memory deallocation fails; that is, if it exits by an exception or simply doesn’t perform its required action.</p>
<h5 id="Example-don’t-6"><a href="#Example-don’t-6" class="headerlink" title="Example, don’t"></a>Example, don’t</h5><pre><code>class Connection &#123;
    // ...
public:
    ~Connection()   // Don&#39;t: very bad destructor
    &#123;
        if (cannot_disconnect()) throw I_give_up&#123;information&#125;;
        // ...
    &#125;
&#125;;
</code></pre>
<h5 id="Note-264"><a href="#Note-264" class="headerlink" title="Note"></a>Note</h5><p>Many have tried to write reliable code violating this rule for examples, such as a network connection that “refuses to close”.<br>To the best of our knowledge nobody has found a general way of doing this.<br>Occasionally, for very specific examples, you can get away with setting some state for future cleanup.<br>For example, we might put a socket that does not want to close on a “bad socket” list,<br>to be examined by a regular sweep of the system state.<br>Every example we have seen of this is error-prone, specialized, and often buggy.</p>
<h5 id="Note-265"><a href="#Note-265" class="headerlink" title="Note"></a>Note</h5><p>The standard library assumes that destructors, deallocation functions (e.g., <code>operator delete</code>), and <code>swap</code> do not throw. If they do, basic standard-library invariants are broken.</p>
<h5 id="Note-266"><a href="#Note-266" class="headerlink" title="Note"></a>Note</h5><p>Deallocation functions, including <code>operator delete</code>, must be <code>noexcept</code>. <code>swap</code> functions must be <code>noexcept</code>.<br>Most destructors are implicitly <code>noexcept</code> by default.<br>Also, <a href="#Rc-move-noexcept">make move operations <code>noexcept</code></a>.</p>
<h5 id="Enforcement-281"><a href="#Enforcement-281" class="headerlink" title="Enforcement"></a>Enforcement</h5><p>Catch destructors, deallocation operations, and <code>swap</code>s that <code>throw</code>.<br>Catch such operations that are not <code>noexcept</code>.</p>
<p><strong>See also</strong>: <a href="#Sd-never-fail">discussion</a></p>
<h3 id="E-17-Don’t-try-to-catch-every-exception-in-every-function"><a href="#E-17-Don’t-try-to-catch-every-exception-in-every-function" class="headerlink" title="E.17: Don’t try to catch every exception in every function"></a><a name="Re-not-always"></a>E.17: Don’t try to catch every exception in every function</h3><h5 id="Reason-310"><a href="#Reason-310" class="headerlink" title="Reason"></a>Reason</h5><p>Catching an exception in a function that cannot take a meaningful recovery action leads to complexity and waste.<br>Let an exception propagate until it reaches a function that can handle it.<br>Let cleanup actions on the unwinding path be handled by <a href="#Re-raii">RAII</a>.</p>
<h5 id="Example-don’t-7"><a href="#Example-don’t-7" class="headerlink" title="Example, don’t"></a>Example, don’t</h5><pre><code>void f()   // bad
&#123;
    try &#123;
        // ...
    &#125;
    catch (...) &#123;
        // no action
        throw;   // propagate exception
    &#125;
&#125;
</code></pre>
<h5 id="Enforcement-282"><a href="#Enforcement-282" class="headerlink" title="Enforcement"></a>Enforcement</h5><ul>
<li>Flag nested try-blocks.</li>
<li>Flag source code files with a too high ratio of try-blocks to functions. (??? Problem: define “too high”)</li>
</ul>
<h3 id="E-18-Minimize-the-use-of-explicit-try-catch"><a href="#E-18-Minimize-the-use-of-explicit-try-catch" class="headerlink" title="E.18: Minimize the use of explicit try/catch"></a><a name="Re-catch"></a>E.18: Minimize the use of explicit <code>try</code>/<code>catch</code></h3><h5 id="Reason-311"><a href="#Reason-311" class="headerlink" title="Reason"></a>Reason</h5><p> <code>try</code>/<code>catch</code> is verbose and non-trivial uses error-prone.<br> <code>try</code>/<code>catch</code> can be a sign of unsystematic and/or low-level resource management or error handling.</p>
<h5 id="Example-Bad"><a href="#Example-Bad" class="headerlink" title="Example, Bad"></a>Example, Bad</h5><pre><code>void f(zstring s)
&#123;
    Gadget* p;
    try &#123;
        p = new Gadget(s);
        // ...
        delete p;
    &#125;
    catch (Gadget_construction_failure) &#123;
        delete p;
        throw;
    &#125;
&#125;
</code></pre>
<p>This code is messy.<br>There could be a leak from the naked pointer in the <code>try</code> block.<br>Not all exceptions are handled.<br><code>deleting</code> an object that failed to construct is almost certainly a mistake.<br>Better:</p>
<pre><code>void f2(zstring s)
&#123;
    Gadget g &#123;s&#125;;
&#125;
</code></pre>
<h5 id="Alternatives-4"><a href="#Alternatives-4" class="headerlink" title="Alternatives"></a>Alternatives</h5><ul>
<li>proper resource handles and <a href="#Re-raii">RAII</a></li>
<li><a href="#Re-finally"><code>finally</code></a></li>
</ul>
<h5 id="Enforcement-283"><a href="#Enforcement-283" class="headerlink" title="Enforcement"></a>Enforcement</h5><p>??? hard, needs a heuristic</p>
<h3 id="E-19-Use-a-final-action-object-to-express-cleanup-if-no-suitable-resource-handle-is-available"><a href="#E-19-Use-a-final-action-object-to-express-cleanup-if-no-suitable-resource-handle-is-available" class="headerlink" title="E.19: Use a final_action object to express cleanup if no suitable resource handle is available"></a><a name="Re-finally"></a>E.19: Use a <code>final_action</code> object to express cleanup if no suitable resource handle is available</h3><h5 id="Reason-312"><a href="#Reason-312" class="headerlink" title="Reason"></a>Reason</h5><p><code>finally</code> is less verbose and harder to get wrong than <code>try</code>/<code>catch</code>.</p>
<h5 id="Example-272"><a href="#Example-272" class="headerlink" title="Example"></a>Example</h5><pre><code>void f(int n)
&#123;
    void* p = malloc(1, n);
    auto _ = finally([p] &#123; free(p); &#125;);
    // ...
&#125;
</code></pre>
<h5 id="Note-267"><a href="#Note-267" class="headerlink" title="Note"></a>Note</h5><p><code>finally</code> is not as messy as <code>try</code>/<code>catch</code>, but it is still ad-hoc.<br>Prefer <a href="#Re-raii">proper resource management objects</a>.<br>Consider <code>finally</code> a last resort.</p>
<h5 id="Note-268"><a href="#Note-268" class="headerlink" title="Note"></a>Note</h5><p>Use of <code>finally</code> is a systematic and reasonably clean alternative to the old <a href="#Re-no-throw-codes"><code>goto exit;</code> technique</a><br>for dealing with cleanup where resource management is not systematic.</p>
<h5 id="Enforcement-284"><a href="#Enforcement-284" class="headerlink" title="Enforcement"></a>Enforcement</h5><p>Heuristic: Detect <code>goto exit;</code></p>
<h3 id="E-25-If-you-can’t-throw-exceptions-simulate-RAII-for-resource-management"><a href="#E-25-If-you-can’t-throw-exceptions-simulate-RAII-for-resource-management" class="headerlink" title="E.25: If you can’t throw exceptions, simulate RAII for resource management"></a><a name="Re-no-throw-raii"></a>E.25: If you can’t throw exceptions, simulate RAII for resource management</h3><h5 id="Reason-313"><a href="#Reason-313" class="headerlink" title="Reason"></a>Reason</h5><p>Even without exceptions, <a href="#Re-raii">RAII</a> is usually the best and most systematic way of dealing with resources.</p>
<h5 id="Note-269"><a href="#Note-269" class="headerlink" title="Note"></a>Note</h5><p>Error handling using exceptions is the only complete and systematic way of handling non-local errors in C++.<br>In particular, non-intrusively signaling failure to construct an object requires an exception.<br>Signaling errors in a way that cannot be ignored requires exceptions.<br>If you can’t use exceptions, simulate their use as best you can.</p>
<p>A lot of fear of exceptions is misguided.<br>When used for exceptional circumstances in code that is not littered with pointers and complicated control structures,<br>exception handling is almost always affordable (in time and space) and almost always leads to better code.<br>This, of course, assumes a good implementation of the exception handling mechanisms, which is not available on all systems.<br>There are also cases where the problems above do not apply, but exceptions cannot be used for other reasons.<br>Some hard-real-time systems are an example: An operation has to be completed within a fixed time with an error or a correct answer.<br>In the absence of appropriate time estimation tools, this is hard to guarantee for exceptions.<br>Such systems (e.g. flight control software) typically also ban the use of dynamic (heap) memory.</p>
<p>So, the primary guideline for error handling is “use exceptions and <a href="#Re-raii">RAII</a>.”<br>This section deals with the cases where you either do not have an efficient implementation of exceptions,<br>or have such a rat’s nest of old-style code<br>(e.g., lots of pointers, ill-defined ownership, and lots of unsystematic error handling based on tests of error codes)<br>that it is infeasible to introduce simple and systematic exception handling.</p>
<p>Before condemning exceptions or complaining too much about their cost, consider examples of the use of <a href="#Re-no-throw-codes">error codes</a>.<br>Consider the cost and complexity of the use of error codes.<br>If performance is your worry, measure.</p>
<h5 id="Example-273"><a href="#Example-273" class="headerlink" title="Example"></a>Example</h5><p>Assume you wanted to write</p>
<pre><code>void func(zstring arg)
&#123;
    Gadget g &#123;arg&#125;;
    // ...
&#125;
</code></pre>
<p>If the <code>gadget</code> isn’t correctly constructed, <code>func</code> exits with an exception.<br>If we cannot throw an exception, we can simulate this RAII style of resource handling by adding a <code>valid()</code> member function to <code>Gadget</code>:</p>
<pre><code>error_indicator func(zstring arg)
&#123;
    Gadget g &#123;arg&#125;;
    if (!g.valid()) return gadget_construction_error;
    // ...
    return 0;   // zero indicates &quot;good&quot;
&#125;
</code></pre>
<p>The problem is of course that the caller now has to remember to test the return value.</p>
<p><strong>See also</strong>: <a href="#Sd-???">Discussion</a></p>
<h5 id="Enforcement-285"><a href="#Enforcement-285" class="headerlink" title="Enforcement"></a>Enforcement</h5><p>Possible (only) for specific versions of this idea: e.g., test for systematic test of <code>valid()</code> after resource handle construction</p>
<h3 id="E-26-If-you-can’t-throw-exceptions-consider-failing-fast"><a href="#E-26-If-you-can’t-throw-exceptions-consider-failing-fast" class="headerlink" title="E.26: If you can’t throw exceptions, consider failing fast"></a><a name="Re-no-throw-crash"></a>E.26: If you can’t throw exceptions, consider failing fast</h3><h5 id="Reason-314"><a href="#Reason-314" class="headerlink" title="Reason"></a>Reason</h5><p>If you can’t do a good job at recovering, at least you can get out before too much consequential damage is done.</p>
<p><strong>See also</strong>: <a href="#Re-no-throw-raii">Simulating RAII</a></p>
<h5 id="Note-270"><a href="#Note-270" class="headerlink" title="Note"></a>Note</h5><p>If you cannot be systematic about error handling, consider “crashing” as a response to any error that cannot be handled locally.<br>That is, if you cannot recover from an error in the context of the function that detected it, call <code>abort()</code>, <code>quick_exit()</code>,<br>or a similar function that will trigger some sort of system restart.</p>
<p>In systems where you have lots of processes and/or lots of computers, you need to expect and handle fatal crashes anyway,<br>say from hardware failures.<br>In such cases, “crashing” is simply leaving error handling to the next level of the system.</p>
<h5 id="Example-274"><a href="#Example-274" class="headerlink" title="Example"></a>Example</h5><pre><code>void f(int n)
&#123;
    // ...
    p = static_cast&lt;X*&gt;(malloc(n, X));
    if (!p) abort();     // abort if memory is exhausted
    // ...
&#125;
</code></pre>
<p>Most programs cannot handle memory exhaustion gracefully anyway. This is roughly equivalent to</p>
<pre><code>void f(int n)
&#123;
    // ...
    p = new X[n];    // throw if memory is exhausted (by default, terminate)
    // ...
&#125;
</code></pre>
<p>Typically, it is a good idea to log the reason for the “crash” before exiting.</p>
<h5 id="Enforcement-286"><a href="#Enforcement-286" class="headerlink" title="Enforcement"></a>Enforcement</h5><p>Awkward</p>
<h3 id="E-27-If-you-can’t-throw-exceptions-use-error-codes-systematically"><a href="#E-27-If-you-can’t-throw-exceptions-use-error-codes-systematically" class="headerlink" title="E.27: If you can’t throw exceptions, use error codes systematically"></a><a name="Re-no-throw-codes"></a>E.27: If you can’t throw exceptions, use error codes systematically</h3><h5 id="Reason-315"><a href="#Reason-315" class="headerlink" title="Reason"></a>Reason</h5><p>Systematic use of any error-handling strategy minimizes the chance of forgetting to handle an error.</p>
<p><strong>See also</strong>: <a href="#Re-no-throw-raii">Simulating RAII</a></p>
<h5 id="Note-271"><a href="#Note-271" class="headerlink" title="Note"></a>Note</h5><p>There are several issues to be addressed:</p>
<ul>
<li>how do you transmit an error indicator from out of a function?</li>
<li>how do you release all resources from a function before doing an error exit?</li>
<li>What do you use as an error indicator?</li>
</ul>
<p>In general, returning an error indicator implies returning two values: The result and an error indicator.<br>The error indicator can be part of the object, e.g. an object can have a <code>valid()</code> indicator<br>or a pair of values can be returned.</p>
<h5 id="Example-275"><a href="#Example-275" class="headerlink" title="Example"></a>Example</h5><pre><code>Gadget make_gadget(int n)
&#123;
    // ...
&#125;

void user()
&#123;
    Gadget g = make_gadget(17);
    if (!g.valid()) &#123;
            // error handling
    &#125;
    // ...
&#125;
</code></pre>
<p>This approach fits with <a href="#Re-no-throw-raii">simulated RAII resource management</a>.<br>The <code>valid()</code> function could return an <code>error_indicator</code> (e.g. a member of an <code>error_indicator</code> enumeration).</p>
<h5 id="Example-276"><a href="#Example-276" class="headerlink" title="Example"></a>Example</h5><p>What if we cannot or do not want to modify the <code>Gadget</code> type?<br>In that case, we must return a pair of values.<br>For example:</p>
<pre><code>std::pair&lt;Gadget, error_indicator&gt; make_gadget(int n)
&#123;
    // ...
&#125;

void user()
&#123;
    auto r = make_gadget(17);
    if (!r.second) &#123;
            // error handling
    &#125;
    Gadget&amp; g = r.first;
    // ...
&#125;
</code></pre>
<p>As shown, <code>std::pair</code> is a possible return type.<br>Some people prefer a specific type.<br>For example:</p>
<pre><code>Gval make_gadget(int n)
&#123;
    // ...
&#125;

void user()
&#123;
    auto r = make_gadget(17);
    if (!r.err) &#123;
            // error handling
    &#125;
    Gadget&amp; g = r.val;
    // ...
&#125;
</code></pre>
<p>One reason to prefer a specific return type is to have names for its members, rather than the somewhat cryptic <code>first</code> and <code>second</code><br>and to avoid confusion with other uses of <code>std::pair</code>.</p>
<h5 id="Example-277"><a href="#Example-277" class="headerlink" title="Example"></a>Example</h5><p>In general, you must clean up before an error exit.<br>This can be messy:</p>
<pre><code>std::pair&lt;int, error_indicator&gt; user()
&#123;
    Gadget g1 = make_gadget(17);
    if (!g1.valid()) &#123;
            return &#123;0, g1_error&#125;;
    &#125;

    Gadget g2 = make_gadget(17);
    if (!g2.valid()) &#123;
            cleanup(g1);
            return &#123;0, g2_error&#125;;
    &#125;

    // ...

    if (all_foobar(g1, g2)) &#123;
        cleanup(g1);
        cleanup(g2);
        return &#123;0, foobar_error&#125;;
    // ...

    cleanup(g1);
    cleanup(g2);
    return &#123;res, 0&#125;;
&#125;
</code></pre>
<p>Simulating RAII can be non-trivial, especially in functions with multiple resources and multiple possible errors.<br>A not uncommon technique is to gather cleanup at the end of the function to avoid repetition:</p>
<pre><code>std::pair&lt;int, error_indicator&gt; user()
&#123;
    error_indicator err = 0;

    Gadget g1 = make_gadget(17);
    if (!g1.valid()) &#123;
            err = g1_error;
            goto exit;
    &#125;

    Gadget g2 = make_gadget(17);
    if (!g2.valid()) &#123;
            err = g2_error;
            goto exit;
    &#125;

    if (all_foobar(g1, g2)) &#123;
        err = foobar_error;
        goto exit;
    &#125;
    // ...

exit:
  if (g1.valid()) cleanup(g1);
  if (g2.valid()) cleanup(g2);
  return &#123;res, err&#125;;
&#125;
</code></pre>
<p>The larger the function, the more tempting this technique becomes.<br><code>finally</code> can <a href="#Re-finally">ease the pain a bit</a>.<br>Also, the larger the program becomes the harder it is to apply an error-indicator-based error-handling strategy systematically.</p>
<p>We <a href="#Re-throw">prefer exception-based error handling</a> and recommend <a href="#Rf-single">keeping functions short</a>.</p>
<p><strong>See also</strong>: <a href="#Sd-???">Discussion</a></p>
<p><strong>See also</strong>: <a href="#Rf-out-multi">Returning multiple values</a></p>
<h5 id="Enforcement-287"><a href="#Enforcement-287" class="headerlink" title="Enforcement"></a>Enforcement</h5><p>Awkward.</p>
<h3 id="E-28-Avoid-error-handling-based-on-global-state-e-g-errno"><a href="#E-28-Avoid-error-handling-based-on-global-state-e-g-errno" class="headerlink" title="E.28: Avoid error handling based on global state (e.g. errno)"></a><a name="Re-no-throw"></a>E.28: Avoid error handling based on global state (e.g. <code>errno</code>)</h3><h5 id="Reason-316"><a href="#Reason-316" class="headerlink" title="Reason"></a>Reason</h5><p>Global state is hard to manage and it is easy to forget to check it.<br>When did you last test the return value of <code>printf()</code>?</p>
<p><strong>See also</strong>: <a href="#Re-no-throw-raii">Simulating RAII</a></p>
<h5 id="Example-bad-121"><a href="#Example-bad-121" class="headerlink" title="Example, bad"></a>Example, bad</h5><pre><code>???
</code></pre>
<h5 id="Note-272"><a href="#Note-272" class="headerlink" title="Note"></a>Note</h5><p>C-style error handling is based on the global variable <code>errno</code>, so it is essentially impossible to avoid this style completely.</p>
<h5 id="Enforcement-288"><a href="#Enforcement-288" class="headerlink" title="Enforcement"></a>Enforcement</h5><p>Awkward.</p>
<h3 id="E-30-Don’t-use-exception-specifications"><a href="#E-30-Don’t-use-exception-specifications" class="headerlink" title="E.30: Don’t use exception specifications"></a><a name="Re-specifications"></a>E.30: Don’t use exception specifications</h3><h5 id="Reason-317"><a href="#Reason-317" class="headerlink" title="Reason"></a>Reason</h5><p>Exception specifications make error handling brittle, impose a run-time cost, and have been removed from the C++ standard.</p>
<h5 id="Example-278"><a href="#Example-278" class="headerlink" title="Example"></a>Example</h5><pre><code>int use(int arg)
    throw(X, Y)
&#123;
    // ...
    auto x = f(arg);
    // ...
&#125;
</code></pre>
<p>If <code>f()</code> throws an exception different from <code>X</code> and <code>Y</code> the unexpected handler is invoked, which by default terminates.<br>That’s OK, but say that we have checked that this cannot happen and <code>f</code> is changed to throw a new exception <code>Z</code>,<br>we now have a crash on our hands unless we change <code>use()</code> (and re-test everything).<br>The snag is that <code>f()</code> may be in a library we do not control and the new exception is not anything that <code>use()</code> can do<br>anything about or is in any way interested in.<br>We can change <code>use()</code> to pass <code>Z</code> through, but now <code>use()</code>‘s callers probably needs to be modified.<br>This quickly becomes unmanageable.<br>Alternatively, we can add a <code>try</code>-<code>catch</code> to <code>use()</code> to map <code>Z</code> into an acceptable exception.<br>This too, quickly becomes unmanageable.<br>Note that changes to the set of exceptions often happens at the lowest level of a system<br>(e.g., because of changes to a network library or some middleware), so changes “bubble up” through long call chains.<br>In a large code base, this could mean that nobody could update to a new version of a library until the last user was modified.<br>If <code>use()</code> is part of a library, it may not be possible to update it because a change could affect unknown clients.</p>
<p>The policy of letting exceptions propagate until they reach a function that potentially can handle it has proven itself over the years.</p>
<h5 id="Note-273"><a href="#Note-273" class="headerlink" title="Note"></a>Note</h5><p>No. This would not be any better had exception specifications been statically enforced.<br>For example, see <a href="#Stroustrup94">Stroustrup94</a>.</p>
<h5 id="Note-274"><a href="#Note-274" class="headerlink" title="Note"></a>Note</h5><p>If no exception may be thrown, use <a href="#Re-noexcept"><code>noexcept</code></a> or its equivalent <code>throw()</code>.</p>
<h5 id="Enforcement-289"><a href="#Enforcement-289" class="headerlink" title="Enforcement"></a>Enforcement</h5><p>Flag every exception specification.</p>
<h3 id="E-31-Properly-order-your-catch-clauses"><a href="#E-31-Properly-order-your-catch-clauses" class="headerlink" title="E.31: Properly order your catch-clauses"></a><a name="Re_catch"></a>E.31: Properly order your <code>catch</code>-clauses</h3><h5 id="Reason-318"><a href="#Reason-318" class="headerlink" title="Reason"></a>Reason</h5><p><code>catch</code>-clauses are evaluated in the order they appear and one clause can hide another.</p>
<h5 id="Example-279"><a href="#Example-279" class="headerlink" title="Example"></a>Example</h5><pre><code>void f()
&#123;
    // ...
    try &#123;
            // ...
    &#125;
    catch (Base&amp; b) &#123; /* ... */ &#125;
    catch (Derived&amp; d) &#123; /* ... */ &#125;
    catch (...) &#123; /* ... */ &#125;
    catch (std::exception&amp; e)&#123; /* ... */ &#125;
&#125;
</code></pre>
<p>If <code>Derived</code>is derived from <code>Base</code> the <code>Derived</code>-handler will never be invoked.<br>The “catch everything” handler ensured that the <code>std::exception</code>-handler will never be invoked.</p>
<h5 id="Enforcement-290"><a href="#Enforcement-290" class="headerlink" title="Enforcement"></a>Enforcement</h5><p>Flag all “hiding handlers”.</p>
<h1 id="Con-Constants-and-immutability"><a href="#Con-Constants-and-immutability" class="headerlink" title="Con: Constants and immutability"></a><a name="S-const"></a>Con: Constants and immutability</h1><p>You can’t have a race condition on a constant.<br>It is easier to reason about a program when many of the objects cannot change their values.<br>Interfaces that promises “no change” of objects passed as arguments greatly increase readability.</p>
<p>Constant rule summary:</p>
<ul>
<li><a href="#Rconst-immutable">Con.1: By default, make objects immutable</a></li>
<li><a href="#Rconst-fct">Con.2: By default, make member functions <code>const</code></a></li>
<li><a href="#Rconst-ref">Con.3: By default, pass pointers and references to <code>const</code>s</a></li>
<li><a href="#Rconst-const">Con.4: Use <code>const</code> to define objects with values that do not change after construction</a></li>
<li><a href="#Rconst-constexpr">Con.5: Use <code>constexpr</code> for values that can be computed at compile time</a></li>
</ul>
<h3 id="Con-1-By-default-make-objects-immutable"><a href="#Con-1-By-default-make-objects-immutable" class="headerlink" title="Con.1: By default, make objects immutable"></a><a name="Rconst-immutable"></a>Con.1: By default, make objects immutable</h3><h5 id="Reason-319"><a href="#Reason-319" class="headerlink" title="Reason"></a>Reason</h5><p>Immutable objects are easier to reason about, so make objects non-<code>const</code> only when there is a need to change their value.<br>Prevents accidental or hard-to-notice change of value.</p>
<h5 id="Example-280"><a href="#Example-280" class="headerlink" title="Example"></a>Example</h5><pre><code>for (const int i : c) cout &lt;&lt; i &lt;&lt; &#39;\n&#39;;    // just reading: const

for (int i : c) cout &lt;&lt; i &lt;&lt; &#39;\n&#39;;          // BAD: just reading
</code></pre>
<h5 id="Exception-49"><a href="#Exception-49" class="headerlink" title="Exception"></a>Exception</h5><p>Function arguments are rarely mutated, but also rarely declared const.<br>To avoid confusion and lots of false positives, don’t enforce this rule for function arguments.</p>
<pre><code>void f(const char* const p); // pedantic
void g(const int i);        // pedantic
</code></pre>
<p>Note that function parameter is a local variable so changes to it are local.</p>
<h5 id="Enforcement-291"><a href="#Enforcement-291" class="headerlink" title="Enforcement"></a>Enforcement</h5><ul>
<li>Flag non-<code>const</code> variables that are not modified (except for parameters to avoid many false positives)</li>
</ul>
<h3 id="Con-2-By-default-make-member-functions-const"><a href="#Con-2-By-default-make-member-functions-const" class="headerlink" title="Con.2: By default, make member functions const"></a><a name="Rconst-fct"></a>Con.2: By default, make member functions <code>const</code></h3><h5 id="Reason-320"><a href="#Reason-320" class="headerlink" title="Reason"></a>Reason</h5><p>A member function should be marked <code>const</code> unless it changes the object’s observable state.<br>This gives a more precise statement of design intent, better readability, more errors caught by the compiler, and sometimes more optimization opportunities.</p>
<h5 id="Example-bad-122"><a href="#Example-bad-122" class="headerlink" title="Example; bad"></a>Example; bad</h5><pre><code>class Point &#123;
    int x, y;
public:
    int getx() &#123; return x; &#125;    // BAD, should be const as it doesn&#39;t modify the object&#39;s state
    // ...
&#125;;

void f(const Point&amp; pt) &#123;
    int x = pt.getx();          // ERROR, doesn&#39;t compile because getx was not marked const
&#125;
</code></pre>
<h5 id="Note-275"><a href="#Note-275" class="headerlink" title="Note"></a>Note</h5><p>It is not inherently bad to pass a pointer or reference to non-<code>const</code>,<br>but that should be done only when the called function is supposed to modify the object.<br>A reader of code must assume that a function that takes a “plain” <code>T*</code> or <code>T&amp;</code> will modify the object referred to.<br>If it doesn’t now, it might do so later without forcing recompilation.</p>
<h5 id="Note-276"><a href="#Note-276" class="headerlink" title="Note"></a>Note</h5><p>There are code/libraries that are offer functions that declare a<code>T*</code> even though<br>those function do not modify that <code>T</code>.<br>This is a problem for people modernizing code.<br>You can</p>
<ul>
<li>update the library to be <code>const</code>-correct; preferred long-term solution</li>
<li>“cast away <code>const</code>“; <a href="#Res-casts-const">best avoided</a></li>
<li>provide a wrapper function</li>
</ul>
<p>Example:</p>
<pre><code>void f(int* p);   // old code: f() does not modify `*p`
void f(const int* p) &#123; f(const_cast&lt;int*&gt;(p)); &#125; // wrapper
</code></pre>
<p>Note that this wrapper solution is a patch that should be used only when the declaration of <code>f()</code> cannot be be modified,<br>e.g. because it is in a library that you cannot modify.</p>
<h5 id="Note-277"><a href="#Note-277" class="headerlink" title="Note"></a>Note</h5><p>A <code>const</code> member function can modify the value of an object that is <code>mutable</code> or accessed through a pointer member.<br>A common use is to maintain a cache rather than repeatedly do a complicated computation.<br>For example, here is a <code>Date</code> that caches (mnemonizes) its string representation to simplify repeated uses:</p>
<pre><code>class Date &#123;
public:
    // ...
    const string&amp; string_ref() const
    &#123;
        if (string_val == &quot;&quot;) compute_string_rep();
        return string_val;
    &#125;
    // ...
private:
    void compute_string_rep() const;    // compute string representation and place it in string_val
    mutable string string_val;
    // ...
&#125;;
</code></pre>
<p>Another way of saying this is that <code>const</code>ness is not transitive.<br>It is possible for a <code>const</code> member function to change the value of <code>mutable</code> members and the value of objects accessed<br>through non-<code>const</code> pointers.<br>It is the job of the class to ensure such mutation is done only when it makes sense according to the semantics (invariants)<br>it offers to its users.</p>
<p><strong>See also</strong>: <a href="#Ri-pimpl">Pimpl</a></p>
<h5 id="Enforcement-292"><a href="#Enforcement-292" class="headerlink" title="Enforcement"></a>Enforcement</h5><ul>
<li>Flag a member function that is not marked <code>const</code>, but that does not perform a non-<code>const</code> operation on any member variable.</li>
</ul>
<h3 id="Con-3-By-default-pass-pointers-and-references-to-consts"><a href="#Con-3-By-default-pass-pointers-and-references-to-consts" class="headerlink" title="Con.3: By default, pass pointers and references to consts"></a><a name="Rconst-ref"></a>Con.3: By default, pass pointers and references to <code>const</code>s</h3><h5 id="Reason-321"><a href="#Reason-321" class="headerlink" title="Reason"></a>Reason</h5><p> To avoid a called function unexpectedly changing the value.<br> It’s far easier to reason about programs when called functions don’t modify state.</p>
<h5 id="Example-281"><a href="#Example-281" class="headerlink" title="Example"></a>Example</h5><pre><code>void f(char* p);        // does f modify *p? (assume it does)
void g(const char* p);  // g does not modify *p
</code></pre>
<h5 id="Note-278"><a href="#Note-278" class="headerlink" title="Note"></a>Note</h5><p>It is not inherently bad to pass a pointer or reference to non-<code>const</code>,<br>but that should be done only when the called function is supposed to modify the object.</p>
<h5 id="Note-279"><a href="#Note-279" class="headerlink" title="Note"></a>Note</h5><p><a href="#Res-casts-const">Do not cast away <code>const</code></a>.</p>
<h5 id="Enforcement-293"><a href="#Enforcement-293" class="headerlink" title="Enforcement"></a>Enforcement</h5><ul>
<li>Flag function that does not modify an object passed by  pointer or reference to non-<code>const</code></li>
<li>Flag a function that (using a cast) modifies an object passed by pointer or reference to <code>const</code></li>
</ul>
<h3 id="Con-4-Use-const-to-define-objects-with-values-that-do-not-change-after-construction"><a href="#Con-4-Use-const-to-define-objects-with-values-that-do-not-change-after-construction" class="headerlink" title="Con.4: Use const to define objects with values that do not change after construction"></a><a name="Rconst-const"></a>Con.4: Use <code>const</code> to define objects with values that do not change after construction</h3><h5 id="Reason-322"><a href="#Reason-322" class="headerlink" title="Reason"></a>Reason</h5><p> Prevent surprises from unexpectedly changed object values.</p>
<h5 id="Example-282"><a href="#Example-282" class="headerlink" title="Example"></a>Example</h5><pre><code>void f()
&#123;
    int x = 7;
    const int y = 9;

    for (;;) &#123;
        // ...
    &#125;
    // ...
&#125;
</code></pre>
<p>As <code>x</code> is not <code>const</code>, we must assume that it is modified somewhere in the loop.</p>
<h5 id="Enforcement-294"><a href="#Enforcement-294" class="headerlink" title="Enforcement"></a>Enforcement</h5><ul>
<li>Flag unmodified non-<code>const</code> variables.</li>
</ul>
<h3 id="Con-5-Use-constexpr-for-values-that-can-be-computed-at-compile-time"><a href="#Con-5-Use-constexpr-for-values-that-can-be-computed-at-compile-time" class="headerlink" title="Con.5: Use constexpr for values that can be computed at compile time"></a><a name="Rconst-constexpr"></a>Con.5: Use <code>constexpr</code> for values that can be computed at compile time</h3><h5 id="Reason-323"><a href="#Reason-323" class="headerlink" title="Reason"></a>Reason</h5><p>Better performance, better compile-time checking, guaranteed compile-time evaluation, no possibility of race conditions.</p>
<h5 id="Example-283"><a href="#Example-283" class="headerlink" title="Example"></a>Example</h5><pre><code>double x = f(2);            // possible run-time evaluation
const double y = f(2);      // possible run-time evaluation
constexpr double z = f(2);  // error unless f(2) can be evaluated at compile time
</code></pre>
<h5 id="Note-280"><a href="#Note-280" class="headerlink" title="Note"></a>Note</h5><p>See F.4.</p>
<h5 id="Enforcement-295"><a href="#Enforcement-295" class="headerlink" title="Enforcement"></a>Enforcement</h5><ul>
<li>Flag <code>const</code> definitions with constant expression initializers.</li>
</ul>
<h1 id="T-Templates-and-generic-programming"><a href="#T-Templates-and-generic-programming" class="headerlink" title="T: Templates and generic programming"></a><a name="S-templates"></a>T: Templates and generic programming</h1><p>Generic programming is programming using types and algorithms parameterized by types, values, and algorithms.<br>In C++, generic programming is supported by the <code>template</code> language mechanisms.</p>
<p>Arguments to generic functions are characterized by sets of requirements on the argument types and values involved.<br>In C++, these requirements are expressed by compile-time predicates called concepts.</p>
<p>Templates can also be used for meta-programming; that is, programs that compose code at compile time.</p>
<p>A central notion in generic programming is “concepts”; that is, requirements on template arguments presented as compile-time predicates.<br>“Concepts” are defined in an ISO Technical specification: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2015/n4553.pdf">concepts</a>.<br>A draft of a set of standard-library concepts can be found in another ISO TS: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/n4569.pdf">ranges</a><br>Concepts are supported in GCC 6.1 and later.<br>Consequently, we comment out uses of concepts in examples; that is, we use them as formalized comments only.<br>If you use GCC 6.1 or later, you can uncomment them.</p>
<p>Template use rule summary:</p>
<ul>
<li><a href="#Rt-raise">T.1: Use templates to raise the level of abstraction of code</a></li>
<li><a href="#Rt-algo">T.2: Use templates to express algorithms that apply to many argument types</a></li>
<li><a href="#Rt-cont">T.3: Use templates to express containers and ranges</a></li>
<li><a href="#Rt-expr">T.4: Use templates to express syntax tree manipulation</a></li>
<li><a href="#Rt-generic-oo">T.5: Combine generic and OO techniques to amplify their strengths, not their costs</a></li>
</ul>
<p>Concept use rule summary:</p>
<ul>
<li><a href="#Rt-concepts">T.10: Specify concepts for all template arguments</a></li>
<li><a href="#Rt-std-concepts">T.11: Whenever possible use standard concepts</a></li>
<li><a href="#Rt-auto">T.12: Prefer concept names over <code>auto</code> for local variables</a></li>
<li><a href="#Rt-shorthand">T.13: Prefer the shorthand notation for simple, single-type argument concepts</a></li>
<li>???</li>
</ul>
<p>Concept definition rule summary:</p>
<ul>
<li><a href="#Rt-low">T.20: Avoid “concepts” without meaningful semantics</a></li>
<li><a href="#Rt-complete">T.21: Require a complete set of operations for a concept</a></li>
<li><a href="#Rt-axiom">T.22: Specify axioms for concepts</a></li>
<li><a href="#Rt-refine">T.23: Differentiate a refined concept from its more general case by adding new use patterns</a></li>
<li><a href="#Rt-tag">T.24: Use tag classes or traits to differentiate concepts that differ only in semantics</a></li>
<li><a href="#Rt-not">T.25: Avoid complementary constraints</a></li>
<li><a href="#Rt-use">T.26: Prefer to define concepts in terms of use-patterns rather than simple syntax</a></li>
<li><a href="#Rt-not">T.30: Use concept negation (<code>!C&lt;T&gt;</code>) sparingly to express a minor difference</a></li>
<li><a href="#Rt-or">T.31: Use concept disjunction (<code>C1&lt;T&gt; || C2&lt;T&gt;</code>) sparingly to express alternatives</a></li>
<li>???</li>
</ul>
<p>Template interface rule summary:</p>
<ul>
<li><a href="#Rt-fo">T.40: Use function objects to pass operations to algorithms</a></li>
<li><a href="#Rt-essential">T.41: Require only essential properties in a template’s concepts</a></li>
<li><a href="#Rt-alias">T.42: Use template aliases to simplify notation and hide implementation details</a></li>
<li><a href="#Rt-using">T.43: Prefer <code>using</code> over <code>typedef</code> for defining aliases</a></li>
<li><a href="#Rt-deduce">T.44: Use function templates to deduce class template argument types (where feasible)</a></li>
<li><a href="#Rt-regular">T.46: Require template arguments to be at least <code>Regular</code> or <code>SemiRegular</code></a></li>
<li><a href="#Rt-visible">T.47: Avoid highly visible unconstrained templates with common names</a></li>
<li><a href="#Rt-concept-def">T.48: If your compiler does not support concepts, fake them with <code>enable_if</code></a></li>
<li><a href="#Rt-erasure">T.49: Where possible, avoid type-erasure</a></li>
</ul>
<p>Template definition rule summary:</p>
<ul>
<li><a href="#Rt-depend">T.60: Minimize a template’s context dependencies</a></li>
<li><a href="#Rt-scary">T.61: Do not over-parameterize members (SCARY)</a></li>
<li><a href="#Rt-nondependent">T.62: Place non-dependent class template members in a non-templated base class</a></li>
<li><a href="#Rt-specialization">T.64: Use specialization to provide alternative implementations of class templates</a></li>
<li><a href="#Rt-tag-dispatch">T.65: Use tag dispatch to provide alternative implementations of functions</a></li>
<li><a href="#Rt-specialization2">T.67: Use specialization to provide alternative implementations for irregular types</a></li>
<li><a href="#Rt-cast">T.68: Use <code>&#123;&#125;</code> rather than <code>()</code> within templates to avoid ambiguities</a></li>
<li><a href="#Rt-customization">T.69: Inside a template, don’t make an unqualified nonmember function call unless you intend it to be a customization point</a></li>
</ul>
<p>Template and hierarchy rule summary:</p>
<ul>
<li><a href="#Rt-hier">T.80: Do not naively templatize a class hierarchy</a></li>
<li><a href="#Rt-array">T.81: Do not mix hierarchies and arrays</a> // ??? somewhere in “hierarchies”</li>
<li><a href="#Rt-linear">T.82: Linearize a hierarchy when virtual functions are undesirable</a></li>
<li><a href="#Rt-virtual">T.83: Do not declare a member function template virtual</a></li>
<li><a href="#Rt-abi">T.84: Use a non-template core implementation to provide an ABI-stable interface</a></li>
<li><a href="#Rt-???">T.??: ????</a></li>
</ul>
<p>Variadic template rule summary:</p>
<ul>
<li><a href="#Rt-variadic">T.100: Use variadic templates when you need a function that takes a variable number of arguments of a variety of types</a></li>
<li><a href="#Rt-variadic-pass">T.101: ??? How to pass arguments to a variadic template ???</a></li>
<li><a href="#Rt-variadic-process">T.102: ??? How to process arguments to a variadic template ???</a></li>
<li><a href="#Rt-variadic-not">T.103: Don’t use variadic templates for homogeneous argument lists</a></li>
<li><a href="#Rt-???">T.??: ????</a></li>
</ul>
<p>Metaprogramming rule summary:</p>
<ul>
<li><a href="#Rt-metameta">T.120: Use template metaprogramming only when you really need to</a></li>
<li><a href="#Rt-emulate">T.121: Use template metaprogramming primarily to emulate concepts</a></li>
<li><a href="#Rt-tmp">T.122: Use templates (usually template aliases) to compute types at compile time</a></li>
<li><a href="#Rt-fct">T.123: Use <code>constexpr</code> functions to compute values at compile time</a></li>
<li><a href="#Rt-std-tmp">T.124: Prefer to use standard-library TMP facilities</a></li>
<li><a href="#Rt-lib">T.125: If you need to go beyond the standard-library TMP facilities, use an existing library</a></li>
<li><a href="#Rt-???">T.??: ????</a></li>
</ul>
<p>Other template rules summary:</p>
<ul>
<li><a href="#Rt-name">T.140: Name all operations with potential for reuse</a></li>
<li><a href="#Rt-lambda">T.141: Use an unnamed lambda if you need a simple function object in one place only</a></li>
<li><a href="#Rt-var">T.142: Use template variables to simplify notation</a></li>
<li><a href="#Rt-nongeneric">T.143: Don’t write unintentionally nongeneric code</a></li>
<li><a href="#Rt-specialize-function">T.144: Don’t specialize function templates</a></li>
<li><a href="#Rt-check-class">T.150: Check that a class matches a concept using <code>static_assert</code></a></li>
<li><a href="#Rt-???">T.??: ????</a></li>
</ul>
<h2 id="T-gp-Generic-programming"><a href="#T-gp-Generic-programming" class="headerlink" title="T.gp: Generic programming"></a><a name="SS-GP"></a>T.gp: Generic programming</h2><p>Generic programming is programming using types and algorithms parameterized by types, values, and algorithms.</p>
<h3 id="T-1-Use-templates-to-raise-the-level-of-abstraction-of-code"><a href="#T-1-Use-templates-to-raise-the-level-of-abstraction-of-code" class="headerlink" title="T.1: Use templates to raise the level of abstraction of code"></a><a name="Rt-raise"></a>T.1: Use templates to raise the level of abstraction of code</h3><h5 id="Reason-324"><a href="#Reason-324" class="headerlink" title="Reason"></a>Reason</h5><p>Generality. Reuse. Efficiency. Encourages consistent definition of user types.</p>
<h5 id="Example-bad-123"><a href="#Example-bad-123" class="headerlink" title="Example, bad"></a>Example, bad</h5><p>Conceptually, the following requirements are wrong because what we want of <code>T</code> is more than just the very low-level concepts of “can be incremented” or “can be added”:</p>
<pre><code>template&lt;typename T&gt;
    // requires Incrementable&lt;T&gt;
T sum1(vector&lt;T&gt;&amp; v, T s)
&#123;
    for (auto x : v) s += x;
    return s;
&#125;

template&lt;typename T&gt;
    // requires Simple_number&lt;T&gt;
T sum2(vector&lt;T&gt;&amp; v, T s)
&#123;
    for (auto x : v) s = s + x;
    return s;
&#125;
</code></pre>
<p>Assuming that <code>Incrementable</code> does not support <code>+</code> and <code>Simple_number</code> does not support <code>+=</code>, we have overconstrained implementers of <code>sum1</code> and <code>sum2</code>.<br>And, in this case, missed an opportunity for a generalization.</p>
<h5 id="Example-284"><a href="#Example-284" class="headerlink" title="Example"></a>Example</h5><pre><code>template&lt;typename T&gt;
    // requires Arithmetic&lt;T&gt;
T sum(vector&lt;T&gt;&amp; v, T s)
&#123;
    for (auto x : v) s += x;
    return s;
&#125;
</code></pre>
<p>Assuming that <code>Arithmetic</code> requires both <code>+</code> and <code>+=</code>, we have constrained the user of <code>sum</code> to provide a complete arithmetic type.<br>That is not a minimal requirement, but it gives the implementer of algorithms much needed freedom and ensures that any <code>Arithmetic</code> type<br>can be used for a wide variety of algorithms.</p>
<p>For additional generality and reusability, we could also use a more general <code>Container</code> or <code>Range</code> concept instead of committing to only one container, <code>vector</code>.</p>
<h5 id="Note-281"><a href="#Note-281" class="headerlink" title="Note"></a>Note</h5><p>If we define a template to require exactly the operations required for a single implementation of a single algorithm<br>(e.g., requiring just <code>+=</code> rather than also <code>=</code> and <code>+</code>) and only those, we have overconstrained maintainers.<br>We aim to minimize requirements on template arguments, but the absolutely minimal requirements of an implementation is rarely a meaningful concept.</p>
<h5 id="Note-282"><a href="#Note-282" class="headerlink" title="Note"></a>Note</h5><p>Templates can be used to express essentially everything (they are Turing complete), but the aim of generic programming (as expressed using templates)<br>is to efficiently generalize operations/algorithms over a set of types with similar semantic properties.</p>
<h5 id="Note-283"><a href="#Note-283" class="headerlink" title="Note"></a>Note</h5><p>The <code>requires</code> in the comments are uses of <code>concepts</code>.<br>“Concepts” are defined in an ISO Technical specification: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2015/n4553.pdf">concepts</a>.<br>Concepts are supported in GCC 6.1 and later.<br>Consequently, we comment out uses of concepts in examples; that is, we use them as formalized comments only.<br>If you use GCC 6.1 or later, you can uncomment them.</p>
<h5 id="Enforcement-296"><a href="#Enforcement-296" class="headerlink" title="Enforcement"></a>Enforcement</h5><ul>
<li>Flag algorithms with “overly simple” requirements, such as direct use of specific operators without a concept.</li>
<li>Do not flag the definition of the “overly simple” concepts themselves; they may simply be building blocks for more useful concepts.</li>
</ul>
<h3 id="T-2-Use-templates-to-express-algorithms-that-apply-to-many-argument-types"><a href="#T-2-Use-templates-to-express-algorithms-that-apply-to-many-argument-types" class="headerlink" title="T.2: Use templates to express algorithms that apply to many argument types"></a><a name="Rt-algo"></a>T.2: Use templates to express algorithms that apply to many argument types</h3><h5 id="Reason-325"><a href="#Reason-325" class="headerlink" title="Reason"></a>Reason</h5><p>Generality. Minimizing the amount of source code. Interoperability. Reuse.</p>
<h5 id="Example-285"><a href="#Example-285" class="headerlink" title="Example"></a>Example</h5><p>That’s the foundation of the STL. A single <code>find</code> algorithm easily works with any kind of input range:</p>
<pre><code>template&lt;typename Iter, typename Val&gt;
    // requires Input_iterator&lt;Iter&gt;
    //       &amp;&amp; Equality_comparable&lt;Value_type&lt;Iter&gt;, Val&gt;
Iter find(Iter b, Iter e, Val v)
&#123;
    // ...
&#125;
</code></pre>
<h5 id="Note-284"><a href="#Note-284" class="headerlink" title="Note"></a>Note</h5><p>Don’t use a template unless you have a realistic need for more than one template argument type.<br>Don’t overabstract.</p>
<h5 id="Enforcement-297"><a href="#Enforcement-297" class="headerlink" title="Enforcement"></a>Enforcement</h5><p>??? tough, probably needs a human</p>
<h3 id="T-3-Use-templates-to-express-containers-and-ranges"><a href="#T-3-Use-templates-to-express-containers-and-ranges" class="headerlink" title="T.3: Use templates to express containers and ranges"></a><a name="Rt-cont"></a>T.3: Use templates to express containers and ranges</h3><h5 id="Reason-326"><a href="#Reason-326" class="headerlink" title="Reason"></a>Reason</h5><p>Containers need an element type, and expressing that as a template argument is general, reusable, and type safe.<br>It also avoids brittle or inefficient workarounds. Convention: That’s the way the STL does it.</p>
<h5 id="Example-286"><a href="#Example-286" class="headerlink" title="Example"></a>Example</h5><pre><code>template&lt;typename T&gt;
    // requires Regular&lt;T&gt;
class Vector &#123;
    // ...
    T* elem;   // points to sz Ts
    int sz;
&#125;;

Vector&lt;double&gt; v(10);
v[7] = 9.9;
</code></pre>
<h5 id="Example-bad-124"><a href="#Example-bad-124" class="headerlink" title="Example, bad"></a>Example, bad</h5><pre><code>class Container &#123;
    // ...
    void* elem;   // points to size elements of some type
    int sz;
&#125;;

Container c(10, sizeof(double));
((double*) c.elem)[] = 9.9;
</code></pre>
<p>This doesn’t directly express the intent of the programmer and hides the structure of the program from the type system and optimizer.</p>
<p>Hiding the <code>void*</code> behind macros simply obscures the problems and introduces new opportunities for confusion.</p>
<p><strong>Exceptions</strong>: If you need an ABI-stable interface, you might have to provide a base implementation and express the (type-safe) template in terms of that.<br>See <a href="#Rt-abi">Stable base</a>.</p>
<h5 id="Enforcement-298"><a href="#Enforcement-298" class="headerlink" title="Enforcement"></a>Enforcement</h5><ul>
<li>Flag uses of <code>void*</code>s and casts outside low-level implementation code</li>
</ul>
<h3 id="T-4-Use-templates-to-express-syntax-tree-manipulation"><a href="#T-4-Use-templates-to-express-syntax-tree-manipulation" class="headerlink" title="T.4: Use templates to express syntax tree manipulation"></a><a name="Rt-expr"></a>T.4: Use templates to express syntax tree manipulation</h3><h5 id="Reason-327"><a href="#Reason-327" class="headerlink" title="Reason"></a>Reason</h5><p> ???</p>
<h5 id="Example-287"><a href="#Example-287" class="headerlink" title="Example"></a>Example</h5><pre><code>???
</code></pre>
<p><strong>Exceptions</strong>: ???</p>
<h3 id="T-5-Combine-generic-and-OO-techniques-to-amplify-their-strengths-not-their-costs"><a href="#T-5-Combine-generic-and-OO-techniques-to-amplify-their-strengths-not-their-costs" class="headerlink" title="T.5: Combine generic and OO techniques to amplify their strengths, not their costs"></a><a name="Rt-generic-oo"></a>T.5: Combine generic and OO techniques to amplify their strengths, not their costs</h3><h5 id="Reason-328"><a href="#Reason-328" class="headerlink" title="Reason"></a>Reason</h5><p>Generic and OO techniques are complementary.</p>
<h5 id="Example-288"><a href="#Example-288" class="headerlink" title="Example"></a>Example</h5><p>Static helps dynamic: Use static polymorphism to implement dynamically polymorphic interfaces.</p>
<pre><code>class Command &#123;
    // pure virtual functions
&#125;;

// implementations
template&lt;/*...*/&gt;
class ConcreteCommand : public Command &#123;
    // implement virtuals
&#125;;
</code></pre>
<h5 id="Example-289"><a href="#Example-289" class="headerlink" title="Example"></a>Example</h5><p>Dynamic helps static: Offer a generic, comfortable, statically bound interface, but internally dispatch dynamically, so you offer a uniform object layout.<br>Examples include type erasure as with <code>std::shared_ptr</code>‘s deleter (but <a href="#Rt-erasure">don’t overuse type erasure</a>).</p>
<h5 id="Note-285"><a href="#Note-285" class="headerlink" title="Note"></a>Note</h5><p>In a class template, nonvirtual functions are only instantiated if they’re used – but virtual functions are instantiated every time.<br>This can bloat code size, and may overconstrain a generic type by instantiating functionality that is never needed.<br>Avoid this, even though the standard-library facets made this mistake.</p>
<h5 id="See-also-4"><a href="#See-also-4" class="headerlink" title="See also"></a>See also</h5><ul>
<li>ref ???</li>
<li>ref ???</li>
<li>ref ???</li>
</ul>
<h5 id="Enforcement-299"><a href="#Enforcement-299" class="headerlink" title="Enforcement"></a>Enforcement</h5><p>See the reference to more specific rules.</p>
<h2 id="T-concepts-Concept-rules"><a href="#T-concepts-Concept-rules" class="headerlink" title="T.concepts: Concept rules"></a><a name="SS-concepts"></a>T.concepts: Concept rules</h2><p>Concepts is a facility for specifying requirements for template arguments.<br>It is an <a href="#Ref-conceptsTS">ISO technical specification</a>, but currently supported only by GCC.<br>Concepts are, however, crucial in the thinking about generic programming and the basis of much work on future C++ libraries<br>(standard and other).</p>
<p>This section assumes concept support</p>
<p>Concept use rule summary:</p>
<ul>
<li><a href="#Rt-concepts">T.10: Specify concepts for all template arguments</a></li>
<li><a href="#Rt-std-concepts">T.11: Whenever possible use standard concepts</a></li>
<li><a href="#Rt-auto">T.12: Prefer concept names over <code>auto</code></a></li>
<li><a href="#Rt-shorthand">T.13: Prefer the shorthand notation for simple, single-type argument concepts</a></li>
<li>???</li>
</ul>
<p>Concept definition rule summary:</p>
<ul>
<li><a href="#Rt-low">T.20: Avoid “concepts” without meaningful semantics</a></li>
<li><a href="#Rt-complete">T.21: Require a complete set of operations for a concept</a></li>
<li><a href="#Rt-axiom">T.22: Specify axioms for concepts</a></li>
<li><a href="#Rt-refine">T.23: Differentiate a refined concept from its more general case by adding new use patterns</a></li>
<li><a href="#Rt-tag">T.24: Use tag classes or traits to differentiate concepts that differ only in semantics</a></li>
<li><a href="#Rt-not">T.25: Avoid complimentary constraints</a></li>
<li><a href="#Rt-use">T.26: Prefer to define concepts in terms of use-patterns rather than simple syntax</a></li>
<li>???</li>
</ul>
<h2 id="T-con-use-Concept-use"><a href="#T-con-use-Concept-use" class="headerlink" title="T.con-use: Concept use"></a><a name="SS-concept-use"></a>T.con-use: Concept use</h2><h3 id="T-10-Specify-concepts-for-all-template-arguments"><a href="#T-10-Specify-concepts-for-all-template-arguments" class="headerlink" title="T.10: Specify concepts for all template arguments"></a><a name="Rt-concepts"></a>T.10: Specify concepts for all template arguments</h3><h5 id="Reason-329"><a href="#Reason-329" class="headerlink" title="Reason"></a>Reason</h5><p>Correctness and readability.<br>The assumed meaning (syntax and semantics) of a template argument is fundamental to the interface of a template.<br>A concept dramatically improves documentation and error handling for the template.<br>Specifying concepts for template arguments is a powerful design tool.</p>
<h5 id="Example-290"><a href="#Example-290" class="headerlink" title="Example"></a>Example</h5><pre><code>template&lt;typename Iter, typename Val&gt;
//    requires Input_iterator&lt;Iter&gt;
//             &amp;&amp; Equality_comparable&lt;Value_type&lt;Iter&gt;, Val&gt;
Iter find(Iter b, Iter e, Val v)
&#123;
    // ...
&#125;
</code></pre>
<p>or equivalently and more succinctly:</p>
<pre><code>template&lt;Input_iterator Iter, typename Val&gt;
//    requires Equality_comparable&lt;Value_type&lt;Iter&gt;, Val&gt;
Iter find(Iter b, Iter e, Val v)
&#123;
    // ...
&#125;
</code></pre>
<h5 id="Note-286"><a href="#Note-286" class="headerlink" title="Note"></a>Note</h5><p>“Concepts” are defined in an ISO Technical specification: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2015/n4553.pdf">concepts</a>.<br>A draft of a set of standard-library concepts can be found in another ISO TS: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/n4569.pdf">ranges</a><br>Concepts are supported in GCC 6.1 and later.<br>Consequently, we comment out uses of concepts in examples; that is, we use them as formalized comments only.<br>If you use GCC 6.1 or later, you can uncomment them:</p>
<pre><code>template&lt;typename Iter, typename Val&gt;
    requires Input_iterator&lt;Iter&gt;
           &amp;&amp; Equality_comparable&lt;Value_type&lt;Iter&gt;, Val&gt;
Iter find(Iter b, Iter e, Val v)
&#123;
    // ...
&#125;
</code></pre>
<h5 id="Note-287"><a href="#Note-287" class="headerlink" title="Note"></a>Note</h5><p>Plain <code>typename</code> (or <code>auto</code>) is the least constraining concept.<br>It should be used only rarely when nothing more than “it’s a type” can be assumed.<br>This is typically only needed when (as part of template metaprogramming code) we manipulate pure expression trees, postponing type checking.</p>
<p><strong>References</strong>: TC++PL4, Palo Alto TR, Sutton</p>
<h5 id="Enforcement-300"><a href="#Enforcement-300" class="headerlink" title="Enforcement"></a>Enforcement</h5><p>Flag template type arguments without concepts</p>
<h3 id="T-11-Whenever-possible-use-standard-concepts"><a href="#T-11-Whenever-possible-use-standard-concepts" class="headerlink" title="T.11: Whenever possible use standard concepts"></a><a name="Rt-std-concepts"></a>T.11: Whenever possible use standard concepts</h3><h5 id="Reason-330"><a href="#Reason-330" class="headerlink" title="Reason"></a>Reason</h5><p> “Standard” concepts (as provided by the <a href="#S-GSL">GSL</a> and the <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/n4569.pdf">Ranges TS</a>, and hopefully soon the ISO standard itself)<br>saves us the work of thinking up our own concepts, are better thought out than we can manage to do in a hurry, and improves interoperability.</p>
<h5 id="Note-288"><a href="#Note-288" class="headerlink" title="Note"></a>Note</h5><p>Unless you are creating a new generic library, most of the concepts you need will already be defined by the standard library.</p>
<h5 id="Example-using-TS-concepts"><a href="#Example-using-TS-concepts" class="headerlink" title="Example (using TS concepts)"></a>Example (using TS concepts)</h5><pre><code>template&lt;typename T&gt;
    // don&#39;t define this: Sortable is in the GSL
concept Ordered_container = Sequence&lt;T&gt; &amp;&amp; Random_access&lt;Iterator&lt;T&gt;&gt; &amp;&amp; Ordered&lt;Value_type&lt;T&gt;&gt;;

void sort(Ordered_container&amp; s);
</code></pre>
<p>This <code>Ordered_container</code> is quite plausible, but it is very similar to the <code>Sortable</code> concept in the GSL (and the Range TS).<br>Is it better? Is it right? Does it accurately reflect the standard’s requirements for <code>sort</code>?<br>It is better and simpler just to use <code>Sortable</code>:</p>
<pre><code>void sort(Sortable&amp; s);   // better
</code></pre>
<h5 id="Note-289"><a href="#Note-289" class="headerlink" title="Note"></a>Note</h5><p>The set of “standard” concepts is evolving as we approach an ISO standard including concepts.</p>
<h5 id="Note-290"><a href="#Note-290" class="headerlink" title="Note"></a>Note</h5><p>Designing a useful concept is challenging.</p>
<h5 id="Enforcement-301"><a href="#Enforcement-301" class="headerlink" title="Enforcement"></a>Enforcement</h5><p>Hard.</p>
<ul>
<li>Look for unconstrained arguments, templates that use “unusual”/non-standard concepts, templates that use “homebrew” concepts without axioms.</li>
<li>Develop a concept-discovery tool (e.g., see <a href="http://www.stroustrup.com/sle2010_webversion.pdf">an early experiment</a>).</li>
</ul>
<h3 id="T-12-Prefer-concept-names-over-auto-for-local-variables"><a href="#T-12-Prefer-concept-names-over-auto-for-local-variables" class="headerlink" title="T.12: Prefer concept names over auto for local variables"></a><a name="Rt-auto"></a>T.12: Prefer concept names over <code>auto</code> for local variables</h3><h5 id="Reason-331"><a href="#Reason-331" class="headerlink" title="Reason"></a>Reason</h5><p> <code>auto</code> is the weakest concept. Concept names convey more meaning than just <code>auto</code>.</p>
<h5 id="Example-using-TS-concepts-1"><a href="#Example-using-TS-concepts-1" class="headerlink" title="Example (using TS concepts)"></a>Example (using TS concepts)</h5><pre><code>vector&lt;string&gt; v&#123; &quot;abc&quot;, &quot;xyz&quot; &#125;;
auto&amp; x = v.front();     // bad
String&amp; s = v.front();   // good (String is a GSL concept)
</code></pre>
<h5 id="Enforcement-302"><a href="#Enforcement-302" class="headerlink" title="Enforcement"></a>Enforcement</h5><ul>
<li>???</li>
</ul>
<h3 id="T-13-Prefer-the-shorthand-notation-for-simple-single-type-argument-concepts"><a href="#T-13-Prefer-the-shorthand-notation-for-simple-single-type-argument-concepts" class="headerlink" title="T.13: Prefer the shorthand notation for simple, single-type argument concepts"></a><a name="Rt-shorthand"></a>T.13: Prefer the shorthand notation for simple, single-type argument concepts</h3><h5 id="Reason-332"><a href="#Reason-332" class="headerlink" title="Reason"></a>Reason</h5><p>Readability. Direct expression of an idea.</p>
<h5 id="Example-using-TS-concepts-2"><a href="#Example-using-TS-concepts-2" class="headerlink" title="Example (using TS concepts)"></a>Example (using TS concepts)</h5><p>To say “<code>T</code> is <code>Sortable</code>“:</p>
<pre><code>template&lt;typename T&gt;       // Correct but verbose: &quot;The parameter is
//    requires Sortable&lt;T&gt;   // of type T which is the name of a type
void sort(T&amp;);             // that is Sortable&quot;

template&lt;Sortable T&gt;       // Better (assuming support for concepts): &quot;The parameter is of type T
void sort(T&amp;);             // which is Sortable&quot;

void sort(Sortable&amp;);      // Best (assuming support for concepts): &quot;The parameter is Sortable&quot;
</code></pre>
<p>The shorter versions better match the way we speak. Note that many templates don’t need to use the <code>template</code> keyword.</p>
<h5 id="Note-291"><a href="#Note-291" class="headerlink" title="Note"></a>Note</h5><p>“Concepts” are defined in an ISO Technical specification: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2015/n4553.pdf">concepts</a>.<br>A draft of a set of standard-library concepts can be found in another ISO TS: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/n4569.pdf">ranges</a><br>Concepts are supported in GCC 6.1 and later.<br>Consequently, we comment out uses of concepts in examples; that is, we use them as formalized comments only.<br>If you use a compiler that supports concepts (e.g., GCC 6.1 or later), you can remove the <code>//</code>.</p>
<h5 id="Enforcement-303"><a href="#Enforcement-303" class="headerlink" title="Enforcement"></a>Enforcement</h5><ul>
<li>Not feasible in the short term when people convert from the <code>&lt;typename T&gt;</code> and <code>&lt;class T</code>&gt; notation.</li>
<li>Later, flag declarations that first introduces a typename and then constrains it with a simple, single-type-argument concept.</li>
</ul>
<h2 id="T-concepts-def-Concept-definition-rules"><a href="#T-concepts-def-Concept-definition-rules" class="headerlink" title="T.concepts.def: Concept definition rules"></a><a name="SS-concepts-def"></a>T.concepts.def: Concept definition rules</h2><p>Defining good concepts is non-trivial.<br>Concepts are meant to represent fundamental concepts in an application domain (hence the name “concepts”).<br>Similarly throwing together a set of syntactic constraints to be used for a the arguments for a single class or algorithm is not what concepts were designed for<br>and will not give the full benefits of the mechanism.</p>
<p>Obviously, defining concepts will be most useful for code that can use an implementation (e.g., GCC 6.1 or later),<br>but defining concepts is in itself a useful design technique and help catch conceptual errors and clean up the concepts (sic!) of an implementation.</p>
<h3 id="T-20-Avoid-“concepts”-without-meaningful-semantics"><a href="#T-20-Avoid-“concepts”-without-meaningful-semantics" class="headerlink" title="T.20: Avoid “concepts” without meaningful semantics"></a><a name="Rt-low"></a>T.20: Avoid “concepts” without meaningful semantics</h3><h5 id="Reason-333"><a href="#Reason-333" class="headerlink" title="Reason"></a>Reason</h5><p>Concepts are meant to express semantic notions, such as “a number”, “a range” of elements, and “totally ordered.”<br>Simple constraints, such as “has a <code>+</code> operator” and “has a <code>&gt;</code> operator” cannot be meaningfully specified in isolation<br>and should be used only as building blocks for meaningful concepts, rather than in user code.</p>
<h5 id="Example-bad-using-TS-concepts"><a href="#Example-bad-using-TS-concepts" class="headerlink" title="Example, bad (using TS concepts)"></a>Example, bad (using TS concepts)</h5><pre><code>template&lt;typename T&gt;
concept Addable = has_plus&lt;T&gt;;    // bad; insufficient

template&lt;Addable N&gt; auto algo(const N&amp; a, const N&amp; b) // use two numbers
&#123;
    // ...
    return a + b;
&#125;

int x = 7;
int y = 9;
auto z = algo(x, y);   // z = 16

string xx = &quot;7&quot;;
string yy = &quot;9&quot;;
auto zz = algo(xx, yy);   // zz = &quot;79&quot;
</code></pre>
<p>Maybe the concatenation was expected. More likely, it was an accident. Defining minus equivalently would give dramatically different sets of accepted types.<br>This <code>Addable</code> violates the mathematical rule that addition is supposed to be commutative: <code>a+b == b+a</code>.</p>
<h5 id="Note-292"><a href="#Note-292" class="headerlink" title="Note"></a>Note</h5><p>The ability to specify a meaningful semantics is a defining characteristic of a true concept, as opposed to a syntactic constraint.</p>
<h5 id="Example-using-TS-concepts-3"><a href="#Example-using-TS-concepts-3" class="headerlink" title="Example (using TS concepts)"></a>Example (using TS concepts)</h5><pre><code>template&lt;typename T&gt;
// The operators +, -, *, and / for a number are assumed to follow the usual mathematical rules
concept Number = has_plus&lt;T&gt;
                 &amp;&amp; has_minus&lt;T&gt;
                 &amp;&amp; has_multiply&lt;T&gt;
                 &amp;&amp; has_divide&lt;T&gt;;

template&lt;Number N&gt; auto algo(const N&amp; a, const N&amp; b)
&#123;
    // ...
    return a + b;
&#125;

int x = 7;
int y = 9;
auto z = algo(x, y);   // z = 16

string xx = &quot;7&quot;;
string yy = &quot;9&quot;;
auto zz = algo(xx, yy);   // error: string is not a Number
</code></pre>
<h5 id="Note-293"><a href="#Note-293" class="headerlink" title="Note"></a>Note</h5><p>Concepts with multiple operations have far lower chance of accidentally matching a type than a single-operation concept.</p>
<h5 id="Enforcement-304"><a href="#Enforcement-304" class="headerlink" title="Enforcement"></a>Enforcement</h5><ul>
<li>Flag single-operation <code>concepts</code> when used outside the definition of other <code>concepts</code>.</li>
<li>Flag uses of <code>enable_if</code> that appears to simulate single-operation <code>concepts</code>.</li>
</ul>
<h3 id="T-21-Require-a-complete-set-of-operations-for-a-concept"><a href="#T-21-Require-a-complete-set-of-operations-for-a-concept" class="headerlink" title="T.21: Require a complete set of operations for a concept"></a><a name="Rt-complete"></a>T.21: Require a complete set of operations for a concept</h3><h5 id="Reason-334"><a href="#Reason-334" class="headerlink" title="Reason"></a>Reason</h5><p>Ease of comprehension.<br>Improved interoperability.<br>Helps implementers and maintainers.</p>
<h5 id="Note-294"><a href="#Note-294" class="headerlink" title="Note"></a>Note</h5><p>This is a specific variant of the general rule that <a href="#Rt-low">a concept must make semantic sense</a>.</p>
<h5 id="Example-bad-using-TS-concepts-1"><a href="#Example-bad-using-TS-concepts-1" class="headerlink" title="Example, bad (using TS concepts)"></a>Example, bad (using TS concepts)</h5><pre><code>template&lt;typename T&gt; concept Subtractable = requires(T a, T, b) &#123; a-b; &#125;;
</code></pre>
<p>This makes no semantic sense.<br>You need at least <code>+</code> to make <code>-</code> meaningful and useful.</p>
<p>Examples of complete sets are</p>
<ul>
<li><code>Arithmetic</code>: <code>+</code>, <code>-</code>, <code>*</code>, <code>/</code>, <code>+=</code>, <code>-=</code>, <code>*=</code>, <code>/=</code></li>
<li><code>Comparable</code>: <code>&lt;</code>, <code>&gt;</code>, <code>&lt;=</code>, <code>&gt;=</code>, <code>==</code>, <code>!=</code></li>
</ul>
<h5 id="Note-295"><a href="#Note-295" class="headerlink" title="Note"></a>Note</h5><p>This rule applies whether we use direct language support for concepts or not.<br>It is a general design rule that even applies to non-templates:</p>
<pre><code>class Minimal &#123;
    // ...
&#125;;

bool operator==(const Minimal&amp;, const Minimal&amp;);
bool operator&lt;(const Minimal&amp;, const Minimal&amp;);

Minimal operator+(const Minimal&amp;, const Minimal&amp;);
// no other operators

void f(const Minimal&amp; x, const Minimal&amp; y)
&#123;
    if (!(x == y)) &#123; /* ... */ &#125;    // OK
    if (x != y) &#123; /* ... */ &#125;       // surprise! error

    while (!(x &lt; y)) &#123; /* ... */ &#125;  // OK
    while (x &gt;= y) &#123; /* ... */ &#125;    // surprise! error

    x = x + y;          // OK
    x += y;             // surprise! error
&#125;
</code></pre>
<p>This is minimal, but surprising and constraining for users.<br>It could even be less efficient.</p>
<p>The rule supports the view that a concept should reflect a (mathematically) coherent set of operations.</p>
<h5 id="Example-291"><a href="#Example-291" class="headerlink" title="Example"></a>Example</h5><pre><code>class Convenient &#123;
    // ...
&#125;;

bool operator==(const Convenient&amp;, const Convenient&amp;);
bool operator&lt;(const Convenient&amp;, const Convenient&amp;);
// ... and the other comparison operators ...

Minimal operator+(const Convenient&amp;, const Convenient&amp;);
// .. and the other arithmetic operators ...

void f(const Convenient&amp; x, const Convenient&amp; y)
&#123;
    if (!(x == y)) &#123; /* ... */ &#125;    // OK
    if (x != y) &#123; /* ... */ &#125;       // OK

    while (!(x &lt; y)) &#123; /* ... */ &#125;  // OK
    while (x &gt;= y) &#123; /* ... */ &#125;    // OK

    x = x + y;     // OK
    x += y;        // OK
&#125;
</code></pre>
<p>It can be a nuisance to define all operators, but not hard.<br>Ideally, that rule should be language supported by giving you comparison operators by default.</p>
<h5 id="Enforcement-305"><a href="#Enforcement-305" class="headerlink" title="Enforcement"></a>Enforcement</h5><ul>
<li>Flag classes that support “odd” subsets of a set of operators, e.g., <code>==</code> but not <code>!=</code> or <code>+</code> but not <code>-</code>.<br>Yes, <code>std::string</code> is “odd”, but it’s too late to change that.</li>
</ul>
<h3 id="T-22-Specify-axioms-for-concepts"><a href="#T-22-Specify-axioms-for-concepts" class="headerlink" title="T.22: Specify axioms for concepts"></a><a name="Rt-axiom"></a>T.22: Specify axioms for concepts</h3><h5 id="Reason-335"><a href="#Reason-335" class="headerlink" title="Reason"></a>Reason</h5><p>A meaningful/useful concept has a semantic meaning.<br>Expressing these semantics in an informal, semi-formal, or formal way makes the concept comprehensible to readers and the effort to express it can catch conceptual errors.<br>Specifying semantics is a powerful design tool.</p>
<h5 id="Example-using-TS-concepts-4"><a href="#Example-using-TS-concepts-4" class="headerlink" title="Example (using TS concepts)"></a>Example (using TS concepts)</h5><pre><code>template&lt;typename T&gt;
    // The operators +, -, *, and / for a number are assumed to follow the usual mathematical rules
    // axiom(T a, T b) &#123; a + b == b + a; a - a == 0; a * (b + c) == a * b + a * c; /*...*/ &#125;
    concept Number = requires(T a, T b) &#123;
        &#123;a + b&#125; -&gt; T;   // the result of a + b is convertible to T
        &#123;a - b&#125; -&gt; T;
        &#123;a * b&#125; -&gt; T;
        &#123;a / b&#125; -&gt; T;
    &#125;
</code></pre>
<h5 id="Note-296"><a href="#Note-296" class="headerlink" title="Note"></a>Note</h5><p>This is an axiom in the mathematical sense: something that may be assumed without proof.<br>In general, axioms are not provable, and when they are the proof is often beyond the capability of a compiler.<br>An axiom may not be general, but the template writer may assume that it holds for all inputs actually used (similar to a precondition).</p>
<h5 id="Note-297"><a href="#Note-297" class="headerlink" title="Note"></a>Note</h5><p>In this context axioms are Boolean expressions.<br>See the <a href="#S-references">Palo Alto TR</a> for examples.<br>Currently, C++ does not support axioms (even the ISO Concepts TS), so we have to make do with comments for a longish while.<br>Once language support is available, the <code>//</code> in front of the axiom can be removed</p>
<h5 id="Note-298"><a href="#Note-298" class="headerlink" title="Note"></a>Note</h5><p>The GSL concepts have well-defined semantics; see the Palo Alto TR and the Ranges TS.</p>
<h5 id="Exception-using-TS-concepts"><a href="#Exception-using-TS-concepts" class="headerlink" title="Exception (using TS concepts)"></a>Exception (using TS concepts)</h5><p>Early versions of a new “concept” still under development will often just define simple sets of constraints without a well-specified semantics.<br>Finding good semantics can take effort and time.<br>An incomplete set of constraints can still be very useful:</p>
<pre><code>// balancer for a generic binary tree
template&lt;typename Node&gt; concept bool Balancer = requires(Node* p) &#123;
    add_fixup(p);
    touch(p);
    detach(p);
&#125;
</code></pre>
<p>So a <code>Balancer</code> must supply at least thee operations on a tree <code>Node</code>,<br>but we are not yet ready to specify detailed semantics because a new kind of balanced tree might require more operations<br>and the precise general semantics for all nodes is hard to pin down in the early stages of design.</p>
<p>A “concept” that is incomplete or without a well-specified semantics can still be useful.<br>For example, it allows for some checking during initial experimentation.<br>However, it should not be assumed to be stable.<br>Each new use case may require such an incomplete concepts to be improved.</p>
<h5 id="Enforcement-306"><a href="#Enforcement-306" class="headerlink" title="Enforcement"></a>Enforcement</h5><ul>
<li>Look for the word “axiom” in concept definition comments</li>
</ul>
<h3 id="T-23-Differentiate-a-refined-concept-from-its-more-general-case-by-adding-new-use-patterns"><a href="#T-23-Differentiate-a-refined-concept-from-its-more-general-case-by-adding-new-use-patterns" class="headerlink" title="T.23: Differentiate a refined concept from its more general case by adding new use patterns."></a><a name="Rt-refine"></a>T.23: Differentiate a refined concept from its more general case by adding new use patterns.</h3><h5 id="Reason-336"><a href="#Reason-336" class="headerlink" title="Reason"></a>Reason</h5><p>Otherwise they cannot be distinguished automatically by the compiler.</p>
<h5 id="Example-using-TS-concepts-5"><a href="#Example-using-TS-concepts-5" class="headerlink" title="Example (using TS concepts)"></a>Example (using TS concepts)</h5><pre><code>template&lt;typename I&gt;
concept bool Input_iter = requires(I iter) &#123; ++iter; &#125;;

template&lt;typename I&gt;
concept bool Fwd_iter = Input_iter&lt;I&gt; &amp;&amp; requires(I iter) &#123; iter++; &#125;
</code></pre>
<p>The compiler can determine refinement based on the sets of required operations (here, suffix <code>++</code>).<br>This decreases the burden on implementers of these types since<br>they do not need any special declarations to “hook into the concept”.<br>If two concepts have exactly the same requirements, they are logically equivalent (there is no refinement).</p>
<h5 id="Enforcement-307"><a href="#Enforcement-307" class="headerlink" title="Enforcement"></a>Enforcement</h5><ul>
<li>Flag a concept that has exactly the same requirements as another already-seen concept (neither is more refined).<br>To disambiguate them, see <a href="#Rt-tag">T.24</a>.</li>
</ul>
<h3 id="T-24-Use-tag-classes-or-traits-to-differentiate-concepts-that-differ-only-in-semantics"><a href="#T-24-Use-tag-classes-or-traits-to-differentiate-concepts-that-differ-only-in-semantics" class="headerlink" title="T.24: Use tag classes or traits to differentiate concepts that differ only in semantics."></a><a name="Rt-tag"></a>T.24: Use tag classes or traits to differentiate concepts that differ only in semantics.</h3><h5 id="Reason-337"><a href="#Reason-337" class="headerlink" title="Reason"></a>Reason</h5><p>Two concepts requiring the same syntax but having different semantics leads to ambiguity unless the programmer differentiates them.</p>
<h5 id="Example-using-TS-concepts-6"><a href="#Example-using-TS-concepts-6" class="headerlink" title="Example (using TS concepts)"></a>Example (using TS concepts)</h5><pre><code>template&lt;typename I&gt;    // iterator providing random access
concept bool RA_iter = ...;

template&lt;typename I&gt;    // iterator providing random access to contiguous data
concept bool Contiguous_iter =
    RA_iter&lt;I&gt; &amp;&amp; is_contiguous&lt;I&gt;::value;  // using is_contiguous trait
</code></pre>
<p>The programmer (in a library) must define <code>is_contiguous</code> (a trait) appropriately.</p>
<p>Wrapping a tag class into a concept leads to a simpler expression of this idea:</p>
<pre><code>template&lt;typename I&gt; concept Contiguous = is_contiguous&lt;I&gt;::value;

template&lt;typename I&gt;
concept bool Contiguous_iter = RA_iter&lt;I&gt; &amp;&amp; Contiguous&lt;I&gt;;
</code></pre>
<p>The programmer (in a library) must define <code>is_contiguous</code> (a trait) appropriately.</p>
<h5 id="Note-299"><a href="#Note-299" class="headerlink" title="Note"></a>Note</h5><p>Traits can be trait classes or type traits.<br>These can be user-defined or standard-library ones.<br>Prefer the standard-library ones.</p>
<h5 id="Enforcement-308"><a href="#Enforcement-308" class="headerlink" title="Enforcement"></a>Enforcement</h5><ul>
<li>The compiler flags ambiguous use of identical concepts.</li>
<li>Flag the definition of identical concepts.</li>
</ul>
<h3 id="T-25-Avoid-complementary-constraints"><a href="#T-25-Avoid-complementary-constraints" class="headerlink" title="T.25: Avoid complementary constraints"></a><a name="Rt-not"></a>T.25: Avoid complementary constraints</h3><h5 id="Reason-338"><a href="#Reason-338" class="headerlink" title="Reason"></a>Reason</h5><p>Clarity. Maintainability.<br>Functions with complementary requirements expressed using negation are brittle.</p>
<h5 id="Example-using-TS-concepts-7"><a href="#Example-using-TS-concepts-7" class="headerlink" title="Example (using TS concepts)"></a>Example (using TS concepts)</h5><p>Initially, people will try to define functions with complementary requirements:</p>
<pre><code>template&lt;typename T&gt;
    requires !C&lt;T&gt;    // bad
void f();

template&lt;typename T&gt;
    requires C&lt;T&gt;
void f();
</code></pre>
<p>This is better:</p>
<pre><code>template&lt;typename T&gt;   // general template
    void f();

template&lt;typename T&gt;   // specialization by concept
    requires C&lt;T&gt;
void f();
</code></pre>
<p>The compiler will choose the unconstrained template only when <code>C&lt;T&gt;</code> is<br>unsatisfied. If you do not want to (or cannot) define an unconstrained<br>version of <code>f()</code>, then delete it.</p>
<pre><code>template&lt;typename T&gt;
void f() = delete;
</code></pre>
<p>The compiler will select the overload and emit an appropriate error.</p>
<h5 id="Note-300"><a href="#Note-300" class="headerlink" title="Note"></a>Note</h5><p>Complementary constraints are unfortunately common in <code>enable_if</code> code:</p>
<pre><code>template&lt;typename T&gt;
enable_if&lt;!C&lt;T&gt;, void&gt;   // bad
f();

template&lt;typename T&gt;
enable_if&lt;C&lt;T&gt;, void&gt;
f();
</code></pre>
<h5 id="Note-301"><a href="#Note-301" class="headerlink" title="Note"></a>Note</h5><p>Complementary requirements on one requirements is sometimes (wrongly) considered manageable.<br>However, for two or more requirements the number of definitions needs can go up exponentially (2,4,9,16,…):</p>
<pre><code>C1&lt;T&gt; &amp;&amp; C2&lt;T&gt;
!C1&lt;T&gt; &amp;&amp; C2&lt;T&gt;
C1&lt;T&gt; &amp;&amp; !C2&lt;T&gt;
!C1&lt;T&gt; &amp;&amp; !C2&lt;T&gt;
</code></pre>
<p>Now the opportunities for errors multiply.</p>
<h5 id="Enforcement-309"><a href="#Enforcement-309" class="headerlink" title="Enforcement"></a>Enforcement</h5><ul>
<li>Flag pairs of functions with <code>C&lt;T&gt;</code> and <code>!C&lt;T&gt;</code> constraints</li>
</ul>
<h3 id="T-26-Prefer-to-define-concepts-in-terms-of-use-patterns-rather-than-simple-syntax"><a href="#T-26-Prefer-to-define-concepts-in-terms-of-use-patterns-rather-than-simple-syntax" class="headerlink" title="T.26: Prefer to define concepts in terms of use-patterns rather than simple syntax"></a><a name="Rt-use"></a>T.26: Prefer to define concepts in terms of use-patterns rather than simple syntax</h3><h5 id="Reason-339"><a href="#Reason-339" class="headerlink" title="Reason"></a>Reason</h5><p>The definition is more readable and corresponds directly to what a user has to write.<br>Conversions are taken into account. You don’t have to remember the names of all the type traits.</p>
<h5 id="Example-using-TS-concepts-8"><a href="#Example-using-TS-concepts-8" class="headerlink" title="Example (using TS concepts)"></a>Example (using TS concepts)</h5><p>You might be tempted to define a concept <code>Equality</code> like this:</p>
<pre><code>template&lt;typename T&gt; concept Equality = has_equal&lt;T&gt; &amp;&amp; has_not_equal&lt;T&gt;;
</code></pre>
<p>Obviously, it would be better and easier just to use the standard <code>EqualityComparable</code>,<br>but - just as an example - if you had to define such a concept, prefer:</p>
<pre><code>template&lt;typename T&gt; concept Equality = requires(T a, T b) &#123;
    bool == &#123; a == b &#125;
    bool == &#123; a != b &#125;
    // axiom &#123; !(a == b) == (a != b) &#125;
    // axiom &#123; a = b; =&gt; a == b &#125;  // =&gt; means &quot;implies&quot;
&#125;
</code></pre>
<p>as opposed to defining two meaningless concepts <code>has_equal</code> and <code>has_not_equal</code> just as helpers in the definition of <code>Equality</code>.<br>By “meaningless” we mean that we cannot specify the semantics of <code>has_equal</code> in isolation.</p>
<h5 id="Enforcement-310"><a href="#Enforcement-310" class="headerlink" title="Enforcement"></a>Enforcement</h5><p>???</p>
<h2 id="Template-interfaces"><a href="#Template-interfaces" class="headerlink" title="Template interfaces"></a><a name="SS-temp-interface"></a>Template interfaces</h2><p>Over the years, programming with templates have suffered from a weak distinction between the interface of a template<br>and its implementation.<br>Before concepts, that distinction had no direct language support.<br>However, the interface to a template is a critical concept - a contract between a user and an implementer - and should be carefully designed.</p>
<h3 id="T-40-Use-function-objects-to-pass-operations-to-algorithms"><a href="#T-40-Use-function-objects-to-pass-operations-to-algorithms" class="headerlink" title="T.40: Use function objects to pass operations to algorithms"></a><a name="Rt-fo"></a>T.40: Use function objects to pass operations to algorithms</h3><h5 id="Reason-340"><a href="#Reason-340" class="headerlink" title="Reason"></a>Reason</h5><p>Function objects can carry more information through an interface than a “plain” pointer to function.<br>In general, passing function objects gives better performance than passing pointers to functions.</p>
<h5 id="Example-using-TS-concepts-9"><a href="#Example-using-TS-concepts-9" class="headerlink" title="Example (using TS concepts)"></a>Example (using TS concepts)</h5><pre><code>bool greater(double x, double y) &#123; return x &gt; y; &#125;
sort(v, greater);                                    // pointer to function: potentially slow
sort(v, [](double x, double y) &#123; return x &gt; y; &#125;);   // function object
sort(v, std::greater&lt;&gt;);                             // function object

bool greater_than_7(double x) &#123; return x &gt; 7; &#125;
auto x = find_if(v, greater_than_7);                 // pointer to function: inflexible
auto y = find_if(v, [](double x) &#123; return x &gt; 7; &#125;); // function object: carries the needed data
auto z = find_if(v, Greater_than&lt;double&gt;(7));        // function object: carries the needed data
</code></pre>
<p>You can, of course, generalize those functions using <code>auto</code> or (when and where available) concepts. For example:</p>
<pre><code>auto y1 = find_if(v, [](Ordered x) &#123; return x &gt; 7; &#125;); // require an ordered type
auto z1 = find_if(v, [](auto x) &#123; return x &gt; 7; &#125;);    // hope that the type has a &gt;
</code></pre>
<h5 id="Note-302"><a href="#Note-302" class="headerlink" title="Note"></a>Note</h5><p>Lambdas generate function objects.</p>
<h5 id="Note-303"><a href="#Note-303" class="headerlink" title="Note"></a>Note</h5><p>The performance argument depends on compiler and optimizer technology.</p>
<h5 id="Enforcement-311"><a href="#Enforcement-311" class="headerlink" title="Enforcement"></a>Enforcement</h5><ul>
<li>Flag pointer to function template arguments.</li>
<li>Flag pointers to functions passed as arguments to a template (risk of false positives).</li>
</ul>
<h3 id="T-41-Require-only-essential-properties-in-a-template’s-concepts"><a href="#T-41-Require-only-essential-properties-in-a-template’s-concepts" class="headerlink" title="T.41: Require only essential properties in a template’s concepts"></a><a name="Rt-essential"></a>T.41: Require only essential properties in a template’s concepts</h3><h5 id="Reason-341"><a href="#Reason-341" class="headerlink" title="Reason"></a>Reason</h5><p>Keep interfaces simple and stable.</p>
<h5 id="Example-using-TS-concepts-10"><a href="#Example-using-TS-concepts-10" class="headerlink" title="Example (using TS concepts)"></a>Example (using TS concepts)</h5><p>Consider, a <code>sort</code> instrumented with (oversimplified) simple debug support:</p>
<pre><code>void sort(Sortable&amp; s)  // sort sequence s
&#123;
    if (debug) cerr &lt;&lt; &quot;enter sort( &quot; &lt;&lt; s &lt;&lt;  &quot;)\n&quot;;
    // ...
    if (debug) cerr &lt;&lt; &quot;exit sort( &quot; &lt;&lt; s &lt;&lt;  &quot;)\n&quot;;
&#125;
</code></pre>
<p>Should this be rewritten to:</p>
<pre><code>template&lt;Sortable S&gt;
    requires Streamable&lt;S&gt;
void sort(S&amp; s)  // sort sequence s
&#123;
    if (debug) cerr &lt;&lt; &quot;enter sort( &quot; &lt;&lt; s &lt;&lt;  &quot;)\n&quot;;
    // ...
    if (debug) cerr &lt;&lt; &quot;exit sort( &quot; &lt;&lt; s &lt;&lt;  &quot;)\n&quot;;
&#125;
</code></pre>
<p>After all, there is nothing in <code>Sortable</code> that requires <code>iostream</code> support.<br>On the other hand, there is nothing in the fundamental idea of sorting that says anything about debugging.</p>
<h5 id="Note-304"><a href="#Note-304" class="headerlink" title="Note"></a>Note</h5><p>If we require every operation used to be listed among the requirements, the interface becomes unstable:<br>Every time we change the debug facilities, the usage data gathering, testing support, error reporting, etc.<br>The definition of the template would need change and every use of the template would have to be recompiled.<br>This is cumbersome, and in some environments infeasible.</p>
<p>Conversely, if we use an operation in the implementation that is not guaranteed by concept checking,<br>we may get a late compile-time error.</p>
<p>By not using concept checking for properties of a template argument that is not considered essential,<br>we delay checking until instantiation time.<br>We consider this a worthwhile tradeoff.</p>
<p>Note that using non-local, non-dependent names (such as <code>debug</code> and <code>cerr</code>) also introduces context dependencies that may lead to “mysterious” errors.</p>
<h5 id="Note-305"><a href="#Note-305" class="headerlink" title="Note"></a>Note</h5><p>It can be hard to decide which properties of a type is essential and which are not.</p>
<h5 id="Enforcement-312"><a href="#Enforcement-312" class="headerlink" title="Enforcement"></a>Enforcement</h5><p>???</p>
<h3 id="T-42-Use-template-aliases-to-simplify-notation-and-hide-implementation-details"><a href="#T-42-Use-template-aliases-to-simplify-notation-and-hide-implementation-details" class="headerlink" title="T.42: Use template aliases to simplify notation and hide implementation details"></a><a name="Rt-alias"></a>T.42: Use template aliases to simplify notation and hide implementation details</h3><h5 id="Reason-342"><a href="#Reason-342" class="headerlink" title="Reason"></a>Reason</h5><p>Improved readability.<br>Implementation hiding.<br>Note that template aliases replace many uses of traits to compute a type.<br>They can also be used to wrap a trait.</p>
<h5 id="Example-292"><a href="#Example-292" class="headerlink" title="Example"></a>Example</h5><pre><code>template&lt;typename T, size_t N&gt;
class Matrix &#123;
    // ...
    using Iterator = typename std::vector&lt;T&gt;::iterator;
    // ...
&#125;;
</code></pre>
<p>This saves the user of <code>Matrix</code> from having to know that its elements are stored in a <code>vector</code> and also saves the user from repeatedly typing <code>typename std::vector&lt;T&gt;::</code>.</p>
<h5 id="Example-293"><a href="#Example-293" class="headerlink" title="Example"></a>Example</h5><pre><code>template&lt;typename T&gt;
void user(T&amp; c)
&#123;
    // ...
    typename container_traits&lt;T&gt;::value_type x; // bad, verbose
    // ...
&#125;

template&lt;typename T&gt;
using Value_type = typename container_traits&lt;T&gt;::value_type;
</code></pre>
<p>This saves the user of <code>Value_type</code> from having to know the technique used to implement <code>value_type</code>s.</p>
<pre><code>template&lt;typename T&gt;
void user2(T&amp; c)
&#123;
    // ...
    Value_type&lt;T&gt; x;
    // ...
&#125;
</code></pre>
<h5 id="Note-306"><a href="#Note-306" class="headerlink" title="Note"></a>Note</h5><p>A simple, common use could be expressed: “Wrap traits!”</p>
<h5 id="Enforcement-313"><a href="#Enforcement-313" class="headerlink" title="Enforcement"></a>Enforcement</h5><ul>
<li>Flag use of <code>typename</code> as a disambiguator outside <code>using</code> declarations.</li>
<li>???</li>
</ul>
<h3 id="T-43-Prefer-using-over-typedef-for-defining-aliases"><a href="#T-43-Prefer-using-over-typedef-for-defining-aliases" class="headerlink" title="T.43: Prefer using over typedef for defining aliases"></a><a name="Rt-using"></a>T.43: Prefer <code>using</code> over <code>typedef</code> for defining aliases</h3><h5 id="Reason-343"><a href="#Reason-343" class="headerlink" title="Reason"></a>Reason</h5><p>Improved readability: With <code>using</code>, the new name comes first rather than being embedded somewhere in a declaration.<br>Generality: <code>using</code> can be used for template aliases, whereas <code>typedef</code>s can’t easily be templates.<br>Uniformity: <code>using</code> is syntactically similar to <code>auto</code>.</p>
<h5 id="Example-294"><a href="#Example-294" class="headerlink" title="Example"></a>Example</h5><pre><code>typedef int (*PFI)(int);   // OK, but convoluted

using PFI2 = int (*)(int);   // OK, preferred

template&lt;typename T&gt;
typedef int (*PFT)(T);      // error

template&lt;typename T&gt;
using PFT2 = int (*)(T);   // OK
</code></pre>
<h5 id="Enforcement-314"><a href="#Enforcement-314" class="headerlink" title="Enforcement"></a>Enforcement</h5><ul>
<li>Flag uses of <code>typedef</code>. This will give a lot of “hits” :-(</li>
</ul>
<h3 id="T-44-Use-function-templates-to-deduce-class-template-argument-types-where-feasible"><a href="#T-44-Use-function-templates-to-deduce-class-template-argument-types-where-feasible" class="headerlink" title="T.44: Use function templates to deduce class template argument types (where feasible)"></a><a name="Rt-deduce"></a>T.44: Use function templates to deduce class template argument types (where feasible)</h3><h5 id="Reason-344"><a href="#Reason-344" class="headerlink" title="Reason"></a>Reason</h5><p>Writing the template argument types explicitly can be tedious and unnecessarily verbose.</p>
<h5 id="Example-295"><a href="#Example-295" class="headerlink" title="Example"></a>Example</h5><pre><code>tuple&lt;int, string, double&gt; t1 = &#123;1, &quot;Hamlet&quot;, 3.14&#125;;   // explicit type
auto t2 = make_tuple(1, &quot;Ophelia&quot;s, 3.14);         // better; deduced type
</code></pre>
<p>Note the use of the <code>s</code> suffix to ensure that the string is a <code>std::string</code>, rather than a C-style string.</p>
<h5 id="Note-307"><a href="#Note-307" class="headerlink" title="Note"></a>Note</h5><p>Since you can trivially write a <code>make_T</code> function, so could the compiler. Thus, <code>make_T</code> functions may become redundant in the future.</p>
<h5 id="Exception-50"><a href="#Exception-50" class="headerlink" title="Exception"></a>Exception</h5><p>Sometimes there isn’t a good way of getting the template arguments deduced and sometimes, you want to specify the arguments explicitly:</p>
<pre><code>vector&lt;double&gt; v = &#123; 1, 2, 3, 7.9, 15.99 &#125;;
list&lt;Record*&gt; lst;
</code></pre>
<h5 id="Note-308"><a href="#Note-308" class="headerlink" title="Note"></a>Note</h5><p>Note that C++17 will make this rule redundant by allowing the template arguments to be deduced directly from constructor arguments:<br><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/p0091r1.html">Template parameter deduction for constructors (Rev. 3)</a>.<br>For example:</p>
<pre><code>tuple t1 = &#123;1, &quot;Hamlet&quot;s, 3.14&#125;; // deduced: tuple&lt;int, string, double&gt;
</code></pre>
<h5 id="Enforcement-315"><a href="#Enforcement-315" class="headerlink" title="Enforcement"></a>Enforcement</h5><p>Flag uses where an explicitly specialized type exactly matches the types of the arguments used.</p>
<h3 id="T-46-Require-template-arguments-to-be-at-least-Regular-or-SemiRegular"><a href="#T-46-Require-template-arguments-to-be-at-least-Regular-or-SemiRegular" class="headerlink" title="T.46: Require template arguments to be at least Regular or SemiRegular"></a><a name="Rt-regular"></a>T.46: Require template arguments to be at least <code>Regular</code> or <code>SemiRegular</code></h3><h5 id="Reason-345"><a href="#Reason-345" class="headerlink" title="Reason"></a>Reason</h5><p> Readability.<br> Preventing surprises and errors.<br> Most uses support that anyway.</p>
<h5 id="Example-296"><a href="#Example-296" class="headerlink" title="Example"></a>Example</h5><pre><code>class X &#123;
        // ...
public:
    explicit X(int);
    X(const X&amp;);            // copy
    X operator=(const X&amp;);
    X(X&amp;&amp;) noexcept;                 // move
    X&amp; operator=(X&amp;&amp;) noexcept;
    ~X();
    // ... no more constructors ...
&#125;;

X x &#123;1&#125;;    // fine
X y = x;      // fine
std::vector&lt;X&gt; v(10); // error: no default constructor
</code></pre>
<h5 id="Note-309"><a href="#Note-309" class="headerlink" title="Note"></a>Note</h5><p>Semiregular requires default constructible.</p>
<h5 id="Enforcement-316"><a href="#Enforcement-316" class="headerlink" title="Enforcement"></a>Enforcement</h5><ul>
<li>Flag types that are not at least <code>SemiRegular</code>.</li>
</ul>
<h3 id="T-47-Avoid-highly-visible-unconstrained-templates-with-common-names"><a href="#T-47-Avoid-highly-visible-unconstrained-templates-with-common-names" class="headerlink" title="T.47: Avoid highly visible unconstrained templates with common names"></a><a name="Rt-visible"></a>T.47: Avoid highly visible unconstrained templates with common names</h3><h5 id="Reason-346"><a href="#Reason-346" class="headerlink" title="Reason"></a>Reason</h5><p> An unconstrained template argument is a perfect match for anything so such a template can be preferred over more specific types that require minor conversions.<br> This is particularly annoying/dangerous when ADL is used.<br> Common names make this problem more likely.</p>
<h5 id="Example-297"><a href="#Example-297" class="headerlink" title="Example"></a>Example</h5><pre><code>namespace Bad &#123;
    struct S &#123; int m; &#125;;
    template&lt;typename T1, typename T2&gt;
    bool operator==(T1, T2) &#123; cout &lt;&lt; &quot;Bad\n&quot;; return true; &#125;
&#125;

namespace T0 &#123;
    bool operator==(int, Bad::S) &#123; cout &lt;&lt; &quot;T0\n&quot;; return true; &#125;  // compare to int

    void test()
    &#123;
        Bad::S bad&#123; 1 &#125;;
        vector&lt;int&gt; v(10);
        bool b = 1 == bad;
        bool b2 = v.size() == bad;
    &#125;
&#125;
</code></pre>
<p>This prints <code>T0</code> and <code>Bad</code>.</p>
<p>Now the <code>==</code> in <code>Bad</code> was designed to cause trouble, but would you have spotted the problem in real code?<br>The problem is that <code>v.size()</code> returns an <code>unsigned</code> integer so that a conversion is needed to call the local <code>==</code>;<br>the <code>==</code> in <code>Bad</code> requires no conversions.<br>Realistic types, such as the standard-library iterators can be made to exhibit similar anti-social tendencies.</p>
<h5 id="Note-310"><a href="#Note-310" class="headerlink" title="Note"></a>Note</h5><p>If an unconstrained template is defined in the same namespace as a type,<br>that unconstrained template can be found by ADL (as happened in the example).<br>That is, it is highly visible.</p>
<h5 id="Note-311"><a href="#Note-311" class="headerlink" title="Note"></a>Note</h5><p>This rule should not be necessary, but the committee cannot agree to exclude unconstrained templated from ADL.</p>
<p>Unfortunately this will get many false positives; the standard library violates this widely, by putting many unconstrained templates and types into the single namespace <code>std</code>.</p>
<h5 id="Enforcement-317"><a href="#Enforcement-317" class="headerlink" title="Enforcement"></a>Enforcement</h5><p>Flag templates defined in a namespace where concrete types are also defined (maybe not feasible until we have concepts).</p>
<h3 id="T-48-If-your-compiler-does-not-support-concepts-fake-them-with-enable-if"><a href="#T-48-If-your-compiler-does-not-support-concepts-fake-them-with-enable-if" class="headerlink" title="T.48: If your compiler does not support concepts, fake them with enable_if"></a><a name="Rt-concept-def"></a>T.48: If your compiler does not support concepts, fake them with <code>enable_if</code></h3><h5 id="Reason-347"><a href="#Reason-347" class="headerlink" title="Reason"></a>Reason</h5><p>Because that’s the best we can do without direct concept support.<br><code>enable_if</code> can be used to conditionally define functions and to select among a set of functions.</p>
<h5 id="Example-298"><a href="#Example-298" class="headerlink" title="Example"></a>Example</h5><pre><code>enable_if&lt;???&gt;
</code></pre>
<h5 id="Note-312"><a href="#Note-312" class="headerlink" title="Note"></a>Note</h5><p>Beware of [complementary constraints](# T.25).<br>Faking concept overloading using <code>enable_if</code> sometimes forces us to use that error-prone design technique.</p>
<h5 id="Enforcement-318"><a href="#Enforcement-318" class="headerlink" title="Enforcement"></a>Enforcement</h5><p>???</p>
<h3 id="T-49-Where-possible-avoid-type-erasure"><a href="#T-49-Where-possible-avoid-type-erasure" class="headerlink" title="T.49: Where possible, avoid type-erasure"></a><a name="Rt-erasure"></a>T.49: Where possible, avoid type-erasure</h3><h5 id="Reason-348"><a href="#Reason-348" class="headerlink" title="Reason"></a>Reason</h5><p>Type erasure incurs an extra level of indirection by hiding type information behind a separate compilation boundary.</p>
<h5 id="Example-299"><a href="#Example-299" class="headerlink" title="Example"></a>Example</h5><pre><code>???
</code></pre>
<p><strong>Exceptions</strong>: Type erasure is sometimes appropriate, such as for <code>std::function</code>.</p>
<h5 id="Enforcement-319"><a href="#Enforcement-319" class="headerlink" title="Enforcement"></a>Enforcement</h5><p>???</p>
<h5 id="Note-313"><a href="#Note-313" class="headerlink" title="Note"></a>Note</h5><h2 id="T-def-Template-definitions"><a href="#T-def-Template-definitions" class="headerlink" title="T.def: Template definitions"></a><a name="SS-temp-def"></a>T.def: Template definitions</h2><p>A template definition (class or function) can contain arbitrary code, so only a comprehensive review of C++ programming techniques would cover this topic.<br>However, this section focuses on what is specific to template implementation.<br>In particular, it focuses on a template definition’s dependence on its context.</p>
<h3 id="T-60-Minimize-a-template’s-context-dependencies"><a href="#T-60-Minimize-a-template’s-context-dependencies" class="headerlink" title="T.60: Minimize a template’s context dependencies"></a><a name="Rt-depend"></a>T.60: Minimize a template’s context dependencies</h3><h5 id="Reason-349"><a href="#Reason-349" class="headerlink" title="Reason"></a>Reason</h5><p>Eases understanding.<br>Minimizes errors from unexpected dependencies.<br>Eases tool creation.</p>
<h5 id="Example-300"><a href="#Example-300" class="headerlink" title="Example"></a>Example</h5><pre><code>template&lt;typename C&gt;
void sort(C&amp; c)
&#123;
    std::sort(begin(c), end(c)); // necessary and useful dependency
&#125;

template&lt;typename Iter&gt;
Iter algo(Iter first, Iter last) &#123;
    for (; first != last; ++first) &#123;
        auto x = sqrt(*first); // potentially surprising dependency: which sqrt()?
        helper(first, x);      // potentially surprising dependency:
                               // helper is chosen based on first and x
        TT var = 7;            // potentially surprising dependency: which TT?
    &#125;
&#125;
</code></pre>
<h5 id="Note-314"><a href="#Note-314" class="headerlink" title="Note"></a>Note</h5><p>Templates typically appear in header files so their context dependencies are more vulnerable to <code>#include</code> order dependencies than functions in <code>.cpp</code> files.</p>
<h5 id="Note-315"><a href="#Note-315" class="headerlink" title="Note"></a>Note</h5><p>Having a template operate only on its arguments would be one way of reducing the number of dependencies to a minimum, but that would generally be unmanageable.<br>For example, an algorithm usually uses other algorithms and invoke operations that does not exclusively operate on arguments.<br>And don’t get us started on macros!</p>
<p><strong>See also</strong>: <a href="#Rt-customization">T.69</a></p>
<h5 id="Enforcement-320"><a href="#Enforcement-320" class="headerlink" title="Enforcement"></a>Enforcement</h5><p>??? Tricky</p>
<h3 id="T-61-Do-not-over-parameterize-members-SCARY"><a href="#T-61-Do-not-over-parameterize-members-SCARY" class="headerlink" title="T.61: Do not over-parameterize members (SCARY)"></a><a name="Rt-scary"></a>T.61: Do not over-parameterize members (SCARY)</h3><h5 id="Reason-350"><a href="#Reason-350" class="headerlink" title="Reason"></a>Reason</h5><p>A member that does not depend on a template parameter cannot be used except for a specific template argument.<br>This limits use and typically increases code size.</p>
<h5 id="Example-bad-125"><a href="#Example-bad-125" class="headerlink" title="Example, bad"></a>Example, bad</h5><pre><code>template&lt;typename T, typename A = std::allocator&#123;&#125;&gt;
    // requires Regular&lt;T&gt; &amp;&amp; Allocator&lt;A&gt;
class List &#123;
public:
    struct Link &#123;   // does not depend on A
        T elem;
        T* pre;
        T* suc;
    &#125;;

    using iterator = Link*;

    iterator first() const &#123; return head; &#125;

    // ...
private:
    Link* head;
&#125;;

List&lt;int&gt; lst1;
List&lt;int, My_allocator&gt; lst2;

???
</code></pre>
<p>This looks innocent enough, but ???</p>
<pre><code>template&lt;typename T&gt;
struct Link &#123;
    T elem;
    T* pre;
    T* suc;
&#125;;

template&lt;typename T, typename A = std::allocator&#123;&#125;&gt;
    // requires Regular&lt;T&gt; &amp;&amp; Allocator&lt;A&gt;
class List2 &#123;
public:
    using iterator = Link&lt;T&gt;*;

    iterator first() const &#123; return head; &#125;

    // ...
private:
    Link* head;
&#125;;

List&lt;int&gt; lst1;
List&lt;int, My_allocator&gt; lst2;

???
</code></pre>
<h5 id="Enforcement-321"><a href="#Enforcement-321" class="headerlink" title="Enforcement"></a>Enforcement</h5><ul>
<li>Flag member types that do not depend on every template argument</li>
<li>Flag member functions that do not depend on every template argument</li>
</ul>
<h3 id="T-62-Place-non-dependent-class-template-members-in-a-non-templated-base-class"><a href="#T-62-Place-non-dependent-class-template-members-in-a-non-templated-base-class" class="headerlink" title="T.62: Place non-dependent class template members in a non-templated base class"></a><a name="Rt-nondependent"></a>T.62: Place non-dependent class template members in a non-templated base class</h3><h5 id="Reason-351"><a href="#Reason-351" class="headerlink" title="Reason"></a>Reason</h5><p> Allow the base class members to be used without specifying template arguments and without template instantiation.</p>
<h5 id="Example-301"><a href="#Example-301" class="headerlink" title="Example"></a>Example</h5><pre><code>template&lt;typename T&gt;
class Foo &#123;
public:
    enum &#123; v1, v2 &#125;;
    // ...
&#125;;
</code></pre>
<p>???</p>
<pre><code>struct Foo_base &#123;
    enum &#123; v1, v2 &#125;;
    // ...
&#125;;

template&lt;typename T&gt;
class Foo : public Foo_base &#123;
public:
    // ...
&#125;;
</code></pre>
<h5 id="Note-316"><a href="#Note-316" class="headerlink" title="Note"></a>Note</h5><p>A more general version of this rule would be<br>“If a template class member depends on only N template parameters out of M, place it in a base class with only N parameters.”<br>For N == 1, we have a choice of a base class of a class in the surrounding scope as in <a href="#Rt-scary">T.61</a>.</p>
<p>??? What about constants? class statics?</p>
<h5 id="Enforcement-322"><a href="#Enforcement-322" class="headerlink" title="Enforcement"></a>Enforcement</h5><ul>
<li>Flag ???</li>
</ul>
<h3 id="T-64-Use-specialization-to-provide-alternative-implementations-of-class-templates"><a href="#T-64-Use-specialization-to-provide-alternative-implementations-of-class-templates" class="headerlink" title="T.64: Use specialization to provide alternative implementations of class templates"></a><a name="Rt-specialization"></a>T.64: Use specialization to provide alternative implementations of class templates</h3><h5 id="Reason-352"><a href="#Reason-352" class="headerlink" title="Reason"></a>Reason</h5><p>A template defines a general interface.<br>Specialization offers a powerful mechanism for providing alternative implementations of that interface.</p>
<h5 id="Example-302"><a href="#Example-302" class="headerlink" title="Example"></a>Example</h5><pre><code>??? string specialization (==)

??? representation specialization ?
</code></pre>
<h5 id="Note-317"><a href="#Note-317" class="headerlink" title="Note"></a>Note</h5><p>???</p>
<h5 id="Enforcement-323"><a href="#Enforcement-323" class="headerlink" title="Enforcement"></a>Enforcement</h5><p>???</p>
<h3 id="T-65-Use-tag-dispatch-to-provide-alternative-implementations-of-a-function"><a href="#T-65-Use-tag-dispatch-to-provide-alternative-implementations-of-a-function" class="headerlink" title="T.65: Use tag dispatch to provide alternative implementations of a function"></a><a name="Rt-tag-dispatch"></a>T.65: Use tag dispatch to provide alternative implementations of a function</h3><h5 id="Reason-353"><a href="#Reason-353" class="headerlink" title="Reason"></a>Reason</h5><ul>
<li>A template defines a general interface.</li>
<li>Tag dispatch allows us to select implementations based on specific properties of an argument type.</li>
<li>Performance.</li>
</ul>
<h5 id="Example-303"><a href="#Example-303" class="headerlink" title="Example"></a>Example</h5><p>This is a simplified version of <code>std::copy</code> (ignoring the possibility of non-contiguous sequences)</p>
<pre><code>struct pod_tag &#123;&#125;;
struct non_pod_tag &#123;&#125;;

template&lt;class T&gt; struct copy_trait &#123; using tag = non_pod_tag; &#125;;   // T is not &quot;plain old data&quot;

template&lt;&gt; struct copy_trait&lt;int&gt; &#123; using tag = pod_tag; &#125;;         // int is &quot;plain old data&quot;

template&lt;class Iter&gt;
Out copy_helper(Iter first, Iter last, Iter out, pod_tag)
&#123;
    // use memmove
&#125;

template&lt;class Iter&gt;
Out copy_helper(Iter first, Iter last, Iter out, non_pod_tag)
&#123;
    // use loop calling copy constructors
&#125;

template&lt;class Itert&gt;
Out copy(Iter first, Iter last, Iter out)
&#123;
    return copy_helper(first, last, out, typename copy_trait&lt;Iter&gt;::tag&#123;&#125;)
&#125;

void use(vector&lt;int&gt;&amp; vi, vector&lt;int&gt;&amp; vi2, vector&lt;string&gt;&amp; vs, vector&lt;string&gt;&amp; vs2)
&#123;
    copy(vi.begin(), vi.end(), vi2.begin()); // uses memmove
    copy(vs.begin(), vs.end(), vs2.begin()); // uses a loop calling copy constructors
&#125;
</code></pre>
<p>This is a general and powerful technique for compile-time algorithm selection.</p>
<h5 id="Note-318"><a href="#Note-318" class="headerlink" title="Note"></a>Note</h5><p>When <code>concept</code>s become widely available such alternatives can be distinguished directly:</p>
<pre><code>template&lt;class Iter&gt;
    requires Pod&lt;Value_type&lt;iter&gt;&gt;
Out copy_helper(In, first, In last, Out out)
&#123;
    // use memmove
&#125;

template&lt;class Iter&gt;
Out copy_helper(In, first, In last, Out out)
&#123;
    // use loop calling copy constructors
&#125;
</code></pre>
<h5 id="Enforcement-324"><a href="#Enforcement-324" class="headerlink" title="Enforcement"></a>Enforcement</h5><p>???</p>
<h3 id="T-67-Use-specialization-to-provide-alternative-implementations-for-irregular-types"><a href="#T-67-Use-specialization-to-provide-alternative-implementations-for-irregular-types" class="headerlink" title="T.67: Use specialization to provide alternative implementations for irregular types"></a><a name="Rt-specialization2"></a>T.67: Use specialization to provide alternative implementations for irregular types</h3><h5 id="Reason-354"><a href="#Reason-354" class="headerlink" title="Reason"></a>Reason</h5><p> ???</p>
<h5 id="Example-304"><a href="#Example-304" class="headerlink" title="Example"></a>Example</h5><pre><code>???
</code></pre>
<h5 id="Enforcement-325"><a href="#Enforcement-325" class="headerlink" title="Enforcement"></a>Enforcement</h5><p>???</p>
<h3 id="T-68-Use-rather-than-within-templates-to-avoid-ambiguities"><a href="#T-68-Use-rather-than-within-templates-to-avoid-ambiguities" class="headerlink" title="T.68: Use {} rather than () within templates to avoid ambiguities"></a><a name="Rt-cast"></a>T.68: Use <code>&#123;&#125;</code> rather than <code>()</code> within templates to avoid ambiguities</h3><h5 id="Reason-355"><a href="#Reason-355" class="headerlink" title="Reason"></a>Reason</h5><p> <code>()</code> is vulnerable to grammar ambiguities.</p>
<h5 id="Example-305"><a href="#Example-305" class="headerlink" title="Example"></a>Example</h5><pre><code>template&lt;typename T, typename U&gt;
void f(T t, U u)
&#123;
    T v1(x);    // is v1 a function of a variable?
    T v2 &#123;x&#125;;   // variable
    auto x = T(u);  // construction or cast?
&#125;

f(1, &quot;asdf&quot;); // bad: cast from const char* to int
</code></pre>
<h5 id="Enforcement-326"><a href="#Enforcement-326" class="headerlink" title="Enforcement"></a>Enforcement</h5><ul>
<li>flag <code>()</code> initializers</li>
<li>flag function-style casts</li>
</ul>
<h3 id="T-69-Inside-a-template-don’t-make-an-unqualified-nonmember-function-call-unless-you-intend-it-to-be-a-customization-point"><a href="#T-69-Inside-a-template-don’t-make-an-unqualified-nonmember-function-call-unless-you-intend-it-to-be-a-customization-point" class="headerlink" title="T.69: Inside a template, don’t make an unqualified nonmember function call unless you intend it to be a customization point"></a><a name="Rt-customization"></a>T.69: Inside a template, don’t make an unqualified nonmember function call unless you intend it to be a customization point</h3><h5 id="Reason-356"><a href="#Reason-356" class="headerlink" title="Reason"></a>Reason</h5><ul>
<li>Provide only intended flexibility.</li>
<li>Avoid vulnerability to accidental environmental changes.</li>
</ul>
<h5 id="Example-306"><a href="#Example-306" class="headerlink" title="Example"></a>Example</h5><p>There are three major ways to let calling code customize a template.</p>
<pre><code>template&lt;class T&gt;
    // Call a member function
void test1(T t)
&#123;
    t.f();    // require T to provide f()
&#125;

template&lt;class T&gt;
void test2(T t)
    // Call a nonmember function without qualification
&#123;
    f(t);  // require f(/*T*/) be available in caller&#39;s scope or in T&#39;s namespace
&#125;

template&lt;class T&gt;
void test3(T t)
    // Invoke a &quot;trait&quot;
&#123;
    test_traits&lt;T&gt;::f(t); // require customizing test_traits&lt;&gt;
                          // to get non-default functions/types
&#125;
</code></pre>
<p>A trait is usually a type alias to compute a type,<br>a <code>constexpr</code> function to compute a value,<br>or a traditional traits template to be specialized on the user’s type.</p>
<h5 id="Note-319"><a href="#Note-319" class="headerlink" title="Note"></a>Note</h5><p>If you intend to call your own helper function <code>helper(t)</code> with a value <code>t</code> that depends on a template type parameter,<br>put it in a <code>::detail</code> namespace and qualify the call as <code>detail::helper(t);</code>.<br>An unqualified call becomes a customization point where any function <code>helper</code> in the namespace of <code>t</code>‘s type can be invoked;<br>this can cause problems like <a href="#Rt-unconstrained-adl">unintentionally invoking unconstrained function templates</a>.</p>
<h5 id="Enforcement-327"><a href="#Enforcement-327" class="headerlink" title="Enforcement"></a>Enforcement</h5><ul>
<li>In a template, flag an unqualified call to a nonmember function that passes a variable of dependent type when there is a nonmember function of the same name in the template’s namespace.</li>
</ul>
<h2 id="T-temp-hier-Template-and-hierarchy-rules"><a href="#T-temp-hier-Template-and-hierarchy-rules" class="headerlink" title="T.temp-hier: Template and hierarchy rules:"></a><a name="SS-temp-hier"></a>T.temp-hier: Template and hierarchy rules:</h2><p>Templates are the backbone of C++’s support for generic programming and class hierarchies the backbone of its support<br>for object-oriented programming.<br>The two language mechanisms can be used effectively in combination, but a few design pitfalls must be avoided.</p>
<h3 id="T-80-Do-not-naively-templatize-a-class-hierarchy"><a href="#T-80-Do-not-naively-templatize-a-class-hierarchy" class="headerlink" title="T.80: Do not naively templatize a class hierarchy"></a><a name="Rt-hier"></a>T.80: Do not naively templatize a class hierarchy</h3><h5 id="Reason-357"><a href="#Reason-357" class="headerlink" title="Reason"></a>Reason</h5><p>Templating a class hierarchy that has many functions, especially many virtual functions, can lead to code bloat.</p>
<h5 id="Example-bad-126"><a href="#Example-bad-126" class="headerlink" title="Example, bad"></a>Example, bad</h5><pre><code>template&lt;typename T&gt;
struct Container &#123;         // an interface
    virtual T* get(int i);
    virtual T* first();
    virtual T* next();
    virtual void sort();
&#125;;

template&lt;typename T&gt;
class Vector : public Container&lt;T&gt; &#123;
public:
    // ...
&#125;;

Vector&lt;int&gt; vi;
Vector&lt;string&gt; vs;
</code></pre>
<p>It is probably a dumb idea to define a <code>sort</code> as a member function of a container, but it is not unheard of and it makes a good example of what not to do.</p>
<p>Given this, the compiler cannot know if <code>vector&lt;int&gt;::sort()</code> is called, so it must generate code for it.<br>Similar for <code>vector&lt;string&gt;::sort()</code>.<br>Unless those two functions are called that’s code bloat.<br>Imagine what this would do to a class hierarchy with dozens of member functions and dozens of derived classes with many instantiations.</p>
<h5 id="Note-320"><a href="#Note-320" class="headerlink" title="Note"></a>Note</h5><p>In many cases you can provide a stable interface by not parameterizing a base;<br>see <a href="#Rt-abi">“stable base”</a> and <a href="#Rt-generic-oo">OO and GP</a></p>
<h5 id="Enforcement-328"><a href="#Enforcement-328" class="headerlink" title="Enforcement"></a>Enforcement</h5><ul>
<li>Flag virtual functions that depend on a template argument. ??? False positives</li>
</ul>
<h3 id="T-81-Do-not-mix-hierarchies-and-arrays"><a href="#T-81-Do-not-mix-hierarchies-and-arrays" class="headerlink" title="T.81: Do not mix hierarchies and arrays"></a><a name="Rt-array"></a>T.81: Do not mix hierarchies and arrays</h3><h5 id="Reason-358"><a href="#Reason-358" class="headerlink" title="Reason"></a>Reason</h5><p>An array of derived classes can implicitly “decay” to a pointer to a base class with potential disastrous results.</p>
<h5 id="Example-307"><a href="#Example-307" class="headerlink" title="Example"></a>Example</h5><p>Assume that <code>Apple</code> and <code>Pear</code> are two kinds of <code>Fruit</code>s.</p>
<pre><code>void maul(Fruit* p)
&#123;
    *p = Pear&#123;&#125;;     // put a Pear into *p
    p[1] = Pear&#123;&#125;;   // put a Pear into p[1]
&#125;

Apple aa [] = &#123; an_apple, another_apple &#125;;   // aa contains Apples (obviously!)

maul(aa);
Apple&amp; a0 = &amp;aa[0];   // a Pear?
Apple&amp; a1 = &amp;aa[1];   // a Pear?
</code></pre>
<p>Probably, <code>aa[0]</code> will be a <code>Pear</code> (without the use of a cast!).<br>If <code>sizeof(Apple) != sizeof(Pear)</code> the access to <code>aa[1]</code> will not be aligned to the proper start of an object in the array.<br>We have a type violation and possibly (probably) a memory corruption.<br>Never write such code.</p>
<p>Note that <code>maul()</code> violates the a <a href="#Rf-ptr"><code>T*</code> points to an individual object rule</a>.</p>
<p><strong>Alternative</strong>: Use a proper (templatized) container:</p>
<pre><code>void maul2(Fruit* p)
&#123;
    *p = Pear&#123;&#125;;   // put a Pear into *p
&#125;

vector&lt;Apple&gt; va = &#123; an_apple, another_apple &#125;;   // va contains Apples (obviously!)

maul2(va);       // error: cannot convert a vector&lt;Apple&gt; to a Fruit*
maul2(&amp;va[0]);   // you asked for it

Apple&amp; a0 = &amp;va[0];   // a Pear?
</code></pre>
<p>Note that the assignment in <code>maul2()</code> violated the <a href="#Res-slice">no-slicing rule</a>.</p>
<h5 id="Enforcement-329"><a href="#Enforcement-329" class="headerlink" title="Enforcement"></a>Enforcement</h5><ul>
<li>Detect this horror!</li>
</ul>
<h3 id="T-82-Linearize-a-hierarchy-when-virtual-functions-are-undesirable"><a href="#T-82-Linearize-a-hierarchy-when-virtual-functions-are-undesirable" class="headerlink" title="T.82: Linearize a hierarchy when virtual functions are undesirable"></a><a name="Rt-linear"></a>T.82: Linearize a hierarchy when virtual functions are undesirable</h3><h5 id="Reason-359"><a href="#Reason-359" class="headerlink" title="Reason"></a>Reason</h5><p> ???</p>
<h5 id="Example-308"><a href="#Example-308" class="headerlink" title="Example"></a>Example</h5><pre><code>???
</code></pre>
<h5 id="Enforcement-330"><a href="#Enforcement-330" class="headerlink" title="Enforcement"></a>Enforcement</h5><p>???</p>
<h3 id="T-83-Do-not-declare-a-member-function-template-virtual"><a href="#T-83-Do-not-declare-a-member-function-template-virtual" class="headerlink" title="T.83: Do not declare a member function template virtual"></a><a name="Rt-virtual"></a>T.83: Do not declare a member function template virtual</h3><h5 id="Reason-360"><a href="#Reason-360" class="headerlink" title="Reason"></a>Reason</h5><p>C++ does not support that.<br>If it did, vtbls could not be generated until link time.<br>And in general, implementations must deal with dynamic linking.</p>
<h5 id="Example-don’t-8"><a href="#Example-don’t-8" class="headerlink" title="Example, don’t"></a>Example, don’t</h5><pre><code>class Shape &#123;
    // ...
    template&lt;class T&gt;
    virtual bool intersect(T* p);   // error: template cannot be virtual
&#125;;
</code></pre>
<h5 id="Note-321"><a href="#Note-321" class="headerlink" title="Note"></a>Note</h5><p>We need a rule because people keep asking about this</p>
<h5 id="Alternative-10"><a href="#Alternative-10" class="headerlink" title="Alternative"></a>Alternative</h5><p>Double dispatch, visitors, calculate which function to call</p>
<h5 id="Enforcement-331"><a href="#Enforcement-331" class="headerlink" title="Enforcement"></a>Enforcement</h5><p>The compiler handles that.</p>
<h3 id="T-84-Use-a-non-template-core-implementation-to-provide-an-ABI-stable-interface"><a href="#T-84-Use-a-non-template-core-implementation-to-provide-an-ABI-stable-interface" class="headerlink" title="T.84: Use a non-template core implementation to provide an ABI-stable interface"></a><a name="Rt-abi"></a>T.84: Use a non-template core implementation to provide an ABI-stable interface</h3><h5 id="Reason-361"><a href="#Reason-361" class="headerlink" title="Reason"></a>Reason</h5><p>Improve stability of code.<br>Avoid code bloat.</p>
<h5 id="Example-309"><a href="#Example-309" class="headerlink" title="Example"></a>Example</h5><p>It could be a base class:</p>
<pre><code>struct Link_base &#123;   // stable
    Link_base* suc;
    Link_base* pre;
&#125;;

template&lt;typename T&gt;   // templated wrapper to add type safety
struct Link : Link_base &#123;
    T val;
&#125;;

struct List_base &#123;
    Link_base* first;   // first element (if any)
    int sz;             // number of elements
    void add_front(Link_base* p);
    // ...
&#125;;

template&lt;typename T&gt;
class List : List_base &#123;
public:
    void put_front(const T&amp; e) &#123; add_front(new Link&lt;T&gt;&#123;e&#125;); &#125;   // implicit cast to Link_base
    T&amp; front() &#123; static_cast&lt;Link&lt;T&gt;*&gt;(first).val; &#125;   // explicit cast back to Link&lt;T&gt;
    // ...
&#125;;

List&lt;int&gt; li;
List&lt;string&gt; ls;
</code></pre>
<p>Now there is only one copy of the operations linking and unlinking elements of a <code>List</code>.<br>The <code>Link</code> and <code>List</code> classes do nothing but type manipulation.</p>
<p>Instead of using a separate “base” type, another common technique is to specialize for <code>void</code> or <code>void*</code> and have the general template for <code>T</code> be just the safely-encapsulated casts to and from the core <code>void</code> implementation.</p>
<p><strong>Alternative</strong>: Use a <a href="#Ri-pimpl">Pimpl</a> implementation.</p>
<h5 id="Enforcement-332"><a href="#Enforcement-332" class="headerlink" title="Enforcement"></a>Enforcement</h5><p>???</p>
<h2 id="T-var-Variadic-template-rules"><a href="#T-var-Variadic-template-rules" class="headerlink" title="T.var: Variadic template rules"></a><a name="SS-variadic"></a>T.var: Variadic template rules</h2><p>???</p>
<h3 id="T-100-Use-variadic-templates-when-you-need-a-function-that-takes-a-variable-number-of-arguments-of-a-variety-of-types"><a href="#T-100-Use-variadic-templates-when-you-need-a-function-that-takes-a-variable-number-of-arguments-of-a-variety-of-types" class="headerlink" title="T.100: Use variadic templates when you need a function that takes a variable number of arguments of a variety of types"></a><a name="Rt-variadic"></a>T.100: Use variadic templates when you need a function that takes a variable number of arguments of a variety of types</h3><h5 id="Reason-362"><a href="#Reason-362" class="headerlink" title="Reason"></a>Reason</h5><p>Variadic templates is the most general mechanism for that, and is both efficient and type-safe. Don’t use C varargs.</p>
<h5 id="Example-310"><a href="#Example-310" class="headerlink" title="Example"></a>Example</h5><pre><code>??? printf
</code></pre>
<h5 id="Enforcement-333"><a href="#Enforcement-333" class="headerlink" title="Enforcement"></a>Enforcement</h5><ul>
<li>Flag uses of <code>va_arg</code> in user code.</li>
</ul>
<h3 id="T-101-How-to-pass-arguments-to-a-variadic-template"><a href="#T-101-How-to-pass-arguments-to-a-variadic-template" class="headerlink" title="T.101: ??? How to pass arguments to a variadic template ???"></a><a name="Rt-variadic-pass"></a>T.101: ??? How to pass arguments to a variadic template ???</h3><h5 id="Reason-363"><a href="#Reason-363" class="headerlink" title="Reason"></a>Reason</h5><p> ???</p>
<h5 id="Example-311"><a href="#Example-311" class="headerlink" title="Example"></a>Example</h5><pre><code>??? beware of move-only and reference arguments
</code></pre>
<h5 id="Enforcement-334"><a href="#Enforcement-334" class="headerlink" title="Enforcement"></a>Enforcement</h5><p>???</p>
<h3 id="T-102-How-to-process-arguments-to-a-variadic-template"><a href="#T-102-How-to-process-arguments-to-a-variadic-template" class="headerlink" title="T.102: How to process arguments to a variadic template"></a><a name="Rt-variadic-process"></a>T.102: How to process arguments to a variadic template</h3><h5 id="Reason-364"><a href="#Reason-364" class="headerlink" title="Reason"></a>Reason</h5><p> ???</p>
<h5 id="Example-312"><a href="#Example-312" class="headerlink" title="Example"></a>Example</h5><pre><code>??? forwarding, type checking, references
</code></pre>
<h5 id="Enforcement-335"><a href="#Enforcement-335" class="headerlink" title="Enforcement"></a>Enforcement</h5><p>???</p>
<h3 id="T-103-Don’t-use-variadic-templates-for-homogeneous-argument-lists"><a href="#T-103-Don’t-use-variadic-templates-for-homogeneous-argument-lists" class="headerlink" title="T.103: Don’t use variadic templates for homogeneous argument lists"></a><a name="Rt-variadic-not"></a>T.103: Don’t use variadic templates for homogeneous argument lists</h3><h5 id="Reason-365"><a href="#Reason-365" class="headerlink" title="Reason"></a>Reason</h5><p>There are more precise ways of specifying a homogeneous sequence, such as an <code>initializer_list</code>.</p>
<h5 id="Example-313"><a href="#Example-313" class="headerlink" title="Example"></a>Example</h5><pre><code>???
</code></pre>
<h5 id="Enforcement-336"><a href="#Enforcement-336" class="headerlink" title="Enforcement"></a>Enforcement</h5><p>???</p>
<h2 id="T-meta-Template-metaprogramming-TMP"><a href="#T-meta-Template-metaprogramming-TMP" class="headerlink" title="T.meta: Template metaprogramming (TMP)"></a><a name="SS-meta"></a>T.meta: Template metaprogramming (TMP)</h2><p>Templates provide a general mechanism for compile-time programming.</p>
<p>Metaprogramming is programming where at least one input or one result is a type.<br>Templates offer Turing-complete (modulo memory capacity) duck typing at compile time.<br>The syntax and techniques needed are pretty horrendous.</p>
<h3 id="T-120-Use-template-metaprogramming-only-when-you-really-need-to"><a href="#T-120-Use-template-metaprogramming-only-when-you-really-need-to" class="headerlink" title="T.120: Use template metaprogramming only when you really need to"></a><a name="Rt-metameta"></a>T.120: Use template metaprogramming only when you really need to</h3><h5 id="Reason-366"><a href="#Reason-366" class="headerlink" title="Reason"></a>Reason</h5><p>Template metaprogramming is hard to get right, slows down compilation, and is often very hard to maintain.<br>However, there are real-world examples where template metaprogramming provides better performance than any alternative short of expert-level assembly code.<br>Also, there are real-world examples where template metaprogramming expresses the fundamental ideas better than run-time code.<br>For example, if you really need AST manipulation at compile time (e.g., for optional matrix operation folding) there may be no other way in C++.</p>
<h5 id="Example-bad-127"><a href="#Example-bad-127" class="headerlink" title="Example, bad"></a>Example, bad</h5><pre><code>???
</code></pre>
<h5 id="Example-bad-128"><a href="#Example-bad-128" class="headerlink" title="Example, bad"></a>Example, bad</h5><pre><code>enable_if
</code></pre>
<p>Instead, use concepts. But see <a href="#Rt-emulate">How to emulate concepts if you don’t have language support</a>.</p>
<h5 id="Example-314"><a href="#Example-314" class="headerlink" title="Example"></a>Example</h5><pre><code>??? good
</code></pre>
<p><strong>Alternative</strong>: If the result is a value, rather than a type, use a <a href="#Rt-fct"><code>constexpr</code> function</a>.</p>
<h5 id="Note-322"><a href="#Note-322" class="headerlink" title="Note"></a>Note</h5><p>If you feel the need to hide your template metaprogramming in macros, you have probably gone too far.</p>
<h3 id="T-121-Use-template-metaprogramming-primarily-to-emulate-concepts"><a href="#T-121-Use-template-metaprogramming-primarily-to-emulate-concepts" class="headerlink" title="T.121: Use template metaprogramming primarily to emulate concepts"></a><a name="Rt-emulate"></a>T.121: Use template metaprogramming primarily to emulate concepts</h3><h5 id="Reason-367"><a href="#Reason-367" class="headerlink" title="Reason"></a>Reason</h5><p>Until concepts become generally available, we need to emulate them using TMP.<br>Use cases that require concepts (e.g. overloading based on concepts) are among the most common (and simple) uses of TMP.</p>
<h5 id="Example-315"><a href="#Example-315" class="headerlink" title="Example"></a>Example</h5><pre><code>template&lt;typename Iter&gt;
    /*requires*/ enable_if&lt;random_access_iterator&lt;Iter&gt;, void&gt;
advance(Iter p, int n) &#123; p += n; &#125;

template&lt;typename Iter&gt;
    /*requires*/ enable_if&lt;forward_iterator&lt;Iter&gt;, void&gt;
advance(Iter p, int n) &#123; assert(n &gt;= 0); while (n--) ++p;&#125;
</code></pre>
<h5 id="Note-323"><a href="#Note-323" class="headerlink" title="Note"></a>Note</h5><p>Such code is much simpler using concepts:</p>
<pre><code>void advance(RandomAccessIterator p, int n) &#123; p += n; &#125;

void advance(ForwardIterator p, int n) &#123; assert(n &gt;= 0); while (n--) ++p;&#125;
</code></pre>
<h5 id="Enforcement-337"><a href="#Enforcement-337" class="headerlink" title="Enforcement"></a>Enforcement</h5><p>???</p>
<h3 id="T-122-Use-templates-usually-template-aliases-to-compute-types-at-compile-time"><a href="#T-122-Use-templates-usually-template-aliases-to-compute-types-at-compile-time" class="headerlink" title="T.122: Use templates (usually template aliases) to compute types at compile time"></a><a name="Rt-tmp"></a>T.122: Use templates (usually template aliases) to compute types at compile time</h3><h5 id="Reason-368"><a href="#Reason-368" class="headerlink" title="Reason"></a>Reason</h5><p>Template metaprogramming is the only directly supported and half-way principled way of generating types at compile time.</p>
<h5 id="Note-324"><a href="#Note-324" class="headerlink" title="Note"></a>Note</h5><p>“Traits” techniques are mostly replaced by template aliases to compute types and <code>constexpr</code> functions to compute values.</p>
<h5 id="Example-316"><a href="#Example-316" class="headerlink" title="Example"></a>Example</h5><pre><code>??? big object / small object optimization
</code></pre>
<h5 id="Enforcement-338"><a href="#Enforcement-338" class="headerlink" title="Enforcement"></a>Enforcement</h5><p>???</p>
<h3 id="T-123-Use-constexpr-functions-to-compute-values-at-compile-time"><a href="#T-123-Use-constexpr-functions-to-compute-values-at-compile-time" class="headerlink" title="T.123: Use constexpr functions to compute values at compile time"></a><a name="Rt-fct"></a>T.123: Use <code>constexpr</code> functions to compute values at compile time</h3><h5 id="Reason-369"><a href="#Reason-369" class="headerlink" title="Reason"></a>Reason</h5><p>A function is the most obvious and conventional way of expressing the computation of a value.<br>Often a <code>constexpr</code> function implies less compile-time overhead than alternatives.</p>
<h5 id="Note-325"><a href="#Note-325" class="headerlink" title="Note"></a>Note</h5><p>“Traits” techniques are mostly replaced by template aliases to compute types and <code>constexpr</code> functions to compute values.</p>
<h5 id="Example-317"><a href="#Example-317" class="headerlink" title="Example"></a>Example</h5><pre><code>template&lt;typename T&gt;
    // requires Number&lt;T&gt;
constexpr T pow(T v, int n)   // power/exponential
&#123;
    T res = 1;
    while (n--) res *= v;
    return res;
&#125;

constexpr auto f7 = pow(pi, 7);
</code></pre>
<h5 id="Enforcement-339"><a href="#Enforcement-339" class="headerlink" title="Enforcement"></a>Enforcement</h5><ul>
<li>Flag template metaprograms yielding a value. These should be replaced with <code>constexpr</code> functions.</li>
</ul>
<h3 id="T-124-Prefer-to-use-standard-library-TMP-facilities"><a href="#T-124-Prefer-to-use-standard-library-TMP-facilities" class="headerlink" title="T.124: Prefer to use standard-library TMP facilities"></a><a name="Rt-std-tmp"></a>T.124: Prefer to use standard-library TMP facilities</h3><h5 id="Reason-370"><a href="#Reason-370" class="headerlink" title="Reason"></a>Reason</h5><p>Facilities defined in the standard, such as <code>conditional</code>, <code>enable_if</code>, and <code>tuple</code>, are portable and can be assumed to be known.</p>
<h5 id="Example-318"><a href="#Example-318" class="headerlink" title="Example"></a>Example</h5><pre><code>???
</code></pre>
<h5 id="Enforcement-340"><a href="#Enforcement-340" class="headerlink" title="Enforcement"></a>Enforcement</h5><p>???</p>
<h3 id="T-125-If-you-need-to-go-beyond-the-standard-library-TMP-facilities-use-an-existing-library"><a href="#T-125-If-you-need-to-go-beyond-the-standard-library-TMP-facilities-use-an-existing-library" class="headerlink" title="T.125: If you need to go beyond the standard-library TMP facilities, use an existing library"></a><a name="Rt-lib"></a>T.125: If you need to go beyond the standard-library TMP facilities, use an existing library</h3><h5 id="Reason-371"><a href="#Reason-371" class="headerlink" title="Reason"></a>Reason</h5><p>Getting advanced TMP facilities is not easy and using a library makes you part of a (hopefully supportive) community.<br>Write your own “advanced TMP support” only if you really have to.</p>
<h5 id="Example-319"><a href="#Example-319" class="headerlink" title="Example"></a>Example</h5><pre><code>???
</code></pre>
<h5 id="Enforcement-341"><a href="#Enforcement-341" class="headerlink" title="Enforcement"></a>Enforcement</h5><p>???</p>
<h2 id="Other-template-rules"><a href="#Other-template-rules" class="headerlink" title="Other template rules"></a><a name="SS-temp-other"></a>Other template rules</h2><h3 id="T-140-Name-all-operations-with-potential-for-reuse"><a href="#T-140-Name-all-operations-with-potential-for-reuse" class="headerlink" title="T.140: Name all operations with potential for reuse"></a><a name="Rt-name"></a>T.140: Name all operations with potential for reuse</h3><h5 id="Reason-372"><a href="#Reason-372" class="headerlink" title="Reason"></a>Reason</h5><p>Documentation, readability, opportunity for reuse.</p>
<h5 id="Example-320"><a href="#Example-320" class="headerlink" title="Example"></a>Example</h5><pre><code>struct Rec &#123;
    string name;
    string addr;
    int id;         // unique identifier
&#125;;

bool same(const Rec&amp; a, const Rec&amp; b)
&#123;
    return a.id == b.id;
&#125;

vector&lt;Rec*&gt; find_id(const string&amp; name);    // find all records for &quot;name&quot;

auto x = find_if(vr.begin(), vr.end(),
    [&amp;](Rec&amp; r) &#123;
        if (r.name.size() != n.size()) return false; // name to compare to is in n
        for (int i = 0; i &lt; r.name.size(); ++i)
            if (tolower(r.name[i]) != tolower(n[i])) return false;
        return true;
    &#125;
);
</code></pre>
<p>There is a useful function lurking here (case insensitive string comparison), as there often is when lambda arguments get large.</p>
<pre><code>bool compare_insensitive(const string&amp; a, const string&amp; b)
&#123;
    if (a.size() != b.size()) return false;
    for (int i = 0; i &lt; a.size(); ++i) if (tolower(a[i]) != tolower(b[i])) return false;
    return true;
&#125;

auto x = find_if(vr.begin(), vr.end(),
    [&amp;](Rec&amp; r) &#123; compare_insensitive(r.name, n); &#125;
);
</code></pre>
<p>Or maybe (if you prefer to avoid the implicit name binding to n):</p>
<pre><code>auto cmp_to_n = [&amp;n](const string&amp; a) &#123; return compare_insensitive(a, n); &#125;;

auto x = find_if(vr.begin(), vr.end(),
    [](const Rec&amp; r) &#123; return cmp_to_n(r.name); &#125;
);
</code></pre>
<h5 id="Note-326"><a href="#Note-326" class="headerlink" title="Note"></a>Note</h5><p>whether functions, lambdas, or operators.</p>
<h5 id="Exception-51"><a href="#Exception-51" class="headerlink" title="Exception"></a>Exception</h5><ul>
<li>Lambdas logically used only locally, such as an argument to <code>for_each</code> and similar control flow algorithms.</li>
<li>Lambdas as <a href="#???">initializers</a></li>
</ul>
<h5 id="Enforcement-342"><a href="#Enforcement-342" class="headerlink" title="Enforcement"></a>Enforcement</h5><ul>
<li>(hard) flag similar lambdas</li>
<li>???</li>
</ul>
<h3 id="T-141-Use-an-unnamed-lambda-if-you-need-a-simple-function-object-in-one-place-only"><a href="#T-141-Use-an-unnamed-lambda-if-you-need-a-simple-function-object-in-one-place-only" class="headerlink" title="T.141: Use an unnamed lambda if you need a simple function object in one place only"></a><a name="Rt-lambda"></a>T.141: Use an unnamed lambda if you need a simple function object in one place only</h3><h5 id="Reason-373"><a href="#Reason-373" class="headerlink" title="Reason"></a>Reason</h5><p>That makes the code concise and gives better locality than alternatives.</p>
<h5 id="Example-321"><a href="#Example-321" class="headerlink" title="Example"></a>Example</h5><pre><code>auto earlyUsersEnd = std::remove_if(users.begin(), users.end(),
                                    [](const User &amp;a) &#123; return a.id &gt; 100; &#125;);
</code></pre>
<h5 id="Exception-52"><a href="#Exception-52" class="headerlink" title="Exception"></a>Exception</h5><p>Naming a lambda can be useful for clarity even if it is used only once.</p>
<h5 id="Enforcement-343"><a href="#Enforcement-343" class="headerlink" title="Enforcement"></a>Enforcement</h5><ul>
<li>Look for identical and near identical lambdas (to be replaced with named functions or named lambdas).</li>
</ul>
<h3 id="T-142-Use-template-variables-to-simplify-notation"><a href="#T-142-Use-template-variables-to-simplify-notation" class="headerlink" title="T.142?: Use template variables to simplify notation"></a><a name="Rt-var"></a>T.142?: Use template variables to simplify notation</h3><h5 id="Reason-374"><a href="#Reason-374" class="headerlink" title="Reason"></a>Reason</h5><p>Improved readability.</p>
<h5 id="Example-322"><a href="#Example-322" class="headerlink" title="Example"></a>Example</h5><pre><code>???
</code></pre>
<h5 id="Enforcement-344"><a href="#Enforcement-344" class="headerlink" title="Enforcement"></a>Enforcement</h5><p>???</p>
<h3 id="T-143-Don’t-write-unintentionally-nongeneric-code"><a href="#T-143-Don’t-write-unintentionally-nongeneric-code" class="headerlink" title="T.143: Don’t write unintentionally nongeneric code"></a><a name="Rt-nongeneric"></a>T.143: Don’t write unintentionally nongeneric code</h3><h5 id="Reason-375"><a href="#Reason-375" class="headerlink" title="Reason"></a>Reason</h5><p>Generality. Reusability. Don’t gratuitously commit to details; use the most general facilities available.</p>
<h5 id="Example-323"><a href="#Example-323" class="headerlink" title="Example"></a>Example</h5><p>Use <code>!=</code> instead of <code>&lt;</code> to compare iterators; <code>!=</code> works for more objects because it doesn’t rely on ordering.</p>
<pre><code>for (auto i = first; i &lt; last; ++i) &#123;   // less generic
    // ...
&#125;

for (auto i = first; i != last; ++i) &#123;   // good; more generic
    // ...
&#125;
</code></pre>
<p>Of course, range-<code>for</code> is better still where it does what you want.</p>
<h5 id="Example-324"><a href="#Example-324" class="headerlink" title="Example"></a>Example</h5><p>Use the least-derived class that has the functionality you need.</p>
<pre><code>class Base &#123;
public:
    Bar f();
    Bar g();
&#125;;

class Derived1 : public Base &#123;
public:
    Bar h();
&#125;;

class Derived2 : public Base &#123;
public:
    Bar j();
&#125;;

// bad, unless there is a specific reason for limiting to Derived1 objects only
void my_func(Derived1&amp; param)
&#123;
    use(param.f());
    use(param.g());
&#125;

// good, uses only Base interface so only commit to that
void my_func(Base&amp; param)
&#123;
    use(param.f());
    use(param.g());
&#125;
</code></pre>
<h5 id="Enforcement-345"><a href="#Enforcement-345" class="headerlink" title="Enforcement"></a>Enforcement</h5><ul>
<li>Flag comparison of iterators using <code>&lt;</code> instead of <code>!=</code>.</li>
<li>Flag <code>x.size() == 0</code> when <code>x.empty()</code> or <code>x.is_empty()</code> is available. Emptiness works for more containers than size(), because some containers don’t know their size or are conceptually of unbounded size.</li>
<li>Flag functions that take a pointer or reference to a more-derived type but only use functions declared in a base type.</li>
</ul>
<h3 id="T-144-Don’t-specialize-function-templates"><a href="#T-144-Don’t-specialize-function-templates" class="headerlink" title="T.144: Don’t specialize function templates"></a><a name="Rt-specialize-function"></a>T.144: Don’t specialize function templates</h3><h5 id="Reason-376"><a href="#Reason-376" class="headerlink" title="Reason"></a>Reason</h5><p>You can’t partially specialize a function template per language rules. You can fully specialize a function template but you almost certainly want to overload instead – because function template specializations don’t participate in overloading, they don’t act as you probably wanted. Rarely, you should actually specialize by delegating to a class template that you can specialize properly.</p>
<h5 id="Example-325"><a href="#Example-325" class="headerlink" title="Example"></a>Example</h5><pre><code>???
</code></pre>
<p><strong>Exceptions</strong>: If you do have a valid reason to specialize a function template, just write a single function template that delegates to a class template, then specialize the class template (including the ability to write partial specializations).</p>
<h5 id="Enforcement-346"><a href="#Enforcement-346" class="headerlink" title="Enforcement"></a>Enforcement</h5><ul>
<li>Flag all specializations of a function template. Overload instead.</li>
</ul>
<h3 id="T-150-Check-that-a-class-matches-a-concept-using-static-assert"><a href="#T-150-Check-that-a-class-matches-a-concept-using-static-assert" class="headerlink" title="T.150: Check that a class matches a concept using static_assert"></a><a name="Rt-check-class"></a>T.150: Check that a class matches a concept using <code>static_assert</code></h3><h5 id="Reason-377"><a href="#Reason-377" class="headerlink" title="Reason"></a>Reason</h5><p>If you intend for a class to match a concept, verifying that early saves users pain.</p>
<h5 id="Example-326"><a href="#Example-326" class="headerlink" title="Example"></a>Example</h5><pre><code>class X &#123;
public:
    X() = delete;
    X(const X&amp;) = default;
    X(X&amp;&amp;) = default;
    X&amp; operator=(const X&amp;) = default;
    // ...
&#125;;
</code></pre>
<p>Somewhere, possibly in an implementation file, let the compiler check the desired properties of <code>X</code>:</p>
<pre><code>static_assert(Default_constructible&lt;X&gt;);    // error: X has no default constructor
static_assert(Copyable&lt;X&gt;);                 // error: we forgot to define X&#39;s move constructor
</code></pre>
<h5 id="Enforcement-347"><a href="#Enforcement-347" class="headerlink" title="Enforcement"></a>Enforcement</h5><p>Not feasible.</p>
<h1 id="CPL-C-style-programming"><a href="#CPL-C-style-programming" class="headerlink" title="CPL: C-style programming"></a><a name="S-cpl"></a>CPL: C-style programming</h1><p>C and C++ are closely related languages.<br>They both originate in “Classic C” from 1978 and have evolved in ISO committees since then.<br>Many attempts have been made to keep them compatible, but neither is a subset of the other.</p>
<p>C rule summary:</p>
<ul>
<li><a href="#Rcpl-C">CPL.1: Prefer C++ to C</a></li>
<li><a href="#Rcpl-subset">CPL.2: If you must use C, use the common subset of C and C++, and compile the C code as C++</a></li>
<li><a href="#Rcpl-interface">CPL.3: If you must use C for interfaces, use C++ in the calling code using such interfaces</a></li>
</ul>
<h3 id="CPL-1-Prefer-C-to-C"><a href="#CPL-1-Prefer-C-to-C" class="headerlink" title="CPL.1: Prefer C++ to C"></a><a name="Rcpl-C"></a>CPL.1: Prefer C++ to C</h3><h5 id="Reason-378"><a href="#Reason-378" class="headerlink" title="Reason"></a>Reason</h5><p>C++ provides better type checking and more notational support.<br>It provides better support for high-level programming and often generates faster code.</p>
<h5 id="Example-327"><a href="#Example-327" class="headerlink" title="Example"></a>Example</h5><pre><code>char ch = 7;
void* pv = &amp;ch;
int* pi = pv;   // not C++
*pi = 999;      // overwrite sizeof(int) bytes near &amp;ch
</code></pre>
<p>The rules for implicit casting to and from <code>void*</code> in C are subtle and unenforced.<br>In particular, this example violates a rule against converting to a type with stricter alignment.</p>
<h5 id="Enforcement-348"><a href="#Enforcement-348" class="headerlink" title="Enforcement"></a>Enforcement</h5><p>Use a C++ compiler.</p>
<h3 id="CPL-2-If-you-must-use-C-use-the-common-subset-of-C-and-C-and-compile-the-C-code-as-C"><a href="#CPL-2-If-you-must-use-C-use-the-common-subset-of-C-and-C-and-compile-the-C-code-as-C" class="headerlink" title="CPL.2: If you must use C, use the common subset of C and C++, and compile the C code as C++"></a><a name="Rcpl-subset"></a>CPL.2: If you must use C, use the common subset of C and C++, and compile the C code as C++</h3><h5 id="Reason-379"><a href="#Reason-379" class="headerlink" title="Reason"></a>Reason</h5><p>That subset can be compiled with both C and C++ compilers, and when compiled as C++ is better type checked than “pure C.”</p>
<h5 id="Example-328"><a href="#Example-328" class="headerlink" title="Example"></a>Example</h5><pre><code>int* p1 = malloc(10 * sizeof(int));                      // not C++
int* p2 = static_cast&lt;int*&gt;(malloc(10 * sizeof(int)));   // not C, C-style C++
int* p3 = new int[10];                                   // not C
int* p4 = (int*) malloc(10 * sizeof(int));               // both C and C++
</code></pre>
<h5 id="Enforcement-349"><a href="#Enforcement-349" class="headerlink" title="Enforcement"></a>Enforcement</h5><ul>
<li><p>Flag if using a build mode that compiles code as C.</p>
<ul>
<li>The C++ compiler will enforce that the code is valid C++ unless you use C extension options.</li>
</ul>
</li>
</ul>
<h3 id="CPL-3-If-you-must-use-C-for-interfaces-use-C-in-the-calling-code-using-such-interfaces"><a href="#CPL-3-If-you-must-use-C-for-interfaces-use-C-in-the-calling-code-using-such-interfaces" class="headerlink" title="CPL.3: If you must use C for interfaces, use C++ in the calling code using such interfaces"></a><a name="Rcpl-interface"></a>CPL.3: If you must use C for interfaces, use C++ in the calling code using such interfaces</h3><h5 id="Reason-380"><a href="#Reason-380" class="headerlink" title="Reason"></a>Reason</h5><p>C++ is more expressive than C and offers better support for many types of programming.</p>
<h5 id="Example-329"><a href="#Example-329" class="headerlink" title="Example"></a>Example</h5><p>For example, to use a 3rd party C library or C systems interface, define the low-level interface in the common subset of C and C++ for better type checking.<br>Whenever possible encapsulate the low-level interface in an interface that follows the C++ guidelines (for better abstraction, memory safety, and resource safety) and use that C++ interface in C++ code.</p>
<h5 id="Example-330"><a href="#Example-330" class="headerlink" title="Example"></a>Example</h5><p>You can call C from C++:</p>
<pre><code>// in C:
double sqrt(double);

// in C++:
extern &quot;C&quot; double sqrt(double);

sqrt(2);
</code></pre>
<h5 id="Example-331"><a href="#Example-331" class="headerlink" title="Example"></a>Example</h5><p>You can call C++ from C:</p>
<pre><code>// in C:
X call_f(struct Y*, int);

// in C++:
extern &quot;C&quot; X call_f(Y* p, int i)
&#123;
    return p-&gt;f(i);   // possibly a virtual function call
&#125;
</code></pre>
<h5 id="Enforcement-350"><a href="#Enforcement-350" class="headerlink" title="Enforcement"></a>Enforcement</h5><p>None needed</p>
<h1 id="SF-Source-files"><a href="#SF-Source-files" class="headerlink" title="SF: Source files"></a><a name="S-source"></a>SF: Source files</h1><p>Distinguish between declarations (used as interfaces) and definitions (used as implementations).<br>Use header files to represent interfaces and to emphasize logical structure.</p>
<p>Source file rule summary:</p>
<ul>
<li><p><a href="#Rs-file-suffix">SF.1: Use a <code>.cpp</code> suffix for code files and <code>.h</code> for interface files if your project doesn’t already follow another convention</a></p>
</li>
<li><p><a href="#Rs-inline">SF.2: A <code>.h</code> file may not contain object definitions or non-inline function definitions</a></p>
</li>
<li><p><a href="#Rs-declaration-header">SF.3: Use <code>.h</code> files for all declarations used in multiple source files</a></p>
</li>
<li><p><a href="#Rs-include-order">SF.4: Include <code>.h</code> files before other declarations in a file</a></p>
</li>
<li><p><a href="#Rs-consistency">SF.5: A <code>.cpp</code> file must include the <code>.h</code> file(s) that defines its interface</a></p>
</li>
<li><p><a href="#Rs-using">SF.6: Use <code>using namespace</code> directives for transition, for foundation libraries (such as <code>std</code>), or within a local scope (only)</a></p>
</li>
<li><p><a href="#Rs-using-directive">SF.7: Don’t write <code>using namespace</code> at global scope in a header file</a></p>
</li>
<li><p><a href="#Rs-guards">SF.8: Use <code>#include</code> guards for all <code>.h</code> files</a></p>
</li>
<li><p><a href="#Rs-cycles">SF.9: Avoid cyclic dependencies among source files</a></p>
</li>
<li><p><a href="#Rs-implicit">SF.10: Avoid dependencies on implicitly <code>#include</code>d names</a></p>
</li>
<li><p><a href="#Rs-contained">SF.11: Header files should be self-contained</a></p>
</li>
<li><p><a href="#Rs-namespace">SF.20: Use <code>namespace</code>s to express logical structure</a></p>
</li>
<li><p><a href="#Rs-unnamed">SF.21: Don’t use an unnamed (anonymous) namespace in a header</a></p>
</li>
<li><p><a href="#Rs-unnamed2">SF.22: Use an unnamed (anonymous) namespace for all internal/nonexported entities</a></p>
</li>
</ul>
<h3 id="SF-1-Use-a-cpp-suffix-for-code-files-and-h-for-interface-files-if-your-project-doesn’t-already-follow-another-convention"><a href="#SF-1-Use-a-cpp-suffix-for-code-files-and-h-for-interface-files-if-your-project-doesn’t-already-follow-another-convention" class="headerlink" title="SF.1: Use a .cpp suffix for code files and .h for interface files if your project doesn’t already follow another convention"></a><a name="Rs-file-suffix"></a>SF.1: Use a <code>.cpp</code> suffix for code files and <code>.h</code> for interface files if your project doesn’t already follow another convention</h3><h5 id="Reason-381"><a href="#Reason-381" class="headerlink" title="Reason"></a>Reason</h5><p>It’s a longstanding convention.<br>But consistency is more important, so if your project uses something else, follow that.</p>
<h5 id="Note-327"><a href="#Note-327" class="headerlink" title="Note"></a>Note</h5><p>This convention reflects a common use pattern:<br>Headers are more often shared with C to compile as both C++ and C, which typically uses <code>.h</code>,<br>and it’s easier to name all headers <code>.h</code> instead of having different extensions for just those headers that are intended to be shared with C.<br>On the other hand, implementation files are rarely shared with C and so should typically be distinguished from <code>.c</code> files,<br>so it’s normally best to name all C++ implementation files something else (such as <code>.cpp</code>).</p>
<p>The specific names <code>.h</code> and <code>.cpp</code> are not required (just recommended as a default) and other names are in widespread use.<br>Examples are <code>.hh</code>, <code>.C</code>, and <code>.cxx</code>. Use such names equivalently.<br>In this document, we refer to <code>.h</code> and <code>.cpp</code> as a shorthand for header and implementation files,<br>even though the actual extension may be different.</p>
<p>Your IDE (if you use one) may have strong opinions about suffices.</p>
<h5 id="Example-332"><a href="#Example-332" class="headerlink" title="Example"></a>Example</h5><pre><code>// foo.h:
extern int a;   // a declaration
extern void foo();

// foo.cpp:
int a;   // a definition
void foo() &#123; ++a; &#125;
</code></pre>
<p><code>foo.h</code> provides the interface to <code>foo.cpp</code>. Global variables are best avoided.</p>
<h5 id="Example-bad-129"><a href="#Example-bad-129" class="headerlink" title="Example, bad"></a>Example, bad</h5><pre><code>// foo.h:
int a;   // a definition
void foo() &#123; ++a; &#125;
</code></pre>
<p><code>#include &lt;foo.h&gt;</code> twice in a program and you get a linker error for two one-definition-rule violations.</p>
<h5 id="Enforcement-351"><a href="#Enforcement-351" class="headerlink" title="Enforcement"></a>Enforcement</h5><ul>
<li>Flag non-conventional file names.</li>
<li>Check that <code>.h</code> and <code>.cpp</code> (and equivalents) follow the rules below.</li>
</ul>
<h3 id="SF-2-A-h-file-may-not-contain-object-definitions-or-non-inline-function-definitions"><a href="#SF-2-A-h-file-may-not-contain-object-definitions-or-non-inline-function-definitions" class="headerlink" title="SF.2: A .h file may not contain object definitions or non-inline function definitions"></a><a name="Rs-inline"></a>SF.2: A <code>.h</code> file may not contain object definitions or non-inline function definitions</h3><h5 id="Reason-382"><a href="#Reason-382" class="headerlink" title="Reason"></a>Reason</h5><p>Including entities subject to the one-definition rule leads to linkage errors.</p>
<h5 id="Example-333"><a href="#Example-333" class="headerlink" title="Example"></a>Example</h5><pre><code>// file.h:
namespace Foo &#123;
    int x = 7;
    int xx() &#123; return x+x; &#125;
&#125;

// file1.cpp:
#include &lt;file.h&gt;
// ... more ...

 // file2.cpp:
#include &lt;file.h&gt;
// ... more ...
</code></pre>
<p>Linking <code>file1.cpp</code> and <code>file2.cpp</code> will give two linker errors.</p>
<p><strong>Alternative formulation</strong>: A <code>.h</code> file must contain only:</p>
<ul>
<li><code>#include</code>s of other <code>.h</code> files (possibly with include guards)</li>
<li>templates</li>
<li>class definitions</li>
<li>function declarations</li>
<li><code>extern</code> declarations</li>
<li><code>inline</code> function definitions</li>
<li><code>constexpr</code> definitions</li>
<li><code>const</code> definitions</li>
<li><code>using</code> alias definitions</li>
<li>???</li>
</ul>
<h5 id="Enforcement-352"><a href="#Enforcement-352" class="headerlink" title="Enforcement"></a>Enforcement</h5><p>Check the positive list above.</p>
<h3 id="SF-3-Use-h-files-for-all-declarations-used-in-multiple-source-files"><a href="#SF-3-Use-h-files-for-all-declarations-used-in-multiple-source-files" class="headerlink" title="SF.3: Use .h files for all declarations used in multiple source files"></a><a name="Rs-declaration-header"></a>SF.3: Use <code>.h</code> files for all declarations used in multiple source files</h3><h5 id="Reason-383"><a href="#Reason-383" class="headerlink" title="Reason"></a>Reason</h5><p>Maintainability. Readability.</p>
<h5 id="Example-bad-130"><a href="#Example-bad-130" class="headerlink" title="Example, bad"></a>Example, bad</h5><pre><code>// bar.cpp:
void bar() &#123; cout &lt;&lt; &quot;bar\n&quot;; &#125;

// foo.cpp:
extern void bar();
void foo() &#123; bar(); &#125;
</code></pre>
<p>A maintainer of <code>bar</code> cannot find all declarations of <code>bar</code> if its type needs changing.<br>The user of <code>bar</code> cannot know if the interface used is complete and correct. At best, error messages come (late) from the linker.</p>
<h5 id="Enforcement-353"><a href="#Enforcement-353" class="headerlink" title="Enforcement"></a>Enforcement</h5><ul>
<li>Flag declarations of entities in other source files not placed in a <code>.h</code>.</li>
</ul>
<h3 id="SF-4-Include-h-files-before-other-declarations-in-a-file"><a href="#SF-4-Include-h-files-before-other-declarations-in-a-file" class="headerlink" title="SF.4: Include .h files before other declarations in a file"></a><a name="Rs-include-order"></a>SF.4: Include <code>.h</code> files before other declarations in a file</h3><h5 id="Reason-384"><a href="#Reason-384" class="headerlink" title="Reason"></a>Reason</h5><p>Minimize context dependencies and increase readability.</p>
<h5 id="Example-334"><a href="#Example-334" class="headerlink" title="Example"></a>Example</h5><pre><code>#include &lt;vector&gt;
#include &lt;algorithm&gt;
#include &lt;string&gt;

// ... my code here ...
</code></pre>
<h5 id="Example-bad-131"><a href="#Example-bad-131" class="headerlink" title="Example, bad"></a>Example, bad</h5><pre><code>#include &lt;vector&gt;

// ... my code here ...

#include &lt;algorithm&gt;
#include &lt;string&gt;
</code></pre>
<h5 id="Note-328"><a href="#Note-328" class="headerlink" title="Note"></a>Note</h5><p>This applies to both <code>.h</code> and <code>.cpp</code> files.</p>
<h5 id="Note-329"><a href="#Note-329" class="headerlink" title="Note"></a>Note</h5><p>There is an argument for insulating code from declarations and macros in header files by <code>#including</code> headers <em>after</em> the code we want to protect<br>(as in the example labeled “bad”).<br>However</p>
<ul>
<li>that only works for one file (at one level): Use that technique in a header included with other headers and the vulnerability reappears.</li>
<li>a namespace (an “implementation namespace”) can protect against many context dependencies.</li>
<li>full protection and flexibility require modules.</li>
</ul>
<p><strong>See also</strong>:</p>
<ul>
<li><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/n4592.pdf">Working Draft, Extensions to C++ for Modules</a></li>
<li><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/p0141r0.pdf">Modules, Componentization, and Transition</a></li>
</ul>
<h5 id="Enforcement-354"><a href="#Enforcement-354" class="headerlink" title="Enforcement"></a>Enforcement</h5><p>Easy.</p>
<h3 id="SF-5-A-cpp-file-must-include-the-h-file-s-that-defines-its-interface"><a href="#SF-5-A-cpp-file-must-include-the-h-file-s-that-defines-its-interface" class="headerlink" title="SF.5: A .cpp file must include the .h file(s) that defines its interface"></a><a name="Rs-consistency"></a>SF.5: A <code>.cpp</code> file must include the <code>.h</code> file(s) that defines its interface</h3><h5 id="Reason-385"><a href="#Reason-385" class="headerlink" title="Reason"></a>Reason</h5><p>This enables the compiler to do an early consistency check.</p>
<h5 id="Example-bad-132"><a href="#Example-bad-132" class="headerlink" title="Example, bad"></a>Example, bad</h5><pre><code>// foo.h:
void foo(int);
int bar(long);
int foobar(int);

// foo.cpp:
void foo(int) &#123; /* ... */ &#125;
int bar(double) &#123; /* ... */ &#125;
double foobar(int);
</code></pre>
<p>The errors will not be caught until link time for a program calling <code>bar</code> or <code>foobar</code>.</p>
<h5 id="Example-335"><a href="#Example-335" class="headerlink" title="Example"></a>Example</h5><pre><code>// foo.h:
void foo(int);
int bar(long);
int foobar(int);

// foo.cpp:
#include &lt;foo.h&gt;

void foo(int) &#123; /* ... */ &#125;
int bar(double) &#123; /* ... */ &#125;
double foobar(int);   // error: wrong return type
</code></pre>
<p>The return-type error for <code>foobar</code> is now caught immediately when <code>foo.cpp</code> is compiled.<br>The argument-type error for <code>bar</code> cannot be caught until link time because of the possibility of overloading, but systematic use of <code>.h</code> files increases the likelihood that it is caught earlier by the programmer.</p>
<h5 id="Enforcement-355"><a href="#Enforcement-355" class="headerlink" title="Enforcement"></a>Enforcement</h5><p>???</p>
<h3 id="SF-6-Use-using-namespace-directives-for-transition-for-foundation-libraries-such-as-std-or-within-a-local-scope-only"><a href="#SF-6-Use-using-namespace-directives-for-transition-for-foundation-libraries-such-as-std-or-within-a-local-scope-only" class="headerlink" title="SF.6: Use using namespace directives for transition, for foundation libraries (such as std), or within a local scope (only)"></a><a name="Rs-using"></a>SF.6: Use <code>using namespace</code> directives for transition, for foundation libraries (such as <code>std</code>), or within a local scope (only)</h3><h5 id="Reason-386"><a href="#Reason-386" class="headerlink" title="Reason"></a>Reason</h5><p> <code>using namespace</code> can lead to name clashes, so it should be used sparingly.<br> However, it is not always possible to qualify every name from a namespace in user code (e.g., during transition)<br> and sometimes a namespace is so fundamental and prevalent in a code base, that consistent qualification would be verbose and distracting.</p>
<h5 id="Example-336"><a href="#Example-336" class="headerlink" title="Example"></a>Example</h5><pre><code>#include &lt;string&gt;
#include &lt;vector&gt;
#include &lt;iostream&gt;
#include &lt;memory&gt;
#include &lt;algorithm&gt;

using namespace std;

// ...
</code></pre>
<p>Here (obviously), the standard library is used pervasively and apparently no other library is used, so requiring <code>std::</code> everywhere<br>could be distracting.</p>
<h5 id="Example-337"><a href="#Example-337" class="headerlink" title="Example"></a>Example</h5><p>The use of <code>using namespace std;</code> leaves the programmer open to a name clash with a name from the standard library</p>
<pre><code>#include &lt;cmath&gt;
using namespace std;

int g(int x)
&#123;
    int sqrt = 7;
    // ...
    return sqrt(x); // error
&#125;
</code></pre>
<p>However, this is not particularly likely to lead to a resolution that is not an error and<br>people who use <code>using namespace std</code> are supposed to know about <code>std</code> and about this risk.</p>
<h5 id="Note-330"><a href="#Note-330" class="headerlink" title="Note"></a>Note</h5><p>A <code>.cpp</code> file is a form of local scope.<br>There is little difference in the opportunities for name clashes in an N-line <code>.cpp</code> containing a <code>using namespace X</code>,<br>an N-line function containing a <code>using namespace X</code>,<br>and M functions each containing a <code>using namespace X</code>with N lines of code in total.</p>
<h5 id="Note-331"><a href="#Note-331" class="headerlink" title="Note"></a>Note</h5><p><a href="#Rs-using-directive">Don’t write <code>using namespace</code> in a header file</a>.</p>
<h5 id="Enforcement-356"><a href="#Enforcement-356" class="headerlink" title="Enforcement"></a>Enforcement</h5><p>Flag multiple <code>using namespace</code> directives for different namespaces in a single source file.</p>
<h3 id="SF-7-Don’t-write-using-namespace-at-global-scope-in-a-header-file"><a href="#SF-7-Don’t-write-using-namespace-at-global-scope-in-a-header-file" class="headerlink" title="SF.7: Don’t write using namespace at global scope in a header file"></a><a name="Rs-using-directive"></a>SF.7: Don’t write <code>using namespace</code> at global scope in a header file</h3><h5 id="Reason-387"><a href="#Reason-387" class="headerlink" title="Reason"></a>Reason</h5><p>Doing so takes away an <code>#include</code>r’s ability to effectively disambiguate and to use alternatives. It also makes <code>#include</code>d headers order-dependent as they may have different meaning when included in different orders.</p>
<h5 id="Example-338"><a href="#Example-338" class="headerlink" title="Example"></a>Example</h5><pre><code>// bad.h
#include &lt;iostream&gt;
using namespace std; // bad

// user.cpp
#include &quot;bad.h&quot;

bool copy(/*... some parameters ...*/);    // some function that happens to be named copy

int main() &#123;
    copy(/*...*/);    // now overloads local ::copy and std::copy, could be ambiguous
&#125;
</code></pre>
<h5 id="Enforcement-357"><a href="#Enforcement-357" class="headerlink" title="Enforcement"></a>Enforcement</h5><p>Flag <code>using namespace</code> at global scope in a header file.</p>
<h3 id="SF-8-Use-include-guards-for-all-h-files"><a href="#SF-8-Use-include-guards-for-all-h-files" class="headerlink" title="SF.8: Use #include guards for all .h files"></a><a name="Rs-guards"></a>SF.8: Use <code>#include</code> guards for all <code>.h</code> files</h3><h5 id="Reason-388"><a href="#Reason-388" class="headerlink" title="Reason"></a>Reason</h5><p>To avoid files being <code>#include</code>d several times.</p>
<p>In order to avoid include guard collisions, do not just name the guard after the filename.<br>Be sure to also include a key and good differentiator, such as the name of library or component<br>the header file is part of.</p>
<h5 id="Example-339"><a href="#Example-339" class="headerlink" title="Example"></a>Example</h5><pre><code>// file foobar.h:
#ifndef LIBRARY_FOOBAR_H
#define LIBRARY_FOOBAR_H
// ... declarations ...
#endif // LIBRARY_FOOBAR_H
</code></pre>
<h5 id="Enforcement-358"><a href="#Enforcement-358" class="headerlink" title="Enforcement"></a>Enforcement</h5><p>Flag <code>.h</code> files without <code>#include</code> guards.</p>
<h5 id="Note-332"><a href="#Note-332" class="headerlink" title="Note"></a>Note</h5><p>Some implementations offer vendor extensions like <code>#pragma once</code> as alternative to include guards.<br>It is not standard and it is not portable.  It injects the hosting machine’s filesystem semantics<br>into your program, in addition to locking you down to a vendor.<br>Our recommendation is to write in ISO C++: See <a href="#Rp-Cplusplus">rule P.2</a>.</p>
<h3 id="SF-9-Avoid-cyclic-dependencies-among-source-files"><a href="#SF-9-Avoid-cyclic-dependencies-among-source-files" class="headerlink" title="SF.9: Avoid cyclic dependencies among source files"></a><a name="Rs-cycles"></a>SF.9: Avoid cyclic dependencies among source files</h3><h5 id="Reason-389"><a href="#Reason-389" class="headerlink" title="Reason"></a>Reason</h5><p>Cycles complicates comprehension and slows down compilation.<br>Complicates conversion to use language-supported modules (when they become available).</p>
<h5 id="Note-333"><a href="#Note-333" class="headerlink" title="Note"></a>Note</h5><p>Eliminate cycles; don’t just break them with <code>#include</code> guards.</p>
<h5 id="Example-bad-133"><a href="#Example-bad-133" class="headerlink" title="Example, bad"></a>Example, bad</h5><pre><code>// file1.h:
#include &quot;file2.h&quot;

// file2.h:
#include &quot;file3.h&quot;

// file3.h:
#include &quot;file1.h&quot;
</code></pre>
<h5 id="Enforcement-359"><a href="#Enforcement-359" class="headerlink" title="Enforcement"></a>Enforcement</h5><p>Flag all cycles.</p>
<h3 id="SF-10-Avoid-dependencies-on-implicitly-included-names"><a href="#SF-10-Avoid-dependencies-on-implicitly-included-names" class="headerlink" title="SF.10: Avoid dependencies on implicitly #included names"></a><a name="Rs-implicit"></a>SF.10: Avoid dependencies on implicitly <code>#include</code>d names</h3><h5 id="Reason-390"><a href="#Reason-390" class="headerlink" title="Reason"></a>Reason</h5><p>Avoid surprises.<br>Avoid having to change <code>#include</code>s if an <code>#include</code>d header changes.<br>Avoid accidentally becoming dependent on implementation details and logically separate entities included in a header.</p>
<h5 id="Example-340"><a href="#Example-340" class="headerlink" title="Example"></a>Example</h5><pre><code>#include &lt;iostream&gt;
using namespace std;

void use()                  // bad
&#123;
    string s;
    cin &gt;&gt; s;               // fine
    getline(cin, s);        // error: getline() not defined
    if (s == &quot;surprise&quot;) &#123;  // error == not defined
        // ...
    &#125;
&#125;
</code></pre>
<p><code>&lt;iostream&gt;</code> exposes the definition of <code>std::string</code> (“why?” makes for a fun trivia question),<br>but it is not required to do so by transitively including the entire <code>&lt;string&gt;</code> header,<br>resulting in the popular beginner question “why doesn’t <code>getline(cin,s);</code> work?”<br>or even an occasional “<code>string</code>s cannot be compared with <code>==</code>).</p>
<p>The solution is to explicitly <code>#include &lt;string&gt;</code>:</p>
<pre><code>#include &lt;iostream&gt;
#include &lt;string&gt;
using namespace std;

void use()
&#123;
    string s;
    cin &gt;&gt; s;               // fine
    getline(cin, s);        // fine
    if (s == &quot;surprise&quot;) &#123;  // fine
        // ...
    &#125;
&#125;
</code></pre>
<h5 id="Note-334"><a href="#Note-334" class="headerlink" title="Note"></a>Note</h5><p>Some headers exist exactly to collect a set of consistent declarations from a variety of headers.<br>For example:</p>
<pre><code>// basic_std_lib.h:

#include &lt;vector&gt;
#include &lt;string&gt;
#include &lt;map&gt;
#include &lt;iostream&gt;
#include &lt;random&gt;
#include &lt;vector&gt;
</code></pre>
<p>a user can now get that set of declarations with a single <code>#include</code>“</p>
<pre><code>#include &quot;basic_std_lib.h&quot;
</code></pre>
<p>This rule against implicit inclusion is not meant to prevent such deliberate aggregation.</p>
<h5 id="Enforcement-360"><a href="#Enforcement-360" class="headerlink" title="Enforcement"></a>Enforcement</h5><p>Enforcement would require some knowledge about what in a header is meant to be “exported” to users and what is there to enable implementation.<br>No really good solution is possible until we have modules.</p>
<h3 id="SF-11-Header-files-should-be-self-contained"><a href="#SF-11-Header-files-should-be-self-contained" class="headerlink" title="SF.11: Header files should be self-contained"></a><a name="Rs-contained"></a>SF.11: Header files should be self-contained</h3><h5 id="Reason-391"><a href="#Reason-391" class="headerlink" title="Reason"></a>Reason</h5><p>Usability, headers should be simple to use and work when included on their own.<br>Headers should encapsulate the functionality they provide.<br>Avoid clients of a header having to manage that header’s dependencies.</p>
<h5 id="Example-341"><a href="#Example-341" class="headerlink" title="Example"></a>Example</h5><pre><code>#include &quot;helpers.h&quot;
// helpers.h depends on std::string and includes &lt;string&gt;
</code></pre>
<h5 id="Note-335"><a href="#Note-335" class="headerlink" title="Note"></a>Note</h5><p>Failing to follow this results in difficult to diagnose errors for clients of a header.</p>
<h5 id="Enforcement-361"><a href="#Enforcement-361" class="headerlink" title="Enforcement"></a>Enforcement</h5><p>A test should verify that the header file itself compiles or that a cpp file which only includes the header file compiles.</p>
<h3 id="SF-20-Use-namespaces-to-express-logical-structure"><a href="#SF-20-Use-namespaces-to-express-logical-structure" class="headerlink" title="SF.20: Use namespaces to express logical structure"></a><a name="Rs-namespace"></a>SF.20: Use <code>namespace</code>s to express logical structure</h3><h5 id="Reason-392"><a href="#Reason-392" class="headerlink" title="Reason"></a>Reason</h5><p> ???</p>
<h5 id="Example-342"><a href="#Example-342" class="headerlink" title="Example"></a>Example</h5><pre><code>???
</code></pre>
<h5 id="Enforcement-362"><a href="#Enforcement-362" class="headerlink" title="Enforcement"></a>Enforcement</h5><p>???</p>
<h3 id="SF-21-Don’t-use-an-unnamed-anonymous-namespace-in-a-header"><a href="#SF-21-Don’t-use-an-unnamed-anonymous-namespace-in-a-header" class="headerlink" title="SF.21: Don’t use an unnamed (anonymous) namespace in a header"></a><a name="Rs-unnamed"></a>SF.21: Don’t use an unnamed (anonymous) namespace in a header</h3><h5 id="Reason-393"><a href="#Reason-393" class="headerlink" title="Reason"></a>Reason</h5><p>It is almost always a bug to mention an unnamed namespace in a header file.</p>
<h5 id="Example-343"><a href="#Example-343" class="headerlink" title="Example"></a>Example</h5><pre><code>???
</code></pre>
<h5 id="Enforcement-363"><a href="#Enforcement-363" class="headerlink" title="Enforcement"></a>Enforcement</h5><ul>
<li>Flag any use of an anonymous namespace in a header file.</li>
</ul>
<h3 id="SF-22-Use-an-unnamed-anonymous-namespace-for-all-internal-nonexported-entities"><a href="#SF-22-Use-an-unnamed-anonymous-namespace-for-all-internal-nonexported-entities" class="headerlink" title="SF.22: Use an unnamed (anonymous) namespace for all internal/nonexported entities"></a><a name="Rs-unnamed2"></a>SF.22: Use an unnamed (anonymous) namespace for all internal/nonexported entities</h3><h5 id="Reason-394"><a href="#Reason-394" class="headerlink" title="Reason"></a>Reason</h5><p>Nothing external can depend on an entity in a nested unnamed namespace.<br>Consider putting every definition in an implementation source file in an unnamed namespace unless that is defining an “external/exported” entity.</p>
<h5 id="Example-344"><a href="#Example-344" class="headerlink" title="Example"></a>Example</h5><p>An API class and its members can’t live in an unnamed namespace; but any “helper” class or function that is defined in an implementation source file should be at an unnamed namespace scope.</p>
<pre><code>???
</code></pre>
<h5 id="Enforcement-364"><a href="#Enforcement-364" class="headerlink" title="Enforcement"></a>Enforcement</h5><ul>
<li>???</li>
</ul>
<h1 id="SL-The-Standard-Library"><a href="#SL-The-Standard-Library" class="headerlink" title="SL: The Standard Library"></a><a name="S-stdlib"></a>SL: The Standard Library</h1><p>Using only the bare language, every task is tedious (in any language).<br>Using a suitable library any task can be reasonably simple.</p>
<p>The standard library has steadily grown over the years.<br>Its description in the standard is now larger than that of the language features.<br>So, it is likely that this library section of the guidelines will eventually grow in size to equal or exceed all the rest.</p>
<p>&lt;&lt; ??? We need another level of rule numbering ??? &gt;&gt;</p>
<p>C++ Standard Library component summary:</p>
<ul>
<li><a href="#SS-con">SL.con: Containers</a></li>
<li><a href="#SS-string">SL.str: String</a></li>
<li><a href="#SS-io">SL.io: Iostream</a></li>
<li><a href="#SS-regex">SL.regex: Regex</a></li>
<li><a href="#SS-chrono">SL.chrono: Time</a></li>
<li><a href="#SS-clib">SL.C: The C Standard Library</a></li>
</ul>
<p>Standard-library rule summary:</p>
<ul>
<li><a href="#Rsl-lib">SL.1: Use libraries wherever possible</a></li>
<li><a href="#Rsl-sl">SL.2: Prefer the standard library to other libraries</a></li>
<li><a href="#sl-std">SL.3: Do not add non-standard entities to namespace <code>std</code></a></li>
<li><a href="#sl-safe">SL.4: Use the standard library in a type-safe manner</a></li>
<li>???</li>
</ul>
<h3 id="SL-1-Use-libraries-wherever-possible"><a href="#SL-1-Use-libraries-wherever-possible" class="headerlink" title="SL.1:  Use libraries wherever possible"></a><a name="Rsl-lib"></a>SL.1:  Use libraries wherever possible</h3><h5 id="Reason-395"><a href="#Reason-395" class="headerlink" title="Reason"></a>Reason</h5><p>Save time. Don’t re-invent the wheel.<br>Don’t replicate the work of others.<br>Benefit from other people’s work when they make improvements.<br>Help other people when you make improvements.</p>
<h3 id="SL-2-Prefer-the-standard-library-to-other-libraries"><a href="#SL-2-Prefer-the-standard-library-to-other-libraries" class="headerlink" title="SL.2: Prefer the standard library to other libraries"></a><a name="Rsl-sl"></a>SL.2: Prefer the standard library to other libraries</h3><h5 id="Reason-396"><a href="#Reason-396" class="headerlink" title="Reason"></a>Reason</h5><p>More people know the standard library.<br>It is more likely to be stable, well-maintained, and widely available than your own code or most other libraries.</p>
<h3 id="SL-3-Do-not-add-non-standard-entities-to-namespace-std"><a href="#SL-3-Do-not-add-non-standard-entities-to-namespace-std" class="headerlink" title="SL.3: Do not add non-standard entities to namespace std"></a><a name="sl-std"></a>SL.3: Do not add non-standard entities to namespace <code>std</code></h3><h5 id="Reason-397"><a href="#Reason-397" class="headerlink" title="Reason"></a>Reason</h5><p>Adding to <code>std</code> may change the meaning of otherwise standards conforming code.<br>Additions to <code>std</code> may clash with future versions of the standard.</p>
<h5 id="Example-345"><a href="#Example-345" class="headerlink" title="Example"></a>Example</h5><pre><code>???
</code></pre>
<h5 id="Enforcement-365"><a href="#Enforcement-365" class="headerlink" title="Enforcement"></a>Enforcement</h5><p>Possible, but messy and likely to cause problems with platforms.</p>
<h3 id="SL-4-Use-the-standard-library-in-a-type-safe-manner"><a href="#SL-4-Use-the-standard-library-in-a-type-safe-manner" class="headerlink" title="SL.4: Use the standard library in a type-safe manner"></a><a name="sl-safe"></a>SL.4: Use the standard library in a type-safe manner</h3><h5 id="Reason-398"><a href="#Reason-398" class="headerlink" title="Reason"></a>Reason</h5><p>Because, obviously, breaking this rule can lead to undefined behavior, memory corruption, and all kinds of other bad errors.</p>
<h5 id="Note-336"><a href="#Note-336" class="headerlink" title="Note"></a>Note</h5><p>This is a semi-philosophical meta-rule, which needs many supporting concrete rules.<br>We need it as an umbrella for the more specific rules.</p>
<p>Summary of more specific rules:</p>
<ul>
<li><a href="#sl-safe">SL.4: Use the standard library in a type-safe manner</a></li>
</ul>
<h2 id="SL-con-Containers"><a href="#SL-con-Containers" class="headerlink" title="SL.con: Containers"></a><a name="SS-con"></a>SL.con: Containers</h2><p>???</p>
<p>Container rule summary:</p>
<ul>
<li><a href="#Rsl-arrays">SL.con.1: Prefer using STL <code>array</code> or <code>vector</code> instead of a C array</a></li>
<li><a href="#Rsl-vector">SL.con.2: Prefer using STL <code>vector</code> by default unless you have a reason to use a different container</a></li>
<li><a href="#Rsl-bounds">SL.con.3: Avoid bounds errors</a></li>
<li>???</li>
</ul>
<h3 id="SL-con-1-Prefer-using-STL-array-or-vector-instead-of-a-C-array"><a href="#SL-con-1-Prefer-using-STL-array-or-vector-instead-of-a-C-array" class="headerlink" title="SL.con.1: Prefer using STL array or vector instead of a C array"></a><a name="Rsl-arrays"></a>SL.con.1: Prefer using STL <code>array</code> or <code>vector</code> instead of a C array</h3><h5 id="Reason-399"><a href="#Reason-399" class="headerlink" title="Reason"></a>Reason</h5><p>C arrays are less safe, and have no advantages over <code>array</code> and <code>vector</code>.<br>For a fixed-length array, use <code>std::array</code>, which does not degenerate to a pointer when passed to a function and does know its size.<br>Also, like a built-in array, a stack-allocated <code>std::array</code> keeps its elements on the stack.<br>For a variable-length array, use <code>std::vector</code>, which additionally can change its size and handles memory allocation.</p>
<h5 id="Example-346"><a href="#Example-346" class="headerlink" title="Example"></a>Example</h5><pre><code>int v[SIZE];                        // BAD

std::array&lt;int, SIZE&gt; w;             // ok
</code></pre>
<h5 id="Example-347"><a href="#Example-347" class="headerlink" title="Example"></a>Example</h5><pre><code>int* v = new int[initial_size];     // BAD, owning raw pointer
delete[] v;                         // BAD, manual delete

std::vector&lt;int&gt; w(initial_size);   // ok
</code></pre>
<h5 id="Note-337"><a href="#Note-337" class="headerlink" title="Note"></a>Note</h5><p>Use <code>gsl::span</code> for non-owning references into a container.</p>
<h5 id="Note-338"><a href="#Note-338" class="headerlink" title="Note"></a>Note</h5><p>Comparing the performance of a fixed-sized array allocated on the stack against a <code>vector</code> with its elements on the free store is bogus.<br>You could just as well compare a <code>std::array</code> on the stack against the result of a <code>malloc()</code> accessed through a pointer.<br>For most code, even the difference between stack allocation and free-store allocation doesn’t matter, but the convenience and safety of <code>vector</code> does.<br>People working with code for which that difference matters are quite capable of choosing between <code>array</code> and <code>vector</code>.</p>
<h5 id="Enforcement-366"><a href="#Enforcement-366" class="headerlink" title="Enforcement"></a>Enforcement</h5><ul>
<li>Flag declaration of a C array inside a function or class that also declares an STL container (to avoid excessive noisy warnings on legacy non-STL code). To fix: At least change the C array to a <code>std::array</code>.</li>
</ul>
<h3 id="SL-con-2-Prefer-using-STL-vector-by-default-unless-you-have-a-reason-to-use-a-different-container"><a href="#SL-con-2-Prefer-using-STL-vector-by-default-unless-you-have-a-reason-to-use-a-different-container" class="headerlink" title="SL.con.2: Prefer using STL vector by default unless you have a reason to use a different container"></a><a name="Rsl-vector"></a>SL.con.2: Prefer using STL <code>vector</code> by default unless you have a reason to use a different container</h3><h5 id="Reason-400"><a href="#Reason-400" class="headerlink" title="Reason"></a>Reason</h5><p><code>vector</code> and <code>array</code> are the only standard containers that offer the fastest general-purpose access (random access, including being vectorization-friendly), the fastest default access pattern (begin-to-end or end-to-begin is prefetcher-friendly), and the lowest space overhead (contiguous layout has zero per-element overhead, which is cache-friendly).<br>Usually you need to add and remove elements from the container, so use <code>vector</code> by default; if you don’t need to modify the container’s size, use <code>array</code>.</p>
<p>Even when other containers seem more suited, such a <code>map</code> for O(log N) lookup performance or a <code>list</code> for efficient insertion in the middle, a <code>vector</code> will usually still perform better for containers up to a few KB in size.</p>
<h5 id="Note-339"><a href="#Note-339" class="headerlink" title="Note"></a>Note</h5><p><code>string</code> should not be used as a container of individual characters. A <code>string</code> is a textual string; if you want a container of characters, use <code>vector&lt;/*char_type*/&gt;</code> or <code>array&lt;/*char_type*/&gt;</code> instead.</p>
<h5 id="Exceptions-1"><a href="#Exceptions-1" class="headerlink" title="Exceptions"></a>Exceptions</h5><p>If you have a good reason to use another container, use that instead. For example:</p>
<ul>
<li><p>If <code>vector</code> suits your needs but you don’t need the container to be variable size, use <code>array</code> instead.</p>
</li>
<li><p>If you want a dictionary-style lookup container that guarantees O(K) or O(log N) lookups, the container will be larger (more than a few KB) and you perform frequent inserts so that the overhead of maintaining a sorted <code>vector</code> is infeasible, go ahead and use an <code>unordered_map</code> or <code>map</code> instead.</p>
</li>
</ul>
<h5 id="Enforcement-367"><a href="#Enforcement-367" class="headerlink" title="Enforcement"></a>Enforcement</h5><ul>
<li>Flag a <code>vector</code> whose size never changes after construction (such as because it’s <code>const</code> or because no non-<code>const</code> functions are called on it). To fix: Use an <code>array</code> instead.</li>
</ul>
<h3 id="SL-con-3-Avoid-bounds-errors"><a href="#SL-con-3-Avoid-bounds-errors" class="headerlink" title="SL.con.3: Avoid bounds errors"></a><a name="Rsl-bounds"></a>SL.con.3: Avoid bounds errors</h3><h5 id="Reason-401"><a href="#Reason-401" class="headerlink" title="Reason"></a>Reason</h5><p>Read or write beyond an allocated range of elements typically leads to bad errors, wrong results, crashes, and security violations.</p>
<h5 id="Note-340"><a href="#Note-340" class="headerlink" title="Note"></a>Note</h5><p>The standard-library functions that apply to ranges of elements all have (or could have) bounds-safe overloads that take <code>span</code>.<br>Standard types such as <code>vector</code> can be modified to perform bounds-checks under the bounds profile (in a compatible way, such as by adding contracts), or used with <code>at()</code>.</p>
<p>Ideally, the in-bounds guarantee should be statically enforced.<br>For example:</p>
<ul>
<li>a range-<code>for</code> cannot loop beyond the range of the container to which it is applied</li>
<li>a <code>v.begin(),v.end()</code> is easily determined to be bounds safe</li>
</ul>
<p>Such loops are as fast as any unchecked/unsafe equivalent.</p>
<p>Often a simple pre-check can eliminate the need for checking of individual indices.<br>For example</p>
<ul>
<li>for <code>v.begin(),v.begin()+i</code> the <code>i</code> can easily be checked against <code>v.size()</code></li>
</ul>
<p>Such loops can be much faster than individually checked element accesses.</p>
<h5 id="Example-bad-134"><a href="#Example-bad-134" class="headerlink" title="Example, bad"></a>Example, bad</h5><pre><code>void f()
&#123;
    array&lt;int, 10&gt; a, b;
    memset(a.data(), 0, 10);         // BAD, and contains a length error (length = 10 * sizeof(int))
    memcmp(a.data(), b.data(), 10);  // BAD, and contains a length error (length = 10 * sizeof(int))
&#125;
</code></pre>
<p>Also, <code>std::array&lt;&gt;::fill()</code> or <code>std::fill()</code> or even an empty initializer are better candidate than <code>memset()</code>.</p>
<h5 id="Example-good-23"><a href="#Example-good-23" class="headerlink" title="Example, good"></a>Example, good</h5><pre><code>void f()
&#123;
    array&lt;int, 10&gt; a, b, c&#123;&#125;;       // c is initialized to zero
    a.fill(0);
    fill(b.begin(), b.end(), 0);    // std::fill()
    fill(b, 0);                     // std::fill() + Ranges TS

    if ( a == b ) &#123;
      // ...
    &#125;
&#125;
</code></pre>
<h5 id="Example-348"><a href="#Example-348" class="headerlink" title="Example"></a>Example</h5><p>If code is using an unmodified standard library, then there are still workarounds that enable use of <code>std::array</code> and <code>std::vector</code> in a bounds-safe manner. Code can call the <code>.at()</code> member function on each class, which will result in an <code>std::out_of_range</code> exception being thrown. Alternatively, code can call the <code>at()</code> free function, which will result in fail-fast (or a customized action) on a bounds violation.</p>
<pre><code>void f(std::vector&lt;int&gt;&amp; v, std::array&lt;int, 12&gt; a, int i)
&#123;
    v[0] = a[0];        // BAD
    v.at(0) = a[0];     // OK (alternative 1)
    at(v, 0) = a[0];    // OK (alternative 2)

    v.at(0) = a[i];     // BAD
    v.at(0) = a.at(i);  // OK (alternative 1)
    v.at(0) = at(a, i); // OK (alternative 2)
&#125;
</code></pre>
<h5 id="Enforcement-368"><a href="#Enforcement-368" class="headerlink" title="Enforcement"></a>Enforcement</h5><ul>
<li>Issue a diagnostic for any call to a standard-library function that is not bounds-checked.<br>??? insert link to a list of banned functions</li>
</ul>
<p>This rule is part of the <a href="#SS-bounds">bounds profile</a>.</p>
<p><strong>TODO Notes</strong>:</p>
<ul>
<li>Impact on the standard library will require close coordination with WG21, if only to ensure compatibility even if never standardized.</li>
<li>We are considering specifying bounds-safe overloads for stdlib (especially C stdlib) functions like <code>memcmp</code> and shipping them in the GSL.</li>
<li>For existing stdlib functions and types like <code>vector</code> that are not fully bounds-checked, the goal is for these features to be bounds-checked when called from code with the bounds profile on, and unchecked when called from legacy code, possibly using contracts (concurrently being proposed by several WG21 members).</li>
</ul>
<h2 id="SL-str-String"><a href="#SL-str-String" class="headerlink" title="SL.str: String"></a><a name="SS-string"></a>SL.str: String</h2><p>Text manipulation is a huge topic.<br><code>std::string</code> doesn’t cover all of it.<br>This section primarily tries to clarify <code>std::string</code>‘s relation to <code>char*</code>, <code>zstring</code>, <code>string_view</code>, and <code>gsl::string_span</code>.<br>The important issue of non-ASCII character sets and encodings (e.g., <code>wchar_t</code>, Unicode, and UTF-8) will be covered elsewhere.</p>
<p><strong>See also</strong>: <a href="#SS-regex">regular expressions</a></p>
<p>Here, we use “sequence of characters” or “string” to refer to a sequence of characters meant to be read as text (somehow, eventually).<br>We don’t consider</p>
<p>String summary:</p>
<ul>
<li><p><a href="#Rstr-string">SL.str.1: Use <code>std::string</code> to own character sequences</a></p>
</li>
<li><p><a href="#Rstr-view">SL.str.2: Use <code>std::string_view</code> or <code>gsl::string_span</code> to refer to character sequences</a></p>
</li>
<li><p><a href="#Rstr-zstring">SL.str.3: Use <code>zstring</code> or <code>czstring</code> to refer to a C-style, zero-terminated, sequence of characters</a></p>
</li>
<li><p><a href="#Rstr-char*">SL.str.4: Use <code>char*</code> to refer to a single character</a></p>
</li>
<li><p><a href="#Rstr-byte">SL.str.5: Use <code>std::byte</code> to refer to byte values that do not necessarily represent characters</a></p>
</li>
<li><p><a href="#Rstr-locale">SL.str.10: Use <code>std::string</code> when you need to perform locale-sensitive string operations</a></p>
</li>
<li><p><a href="#Rstr-span">SL.str.11: Use <code>gsl::string_span</code> rather than <code>std::string_view</code> when you need to mutate a string</a></p>
</li>
<li><p><a href="#Rstr-s">SL.str.12: Use the <code>s</code> suffix for string literals meant to be standard-library <code>string</code>s</a></p>
</li>
</ul>
<p><strong>See also</strong>:</p>
<ul>
<li><a href="#Rf-range">F.24 span</a></li>
<li><a href="#Rf-zstring">F.25 zstring</a></li>
</ul>
<h3 id="SL-str-1-Use-std-string-to-own-character-sequences"><a href="#SL-str-1-Use-std-string-to-own-character-sequences" class="headerlink" title="SL.str.1: Use std::string to own character sequences"></a><a name="Rstr-string"></a>SL.str.1: Use <code>std::string</code> to own character sequences</h3><h5 id="Reason-402"><a href="#Reason-402" class="headerlink" title="Reason"></a>Reason</h5><p><code>string</code> correctly handles allocation, ownership, copying, gradual expansion, and offers a variety of useful operations.</p>
<h5 id="Example-349"><a href="#Example-349" class="headerlink" title="Example"></a>Example</h5><pre><code>vector&lt;string&gt; read_until(const string&amp; terminator)
&#123;
    vector&lt;string&gt; res;
    for (string s; cin &gt;&gt; s &amp;&amp; s != terminator; ) // read a word
        res.push_back(s);
    return res;
&#125;
</code></pre>
<p>Note how <code>&gt;&gt;</code> and <code>!=</code> are provided for <code>string</code> (as examples of useful operations) and there are no explicit<br>allocations, deallocations, or range checks (<code>string</code> takes care of those).</p>
<p>In C++17, we might use <code>string_view</code> as the argument, rather than <code>const string*</code> to allow more flexibility to callers:</p>
<pre><code>vector&lt;string&gt; read_until(string_view terminator)   // C++17
&#123;
    vector&lt;string&gt; res;
    for (string s; cin &gt;&gt; s &amp;&amp; s != terminator; ) // read a word
        res.push_back(s);
    return res;
&#125;
</code></pre>
<p>The <code>gsl::string_span</code> is a current alternative offering most of the benefits of <code>std::string_view</code> for simple examples:</p>
<pre><code>vector&lt;string&gt; read_until(string_span terminator)
&#123;
    vector&lt;string&gt; res;
    for (string s; cin &gt;&gt; s &amp;&amp; s != terminator; ) // read a word
        res.push_back(s);
    return res;
&#125;
</code></pre>
<h5 id="Example-bad-135"><a href="#Example-bad-135" class="headerlink" title="Example, bad"></a>Example, bad</h5><p>Don’t use C-style strings for operations that require non-trivial memory management</p>
<pre><code>char* cat(const char* s1, const char* s2)   // beware!
    // return s1 + &#39;.&#39; + s2
&#123;
    int l1 = strlen(s1);
    int l2 = strlen(s2);
    char* p = (char*) malloc(l1 + l2 + 2);
    strcpy(p, s1, l1);
    p[l1] = &#39;.&#39;;
    strcpy(p + l1 + 1, s2, l2);
    p[l1 + l2 + 1] = 0;
    return p;
&#125;
</code></pre>
<p>Did we get that right?<br>Will the caller remember to <code>free()</code> the returned pointer?<br>Will this code pass a security review?</p>
<h5 id="Note-341"><a href="#Note-341" class="headerlink" title="Note"></a>Note</h5><p>Do not assume that <code>string</code> is slower than lower-level techniques without measurement and remember than not all code is performance critical.<br><a href="#Rper-Knuth">Don’t optimize prematurely</a></p>
<h5 id="Enforcement-369"><a href="#Enforcement-369" class="headerlink" title="Enforcement"></a>Enforcement</h5><p>???</p>
<h3 id="SL-str-2-Use-std-string-view-or-gsl-string-span-to-refer-to-character-sequences"><a href="#SL-str-2-Use-std-string-view-or-gsl-string-span-to-refer-to-character-sequences" class="headerlink" title="SL.str.2: Use std::string_view or gsl::string_span to refer to character sequences"></a><a name="Rstr-view"></a>SL.str.2: Use <code>std::string_view</code> or <code>gsl::string_span</code> to refer to character sequences</h3><h5 id="Reason-403"><a href="#Reason-403" class="headerlink" title="Reason"></a>Reason</h5><p><code>std::string_view</code> or <code>gsl::string_span</code> provides simple and (potentially) safe access to character sequences independently of how<br>those sequences are allocated and stored.</p>
<h5 id="Example-350"><a href="#Example-350" class="headerlink" title="Example"></a>Example</h5><pre><code>vector&lt;string&gt; read_until(string_span terminator);

void user(zstring p, const string&amp; s, string_span ss)
&#123;
    auto v1 = read_until(p);
    auto v2 = read_until(s);
    auto v3 = read_until(ss);
    // ...
&#125;
</code></pre>
<h5 id="Note-342"><a href="#Note-342" class="headerlink" title="Note"></a>Note</h5><p><code>std::string_view</code> (C++17) is read-only.</p>
<h5 id="Enforcement-370"><a href="#Enforcement-370" class="headerlink" title="Enforcement"></a>Enforcement</h5><p>???</p>
<h3 id="SL-str-3-Use-zstring-or-czstring-to-refer-to-a-C-style-zero-terminated-sequence-of-characters"><a href="#SL-str-3-Use-zstring-or-czstring-to-refer-to-a-C-style-zero-terminated-sequence-of-characters" class="headerlink" title="SL.str.3: Use zstring or czstring to refer to a C-style, zero-terminated, sequence of characters"></a><a name="Rstr-zstring"></a>SL.str.3: Use <code>zstring</code> or <code>czstring</code> to refer to a C-style, zero-terminated, sequence of characters</h3><h5 id="Reason-404"><a href="#Reason-404" class="headerlink" title="Reason"></a>Reason</h5><p>Readability.<br>Statement of intent.<br>A plain <code>char*</code> can be a pointer to a single character, a pointer to an array of characters, a pointer to a C-style (zero-terminated) string, or even to a small integer.<br>Distinguishing these alternatives prevents misunderstandings and bugs.</p>
<h5 id="Example-351"><a href="#Example-351" class="headerlink" title="Example"></a>Example</h5><pre><code>void f1(const char* s); // s is probably a string
</code></pre>
<p>All we know is that it is supposed to be the nullptr or point to at least one character</p>
<pre><code>void f1(zstring s);     // s is a C-style string or the nullptr
void f1(czstring s);    // s is a C-style string constant or the nullptr
void f1(std::byte* s);  // s is a pointer to a byte (C++17)
</code></pre>
<h5 id="Note-343"><a href="#Note-343" class="headerlink" title="Note"></a>Note</h5><p>Don’t convert a C-style string to <code>string</code> unless there is a reason to.</p>
<h5 id="Note-344"><a href="#Note-344" class="headerlink" title="Note"></a>Note</h5><p>Like any other “plain pointer”, a <code>zstring</code> should not represent ownership.</p>
<h5 id="Note-345"><a href="#Note-345" class="headerlink" title="Note"></a>Note</h5><p>There are billions of lines of C++ “out there”, most use <code>char*</code> and <code>const char*</code> without documenting intent.<br>They are used in a wide variety of ways, including to represent ownership and as generic pointers to memory (instead of <code>void*</code>).<br>It is hard to separate these uses, so this guideline is hard to follow.<br>This is one of the major sources of bugs in C and C++ programs, so it is worthwhile to follow this guideline wherever feasible..</p>
<h5 id="Enforcement-371"><a href="#Enforcement-371" class="headerlink" title="Enforcement"></a>Enforcement</h5><ul>
<li>Flag uses of <code>[]</code> on a <code>char*</code></li>
<li>Flag uses of <code>delete</code> on a <code>char*</code></li>
<li>Flag uses of <code>free()</code> on a <code>char*</code></li>
</ul>
<h3 id="SL-str-4-Use-char-to-refer-to-a-single-character"><a href="#SL-str-4-Use-char-to-refer-to-a-single-character" class="headerlink" title="SL.str.4: Use char* to refer to a single character"></a><a name="Rstr-char*"></a>SL.str.4: Use <code>char*</code> to refer to a single character</h3><h5 id="Reason-405"><a href="#Reason-405" class="headerlink" title="Reason"></a>Reason</h5><p>The variety of uses of <code>char*</code> in current code is a major source of errors.</p>
<h5 id="Example-bad-136"><a href="#Example-bad-136" class="headerlink" title="Example, bad"></a>Example, bad</h5><pre><code>char arr[] = &#123;&#39;a&#39;, &#39;b&#39;, &#39;c&#39;&#125;;

void print(const char* p)
&#123;
    cout &lt;&lt; p &lt;&lt; &#39;\n&#39;;
&#125;

void use()
&#123;
    print(arr);   // run-time error; potentially very bad
&#125;
</code></pre>
<p>The array <code>arr</code> is not a C-style string because it is not zero-terminated.</p>
<h5 id="Alternative-11"><a href="#Alternative-11" class="headerlink" title="Alternative"></a>Alternative</h5><p>See <a href="#Rstr-zstring"><code>zstring</code></a>, <a href="#Rstr-string"><code>string</code></a>, and <a href="#Rstr-view"><code>string_span</code></a>.</p>
<h5 id="Enforcement-372"><a href="#Enforcement-372" class="headerlink" title="Enforcement"></a>Enforcement</h5><ul>
<li>Flag uses of <code>[]</code> on a <code>char*</code></li>
</ul>
<h3 id="SL-str-5-Use-std-byte-to-refer-to-byte-values-that-do-not-necessarily-represent-characters"><a href="#SL-str-5-Use-std-byte-to-refer-to-byte-values-that-do-not-necessarily-represent-characters" class="headerlink" title="SL.str.5: Use std::byte to refer to byte values that do not necessarily represent characters"></a><a name="Rstr-byte"></a>SL.str.5: Use <code>std::byte</code> to refer to byte values that do not necessarily represent characters</h3><h5 id="Reason-406"><a href="#Reason-406" class="headerlink" title="Reason"></a>Reason</h5><p>Use of <code>char*</code> to represent a pointer to something that is not necessarily a character causes confusion<br>and disables valuable optimizations.</p>
<h5 id="Example-352"><a href="#Example-352" class="headerlink" title="Example"></a>Example</h5><pre><code>???
</code></pre>
<h5 id="Note-346"><a href="#Note-346" class="headerlink" title="Note"></a>Note</h5><p>C++17</p>
<h5 id="Enforcement-373"><a href="#Enforcement-373" class="headerlink" title="Enforcement"></a>Enforcement</h5><p>???</p>
<h3 id="SL-str-10-Use-std-string-when-you-need-to-perform-locale-sensitive-string-operations"><a href="#SL-str-10-Use-std-string-when-you-need-to-perform-locale-sensitive-string-operations" class="headerlink" title="SL.str.10: Use std::string when you need to perform locale-sensitive string operations"></a><a name="Rstr-locale"></a>SL.str.10: Use <code>std::string</code> when you need to perform locale-sensitive string operations</h3><h5 id="Reason-407"><a href="#Reason-407" class="headerlink" title="Reason"></a>Reason</h5><p><code>std::string</code> supports standard-library <a href="#Rstr-locale"><code>locale</code> facilities</a></p>
<h5 id="Example-353"><a href="#Example-353" class="headerlink" title="Example"></a>Example</h5><pre><code>???
</code></pre>
<h5 id="Note-347"><a href="#Note-347" class="headerlink" title="Note"></a>Note</h5><p>???</p>
<h5 id="Enforcement-374"><a href="#Enforcement-374" class="headerlink" title="Enforcement"></a>Enforcement</h5><p>???</p>
<h3 id="SL-str-11-Use-gsl-string-span-rather-than-std-string-view-when-you-need-to-mutate-a-string"><a href="#SL-str-11-Use-gsl-string-span-rather-than-std-string-view-when-you-need-to-mutate-a-string" class="headerlink" title="SL.str.11: Use gsl::string_span rather than std::string_view when you need to mutate a string"></a><a name="Rstr-span"></a>SL.str.11: Use <code>gsl::string_span</code> rather than <code>std::string_view</code> when you need to mutate a string</h3><h5 id="Reason-408"><a href="#Reason-408" class="headerlink" title="Reason"></a>Reason</h5><p><code>std::string_view</code> is read-only.</p>
<h5 id="Example-354"><a href="#Example-354" class="headerlink" title="Example"></a>Example</h5><p>???</p>
<h5 id="Note-348"><a href="#Note-348" class="headerlink" title="Note"></a>Note</h5><p>???</p>
<h5 id="Enforcement-375"><a href="#Enforcement-375" class="headerlink" title="Enforcement"></a>Enforcement</h5><p>The compiler will flag attempts to write to a <code>string_view</code>.</p>
<h3 id="SL-str-12-Use-the-s-suffix-for-string-literals-meant-to-be-standard-library-strings"><a href="#SL-str-12-Use-the-s-suffix-for-string-literals-meant-to-be-standard-library-strings" class="headerlink" title="SL.str.12: Use the s suffix for string literals meant to be standard-library strings"></a><a name="Rstr-s"></a>SL.str.12: Use the <code>s</code> suffix for string literals meant to be standard-library <code>string</code>s</h3><h5 id="Reason-409"><a href="#Reason-409" class="headerlink" title="Reason"></a>Reason</h5><p>Direct expression of an idea minimizes mistakes.</p>
<h5 id="Example-355"><a href="#Example-355" class="headerlink" title="Example"></a>Example</h5><pre><code>auto pp1 = make_pair(&quot;Tokyo&quot;, 9.00);         // &#123;C-style string,double&#125; intended?
pair&lt;string, double&gt; pp2 = &#123;&quot;Tokyo&quot;, 9.00&#125;;  // a bit verbose
auto pp3 = make_pair(&quot;Tokyo&quot;s, 9.00);        // &#123;std::string,double&#125;    // C++14
pair pp4 = &#123;&quot;Tokyo&quot;s, 9.00&#125;;                 // &#123;std::string,double&#125;    // C++17
</code></pre>
<h5 id="Note-349"><a href="#Note-349" class="headerlink" title="Note"></a>Note</h5><p>C++14</p>
<h5 id="Enforcement-376"><a href="#Enforcement-376" class="headerlink" title="Enforcement"></a>Enforcement</h5><p>???</p>
<h2 id="SL-io-Iostream"><a href="#SL-io-Iostream" class="headerlink" title="SL.io: Iostream"></a><a name="SS-io"></a>SL.io: Iostream</h2><p><code>iostream</code>s is a type safe, extensible, formatted and unformatted I/O library for streaming I/O.<br>It supports multiple (and user extensible) buffering strategies and multiple locales.<br>It can be used for conventional I/O, reading and writing to memory (string streams),<br>and user-defines extensions, such as streaming across networks (asio: not yet standardized).</p>
<p>Iostream rule summary:</p>
<ul>
<li><a href="#Rio-low">SL.io.1: Use character-level input only when you have to</a></li>
<li><a href="#Rio-validate">SL.io.2: When reading, always consider ill-formed input</a></li>
<li><a href="#Rio-streams">SL.io.3: Prefer iostreams for I/O</a></li>
<li><a href="#Rio-sync">SL.io.10: Unless you use <code>printf</code>-family functions call <code>ios_base::sync_with_stdio(false)</code></a></li>
<li><a href="#Rio-endl">SL.io.50: Avoid <code>endl</code></a></li>
<li><a href="#???">???</a></li>
</ul>
<h3 id="SL-io-1-Use-character-level-input-only-when-you-have-to"><a href="#SL-io-1-Use-character-level-input-only-when-you-have-to" class="headerlink" title="SL.io.1: Use character-level input only when you have to"></a><a name="Rio-low"></a>SL.io.1: Use character-level input only when you have to</h3><h5 id="Reason-410"><a href="#Reason-410" class="headerlink" title="Reason"></a>Reason</h5><p>Unless you genuinely just deal with individual characters, using character-level input leads to the user code performing potentially error-prone<br>and potentially inefficient composition of tokens out of characters.</p>
<h5 id="Example-356"><a href="#Example-356" class="headerlink" title="Example"></a>Example</h5><pre><code>char c;
char buf[128];
int i = 0;
while (cin.get(c) &amp;&amp; !isspace(c) &amp;&amp; i &lt; 128)
    buf[i++] = c;
if (i == 128) &#123;
    // ... handle too long string ....
&#125;
</code></pre>
<p>Better (much simpler and probably faster):</p>
<pre><code>string s;
s.reserve(128);
cin &gt;&gt; s;
</code></pre>
<p>and the <code>reserve(128)</code> is probably not worthwhile.</p>
<h5 id="Enforcement-377"><a href="#Enforcement-377" class="headerlink" title="Enforcement"></a>Enforcement</h5><p>???</p>
<h3 id="SL-io-2-When-reading-always-consider-ill-formed-input"><a href="#SL-io-2-When-reading-always-consider-ill-formed-input" class="headerlink" title="SL.io.2: When reading, always consider ill-formed input"></a><a name="Rio-validate"></a>SL.io.2: When reading, always consider ill-formed input</h3><h5 id="Reason-411"><a href="#Reason-411" class="headerlink" title="Reason"></a>Reason</h5><p>Errors are typically best handled as soon as possible.<br>If input isn’t validated, every function must be written to cope with bad data (and that is not practical).</p>
<h5 id="Example-357"><a href="#Example-357" class="headerlink" title="Example"></a>Example</h5><pre><code>???
</code></pre>
<h5 id="Enforcement-378"><a href="#Enforcement-378" class="headerlink" title="Enforcement"></a>Enforcement</h5><p>???</p>
<h3 id="SL-io-3-Prefer-iostreams-for-I-O"><a href="#SL-io-3-Prefer-iostreams-for-I-O" class="headerlink" title="SL.io.3: Prefer iostreams for I/O"></a><a name="Rio-streams"></a>SL.io.3: Prefer <code>iostream</code>s for I/O</h3><h5 id="Reason-412"><a href="#Reason-412" class="headerlink" title="Reason"></a>Reason</h5><p><code>iostream</code>s are safe, flexible, and extensible.</p>
<h5 id="Example-358"><a href="#Example-358" class="headerlink" title="Example"></a>Example</h5><pre><code>// write a complex number:
complex&lt;double&gt; z&#123; 3, 4 &#125;;
cout &lt;&lt; z &lt;&lt; &#39;\n&#39;;
</code></pre>
<p><code>complex</code> is a user-defined type and its I/O is defined without modifying the <code>iostream</code> library.</p>
<h5 id="Example-359"><a href="#Example-359" class="headerlink" title="Example"></a>Example</h5><pre><code>// read a file of complex numbers:
for (complex&lt;double&gt; z; cin &gt;&gt; z; )
    v.push_back(z);
</code></pre>
<h5 id="Exception-53"><a href="#Exception-53" class="headerlink" title="Exception"></a>Exception</h5><p>??? performance ???</p>
<h5 id="Discussion-iostreams-vs-the-printf-family"><a href="#Discussion-iostreams-vs-the-printf-family" class="headerlink" title="Discussion: iostreams vs. the printf() family"></a>Discussion: <code>iostream</code>s vs. the <code>printf()</code> family</h5><p>It is often (and often correctly) pointed out that the <code>printf()</code> family has two advantages compared to <code>iostream</code>s:<br>flexibility of formatting and performance.<br>This has to be weighed against <code>iostream</code>s advantages of extensibility to handle user-defined types, resilient against security violations,<br>implicit memory management, and <code>locale</code> handling.</p>
<p>If you need I/O performance, you can almost always do better than <code>printf()</code>.</p>
<p><code>gets()</code> <code>scanf()</code> using <code>s</code>, and <code>printf()</code> using <code>%s</code> are security hazards (vulnerable to buffer overflow and generally error-prone).<br>In C11, they are replaced by <code>gets_s()</code>, <code>scanf_s()</code>, and <code>printf_s()</code> as safer alternatives, but they are still not type safe.</p>
<h5 id="Enforcement-379"><a href="#Enforcement-379" class="headerlink" title="Enforcement"></a>Enforcement</h5><p>Optionally flag <code>&lt;cstdio&gt;</code> and <code>&lt;stdio.h&gt;</code>.</p>
<h3 id="SL-io-10-Unless-you-use-printf-family-functions-call-ios-base-sync-with-stdio-false"><a href="#SL-io-10-Unless-you-use-printf-family-functions-call-ios-base-sync-with-stdio-false" class="headerlink" title="SL.io.10: Unless you use printf-family functions call ios_base::sync_with_stdio(false)"></a><a name="Rio-sync"></a>SL.io.10: Unless you use <code>printf</code>-family functions call <code>ios_base::sync_with_stdio(false)</code></h3><h5 id="Reason-413"><a href="#Reason-413" class="headerlink" title="Reason"></a>Reason</h5><p>Synchronizing <code>iostreams</code> with <code>printf-style</code> I/O can be costly.<br><code>cin</code> and <code>cout</code> are by default synchronized with <code>printf</code>.</p>
<h5 id="Example-360"><a href="#Example-360" class="headerlink" title="Example"></a>Example</h5><pre><code>int main()
&#123;
    ios_base::sync_with_stdio(false);
    // ... use iostreams ...
&#125;
</code></pre>
<h5 id="Enforcement-380"><a href="#Enforcement-380" class="headerlink" title="Enforcement"></a>Enforcement</h5><p>???</p>
<h3 id="SL-io-50-Avoid-endl"><a href="#SL-io-50-Avoid-endl" class="headerlink" title="SL.io.50: Avoid endl"></a><a name="Rio-endl"></a>SL.io.50: Avoid <code>endl</code></h3><h5 id="Reason-414"><a href="#Reason-414" class="headerlink" title="Reason"></a>Reason</h5><p>The <code>endl</code> manipulator is mostly equivalent to <code>&#39;\n&#39;</code> and <code>&quot;\n&quot;</code>;<br>as most commonly used it simply slows down output by doing redundant <code>flush()</code>s.<br>This slowdown can be significant compared to <code>printf</code>-style output.</p>
<h5 id="Example-361"><a href="#Example-361" class="headerlink" title="Example"></a>Example</h5><pre><code>cout &lt;&lt; &quot;Hello, World!&quot; &lt;&lt; endl;    // two output operations and a flush
cout &lt;&lt; &quot;Hello, World!\n&quot;;          // one output operation and no flush
</code></pre>
<h5 id="Note-350"><a href="#Note-350" class="headerlink" title="Note"></a>Note</h5><p>For <code>cin</code>/<code>cout</code> (and equivalent) interaction, there is no reason to flush; that’s done automatically.<br>For writing to a file, there is rarely a need to <code>flush</code>.</p>
<h5 id="Note-351"><a href="#Note-351" class="headerlink" title="Note"></a>Note</h5><p>Apart from the (occasionally important) issue of performance,<br>the choice between <code>&#39;\n&#39;</code> and <code>endl</code> is almost completely aesthetic.</p>
<h2 id="SL-regex-Regex"><a href="#SL-regex-Regex" class="headerlink" title="SL.regex: Regex"></a><a name="SS-regex"></a>SL.regex: Regex</h2><p><code>&lt;regex&gt;</code> is the standard C++ regular expression library.<br>It supports a variety of regular expression pattern conventions.</p>
<h2 id="SL-chrono-Time"><a href="#SL-chrono-Time" class="headerlink" title="SL.chrono: Time"></a><a name="SS-chrono"></a>SL.chrono: Time</h2><p><code>&lt;chrono&gt;</code> (defined in namespace <code>std::chrono</code>) provides the notions of <code>time_point</code> and <code>duration</code> together with functions for<br>outputting time in various units.<br>It provides clocks for registering <code>time_points</code>.</p>
<h2 id="SL-C-The-C-Standard-Library"><a href="#SL-C-The-C-Standard-Library" class="headerlink" title="SL.C: The C Standard Library"></a><a name="SS-clib"></a>SL.C: The C Standard Library</h2><p>???</p>
<p>C Standard Library rule summary:</p>
<ul>
<li><a href="#Rclib-jmp">S.C.1: Don’t use setjmp/longjmp</a></li>
<li><a href="#???">???</a></li>
<li><a href="#???">???</a></li>
</ul>
<h3 id="SL-C-1-Don’t-use-setjmp-longjmp"><a href="#SL-C-1-Don’t-use-setjmp-longjmp" class="headerlink" title="SL.C.1: Don’t use setjmp/longjmp"></a><a name="Rclib-jmp"></a>SL.C.1: Don’t use setjmp/longjmp</h3><h5 id="Reason-415"><a href="#Reason-415" class="headerlink" title="Reason"></a>Reason</h5><p>a <code>longjmp</code> ignores destructors, thus invalidating all resource-management strategies relying on RAII</p>
<h5 id="Enforcement-381"><a href="#Enforcement-381" class="headerlink" title="Enforcement"></a>Enforcement</h5><p>Flag all occurrences of <code>longjmp</code>and <code>setjmp</code></p>
<h1 id="A-Architectural-ideas"><a href="#A-Architectural-ideas" class="headerlink" title="A: Architectural ideas"></a><a name="S-A"></a>A: Architectural ideas</h1><p>This section contains ideas about higher-level architectural ideas and libraries.</p>
<p>Architectural rule summary:</p>
<ul>
<li><a href="#Ra-stable">A.1: Separate stable from less stable part of code</a></li>
<li><a href="#Ra-lib">A.2: Express potentially reusable parts as a library</a></li>
<li><a href="#?Ra-dag">A.4: There should be no cycles among libraries</a></li>
<li><a href="#???">???</a></li>
<li><a href="#???">???</a></li>
<li><a href="#???">???</a></li>
<li><a href="#???">???</a></li>
<li><a href="#???">???</a></li>
<li><a href="#???">???</a></li>
</ul>
<h3 id="A-1-Separate-stable-from-less-stable-part-of-code"><a href="#A-1-Separate-stable-from-less-stable-part-of-code" class="headerlink" title="A.1: Separate stable from less stable part of code"></a><a name="Ra-stable"></a>A.1: Separate stable from less stable part of code</h3><p>???</p>
<h3 id="A-2-Express-potentially-reusable-parts-as-a-library"><a href="#A-2-Express-potentially-reusable-parts-as-a-library" class="headerlink" title="A.2: Express potentially reusable parts as a library"></a><a name="Ra-lib"></a>A.2: Express potentially reusable parts as a library</h3><h5 id="Reason-416"><a href="#Reason-416" class="headerlink" title="Reason"></a>Reason</h5><h5 id="Note-352"><a href="#Note-352" class="headerlink" title="Note"></a>Note</h5><p>A library is a collection of declarations and definitions maintained, documented, and shipped together.<br>A library could be a set of headers (a “header only library”) or a set of headers plus a set of object files.<br>A library can be statically or dynamically linked into a program, or it may be <code>#include</code>d</p>
<h3 id="A-4-There-should-be-no-cycles-among-libraries"><a href="#A-4-There-should-be-no-cycles-among-libraries" class="headerlink" title="A.4: There should be no cycles among libraries"></a><a name="Ra-dag"></a>A.4: There should be no cycles among libraries</h3><h5 id="Reason-417"><a href="#Reason-417" class="headerlink" title="Reason"></a>Reason</h5><ul>
<li>A cycle implies complication of the build process.</li>
<li>Cycles are hard to understand and may introduce indeterminism (unspecified behavior).</li>
</ul>
<h5 id="Note-353"><a href="#Note-353" class="headerlink" title="Note"></a>Note</h5><p>A library can contain cyclic references in the definition of its components.<br>For example:</p>
<pre><code>???
</code></pre>
<p>However, a library should not depend on another that depends on it.</p>
<h1 id="NR-Non-Rules-and-myths"><a href="#NR-Non-Rules-and-myths" class="headerlink" title="NR: Non-Rules and myths"></a><a name="S-not"></a>NR: Non-Rules and myths</h1><p>This section contains rules and guidelines that are popular somewhere, but that we deliberately don’t recommend.<br>We know full well that there have been times and places where these rules made sense, and we have used them ourselves at times.<br>However, in the context of the styles of programming we recommend and support with the guidelines, these “non-rules” would do harm.</p>
<p>Even today, there can be contexts where the rules make sense.<br>For example, lack of suitable tool support can make exceptions unsuitable in hard-real-time systems,<br>but please don’t blindly trust “common wisdom” (e.g., unsupported statements about “efficiency”);<br>such “wisdom” may be based on decades-old information or experienced from languages with very different properties than C++<br>(e.g., C or Java).</p>
<p>The positive arguments for alternatives to these non-rules are listed in the rules offered as “Alternatives”.</p>
<p>Non-rule summary:</p>
<ul>
<li><a href="#Rnr-top">NR.1: Don’t: All declarations should be at the top of a function</a></li>
<li><a href="#Rnr-single-return">NR.2: Don’t: Have only a single <code>return</code>-statement in a function</a></li>
<li><a href="#Rnr-no-exceptions">NR.3: Don’t: Don’t use exceptions</a></li>
<li><a href="#Rnr-lots-of-files">NR.4: Don’t: Place each class declaration in its own source file</a></li>
<li><a href="#Rnr-two-phase-init">NR.5: Don’t: Don’t do substantive work in a constructor; instead use two-phase initialization</a></li>
<li><a href="#Rnr-goto-exit">NR.6: Don’t: Place all cleanup actions at the end of a function and <code>goto exit</code></a></li>
<li><a href="#Rnr-protected-data">NR.7: Don’t: Make all data members <code>protected</code></a></li>
<li>???</li>
</ul>
<h3 id="NR-1-Don’t-All-declarations-should-be-at-the-top-of-a-function"><a href="#NR-1-Don’t-All-declarations-should-be-at-the-top-of-a-function" class="headerlink" title="NR.1: Don’t: All declarations should be at the top of a function"></a><a name="Rnr-top"></a>NR.1: Don’t: All declarations should be at the top of a function</h3><h5 id="Reason-not-to-follow-this-rule"><a href="#Reason-not-to-follow-this-rule" class="headerlink" title="Reason (not to follow this rule)"></a>Reason (not to follow this rule)</h5><p>This rule is a legacy of old programming languages that didn’t allow initialization of variables and constants after a statement.<br>This leads to longer programs and more errors caused by uninitialized and wrongly initialized variables.</p>
<h5 id="Example-bad-137"><a href="#Example-bad-137" class="headerlink" title="Example, bad"></a>Example, bad</h5><pre><code>int use(int x)
&#123;
    int i;
    char c;
    double d;

    // ... some stuff ...

    if (x &lt; i) &#123;
        // ...
        i = f(x, d);
    &#125;
    if (i &lt; x) &#123;
        // ...
        i = g(x, c);
    &#125;
    return i;
&#125;
</code></pre>
<p>The larger the distance between the uninitialized variable and its use, the larger the chance of a bug.<br>Fortunately, compilers catch many “used before set” errors.<br>Unfortunately, compilers cannot catch all such errors and unfortunately, the bugs aren’t always as simple to spot as in this small example.</p>
<h5 id="Alternative-12"><a href="#Alternative-12" class="headerlink" title="Alternative"></a>Alternative</h5><ul>
<li><a href="#Res-always">Always initialize an object</a></li>
<li><a href="#Res-introduce">ES.21: Don’t introduce a variable (or constant) before you need to use it</a></li>
</ul>
<h3 id="NR-2-Don’t-Have-only-a-single-return-statement-in-a-function"><a href="#NR-2-Don’t-Have-only-a-single-return-statement-in-a-function" class="headerlink" title="NR.2: Don’t: Have only a single return-statement in a function"></a><a name="Rnr-single-return"></a>NR.2: Don’t: Have only a single <code>return</code>-statement in a function</h3><h5 id="Reason-not-to-follow-this-rule-1"><a href="#Reason-not-to-follow-this-rule-1" class="headerlink" title="Reason (not to follow this rule)"></a>Reason (not to follow this rule)</h5><p>The single-return rule can lead to unnecessarily convoluted code and the introduction of extra state variables.<br>In particular, the single-return rule makes it harder to concentrate error checking at the top of a function.</p>
<h5 id="Example-362"><a href="#Example-362" class="headerlink" title="Example"></a>Example</h5><pre><code>template&lt;class T&gt;
//  requires Number&lt;T&gt;
string sign(T x)
&#123;
    if (x &lt; 0)
        return &quot;negative&quot;;
    else if (x &gt; 0)
        return &quot;positive&quot;;
    return &quot;zero&quot;;
&#125;
</code></pre>
<p>to use a single return only we would have to do something like</p>
<pre><code>template&lt;class T&gt;
//  requires Number&lt;T&gt;
string sign(T x)        // bad
&#123;
    string res;
    if (x &lt; 0)
        res = &quot;negative&quot;;
    else if (x &gt; 0)
        res = &quot;positive&quot;;
    else
        res = &quot;zero&quot;;
    return res;
&#125;
</code></pre>
<p>This is both longer and likely to be less efficient.<br>The larger and more complicated the function is, the more painful the workarounds get.<br>Of course many simple functions will naturally have just one <code>return</code> because of their simpler inherent logic.</p>
<h5 id="Example-363"><a href="#Example-363" class="headerlink" title="Example"></a>Example</h5><pre><code>int index(const char* p)
&#123;
    if (!p) return -1;  // error indicator: alternatively &quot;throw nullptr_error&#123;&#125;&quot;
    // ... do a lookup to find the index for p
    return i;
&#125;
</code></pre>
<p>If we applied the rule, we’d get something like</p>
<pre><code>int index2(const char* p)
&#123;
    int i;
    if (!p)
        i = -1;  // error indicator
    else &#123;
        // ... do a lookup to find the index for p
    &#125;
    return i;
&#125;
</code></pre>
<p>Note that we (deliberately) violated the rule against uninitialized variables because this style commonly leads to that.<br>Also, this style is a temptation to use the <a href="#Rnr-goto-exit">goto exit</a> non-rule.</p>
<h5 id="Alternative-13"><a href="#Alternative-13" class="headerlink" title="Alternative"></a>Alternative</h5><ul>
<li>Keep functions short and simple</li>
<li>Feel free to use multiple <code>return</code> statements (and to throw exceptions).</li>
</ul>
<h3 id="NR-3-Don’t-Don’t-use-exceptions"><a href="#NR-3-Don’t-Don’t-use-exceptions" class="headerlink" title="NR.3: Don’t: Don’t use exceptions"></a><a name="Rnr-no-exceptions"></a>NR.3: Don’t: Don’t use exceptions</h3><h5 id="Reason-not-to-follow-this-rule-2"><a href="#Reason-not-to-follow-this-rule-2" class="headerlink" title="Reason (not to follow this rule)"></a>Reason (not to follow this rule)</h5><p>There seem to be three main reasons given for this non-rule:</p>
<ul>
<li>exceptions are inefficient</li>
<li>exceptions lead to leaks and errors</li>
<li>exception performance is not predictable</li>
</ul>
<p>There is no way we can settle this issue to the satisfaction of everybody.<br>After all, the discussions about exceptions have been going on for 40+ years.<br>Some languages cannot be used without exceptions, but others do not support them.<br>This leads to strong traditions for the use and non-use of exceptions, and to heated debates.</p>
<p>However, we can briefly outline why we consider exceptions the best alternative for general-purpose programming<br>and in the context of these guidelines.<br>Simple arguments for and against are often inconclusive.<br>There are specialized applications where exceptions indeed can be inappropriate<br>(e.g., hard-real-time systems without support for reliable estimates of the cost of handling an exception).</p>
<p>Consider the major objections to exceptions in turn</p>
<ul>
<li>Exceptions are inefficient:<br>Compared to what?<br>When comparing make sure that the same set of errors are handled and that they are handled equivalently.<br>In particular, do not compare a program that immediately terminate on seeing an error with a program<br>that carefully cleans up resources before logging an error.<br>Yes, some systems have poor exception handling implementations; sometimes, such implementations force us to use<br>other error-handling approaches, but that’s not a fundamental problem with exceptions.<br>When using an efficiency argument - in any context - be careful that you have good data that actually provides<br>insight into the problem under discussion.</li>
<li>Exceptions lead to leaks and errors.<br>They do not.<br>If your program is a rat’s nest of pointers without an overall strategy for resource management,<br>you have a problem whatever you do.<br>If your system consists of a million lines of such code,<br>you probably will not be able to use exceptions,<br>but that’s a problem with excessive and undisciplined pointer use, rather than with exceptions.<br>In our opinion, you need RAII to make exception-based error handling simple and safe – simpler and safer than alternatives.</li>
<li>Exception performance is not predictable.<br>If you are in a hard-real-time system where you must guarantee completion of a task in a given time,<br>you need tools to back up such guarantees.<br>As far as we know such tools are not available (at least not to most programmers).</li>
</ul>
<p>Many, possibly most, problems with exceptions stem from historical needs to interact with messy old code.</p>
<p>The fundamental arguments for the use of exceptions are</p>
<ul>
<li>They clearly differentiate between erroneous return and ordinary return</li>
<li>They cannot be forgotten or ignored</li>
<li>They can be used systematically</li>
</ul>
<p>Remember</p>
<ul>
<li>Exceptions are for reporting errors (in C++; other languages can have different uses for exceptions).</li>
<li>Exceptions are not for errors that can be handled locally.</li>
<li>Don’t try to catch every exception in every function (that’s tedious, clumsy, and leads to slow code).</li>
<li>Exceptions are not for errors that require instant termination of a module/system after a non-recoverable error.</li>
</ul>
<h5 id="Example-364"><a href="#Example-364" class="headerlink" title="Example"></a>Example</h5><pre><code>???
</code></pre>
<h5 id="Alternative-14"><a href="#Alternative-14" class="headerlink" title="Alternative"></a>Alternative</h5><ul>
<li><a href="#Re-raii">RAII</a></li>
<li>Contracts/assertions: Use GSL’s <code>Expects</code> and <code>Ensures</code> (until we get language support for contracts)</li>
</ul>
<h3 id="NR-4-Don’t-Place-each-class-declaration-in-its-own-source-file"><a href="#NR-4-Don’t-Place-each-class-declaration-in-its-own-source-file" class="headerlink" title="NR.4: Don’t: Place each class declaration in its own source file"></a><a name="Rnr-lots-of-files"></a>NR.4: Don’t: Place each class declaration in its own source file</h3><h5 id="Reason-not-to-follow-this-rule-3"><a href="#Reason-not-to-follow-this-rule-3" class="headerlink" title="Reason (not to follow this rule)"></a>Reason (not to follow this rule)</h5><p>The resulting number of files are hard to manage and can slow down compilation.<br>Individual classes are rarely a good logical unit of maintenance and distribution.</p>
<h5 id="Example-365"><a href="#Example-365" class="headerlink" title="Example"></a>Example</h5><pre><code>???
</code></pre>
<h5 id="Alternative-15"><a href="#Alternative-15" class="headerlink" title="Alternative"></a>Alternative</h5><ul>
<li>Use namespaces containing logically cohesive sets of classes and functions.</li>
</ul>
<h3 id="NR-5-Don’t-Don’t-do-substantive-work-in-a-constructor-instead-use-two-phase-initialization"><a href="#NR-5-Don’t-Don’t-do-substantive-work-in-a-constructor-instead-use-two-phase-initialization" class="headerlink" title="NR.5: Don’t: Don’t do substantive work in a constructor; instead use two-phase initialization"></a><a name="Rnr-two-phase-init"></a>NR.5: Don’t: Don’t do substantive work in a constructor; instead use two-phase initialization</h3><h5 id="Reason-not-to-follow-this-rule-4"><a href="#Reason-not-to-follow-this-rule-4" class="headerlink" title="Reason (not to follow this rule)"></a>Reason (not to follow this rule)</h5><p>Following this rule leads to weaker invariants,<br>more complicated code (having to deal with semi-constructed objects),<br>and errors (when we didn’t deal correctly with semi-constructed objects consistently).</p>
<h5 id="Example-366"><a href="#Example-366" class="headerlink" title="Example"></a>Example</h5><pre><code>???
</code></pre>
<h5 id="Alternative-16"><a href="#Alternative-16" class="headerlink" title="Alternative"></a>Alternative</h5><ul>
<li>Always establish a class invariant in a constructor.</li>
<li>Don’t define an object before it is needed.</li>
</ul>
<h3 id="NR-6-Don’t-Place-all-cleanup-actions-at-the-end-of-a-function-and-goto-exit"><a href="#NR-6-Don’t-Place-all-cleanup-actions-at-the-end-of-a-function-and-goto-exit" class="headerlink" title="NR.6: Don’t: Place all cleanup actions at the end of a function and goto exit"></a><a name="Rnr-goto-exit"></a>NR.6: Don’t: Place all cleanup actions at the end of a function and <code>goto exit</code></h3><h5 id="Reason-not-to-follow-this-rule-5"><a href="#Reason-not-to-follow-this-rule-5" class="headerlink" title="Reason (not to follow this rule)"></a>Reason (not to follow this rule)</h5><p><code>goto</code> is error-prone.<br>This technique is a pre-exception technique for RAII-like resource and error handling.</p>
<h5 id="Example-bad-138"><a href="#Example-bad-138" class="headerlink" title="Example, bad"></a>Example, bad</h5><pre><code>void do_something(int n)
&#123;
    if (n &lt; 100) goto exit;
    // ...
    int* p = (int*) malloc(n);
    // ...
    if (some_error) goto_exit;
    // ...
exit:
    free(p);
&#125;
</code></pre>
<p>and spot the bug.</p>
<h5 id="Alternative-17"><a href="#Alternative-17" class="headerlink" title="Alternative"></a>Alternative</h5><ul>
<li>Use exceptions and <a href="#Re-raii">RAII</a></li>
<li>for non-RAII resources, use <a href="#Re-finally"><code>finally</code></a>.</li>
</ul>
<h3 id="NR-7-Don’t-Make-all-data-members-protected"><a href="#NR-7-Don’t-Make-all-data-members-protected" class="headerlink" title="NR.7: Don’t: Make all data members protected"></a><a name="Rnr-protected-data"></a>NR.7: Don’t: Make all data members <code>protected</code></h3><h5 id="Reason-not-to-follow-this-rule-6"><a href="#Reason-not-to-follow-this-rule-6" class="headerlink" title="Reason (not to follow this rule)"></a>Reason (not to follow this rule)</h5><p><code>protected</code> data is a source of errors.<br><code>protected</code> data can be manipulated from an unbounded amount of code in various places.<br><code>protected</code> data is the class hierarchy equivalent to global data.</p>
<h5 id="Example-367"><a href="#Example-367" class="headerlink" title="Example"></a>Example</h5><pre><code>???
</code></pre>
<h5 id="Alternative-18"><a href="#Alternative-18" class="headerlink" title="Alternative"></a>Alternative</h5><ul>
<li><a href="#Rh-protected">Make member data <code>public</code> or (preferably) <code>private</code></a></li>
</ul>
<h1 id="RF-References"><a href="#RF-References" class="headerlink" title="RF: References"></a><a name="S-references"></a>RF: References</h1><p>Many coding standards, rules, and guidelines have been written for C++, and especially for specialized uses of C++.<br>Many</p>
<ul>
<li>focus on lower-level issues, such as the spelling of identifiers</li>
<li>are written by C++ novices</li>
<li>see “stopping programmers from doing unusual things” as their primary aim</li>
<li>aim at portability across many compilers (some 10 years old)</li>
<li>are written to preserve decades old code bases</li>
<li>aim at a single application domain</li>
<li>are downright counterproductive</li>
<li>are ignored (must be ignored by programmers to get their work done well)</li>
</ul>
<p>A bad coding standard is worse than no coding standard.<br>However an appropriate set of guidelines are much better than no standards: “Form is liberating.”</p>
<p>Why can’t we just have a language that allows all we want and disallows all we don’t want (“a perfect language”)?<br>Fundamentally, because affordable languages (and their tool chains) also serve people with needs that differ from yours and serve more needs than you have today.<br>Also, your needs change over time and a general-purpose language is needed to allow you to adapt.<br>A language that is ideal for today would be overly restrictive tomorrow.</p>
<p>Coding guidelines adapt the use of a language to specific needs.<br>Thus, there cannot be a single coding style for everybody.<br>We expect different organizations to provide additions, typically with more restrictions and firmer style rules.</p>
<p>Reference sections:</p>
<ul>
<li><a href="#SS-rules">RF.rules: Coding rules</a></li>
<li><a href="#SS-books">RF.books: Books with coding guidelines</a></li>
<li><a href="#SS-Cplusplus">RF.C++: C++ Programming (C++11/C++14)</a></li>
<li><a href="#SS-web">RF.web: Websites</a></li>
<li><a href="#SS-vid">RS.video: Videos about “modern C++”</a></li>
<li><a href="#SS-man">RF.man: Manuals</a></li>
<li><a href="#SS-core">RF.core: Core Guidelines materials</a></li>
</ul>
<h2 id="RF-rules-Coding-rules"><a href="#RF-rules-Coding-rules" class="headerlink" title="RF.rules: Coding rules"></a><a name="SS-rules"></a>RF.rules: Coding rules</h2><ul>
<li><a href="http://www.boost.org/development/requirements.html">Boost Library Requirements and Guidelines</a>.<br>???.</li>
<li><a href="https://github.com/bloomberg/bde/wiki/CodingStandards.pdf">Bloomberg: BDE C++ Coding</a>.<br>Has a strong emphasis on code organization and layout.</li>
<li>Facebook: ???</li>
<li><a href="https://gcc.gnu.org/codingconventions.html">GCC Coding Conventions</a>.<br>C++03 and (reasonably) a bit backwards looking.</li>
<li><a href="https://google.github.io/styleguide/cppguide.html">Google C++ Style Guide</a>.<br>Geared toward C++03 and (also) older code bases. Google experts are now actively collaborating here on helping to improve these Guidelines, and hopefully to merge efforts so these can be a modern common set they could also recommend.</li>
<li><a href="http://www.stroustrup.com/JSF-AV-rules.pdf">JSF++: JOINT STRIKE FIGHTER AIR VEHICLE C++ CODING STANDARDS</a>.<br>Document Number 2RDU00001 Rev C. December 2005.<br>For flight control software.<br>For hard-real-time.<br>This means that it is necessarily very restrictive (“if the program fails somebody dies”).<br>For example, no free store allocation or deallocation may occur after the plane takes off (no memory overflow and no fragmentation allowed).<br>No exception may be used (because there was no available tool for guaranteeing that an exception would be handled within a fixed short time).<br>Libraries used have to have been approved for mission critical applications.<br>Any similarities to this set of guidelines are unsurprising because Bjarne Stroustrup was an author of JSF++.<br>Recommended, but note its very specific focus.</li>
<li><a href="https://developer.mozilla.org/en-US/docs/Mozilla/C%2B%2B_Portability_Guide">Mozilla Portability Guide</a>.<br>As the name indicates, this aims for portability across many (old) compilers.<br>As such, it is restrictive.</li>
<li><a href="http://geosoft.no/development/cppstyle.html">Geosoft.no: C++ Programming Style Guidelines</a>.<br>???.</li>
<li><a href="http://www.possibility.com/Cpp/CppCodingStandard.html">Possibility.com: C++ Coding Standard</a>.<br>???.</li>
<li><a href="https://www.securecoding.cert.org/confluence/pages/viewpage.action?pageId=637">SEI CERT: Secure C++ Coding Standard</a>.<br>A very nicely done set of rules (with examples and rationales) done for security-sensitive code.<br>Many of their rules apply generally.</li>
<li><a href="http://www.codingstandard.com/">High Integrity C++ Coding Standard</a>.</li>
<li><a href="http://llvm.org/docs/CodingStandards.html">llvm</a>.<br>Somewhat brief, pre-C++11, and (not unreasonably) adjusted to its domain.</li>
<li>???</li>
</ul>
<h2 id="RF-books-Books-with-coding-guidelines"><a href="#RF-books-Books-with-coding-guidelines" class="headerlink" title="RF.books: Books with coding guidelines"></a><a name="SS-books"></a>RF.books: Books with coding guidelines</h2><ul>
<li><a href="#Meyers96">Meyers96</a> Scott Meyers: <em>More Effective C++</em>. Addison-Wesley 1996.</li>
<li><a href="#Meyers97">Meyers97</a> Scott Meyers: <em>Effective C++, Second Edition</em>. Addison-Wesley 1997.</li>
<li><a href="#Meyers01">Meyers01</a> Scott Meyers: <em>Effective STL</em>. Addison-Wesley 2001.</li>
<li><a href="#Meyers05">Meyers05</a> Scott Meyers: <em>Effective C++, Third Edition</em>. Addison-Wesley 2005.</li>
<li><a href="#Meyers15">Meyers15</a> Scott Meyers: <em>Effective Modern C++</em>. O’Reilly 2015.</li>
<li><a href="#SuttAlex05">SuttAlex05</a> Sutter and Alexandrescu: <em>C++ Coding Standards</em>. Addison-Wesley 2005. More a set of meta-rules than a set of rules. Pre-C++11.</li>
<li><a href="#Stroustrup05">Stroustrup05</a> Bjarne Stroustrup: <a href="http://www.stroustrup.com/SELLrationale.pdf">A rationale for semantically enhanced library languages</a>.<br>LCSD05. October 2005.</li>
<li><a href="#Stroustrup05">Stroustrup14</a> Stroustrup: <a href="http://www.stroustrup.com/Tour.html">A Tour of C++</a>.<br>Addison Wesley 2014.<br>Each chapter ends with an advice section consisting of a set of recommendations.</li>
<li><a href="#Stroustrup13">Stroustrup13</a> Stroustrup: <a href="http://www.stroustrup.com/4th.html">The C++ Programming Language (4th Edition)</a>.<br>Addison Wesley 2013.<br>Each chapter ends with an advice section consisting of a set of recommendations.</li>
<li>Stroustrup: <a href="http://www.stroustrup.com/Programming/PPP-style.pdf">Style Guide</a><br>for <a href="http://www.stroustrup.com/programming.html">Programming: Principles and Practice using C++</a>.<br>Mostly low-level naming and layout rules.<br>Primarily a teaching tool.</li>
</ul>
<h2 id="RF-C-C-Programming-C-11-C-14"><a href="#RF-C-C-Programming-C-11-C-14" class="headerlink" title="RF.C++: C++ Programming (C++11/C++14)"></a><a name="SS-Cplusplus"></a>RF.C++: C++ Programming (C++11/C++14)</h2><ul>
<li><a href="http://www.stroustrup.com/4th.html">TC++PL4</a>:<br>A thorough description of the C++ language and standard libraries for experienced programmers.</li>
<li><a href="http://www.stroustrup.com/Tour.html">Tour++</a>:<br>An overview of the C++ language and standard libraries for experienced programmers.</li>
<li><a href="http://www.stroustrup.com/programming.html">Programming: Principles and Practice using C++</a>:<br>A textbook for beginners and relative novices.</li>
</ul>
<h2 id="RF-web-Websites"><a href="#RF-web-Websites" class="headerlink" title="RF.web: Websites"></a><a name="SS-web"></a>RF.web: Websites</h2><ul>
<li><a href="https://isocpp.org/">isocpp.org</a></li>
<li><a href="http://www.stroustrup.com/">Bjarne Stroustrup’s home pages</a></li>
<li><a href="http://www.open-std.org/jtc1/sc22/wg21/">WG21</a></li>
<li><a href="http://www.boost.org/">Boost</a><a name="Boost"></a></li>
<li><a href="http://www.adobe.com/open-source.html">Adobe open source</a></li>
<li><a href="http://pocoproject.org/">Poco libraries</a></li>
<li>Sutter’s Mill?</li>
<li>???</li>
</ul>
<h2 id="RS-video-Videos-about-“modern-C-”"><a href="#RS-video-Videos-about-“modern-C-”" class="headerlink" title="RS.video: Videos about “modern C++”"></a><a name="SS-vid"></a>RS.video: Videos about “modern C++”</h2><ul>
<li>Bjarne Stroustrup: <a href="http://channel9.msdn.com/Events/GoingNative/GoingNative-2012/Keynote-Bjarne-Stroustrup-Cpp11-Style">C++11 Style</a>. 2012.</li>
<li>Bjarne Stroustrup: <a href="http://channel9.msdn.com/Events/GoingNative/2013/Opening-Keynote-Bjarne-Stroustrup">The Essence of C++: With Examples in C++84, C++98, C++11, and C++14</a>. 2013</li>
<li>All the talks from <a href="https://isocpp.org/blog/2014/11/cppcon-videos-c9">CppCon ‘14</a></li>
<li>Bjarne Stroustrup: <a href="https://www.youtube.com/watch?v=86xWVb4XIyE">The essence of C++</a> at the University of Edinburgh. 2014.</li>
<li>Bjarne Stroustrup: <a href="https://www.youtube.com/watch?v=_wzc7a3McOs">The Evolution of C++ Past, Present and Future</a>. CppCon 2016 keynote.</li>
<li>Bjarne Stroustrup: <a href="https://www.youtube.com/watch?v=nesCaocNjtQ">Make Simple Tasks Simple!</a>. CppCon 2014 keynote.</li>
<li>Bjarne Stroustrup: <a href="https://www.youtube.com/watch?v=1OEu9C51K2A">Writing Good C++14</a>. CppCon 2015 keynote about the Core Guidelines.</li>
<li>Herb Sutter: <a href="https://www.youtube.com/watch?v=hEx5DNLWGgA">Writing Good C++14… By Default</a>. CppCon 2015 keynote about the Core Guidelines.</li>
<li>CppCon 15</li>
<li>??? C++ Next</li>
<li>??? Meting C++</li>
<li>??? more ???</li>
</ul>
<h2 id="RF-man-Manuals"><a href="#RF-man-Manuals" class="headerlink" title="RF.man: Manuals"></a><a name="SS-man"></a>RF.man: Manuals</h2><ul>
<li>ISO C++ Standard C++11.</li>
<li>ISO C++ Standard C++14.</li>
<li><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/n4606.pdf">ISO C++ Standard C++17 CD</a>. Committee Draft.</li>
<li><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2012/n3351.pdf">Palo Alto “Concepts” TR</a>.</li>
<li><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2015/n4553.pdf">ISO C++ Concepts TS</a>.</li>
<li><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/n4569.pdf">WG21 Ranges report</a>. Draft.</li>
</ul>
<h2 id="RF-core-Core-Guidelines-materials"><a href="#RF-core-Core-Guidelines-materials" class="headerlink" title="RF.core: Core Guidelines materials"></a><a name="SS-core"></a>RF.core: Core Guidelines materials</h2><p>This section contains materials that has been useful for presenting the core guidelines and the ideas behind them:</p>
<ul>
<li><a href="https://github.com/isocpp/CppCoreGuidelines/tree/master/docs">Our documents directory</a></li>
<li>Stroustrup, Sutter, and Dos Reis: <a href="http://www.stroustrup.com/resource-model.pdf">A brief introduction to C++’s model for type- and resource-safety</a>. A paper with lots of examples.</li>
<li>Sergey Zubkov: <a href="https://www.youtube.com/watch?v=DyLwdl_6vmU">a Core Guidelines talk</a><br>and here are the <a href="http://2017.cppconf.ru/talks/sergey-zubkov">slides</a>. In Russian. 2017.</li>
<li>Neil MacIntosh: <a href="https://www.youtube.com/watch?v=_GhNnCuaEjo">The Guideline Support Library: One Year Later</a>. CppCon 2016.</li>
<li>Bjarne Stroustrup: <a href="https://www.youtube.com/watch?v=1OEu9C51K2A">Writing Good C++14</a>. CppCon 2015 keynote.</li>
<li>Herb Sutter: <a href="https://www.youtube.com/watch?v=hEx5DNLWGgA">Writing Good C++14… By Default</a>. CppCon 2015 keynote.</li>
<li>Peter Sommerlad: <a href="https://www.youtube.com/watch?v=fQ926v4ZzAM">C++ Core Guidelines - Modernize your C++ Code Base</a>. ACCU 2017.</li>
<li>Bjarne Stroustrup: <a href="https://www.youtube.com/watch?v=01zI9kV4h8c">No Littering!</a>. Bay Area ACCU 2016.<br>It gives some idea of the ambition level for the Core Guidelines.</li>
</ul>
<p>Note that slides for CppCon presentations are available (links with the posted videos).</p>
<p>Contributions to this list would be most welcome.</p>
<h2 id="Acknowledgements"><a href="#Acknowledgements" class="headerlink" title="Acknowledgements"></a><a name="SS-ack"></a>Acknowledgements</h2><p>Thanks to the many people who contributed rules, suggestions, supporting information, references, etc.:</p>
<ul>
<li>Peter Juhl</li>
<li>Neil MacIntosh</li>
<li>Axel Naumann</li>
<li>Andrew Pardoe</li>
<li>Gabriel Dos Reis</li>
<li>Zhuang, Jiangang (Jeff)</li>
<li>Sergey Zubkov</li>
</ul>
<p>and see the contributor list on the github.</p>
<h1 id="Pro-Profiles"><a href="#Pro-Profiles" class="headerlink" title="Pro: Profiles"></a><a name="S-profile"></a>Pro: Profiles</h1><p>Ideally, we would follow all of the guidelines.<br>That would give the cleanest, most regular, least error-prone, and often the fastest code.<br>Unfortunately, that is usually impossible because we have to fit our code into large code bases and use existing libraries.<br>Often, such code has been written over decades and does not follow these guidelines.<br>We must aim for <a href="#S-modernizing">gradual adoption</a>.</p>
<p>Whatever strategy for gradual adoption we adopt, we need to be able to apply sets of related guidelines to address some set<br>of problems first and leave the rest until later.<br>A similar idea of “related guidelines” becomes important when some, but not all, guidelines are considered relevant to a code base<br>or if a set of specialized guidelines is to be applied for a specialized application area.<br>We call such a set of related guidelines a “profile”.<br>We aim for such a set of guidelines to be coherent so that they together help us reach a specific goal, such as “absence of range errors”<br>or “static type safety.”<br>Each profile is designed to eliminate a class of errors.<br>Enforcement of “random” rules in isolation is more likely to be disruptive to a code base than delivering a definite improvement.</p>
<p>A “profile” is a set of deterministic and portably enforceable subset rules (i.e., restrictions) that are designed to achieve a specific guarantee.<br>“Deterministic” means they require only local analysis and could be implemented in a compiler (though they don’t need to be).<br>“Portably enforceable” means they are like language rules, so programmers can count on different enforcement tools giving the same answer for the same code.</p>
<p>Code written to be warning-free using such a language profile is considered to conform to the profile.<br>Conforming code is considered to be safe by construction with regard to the safety properties targeted by that profile.<br>Conforming code will not be the root cause of errors for that property,<br>although such errors may be introduced into a program by other code, libraries or the external environment.<br>A profile may also introduce additional library types to ease conformance and encourage correct code.</p>
<p>Profiles summary:</p>
<ul>
<li><a href="#SS-type">Pro.type: Type safety</a></li>
<li><a href="#SS-bounds">Pro.bounds: Bounds safety</a></li>
<li><a href="#SS-lifetime">Pro.lifetime: Lifetime safety</a></li>
</ul>
<p>In the future, we expect to define many more profiles and add more checks to existing profiles.<br>Candidates include:</p>
<ul>
<li>narrowing arithmetic promotions/conversions (likely part of a separate safe-arithmetic profile)</li>
<li>arithmetic cast from negative floating point to unsigned integral type (ditto)</li>
<li>selected undefined behavior: Start with Gabriel Dos Reis’s UB list developed for the WG21 study group</li>
<li>selected unspecified behavior: Addressing portability concerns.</li>
<li><code>const</code> violations: Mostly done by compilers already, but we can catch inappropriate casting and underuse of <code>const</code>.</li>
</ul>
<p>Enabling a profile is implementation defined; typically, it is set in the analysis tool used.</p>
<p>To suppress enforcement of a profile check, place a <code>suppress</code> annotation on a language contract. For example:</p>
<pre><code>[[suppress(bounds)]] char* raw_find(char* p, int n, char x)    // find x in p[0]..p[n - 1]
&#123;
    // ...
&#125;
</code></pre>
<p>Now <code>raw_find()</code> can scramble memory to its heart’s content.<br>Obviously, suppression should be very rare.</p>
<h2 id="Pro-safety-Type-safety-profile"><a href="#Pro-safety-Type-safety-profile" class="headerlink" title="Pro.safety: Type-safety profile"></a><a name="SS-type"></a>Pro.safety: Type-safety profile</h2><p>This profile makes it easier to construct code that uses types correctly and avoids inadvertent type punning.<br>It does so by focusing on removing the primary sources of type violations, including unsafe uses of casts and unions.</p>
<p>For the purposes of this section,<br>type-safety is defined to be the property that a variable is not used in a way that doesn’t obey the rules for the type of its definition.<br>Memory accessed as a type <code>T</code> should not be valid memory that actually contains an object of an unrelated type <code>U</code>.<br>Note that the safety is intended to be complete when combined also with <a href="#SS-bounds">Bounds safety</a> and <a href="#SS-lifetime">Lifetime safety</a>.</p>
<p>An implementation of this profile shall recognize the following patterns in source code as non-conforming and issue a diagnostic.</p>
<p>Type safety profile summary:</p>
<ul>
<li><a name="Pro-type-avoidcasts"></a>Type.1: <a href="#Res-casts">Avoid casts</a>:<br><a name="Pro-type-reinterpretcast">a. </a>Don’t use <code>reinterpret_cast</code>; A strict version of <a href="#Res-casts">Avoid casts</a> and <a href="#Res-casts-named">prefer named casts</a>.<br><a name="Pro-type-arithmeticcast">b. </a>Don’t use <code>static_cast</code> for arithmetic types; A strict version of <a href="#Res-casts">Avoid casts</a> and <a href="#Res-casts-named">prefer named casts</a>.<br><a name="Pro-type-identitycast">c. </a>Don’t cast between pointer types where the source type and the target type are the same; A strict version of <a href="#Res-casts">Avoid casts</a>.<br><a name="Pro-type-implicitpointercast">d. </a>Don’t cast between pointer types when the conversion could be implicit; A strict version of <a href="#Res-casts">Avoid casts</a>.</li>
<li><a name="Pro-type-downcast"></a>Type.2: Don’t use <code>static_cast</code> to downcast:<br><a href="#Rh-dynamic_cast">Use <code>dynamic_cast</code> instead</a>.</li>
<li><a name="Pro-type-constcast"></a>Type.3: Don’t use <code>const_cast</code> to cast away <code>const</code> (i.e., at all):<br><a href="#Res-casts-const">Don’t cast away const</a>.</li>
<li><a name="Pro-type-cstylecast"></a>Type.4: Don’t use C-style <code>(T)expression</code> or functional <code>T(expression)</code> casts:<br>Prefer <a href="#Res-construct">construction</a> or <a href="#Res-cast-named">named casts</a>.</li>
<li><a name="Pro-type-init"></a>Type.5: Don’t use a variable before it has been initialized:<br><a href="#Res-always">always initialize</a>.</li>
<li><a name="Pro-type-memberinit"></a>Type.6: Always initialize a member variable:<br><a href="#Res-always">always initialize</a>,<br>possibly using <a href="#Rc-default0">default constructors</a> or<br><a href="#Rc-in-class-initializers">default member initializers</a>.</li>
<li><a name="Pro-type-unon"></a>Type.7: Avoid naked union:<br><a href="#Ru-naked">Use <code>variant</code> instead</a>.</li>
<li><a name="Pro-type-varargs"></a>Type.8: Avoid varargs:<br><a href="#F-varargs">Don’t use <code>va_arg</code> arguments</a>.</li>
</ul>
<h5 id="Impact"><a href="#Impact" class="headerlink" title="Impact"></a>Impact</h5><p>With the type-safety profile you can trust that every operation is applied to a valid object.<br>Exception may be thrown to indicate errors that cannot be detected statically (at compile time).<br>Note that this type-safety can be complete only if we also have <a href="#SS-bounds">Bounds safety</a> and <a href="#SS-lifetime">Lifetime safety</a>.<br>Without those guarantees, a region of memory could be accessed independent of which object, objects, or parts of objects are stored in it.</p>
<h2 id="Pro-bounds-Bounds-safety-profile"><a href="#Pro-bounds-Bounds-safety-profile" class="headerlink" title="Pro.bounds: Bounds safety profile"></a><a name="SS-bounds"></a>Pro.bounds: Bounds safety profile</h2><p>This profile makes it easier to construct code that operates within the bounds of allocated blocks of memory.<br>It does so by focusing on removing the primary sources of bounds violations: pointer arithmetic and array indexing.<br>One of the core features of this profile is to restrict pointers to only refer to single objects, not arrays.</p>
<p>We define bounds-safety to be the property that a program does not use an object to access memory outside of the range that was allocated for it.<br>Bounds safety is intended to be complete only when combined with <a href="#SS-type">Type safety</a> and <a href="#SS-lifetime">Lifetime safety</a>,<br>which cover other unsafe operations that allow bounds violations.</p>
<p>Bounds safety profile summary:</p>
<ul>
<li><a href="Pro-bounds-arithmetic"></a>Bounds.1: Don’t use pointer arithmetic. Use <code>span</code> instead:<br><a href="#Ri-array">Pass pointers to single objects (only)</a> and <a href="#Res-simple">Keep pointer arithmetic simple</a>.</li>
<li><a href="Pro-bounds-arrayindex"></a>Bounds.2: Only index into arrays using constant expressions:<br><a href="#Ri-array">Pass pointers to single objects (only)</a> and <a href="#Res-simple">Keep pointer arithmetic simple</a>.</li>
<li><a href="Pro-bounds-decay"></a>Bounds.3: No array-to-pointer decay:<br><a href="#Ri-array">Pass pointers to single objects (only)</a> and <a href="#Res-simple">Keep pointer arithmetic simple</a>.</li>
<li><a href="Pro-bounds-stdlib"></a>Bounds.4: Don’t use standard-library functions and types that are not bounds-checked:<br><a href="#Rsl-bounds">Use the standard library in a type-safe manner</a>.</li>
</ul>
<h5 id="Impact-1"><a href="#Impact-1" class="headerlink" title="Impact"></a>Impact</h5><p>Bounds safety implies that access to an object - notably arrays - does not access beyond the object’s memory allocation.<br>This eliminates a large class of insidious and hard-to-find errors, including the (in)famous “buffer overflow” errors.<br>This closes security loopholes as well as a prominent source of memory corruption (when writing out of bounds).<br>Even an out-of-bounds access is “just a read”, it can lead to invariant violations (when the accessed isn’t of the assumed type)<br>and “mysterious values.”</p>
<h2 id="Pro-lifetime-Lifetime-safety-profile"><a href="#Pro-lifetime-Lifetime-safety-profile" class="headerlink" title="Pro.lifetime: Lifetime safety profile"></a><a name="SS-lifetime"></a>Pro.lifetime: Lifetime safety profile</h2><p>Accessing through a pointer that doesn’t point to anything is a major source of errors,<br>and very hard to avoid in many traditional C or C++ styles of programming.<br>For example, a pointer may be uninitialized, the <code>nullptr</code>, point beyond the range of an array, or to a deleted object.</p>
<p>See /docs folder for the initial design. The detailed formal rules are in progress (as of May 2017).</p>
<p>Lifetime safety profile summary:</p>
<ul>
<li><a href="Pro-lifetime-invalid-deref"></a>Lifetime.1: Don’t dereference a possibly invalid pointer:<br><a href="#Res-deref">detect or avoid</a>.</li>
</ul>
<h5 id="Impact-2"><a href="#Impact-2" class="headerlink" title="Impact"></a>Impact</h5><p>Once completely enforced through a combination of style rules, static analysis, and library support, this profile</p>
<ul>
<li>eliminates one of the major sources of nasty errors in C++</li>
<li>eliminates a major source of potential security violations</li>
<li>improves performance by eliminating redundant “paranoia” checks</li>
<li>increases confidence in correctness of code</li>
<li>avoids undefined behavior by enforcing a key C++ language rule</li>
</ul>
<h1 id="GSL-Guideline-support-library"><a href="#GSL-Guideline-support-library" class="headerlink" title="GSL: Guideline support library"></a><a name="S-gsl"></a>GSL: Guideline support library</h1><p>The GSL is a small library of facilities designed to support this set of guidelines.<br>Without these facilities, the guidelines would have to be far more restrictive on language details.</p>
<p>The Core Guidelines support library is defined in namespace <code>gsl</code> and the names may be aliases for standard library or other well-known library names. Using the (compile-time) indirection through the <code>gsl</code> namespace allows for experimentation and for local variants of the support facilities.</p>
<p>The GSL is header only, and can be found at <a href="https://github.com/Microsoft/GSL">GSL: Guideline support library</a>.<br>The support library facilities are designed to be extremely lightweight (zero-overhead) so that they impose no overhead compared to using conventional alternatives.<br>Where desirable, they can be “instrumented” with additional functionality (e.g., checks) for tasks such as debugging.</p>
<p>These Guidelines assume a <code>variant</code> type, but this is not currently in GSL.<br>Eventually, use <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/p0088r3.html">the one voted into C++17</a>.</p>
<p>Summary of GSL components:</p>
<ul>
<li><a href="#SS-views">GSL.view: Views</a></li>
<li><a href="#SS-ownership">GSL.owner</a></li>
<li><a href="#SS-assertions">GSL.assert: Assertions</a></li>
<li><a href="#SS-utilities">GSL.util: Utilities</a></li>
<li><a href="#SS-gsl-concepts">GSL.concept: Concepts</a></li>
</ul>
<p>We plan for a “ISO C++ standard style” semi-formal specification of the GSL.</p>
<p>We rely on the ISO C++ Standard Library and hope for parts of the GSL to be absorbed into the standard library.</p>
<h2 id="GSL-view-Views"><a href="#GSL-view-Views" class="headerlink" title="GSL.view: Views"></a><a name="SS-views"></a>GSL.view: Views</h2><p>These types allow the user to distinguish between owning and non-owning pointers and between pointers to a single object and pointers to the first element of a sequence.</p>
<p>These “views” are never owners.</p>
<p>References are never owners (see <a href="#Rr-ref">R.4</a>. Note: References have many opportunities to outlive the objects they refer to (returning a local variable by reference, holding a reference to an element of a vector and doing <code>push_back</code>, binding to <code>std::max(x, y + 1)</code>, etc. The Lifetime safety profile aims to address those things, but even so <code>owner&lt;T&amp;&gt;</code> does not make sense and is discouraged.</p>
<p>The names are mostly ISO standard-library style (lower case and underscore):</p>
<ul>
<li><code>T*</code>      // The <code>T*</code> is not an owner, may be null; assumed to be pointing to a single element.</li>
<li><code>T&amp;</code>      // The <code>T&amp;</code> is not an owner and can never be a “null reference”; references are always bound to objects.</li>
</ul>
<p>The “raw-pointer” notation (e.g. <code>int*</code>) is assumed to have its most common meaning; that is, a pointer points to an object, but does not own it.<br>Owners should be converted to resource handles (e.g., <code>unique_ptr</code> or <code>vector&lt;T&gt;</code>) or marked <code>owner&lt;T*&gt;</code>.</p>
<ul>
<li><code>owner&lt;T*&gt;</code>   // a <code>T*</code> that owns the object pointed/referred to; may be <code>nullptr</code>.</li>
</ul>
<p><code>owner</code> is used to mark owning pointers in code that cannot be upgraded to use proper resource handles.<br>Reasons for that include:</p>
<ul>
<li>Cost of conversion.</li>
<li>The pointer is used with an ABI.</li>
<li>The pointer is part of the implementation of a resource handle.</li>
</ul>
<p>An <code>owner&lt;T&gt;</code> differs from a resource handle for a <code>T</code> by still requiring an explicit <code>delete</code>.</p>
<p>An <code>owner&lt;T&gt;</code> is assumed to refer to an object on the free store (heap).</p>
<p>If something is not supposed to be <code>nullptr</code>, say so:</p>
<ul>
<li><p><code>not_null&lt;T&gt;</code>   // <code>T</code> is usually a pointer type (e.g., <code>not_null&lt;int*&gt;</code> and <code>not_null&lt;owner&lt;Foo*&gt;&gt;</code>) that may not be <code>nullptr</code>.<br><code>T</code> can be any type for which <code>==nullptr</code> is meaningful.</p>
</li>
<li><p><code>span&lt;T&gt;</code>       // <code>[p:p+n)</code>, constructor from <code>&#123;p, q&#125;</code> and <code>&#123;p, n&#125;</code>; <code>T</code> is the pointer type</p>
</li>
<li><p><code>span_p&lt;T&gt;</code>     // <code>&#123;p, predicate&#125;</code> <code>[p:q)</code> where <code>q</code> is the first element for which <code>predicate(*p)</code> is true</p>
</li>
<li><p><code>string_span</code>   // <code>span&lt;char&gt;</code></p>
</li>
<li><p><code>cstring_span</code>  // <code>span&lt;const char&gt;</code></p>
</li>
</ul>
<p>A <code>span&lt;T&gt;</code> refers to zero or more mutable <code>T</code>s unless <code>T</code> is a <code>const</code> type.</p>
<p>“Pointer arithmetic” is best done within <code>span</code>s.<br>A <code>char*</code> that points to more than one <code>char</code> but is not a C-style string (e.g., a pointer into an input buffer) should be represented by a <code>span</code>.</p>
<ul>
<li><code>zstring</code>    // a <code>char*</code> supposed to be a C-style string; that is, a zero-terminated sequence of <code>char</code> or <code>nullptr</code></li>
<li><code>czstring</code>   // a <code>const char*</code> supposed to be a C-style string; that is, a zero-terminated sequence of <code>const</code> <code>char</code> or <code>nullptr</code></li>
</ul>
<p>Logically, those last two aliases are not needed, but we are not always logical, and they make the distinction between a pointer to one <code>char</code> and a pointer to a C-style string explicit.<br>A sequence of characters that is not assumed to be zero-terminated should be a <code>char*</code>, rather than a <code>zstring</code>.<br>French accent optional.</p>
<p>Use <code>not_null&lt;zstring&gt;</code> for C-style strings that cannot be <code>nullptr</code>. ??? Do we need a name for <code>not_null&lt;zstring&gt;</code>? or is its ugliness a feature?</p>
<h2 id="GSL-owner-Ownership-pointers"><a href="#GSL-owner-Ownership-pointers" class="headerlink" title="GSL.owner: Ownership pointers"></a><a name="SS-ownership"></a>GSL.owner: Ownership pointers</h2><ul>
<li><code>unique_ptr&lt;T&gt;</code>     // unique ownership: <code>std::unique_ptr&lt;T&gt;</code></li>
<li><code>shared_ptr&lt;T&gt;</code>     // shared ownership: <code>std::shared_ptr&lt;T&gt;</code> (a counted pointer)</li>
<li><code>stack_array&lt;T&gt;</code>    // A stack-allocated array. The number of elements are determined at construction and fixed thereafter. The elements are mutable unless <code>T</code> is a <code>const</code> type.</li>
<li><code>dyn_array&lt;T&gt;</code>      // ??? needed ??? A heap-allocated array. The number of elements are determined at construction and fixed thereafter.<br>The elements are mutable unless <code>T</code> is a <code>const</code> type. Basically a <code>span</code> that allocates and owns its elements.</li>
</ul>
<h2 id="GSL-assert-Assertions"><a href="#GSL-assert-Assertions" class="headerlink" title="GSL.assert: Assertions"></a><a name="SS-assertions"></a>GSL.assert: Assertions</h2><ul>
<li><code>Expects</code>     // precondition assertion. Currently placed in function bodies. Later, should be moved to declarations.<pre><code>   // `Expects(p)` terminates the program unless `p == true`
   // `Expect` in under control of some options (enforcement, error message, alternatives to terminate)
</code></pre>
</li>
<li><code>Ensures</code>     // postcondition assertion. Currently placed in function bodies. Later, should be moved to declarations.</li>
</ul>
<p>These assertions are currently macros (yuck!) and must appear in function definitions (only)<br>pending standard committee decisions on contracts and assertion syntax.<br>See <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/p0380r1.pdf">the contract proposal</a>; using the attribute syntax,<br>for example, <code>Expects(p)</code> will become <code>[[expects: p]]</code>.</p>
<h2 id="GSL-util-Utilities"><a href="#GSL-util-Utilities" class="headerlink" title="GSL.util: Utilities"></a><a name="SS-utilities"></a>GSL.util: Utilities</h2><ul>
<li><code>finally</code>        // <code>finally(f)</code> makes a <code>final_action&#123;f&#125;</code> with a destructor that invokes <code>f</code></li>
<li><code>narrow_cast</code>    // <code>narrow_cast&lt;T&gt;(x)</code> is <code>static_cast&lt;T&gt;(x)</code></li>
<li><code>narrow</code>         // <code>narrow&lt;T&gt;(x)</code> is <code>static_cast&lt;T&gt;(x)</code> if <code>static_cast&lt;T&gt;(x) == x</code> or it throws <code>narrowing_error</code></li>
<li><code>[[implicit]]</code>   // “Marker” to put on single-argument constructors to explicitly make them non-explicit.</li>
<li><code>move_owner</code>     // <code>p = move_owner(q)</code> means <code>p = q</code> but ???</li>
<li><code>joining_thread</code> // a RAII style version of <code>std::thread</code> that joins.</li>
<li><code>index</code>          // a type to use for all container and array indexing (currently an alias for <code>ptrdiff_t</code>)</li>
</ul>
<h2 id="GSL-concept-Concepts"><a href="#GSL-concept-Concepts" class="headerlink" title="GSL.concept: Concepts"></a><a name="SS-gsl-concepts"></a>GSL.concept: Concepts</h2><p>These concepts (type predicates) are borrowed from<br>Andrew Sutton’s Origin library,<br>the Range proposal,<br>and the ISO WG21 Palo Alto TR.<br>They are likely to be very similar to what will become part of the ISO C++ standard.<br>The notation is that of the ISO WG21 <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2015/n4553.pdf">Concepts TS</a>.<br>Most of the concepts below are defined in <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/n4569.pdf">the Ranges TS</a>.</p>
<ul>
<li><code>Range</code></li>
<li><code>String</code>   // ???</li>
<li><code>Number</code>   // ???</li>
<li><code>Sortable</code></li>
<li><code>Pointer</code>  // A type with <code>*</code>, <code>-&gt;</code>, <code>==</code>, and default construction (default construction is assumed to set the singular “null” value); see <a href="#SS-gsl-smartptrconcepts">smart pointers</a></li>
<li><code>Unique_ptr</code>  // A type that matches <code>Pointer</code>, has move (not copy), and matches the Lifetime profile criteria for a <code>unique</code> owner type; see <a href="#SS-gsl-smartptrconcepts">smart pointers</a></li>
<li><code>Shared_ptr</code>   // A type that matches <code>Pointer</code>, has copy, and matches the Lifetime profile criteria for a <code>shared</code> owner type; see <a href="#SS-gsl-smartptrconcepts">smart pointers</a></li>
<li><code>EqualityComparable</code>   // ???Must we suffer CaMelcAse???</li>
<li><code>Convertible</code></li>
<li><code>Common</code></li>
<li><code>Boolean</code></li>
<li><code>Integral</code></li>
<li><code>SignedIntegral</code></li>
<li><code>SemiRegular</code> // ??? Copyable?</li>
<li><code>Regular</code></li>
<li><code>TotallyOrdered</code></li>
<li><code>Function</code></li>
<li><code>RegularFunction</code></li>
<li><code>Predicate</code></li>
<li><code>Relation</code></li>
<li>…</li>
</ul>
<h3 id="GSL-ptr-Smart-pointer-concepts"><a href="#GSL-ptr-Smart-pointer-concepts" class="headerlink" title="GSL.ptr: Smart pointer concepts"></a><a name="SS-gsl-smartptrconcepts"></a>GSL.ptr: Smart pointer concepts</h3><p>See <a href="https://github.com/isocpp/CppCoreGuidelines/blob/master/docs/Lifetimes%20I%20and%20II%20-%20v0.9.1.pdf">Lifetimes paper</a>.</p>
<h1 id="NL-Naming-and-layout-rules"><a href="#NL-Naming-and-layout-rules" class="headerlink" title="NL: Naming and layout rules"></a><a name="S-naming"></a>NL: Naming and layout rules</h1><p>Consistent naming and layout are helpful.<br>If for no other reason because it minimizes “my style is better than your style” arguments.<br>However, there are many, many, different styles around and people are passionate about them (pro and con).<br>Also, most real-world projects includes code from many sources, so standardizing on a single style for all code is often impossible.<br>We present a set of rules that you might use if you have no better ideas, but the real aim is consistency, rather than any particular rule set.<br>IDEs and tools can help (as well as hinder).</p>
<p>Naming and layout rules:</p>
<ul>
<li><a href="#Rl-comments">NL.1: Don’t say in comments what can be clearly stated in code</a></li>
<li><a href="#Rl-comments-intent">NL.2: State intent in comments</a></li>
<li><a href="#Rl-comments-crisp">NL.3: Keep comments crisp</a></li>
<li><a href="#Rl-indent">NL.4: Maintain a consistent indentation style</a></li>
<li><a href="#Rl-name-type">NL.5: Avoid encoding type information in names</a></li>
<li><a href="#Rl-name-length">NL.7: Make the length of a name roughly proportional to the length of its scope</a></li>
<li><a href="#Rl-name">NL.8: Use a consistent naming style</a></li>
<li><a href="#Rl-all-caps">NL.9: Use <code>ALL_CAPS</code> for macro names only</a></li>
<li><a href="#Rl-camel">NL.10: Prefer <code>underscore_style</code> names</a></li>
<li><a href="#Rl-literals">NL.11: Make literals readable</a></li>
<li><a href="#Rl-space">NL.15: Use spaces sparingly</a></li>
<li><a href="#Rl-order">NL.16: Use a conventional class member declaration order</a></li>
<li><a href="#Rl-knr">NL.17: Use K&amp;R-derived layout</a></li>
<li><a href="#Rl-ptr">NL.18: Use C++-style declarator layout</a></li>
<li><a href="#Rl-misread">NL.19: Avoid names that are easily misread</a></li>
<li><a href="#Rl-stmt">NL.20: Don’t place two statements on the same line</a></li>
<li><a href="#Rl-dcl">NL.21: Declare one name (only) per declaration</a></li>
<li><a href="#Rl-void">NL.25: Don’t use <code>void</code> as an argument type</a></li>
<li><a href="#Rl-const">NL.26: Use conventional <code>const</code> notation</a></li>
</ul>
<p>Most of these rules are aesthetic and programmers hold strong opinions.<br>IDEs also tend to have defaults and a range of alternatives.<br>These rules are suggested defaults to follow unless you have reasons not to.</p>
<p>We have had comments to the effect that naming and layout are so personal and/or arbitrary that we should not try to “legislate” them.<br>We are not “legislating” (see the previous paragraph).<br>However, we have had many requests for a set of naming and layout conventions to use when there are no external constraints.</p>
<p>More specific and detailed rules are easier to enforce.</p>
<p>These rules bear a strong resemblance to the recommendations in the <a href="http://www.stroustrup.com/Programming/PPP-style.pdf">PPP Style Guide</a><br>written in support of Stroustrup’s <a href="http://www.stroustrup.com/programming.html">Programming: Principles and Practice using C++</a>.</p>
<h3 id="NL-1-Don’t-say-in-comments-what-can-be-clearly-stated-in-code"><a href="#NL-1-Don’t-say-in-comments-what-can-be-clearly-stated-in-code" class="headerlink" title="NL.1: Don’t say in comments what can be clearly stated in code"></a><a name="Rl-comments"></a>NL.1: Don’t say in comments what can be clearly stated in code</h3><h5 id="Reason-418"><a href="#Reason-418" class="headerlink" title="Reason"></a>Reason</h5><p>Compilers do not read comments.<br>Comments are less precise than code.<br>Comments are not updated as consistently as code.</p>
<h5 id="Example-bad-139"><a href="#Example-bad-139" class="headerlink" title="Example, bad"></a>Example, bad</h5><pre><code>auto x = m * v1 + vv;   // multiply m with v1 and add the result to vv
</code></pre>
<h5 id="Enforcement-382"><a href="#Enforcement-382" class="headerlink" title="Enforcement"></a>Enforcement</h5><p>Build an AI program that interprets colloquial English text and see if what is said could be better expressed in C++.</p>
<h3 id="NL-2-State-intent-in-comments"><a href="#NL-2-State-intent-in-comments" class="headerlink" title="NL.2: State intent in comments"></a><a name="Rl-comments-intent"></a>NL.2: State intent in comments</h3><h5 id="Reason-419"><a href="#Reason-419" class="headerlink" title="Reason"></a>Reason</h5><p>Code says what is done, not what is supposed to be done. Often intent can be stated more clearly and concisely than the implementation.</p>
<h5 id="Example-368"><a href="#Example-368" class="headerlink" title="Example"></a>Example</h5><pre><code>void stable_sort(Sortable&amp; c)
    // sort c in the order determined by &lt;, keep equal elements (as defined by ==) in
    // their original relative order
&#123;
    // ... quite a few lines of non-trivial code ...
&#125;
</code></pre>
<h5 id="Note-354"><a href="#Note-354" class="headerlink" title="Note"></a>Note</h5><p>If the comment and the code disagree, both are likely to be wrong.</p>
<h3 id="NL-3-Keep-comments-crisp"><a href="#NL-3-Keep-comments-crisp" class="headerlink" title="NL.3: Keep comments crisp"></a><a name="Rl-comments-crisp"></a>NL.3: Keep comments crisp</h3><h5 id="Reason-420"><a href="#Reason-420" class="headerlink" title="Reason"></a>Reason</h5><p>Verbosity slows down understanding and makes the code harder to read by spreading it around in the source file.</p>
<h5 id="Note-355"><a href="#Note-355" class="headerlink" title="Note"></a>Note</h5><p>Use intelligible English.<br>I may be fluent in Danish, but most programmers are not; the maintainers of my code may not be.<br>Avoid SMS lingo and watch your grammar, punctuation, and capitalization.<br>Aim for professionalism, not “cool.”</p>
<h5 id="Enforcement-383"><a href="#Enforcement-383" class="headerlink" title="Enforcement"></a>Enforcement</h5><p>not possible.</p>
<h3 id="NL-4-Maintain-a-consistent-indentation-style"><a href="#NL-4-Maintain-a-consistent-indentation-style" class="headerlink" title="NL.4: Maintain a consistent indentation style"></a><a name="Rl-indent"></a>NL.4: Maintain a consistent indentation style</h3><h5 id="Reason-421"><a href="#Reason-421" class="headerlink" title="Reason"></a>Reason</h5><p>Readability. Avoidance of “silly mistakes.”</p>
<h5 id="Example-bad-140"><a href="#Example-bad-140" class="headerlink" title="Example, bad"></a>Example, bad</h5><pre><code>int i;
for (i = 0; i &lt; max; ++i); // bug waiting to happen
if (i == j)
    return i;
</code></pre>
<h5 id="Note-356"><a href="#Note-356" class="headerlink" title="Note"></a>Note</h5><p>Always indenting the statement after <code>if (...)</code>, <code>for (...)</code>, and <code>while (...)</code> is usually a good idea:</p>
<pre><code>if (i &lt; 0) error(&quot;negative argument&quot;);

if (i &lt; 0)
    error(&quot;negative argument&quot;);
</code></pre>
<h5 id="Enforcement-384"><a href="#Enforcement-384" class="headerlink" title="Enforcement"></a>Enforcement</h5><p>Use a tool.</p>
<h3 id="NL-5-Avoid-encoding-type-information-in-names"><a href="#NL-5-Avoid-encoding-type-information-in-names" class="headerlink" title="NL.5: Avoid encoding type information in names"></a><a name="Rl-name-type"></a>NL.5: Avoid encoding type information in names</h3><h5 id="Rationale"><a href="#Rationale" class="headerlink" title="Rationale"></a>Rationale</h5><p>If names reflect types rather than functionality, it becomes hard to change the types used to provide that functionality.<br>Also, if the type of a variable is changed, code using it will have to be modified.<br>Minimize unintentional conversions.</p>
<h5 id="Example-bad-141"><a href="#Example-bad-141" class="headerlink" title="Example, bad"></a>Example, bad</h5><pre><code>void print_int(int i);
void print_string(const char*);

print_int(1);          // repetitive, manual type matching
print_string(&quot;xyzzy&quot;); // repetitive, manual type matching
</code></pre>
<h5 id="Example-good-24"><a href="#Example-good-24" class="headerlink" title="Example, good"></a>Example, good</h5><pre><code>void print(int i);
void print(string_view);    // also works on any string-like sequence

print(1);              // clear, automatic type matching
print(&quot;xyzzy&quot;);        // clear, automatic type matching
</code></pre>
<h5 id="Note-357"><a href="#Note-357" class="headerlink" title="Note"></a>Note</h5><p>Names with types encoded are either verbose or cryptic.</p>
<pre><code>printS  // print a std::string
prints  // print a C-style string
printi  // print an int
</code></pre>
<p>Requiring techniques like Hungarian notation to encode a type in a name is needed in C, but is generally unnecessary and actively harmful in a strongly statically-typed language like C++, because the annotations get out of date (the warts are just like comments and rot just like them) and they interfere with good use of the language (use the same name and overload resolution instead).</p>
<h5 id="Note-358"><a href="#Note-358" class="headerlink" title="Note"></a>Note</h5><p>Some styles use very general (not type-specific) prefixes to denote the general use of a variable.</p>
<pre><code>auto p = new User();
auto p = make_unique&lt;User&gt;();
// note: &quot;p&quot; is not being used to say &quot;raw pointer to type User,&quot;
//       just generally to say &quot;this is an indirection&quot;

auto cntHits = calc_total_of_hits(/*...*/);
// note: &quot;cnt&quot; is not being used to encode a type,
//       just generally to say &quot;this is a count of something&quot;
</code></pre>
<p>This is not harmful and does not fall under this guideline because it does not encode type information.</p>
<h5 id="Note-359"><a href="#Note-359" class="headerlink" title="Note"></a>Note</h5><p>Some styles distinguishes members from local variable, and/or from global variable.</p>
<pre><code>struct S &#123;
    int m_;
    S(int m) :m_&#123;abs(m)&#125; &#123; &#125;
&#125;;
</code></pre>
<p>This is not harmful and does not fall under this guideline because it does not encode type information.</p>
<h5 id="Note-360"><a href="#Note-360" class="headerlink" title="Note"></a>Note</h5><p>Like C++, some styles distinguishes types from non-types.<br>For example, by capitalizing type names, but not the names of functions and variables.</p>
<pre><code>typename&lt;typename T&gt;
class HashTable &#123;   // maps string to T
    // ...
&#125;;

HashTable&lt;int&gt; index;
</code></pre>
<p>This is not harmful and does not fall under this guideline because it does not encode type information.</p>
<h3 id="NL-7-Make-the-length-of-a-name-roughly-proportional-to-the-length-of-its-scope"><a href="#NL-7-Make-the-length-of-a-name-roughly-proportional-to-the-length-of-its-scope" class="headerlink" title="NL.7: Make the length of a name roughly proportional to the length of its scope"></a><a name="Rl-name-length"></a>NL.7: Make the length of a name roughly proportional to the length of its scope</h3><p><strong>Rationale</strong>: The larger the scope the greater the chance of confusion and of an unintended name clash.</p>
<h5 id="Example-369"><a href="#Example-369" class="headerlink" title="Example"></a>Example</h5><pre><code>double sqrt(double x);   // return the square root of x; x must be non-negative

int length(const char* p);  // return the number of characters in a zero-terminated C-style string

int length_of_string(const char zero_terminated_array_of_char[])    // bad: verbose

int g;      // bad: global variable with a cryptic name

int open;   // bad: global variable with a short, popular name
</code></pre>
<p>The use of <code>p</code> for pointer and <code>x</code> for a floating-point variable is conventional and non-confusing in a restricted scope.</p>
<h5 id="Enforcement-385"><a href="#Enforcement-385" class="headerlink" title="Enforcement"></a>Enforcement</h5><p>???</p>
<h3 id="NL-8-Use-a-consistent-naming-style"><a href="#NL-8-Use-a-consistent-naming-style" class="headerlink" title="NL.8: Use a consistent naming style"></a><a name="Rl-name"></a>NL.8: Use a consistent naming style</h3><p><strong>Rationale</strong>: Consistence in naming and naming style increases readability.</p>
<h5 id="Note-361"><a href="#Note-361" class="headerlink" title="Note"></a>Note</h5><p>There are many styles and when you use multiple libraries, you can’t follow all their different conventions.<br>Choose a “house style”, but leave “imported” libraries with their original style.</p>
<h5 id="Example-370"><a href="#Example-370" class="headerlink" title="Example"></a>Example</h5><p>ISO Standard, use lower case only and digits, separate words with underscores:</p>
<ul>
<li><code>int</code></li>
<li><code>vector</code></li>
<li><code>my_map</code></li>
</ul>
<p>Avoid double underscores <code>__</code>.</p>
<h5 id="Example-371"><a href="#Example-371" class="headerlink" title="Example"></a>Example</h5><p><a href="http://www.stroustrup.com/Programming/PPP-style.pdf">Stroustrup</a>:<br>ISO Standard, but with upper case used for your own types and concepts:</p>
<ul>
<li><code>int</code></li>
<li><code>vector</code></li>
<li><code>My_map</code></li>
</ul>
<h5 id="Example-372"><a href="#Example-372" class="headerlink" title="Example"></a>Example</h5><p>CamelCase: capitalize each word in a multi-word identifier:</p>
<ul>
<li><code>int</code></li>
<li><code>vector</code></li>
<li><code>MyMap</code></li>
<li><code>myMap</code></li>
</ul>
<p>Some conventions capitalize the first letter, some don’t.</p>
<h5 id="Note-362"><a href="#Note-362" class="headerlink" title="Note"></a>Note</h5><p>Try to be consistent in your use of acronyms and lengths of identifiers:</p>
<pre><code>int mtbf &#123;12&#125;;
int mean_time_between_failures &#123;12&#125;; // make up your mind
</code></pre>
<h5 id="Enforcement-386"><a href="#Enforcement-386" class="headerlink" title="Enforcement"></a>Enforcement</h5><p>Would be possible except for the use of libraries with varying conventions.</p>
<h3 id="NL-9-Use-ALL-CAPS-for-macro-names-only"><a href="#NL-9-Use-ALL-CAPS-for-macro-names-only" class="headerlink" title="NL.9: Use ALL_CAPS for macro names only"></a><a name="Rl-all-caps"></a>NL.9: Use <code>ALL_CAPS</code> for macro names only</h3><h5 id="Reason-422"><a href="#Reason-422" class="headerlink" title="Reason"></a>Reason</h5><p>To avoid confusing macros with names that obey scope and type rules.</p>
<h5 id="Example-373"><a href="#Example-373" class="headerlink" title="Example"></a>Example</h5><pre><code>void f()
&#123;
    const int SIZE&#123;1000&#125;;  // Bad, use &#39;size&#39; instead
    int v[SIZE];
&#125;
</code></pre>
<h5 id="Note-363"><a href="#Note-363" class="headerlink" title="Note"></a>Note</h5><p>This rule applies to non-macro symbolic constants:</p>
<pre><code>enum bad &#123; BAD, WORSE, HORRIBLE &#125;; // BAD
</code></pre>
<h5 id="Enforcement-387"><a href="#Enforcement-387" class="headerlink" title="Enforcement"></a>Enforcement</h5><ul>
<li>Flag macros with lower-case letters</li>
<li>Flag <code>ALL_CAPS</code> non-macro names</li>
</ul>
<h3 id="NL-10-Prefer-underscore-style-names"><a href="#NL-10-Prefer-underscore-style-names" class="headerlink" title="NL.10: Prefer underscore_style names"></a><a name="Rl-camel"></a>NL.10: Prefer <code>underscore_style</code> names</h3><h5 id="Reason-423"><a href="#Reason-423" class="headerlink" title="Reason"></a>Reason</h5><p>The use of underscores to separate parts of a name is the original C and C++ style and used in the C++ Standard Library.</p>
<h5 id="Note-364"><a href="#Note-364" class="headerlink" title="Note"></a>Note</h5><p>This rule is a default to use only if you have a choice.<br>Often, you don’t have a choice and must follow an established style for <a href="#Rl-name">consistency</a>.<br>The need for consistency beats personal taste.</p>
<h5 id="Example-374"><a href="#Example-374" class="headerlink" title="Example"></a>Example</h5><p><a href="http://www.stroustrup.com/Programming/PPP-style.pdf">Stroustrup</a>:<br>ISO Standard, but with upper case used for your own types and concepts:</p>
<ul>
<li><code>int</code></li>
<li><code>vector</code></li>
<li><code>My_map</code></li>
</ul>
<h5 id="Enforcement-388"><a href="#Enforcement-388" class="headerlink" title="Enforcement"></a>Enforcement</h5><p>Impossible.</p>
<h3 id="NL-15-Use-spaces-sparingly"><a href="#NL-15-Use-spaces-sparingly" class="headerlink" title="NL.15: Use spaces sparingly"></a><a name="Rl-space"></a>NL.15: Use spaces sparingly</h3><h5 id="Reason-424"><a href="#Reason-424" class="headerlink" title="Reason"></a>Reason</h5><p>Too much space makes the text larger and distracts.</p>
<h5 id="Example-bad-142"><a href="#Example-bad-142" class="headerlink" title="Example, bad"></a>Example, bad</h5><pre><code>#include &lt; map &gt;

int main(int argc, char * argv [ ])
&#123;
    // ...
&#125;
</code></pre>
<h5 id="Example-375"><a href="#Example-375" class="headerlink" title="Example"></a>Example</h5><pre><code>#include &lt;map&gt;

int main(int argc, char* argv[])
&#123;
    // ...
&#125;
</code></pre>
<h5 id="Note-365"><a href="#Note-365" class="headerlink" title="Note"></a>Note</h5><p>Some IDEs have their own opinions and add distracting space.</p>
<h5 id="Note-366"><a href="#Note-366" class="headerlink" title="Note"></a>Note</h5><p>We value well-placed whitespace as a significant help for readability. Just don’t overdo it.</p>
<h3 id="NL-11-Make-literals-readable"><a href="#NL-11-Make-literals-readable" class="headerlink" title="NL.11: Make literals readable"></a><a name="Rl-literals"></a>NL.11: Make literals readable</h3><h5 id="Reason-425"><a href="#Reason-425" class="headerlink" title="Reason"></a>Reason</h5><p>Readability.</p>
<h5 id="Example-376"><a href="#Example-376" class="headerlink" title="Example"></a>Example</h5><p>Use digit separators to avoid long strings of digits</p>
<pre><code>auto c = 299&#39;792&#39;458; // m/s2
auto q2 = 0b0000&#39;1111&#39;0000&#39;0000;
auto ss_number = 123&#39;456&#39;7890;
</code></pre>
<h5 id="Example-377"><a href="#Example-377" class="headerlink" title="Example"></a>Example</h5><p>Use literal suffixes where clarification is needed</p>
<pre><code>auto hello = &quot;Hello!&quot;s; // a std::string
auto world = &quot;world&quot;;   // a C-style string
auto interval = 100ms;  // using &lt;chrono&gt;
</code></pre>
<h5 id="Note-367"><a href="#Note-367" class="headerlink" title="Note"></a>Note</h5><p>Literals should not be sprinkled all over the code as <a href="#Res-magic">“magic constants”</a>,<br>but it is still a good idea to make them readable where they are defined.<br>It is easy to make a typo in a long string of integers.</p>
<h5 id="Enforcement-389"><a href="#Enforcement-389" class="headerlink" title="Enforcement"></a>Enforcement</h5><p>Flag long digit sequences. The trouble is to define “long”; maybe 7.</p>
<h3 id="NL-16-Use-a-conventional-class-member-declaration-order"><a href="#NL-16-Use-a-conventional-class-member-declaration-order" class="headerlink" title="NL.16: Use a conventional class member declaration order"></a><a name="Rl-order"></a>NL.16: Use a conventional class member declaration order</h3><h5 id="Reason-426"><a href="#Reason-426" class="headerlink" title="Reason"></a>Reason</h5><p>A conventional order of members improves readability.</p>
<p>When declaring a class use the following order</p>
<ul>
<li>types: classes, enums, and aliases (<code>using</code>)</li>
<li>constructors, assignments, destructor</li>
<li>functions</li>
<li>data</li>
</ul>
<p>Use the <code>public</code> before <code>protected</code> before <code>private</code> order.</p>
<h5 id="Example-378"><a href="#Example-378" class="headerlink" title="Example"></a>Example</h5><pre><code>class X &#123;
public:
    // interface
protected:
    // unchecked function for use by derived class implementations
private:
    // implementation details
&#125;;
</code></pre>
<h5 id="Example-379"><a href="#Example-379" class="headerlink" title="Example"></a>Example</h5><p>Sometimes, the default order of members conflicts with a desire to separate the public interface from implementation details.<br>In such cases, private types and functions can be placed with private data.</p>
<pre><code>class X &#123;
public:
    // interface
protected:
    // unchecked function for use by derived class implementations
private:
    // implementation details (types, functions, and data)
&#125;;
</code></pre>
<h5 id="Example-bad-143"><a href="#Example-bad-143" class="headerlink" title="Example, bad"></a>Example, bad</h5><p>Avoid multiple blocks of declarations of one access (e.g., <code>public</code>) dispersed among blocks of declarations with different access (e.g. <code>private</code>).</p>
<pre><code>class X &#123;   // bad
public:
    void f();
public:
    int g();
    // ...
&#125;;
</code></pre>
<p>The use of macros to declare groups of members often leads to violation of any ordering rules.<br>However, macros obscures what is being expressed anyway.</p>
<h5 id="Enforcement-390"><a href="#Enforcement-390" class="headerlink" title="Enforcement"></a>Enforcement</h5><p>Flag departures from the suggested order. There will be a lot of old code that doesn’t follow this rule.</p>
<h3 id="NL-17-Use-K-amp-R-derived-layout"><a href="#NL-17-Use-K-amp-R-derived-layout" class="headerlink" title="NL.17: Use K&amp;R-derived layout"></a><a name="Rl-knr"></a>NL.17: Use K&amp;R-derived layout</h3><h5 id="Reason-427"><a href="#Reason-427" class="headerlink" title="Reason"></a>Reason</h5><p>This is the original C and C++ layout. It preserves vertical space well. It distinguishes different language constructs (such as functions and classes) well.</p>
<h5 id="Note-368"><a href="#Note-368" class="headerlink" title="Note"></a>Note</h5><p>In the context of C++, this style is often called “Stroustrup”.</p>
<h5 id="Example-380"><a href="#Example-380" class="headerlink" title="Example"></a>Example</h5><pre><code>struct Cable &#123;
    int x;
    // ...
&#125;;

double foo(int x)
&#123;
    if (0 &lt; x) &#123;
        // ...
    &#125;

    switch (x) &#123;
    case 0:
        // ...
        break;
    case amazing:
        // ...
        break;
    default:
        // ...
        break;
    &#125;

    if (0 &lt; x)
        ++x;

    if (x &lt; 0)
        something();
    else
        something_else();

    return some_value;
&#125;
</code></pre>
<p>Note the space between <code>if</code> and <code>(</code></p>
<h5 id="Note-369"><a href="#Note-369" class="headerlink" title="Note"></a>Note</h5><p>Use separate lines for each statement, the branches of an <code>if</code>, and the body of a <code>for</code>.</p>
<h5 id="Note-370"><a href="#Note-370" class="headerlink" title="Note"></a>Note</h5><p>The <code>&#123;</code> for a <code>class</code> and a <code>struct</code> is <em>not</em> on a separate line, but the <code>&#123;</code> for a function is.</p>
<h5 id="Note-371"><a href="#Note-371" class="headerlink" title="Note"></a>Note</h5><p>Capitalize the names of your user-defined types to distinguish them from standards-library types.</p>
<h5 id="Note-372"><a href="#Note-372" class="headerlink" title="Note"></a>Note</h5><p>Do not capitalize function names.</p>
<h5 id="Enforcement-391"><a href="#Enforcement-391" class="headerlink" title="Enforcement"></a>Enforcement</h5><p>If you want enforcement, use an IDE to reformat.</p>
<h3 id="NL-18-Use-C-style-declarator-layout"><a href="#NL-18-Use-C-style-declarator-layout" class="headerlink" title="NL.18: Use C++-style declarator layout"></a><a name="Rl-ptr"></a>NL.18: Use C++-style declarator layout</h3><h5 id="Reason-428"><a href="#Reason-428" class="headerlink" title="Reason"></a>Reason</h5><p>The C-style layout emphasizes use in expressions and grammar, whereas the C++-style emphasizes types.<br>The use in expressions argument doesn’t hold for references.</p>
<h5 id="Example-381"><a href="#Example-381" class="headerlink" title="Example"></a>Example</h5><pre><code>T&amp; operator[](size_t);   // OK
T &amp;operator[](size_t);   // just strange
T &amp; operator[](size_t);   // undecided
</code></pre>
<h5 id="Enforcement-392"><a href="#Enforcement-392" class="headerlink" title="Enforcement"></a>Enforcement</h5><p>Impossible in the face of history.</p>
<h3 id="NL-19-Avoid-names-that-are-easily-misread"><a href="#NL-19-Avoid-names-that-are-easily-misread" class="headerlink" title="NL.19: Avoid names that are easily misread"></a><a name="Rl-misread"></a>NL.19: Avoid names that are easily misread</h3><h5 id="Reason-429"><a href="#Reason-429" class="headerlink" title="Reason"></a>Reason</h5><p>Readability.<br>Not everyone has screens and printers that make it easy to distinguish all characters.<br>We easily confuse similarly spelled and slightly misspelled words.</p>
<h5 id="Example-382"><a href="#Example-382" class="headerlink" title="Example"></a>Example</h5><pre><code>int oO01lL = 6; // bad

int splunk = 7;
int splonk = 8; // bad: splunk and splonk are easily confused
</code></pre>
<h5 id="Enforcement-393"><a href="#Enforcement-393" class="headerlink" title="Enforcement"></a>Enforcement</h5><p>???</p>
<h3 id="NL-20-Don’t-place-two-statements-on-the-same-line"><a href="#NL-20-Don’t-place-two-statements-on-the-same-line" class="headerlink" title="NL.20: Don’t place two statements on the same line"></a><a name="Rl-stmt"></a>NL.20: Don’t place two statements on the same line</h3><h5 id="Reason-430"><a href="#Reason-430" class="headerlink" title="Reason"></a>Reason</h5><p>Readability.<br>It is really easy to overlook a statement when there is more on a line.</p>
<h5 id="Example-383"><a href="#Example-383" class="headerlink" title="Example"></a>Example</h5><pre><code>int x = 7; char* p = 29;    // don&#39;t
int x = 7; f(x);  ++x;      // don&#39;t
</code></pre>
<h5 id="Enforcement-394"><a href="#Enforcement-394" class="headerlink" title="Enforcement"></a>Enforcement</h5><p>Easy.</p>
<h3 id="NL-21-Declare-one-name-only-per-declaration"><a href="#NL-21-Declare-one-name-only-per-declaration" class="headerlink" title="NL.21: Declare one name (only) per declaration"></a><a name="Rl-dcl"></a>NL.21: Declare one name (only) per declaration</h3><h5 id="Reason-431"><a href="#Reason-431" class="headerlink" title="Reason"></a>Reason</h5><p>Readability.<br>Minimizing confusion with the declarator syntax.</p>
<h5 id="Note-373"><a href="#Note-373" class="headerlink" title="Note"></a>Note</h5><p>For details, see <a href="#Res-name-one">ES.10</a>.</p>
<h3 id="NL-25-Don’t-use-void-as-an-argument-type"><a href="#NL-25-Don’t-use-void-as-an-argument-type" class="headerlink" title="NL.25: Don’t use void as an argument type"></a><a name="Rl-void"></a>NL.25: Don’t use <code>void</code> as an argument type</h3><h5 id="Reason-432"><a href="#Reason-432" class="headerlink" title="Reason"></a>Reason</h5><p>It’s verbose and only needed where C compatibility matters.</p>
<h5 id="Example-384"><a href="#Example-384" class="headerlink" title="Example"></a>Example</h5><pre><code>void f(void);   // bad

void g();       // better
</code></pre>
<h5 id="Note-374"><a href="#Note-374" class="headerlink" title="Note"></a>Note</h5><p>Even Dennis Ritchie deemed <code>void f(void)</code> an abomination.<br>You can make an argument for that abomination in C when function prototypes were rare so that banning:</p>
<pre><code>int f();
f(1, 2, &quot;weird but valid C89&quot;);   // hope that f() is defined int f(a, b, c) char* c; &#123; /* ... */ &#125;
</code></pre>
<p>would have caused major problems, but not in the 21st century and in C++.</p>
<h3 id="NL-26-Use-conventional-const-notation"><a href="#NL-26-Use-conventional-const-notation" class="headerlink" title="NL.26: Use conventional const notation"></a><a name="Rl-const"></a>NL.26: Use conventional <code>const</code> notation</h3><h5 id="Reason-433"><a href="#Reason-433" class="headerlink" title="Reason"></a>Reason</h5><p>Conventional notation is more familiar to more programmers.<br>Consistency in large code bases.</p>
<h5 id="Example-385"><a href="#Example-385" class="headerlink" title="Example"></a>Example</h5><pre><code>const int x = 7;    // OK
int const y = 9;    // bad

const int *const p = nullptr;   // OK, constant pointer to constant int
int const *const p = nullptr;   // bad, constant pointer to constant int
</code></pre>
<h5 id="Note-375"><a href="#Note-375" class="headerlink" title="Note"></a>Note</h5><p>We are well aware that you could claim the “bad” examples more logical than the ones marked “OK”,<br>but they also confuse more people, especially novices relying on teaching material using the far more common, conventional OK style.</p>
<p>As ever, remember that the aim of these naming and layout rules is consistency and that aesthetics vary immensely.</p>
<h5 id="Enforcement-395"><a href="#Enforcement-395" class="headerlink" title="Enforcement"></a>Enforcement</h5><p>Flag <code>const</code> used as a suffix for a type.</p>
<h1 id="FAQ-Answers-to-frequently-asked-questions"><a href="#FAQ-Answers-to-frequently-asked-questions" class="headerlink" title="FAQ: Answers to frequently asked questions"></a><a name="S-faq"></a>FAQ: Answers to frequently asked questions</h1><p>This section covers answers to frequently asked questions about these guidelines.</p>
<h3 id="FAQ-1-What-do-these-guidelines-aim-to-achieve"><a href="#FAQ-1-What-do-these-guidelines-aim-to-achieve" class="headerlink" title="FAQ.1: What do these guidelines aim to achieve?"></a><a name="Faq-aims"></a>FAQ.1: What do these guidelines aim to achieve?</h3><p>See the <a href="#S-abstract">top of this page</a>. This is an open-source project to maintain modern authoritative guidelines for writing C++ code using the current C++ Standard (as of this writing, C++14). The guidelines are designed to be modern, machine-enforceable wherever possible, and open to contributions and forking so that organizations can easily incorporate them into their own corporate coding guidelines.</p>
<h3 id="FAQ-2-When-and-where-was-this-work-first-announced"><a href="#FAQ-2-When-and-where-was-this-work-first-announced" class="headerlink" title="FAQ.2: When and where was this work first announced?"></a><a name="Faq-announced"></a>FAQ.2: When and where was this work first announced?</h3><p>It was announced by <a href="https://isocpp.org/blog/2015/09/stroustrup-cppcon15-keynote">Bjarne Stroustrup in his CppCon 2015 opening keynote, “Writing Good C++14”</a>. See also the <a href="https://isocpp.org/blog/2015/09/bjarne-stroustrup-announces-cpp-core-guidelines">accompanying isocpp.org blog post</a>, and for the rationale of the type and memory safety guidelines see <a href="https://isocpp.org/blog/2015/09/sutter-cppcon15-day2plenary">Herb Sutter’s follow-up CppCon 2015 talk, “Writing Good C++14 … By Default”</a>.</p>
<h3 id="FAQ-3-Who-are-the-authors-and-maintainers-of-these-guidelines"><a href="#FAQ-3-Who-are-the-authors-and-maintainers-of-these-guidelines" class="headerlink" title="FAQ.3: Who are the authors and maintainers of these guidelines?"></a><a name="Faq-maintainers"></a>FAQ.3: Who are the authors and maintainers of these guidelines?</h3><p>The initial primary authors and maintainers are Bjarne Stroustrup and Herb Sutter, and the guidelines so far were developed with contributions from experts at CERN, Microsoft, Morgan Stanley, and several other organizations. At the time of their release, the guidelines are in a “0.6” state, and contributions are welcome. As Stroustrup said in his announcement: “We need help!”</p>
<h3 id="FAQ-4-How-can-I-contribute"><a href="#FAQ-4-How-can-I-contribute" class="headerlink" title="FAQ.4: How can I contribute?"></a><a name="Faq-contribute"></a>FAQ.4: How can I contribute?</h3><p>See <a href="https://github.com/isocpp/CppCoreGuidelines/blob/master/CONTRIBUTING.md">CONTRIBUTING.md</a>. We appreciate volunteer help!</p>
<h3 id="FAQ-5-How-can-I-become-an-editor-maintainer"><a href="#FAQ-5-How-can-I-become-an-editor-maintainer" class="headerlink" title="FAQ.5: How can I become an editor/maintainer?"></a><a name="Faq-maintainer"></a>FAQ.5: How can I become an editor/maintainer?</h3><p>By contributing a lot first and having the consistent quality of your contributions recognized. See <a href="https://github.com/isocpp/CppCoreGuidelines/blob/master/CONTRIBUTING.md">CONTRIBUTING.md</a>. We appreciate volunteer help!</p>
<h3 id="FAQ-6-Have-these-guidelines-been-approved-by-the-ISO-C-standards-committee-Do-they-represent-the-consensus-of-the-committee"><a href="#FAQ-6-Have-these-guidelines-been-approved-by-the-ISO-C-standards-committee-Do-they-represent-the-consensus-of-the-committee" class="headerlink" title="FAQ.6: Have these guidelines been approved by the ISO C++ standards committee? Do they represent the consensus of the committee?"></a><a name="Faq-iso"></a>FAQ.6: Have these guidelines been approved by the ISO C++ standards committee? Do they represent the consensus of the committee?</h3><p>No. These guidelines are outside the standard. They are intended to serve the standard, and be maintained as current guidelines about how to use the current Standard C++ effectively. We aim to keep them in sync with the standard as that is evolved by the committee.</p>
<h3 id="FAQ-7-If-these-guidelines-are-not-approved-by-the-committee-why-are-they-under-github-com-isocpp"><a href="#FAQ-7-If-these-guidelines-are-not-approved-by-the-committee-why-are-they-under-github-com-isocpp" class="headerlink" title="FAQ.7: If these guidelines are not approved by the committee, why are they under github.com/isocpp?"></a><a name="Faq-isocpp"></a>FAQ.7: If these guidelines are not approved by the committee, why are they under <code>github.com/isocpp</code>?</h3><p>Because <code>isocpp</code> is the Standard C++ Foundation; the committee’s repositories are under <a href="https://github.com/cplusplus">github.com/<em>cplusplus</em></a>. Some neutral organization has to own the copyright and license to make it clear this is not being dominated by any one person or vendor. The natural entity is the Foundation, which exists to promote the use and up-to-date understanding of modern Standard C++ and the work of the committee. This follows the same pattern that isocpp.org did for the <a href="https://isocpp.org/faq">C++ FAQ</a>, which was initially the work of Bjarne Stroustrup, Marshall Cline, and Herb Sutter and contributed to the open project in the same way.</p>
<h3 id="FAQ-8-Will-there-be-a-C-98-version-of-these-Guidelines-a-C-11-version"><a href="#FAQ-8-Will-there-be-a-C-98-version-of-these-Guidelines-a-C-11-version" class="headerlink" title="FAQ.8: Will there be a C++98 version of these Guidelines? a C++11 version?"></a><a name="Faq-cpp98"></a>FAQ.8: Will there be a C++98 version of these Guidelines? a C++11 version?</h3><p>No. These guidelines are about how to best use Standard C++14 (and, if you have an implementation available, the Concepts Technical Specification) and write code assuming you have a modern conforming compiler.</p>
<h3 id="FAQ-9-Do-these-guidelines-propose-new-language-features"><a href="#FAQ-9-Do-these-guidelines-propose-new-language-features" class="headerlink" title="FAQ.9: Do these guidelines propose new language features?"></a><a name="Faq-language-extensions"></a>FAQ.9: Do these guidelines propose new language features?</h3><p>No. These guidelines are about how to best use Standard C++14 + the Concepts Technical Specification, and they limit themselves to recommending only those features.</p>
<h3 id="FAQ-10-What-version-of-Markdown-do-these-guidelines-use"><a href="#FAQ-10-What-version-of-Markdown-do-these-guidelines-use" class="headerlink" title="FAQ.10: What version of Markdown do these guidelines use?"></a><a name="Faq-markdown"></a>FAQ.10: What version of Markdown do these guidelines use?</h3><p>These coding standards are written using <a href="http://commonmark.org/">CommonMark</a>, and <code>&lt;a&gt;</code> HTML anchors.</p>
<p>We are considering the following extensions from <a href="https://help.github.com/articles/github-flavored-markdown/">GitHub Flavored Markdown (GFM)</a>:</p>
<ul>
<li>fenced code blocks (consistently using indented vs. fenced is under discussion)</li>
<li>tables (none yet but we’ll likely need them, and this is a GFM extension)</li>
</ul>
<p>Avoid other HTML tags and other extensions.</p>
<p>Note: We are not yet consistent with this style.</p>
<h3 id="FAQ-50-What-is-the-GSL-guideline-support-library"><a href="#FAQ-50-What-is-the-GSL-guideline-support-library" class="headerlink" title="FAQ.50: What is the GSL (guideline support library)?"></a><a name="Faq-gsl"></a>FAQ.50: What is the GSL (guideline support library)?</h3><p>The GSL is the small set of types and aliases specified in these guidelines. As of this writing, their specification herein is too sparse; we plan to add a WG21-style interface specification to ensure that different implementations agree, and to propose as a contribution for possible standardization, subject as usual to whatever the committee decides to accept/improve/alter/reject.</p>
<h3 id="FAQ-51-Is-github-com-Microsoft-GSL-the-GSL"><a href="#FAQ-51-Is-github-com-Microsoft-GSL-the-GSL" class="headerlink" title="FAQ.51: Is github.com/Microsoft/GSL the GSL?"></a><a name="Faq-msgsl"></a>FAQ.51: Is <a href="https://github.com/Microsoft/GSL">github.com/Microsoft/GSL</a> the GSL?</h3><p>No. That is just a first implementation contributed by Microsoft. Other implementations by other vendors are encouraged, as are forks of and contributions to that implementation. As of this writing one week into the public project, at least one GPLv3 open-source implementation already exists. We plan to produce a WG21-style interface specification to ensure that different implementations agree.</p>
<h3 id="FAQ-52-Why-not-supply-an-actual-GSL-implementation-in-with-these-guidelines"><a href="#FAQ-52-Why-not-supply-an-actual-GSL-implementation-in-with-these-guidelines" class="headerlink" title="FAQ.52: Why not supply an actual GSL implementation in/with these guidelines?"></a><a name="Faq-gsl-implementation"></a>FAQ.52: Why not supply an actual GSL implementation in/with these guidelines?</h3><p>We are reluctant to bless one particular implementation because we do not want to make people think there is only one, and inadvertently stifle parallel implementations. And if these guidelines included an actual implementation, then whoever contributed it could be mistakenly seen as too influential. We prefer to follow the long-standing approach of the committee, namely to specify interfaces, not implementations. But at the same time we want at least one implementation available; we hope for many.</p>
<h3 id="FAQ-53-Why-weren’t-the-GSL-types-proposed-through-Boost"><a href="#FAQ-53-Why-weren’t-the-GSL-types-proposed-through-Boost" class="headerlink" title="FAQ.53: Why weren’t the GSL types proposed through Boost?"></a><a name="Faq-boost"></a>FAQ.53: Why weren’t the GSL types proposed through Boost?</h3><p>Because we want to use them immediately, and because they are temporary in that we want to retire them as soon as types that fill the same needs exist in the standard library.</p>
<h3 id="FAQ-54-Has-the-GSL-guideline-support-library-been-approved-by-the-ISO-C-standards-committee"><a href="#FAQ-54-Has-the-GSL-guideline-support-library-been-approved-by-the-ISO-C-standards-committee" class="headerlink" title="FAQ.54: Has the GSL (guideline support library) been approved by the ISO C++ standards committee?"></a><a name="Faq-gsl-iso"></a>FAQ.54: Has the GSL (guideline support library) been approved by the ISO C++ standards committee?</h3><p>No. The GSL exists only to supply a few types and aliases that are not currently in the standard library. If the committee decides on standardized versions (of these or other types that fill the same need) then they can be removed from the GSL.</p>
<h3 id="FAQ-55-If-you’re-using-the-standard-types-where-available-why-is-the-GSL-string-span-different-from-the-string-view-in-the-Library-Fundamentals-1-Technical-Specification-and-C-17-Working-Paper-Why-not-just-use-the-committee-approved-string-view"><a href="#FAQ-55-If-you’re-using-the-standard-types-where-available-why-is-the-GSL-string-span-different-from-the-string-view-in-the-Library-Fundamentals-1-Technical-Specification-and-C-17-Working-Paper-Why-not-just-use-the-committee-approved-string-view" class="headerlink" title="FAQ.55: If you’re using the standard types where available, why is the GSL string_span different from the string_view in the Library Fundamentals 1 Technical Specification and C++17 Working Paper? Why not just use the committee-approved string_view?"></a><a name="Faq-gsl-string-view"></a>FAQ.55: If you’re using the standard types where available, why is the GSL <code>string_span</code> different from the <code>string_view</code> in the Library Fundamentals 1 Technical Specification and C++17 Working Paper? Why not just use the committee-approved <code>string_view</code>?</h3><p>The consensus on the taxonomy of views for the C++ Standard Library was that “view” means “read-only”, and “span” means “read/write”. The read-only <code>string_view</code> was the first such component to complete the standardization process, while <code>span</code> and <code>string_span</code> are currently being considered for standardization.</p>
<h3 id="FAQ-56-Is-owner-the-same-as-the-proposed-observer-ptr"><a href="#FAQ-56-Is-owner-the-same-as-the-proposed-observer-ptr" class="headerlink" title="FAQ.56: Is owner the same as the proposed observer_ptr?"></a><a name="Faq-gsl-owner"></a>FAQ.56: Is <code>owner</code> the same as the proposed <code>observer_ptr</code>?</h3><p>No. <code>owner</code> owns, is an alias, and can be applied to any indirection type. The main intent of <code>observer_ptr</code> is to signify a <em>non</em>-owning pointer.</p>
<h3 id="FAQ-57-Is-stack-array-the-same-as-the-standard-array"><a href="#FAQ-57-Is-stack-array-the-same-as-the-standard-array" class="headerlink" title="FAQ.57: Is stack_array the same as the standard array?"></a><a name="Faq-gsl-stack-array"></a>FAQ.57: Is <code>stack_array</code> the same as the standard <code>array</code>?</h3><p>No. <code>stack_array</code> is guaranteed to be allocated on the stack. Although a <code>std::array</code> contains its storage directly inside itself, the <code>array</code> object can be put anywhere, including the heap.</p>
<h3 id="FAQ-58-Is-dyn-array-the-same-as-vector-or-the-proposed-dynarray"><a href="#FAQ-58-Is-dyn-array-the-same-as-vector-or-the-proposed-dynarray" class="headerlink" title="FAQ.58: Is dyn_array the same as vector or the proposed dynarray?"></a><a name="Faq-gsl-dyn-array"></a>FAQ.58: Is <code>dyn_array</code> the same as <code>vector</code> or the proposed <code>dynarray</code>?</h3><p>No. <code>dyn_array</code> is not resizable, and is a safe way to refer to a heap-allocated fixed-size array. Unlike <code>vector</code>, it is intended to replace array-<code>new[]</code>. Unlike the <code>dynarray</code> that has been proposed in the committee, this does not anticipate compiler/language magic to somehow allocate it on the stack when it is a member of an object that is allocated on the stack; it simply refers to a “dynamic” or heap-based array.</p>
<h3 id="FAQ-59-Is-Expects-the-same-as-assert"><a href="#FAQ-59-Is-Expects-the-same-as-assert" class="headerlink" title="FAQ.59: Is Expects the same as assert?"></a><a name="Faq-gsl-expects"></a>FAQ.59: Is <code>Expects</code> the same as <code>assert</code>?</h3><p>No. It is a placeholder for language support for contract preconditions.</p>
<h3 id="FAQ-60-Is-Ensures-the-same-as-assert"><a href="#FAQ-60-Is-Ensures-the-same-as-assert" class="headerlink" title="FAQ.60: Is Ensures the same as assert?"></a><a name="Faq-gsl-ensures"></a>FAQ.60: Is <code>Ensures</code> the same as <code>assert</code>?</h3><p>No. It is a placeholder for language support for contract postconditions.</p>
<h1 id="Appendix-A-Libraries"><a href="#Appendix-A-Libraries" class="headerlink" title="Appendix A: Libraries"></a><a name="S-libraries"></a>Appendix A: Libraries</h1><p>This section lists recommended libraries, and explicitly recommends a few.</p>
<p>??? Suitable for the general guide? I think not ???</p>
<h1 id="Appendix-B-Modernizing-code"><a href="#Appendix-B-Modernizing-code" class="headerlink" title="Appendix B: Modernizing code"></a><a name="S-modernizing"></a>Appendix B: Modernizing code</h1><p>Ideally, we follow all rules in all code.<br>Realistically, we have to deal with a lot of old code:</p>
<ul>
<li>application code written before the guidelines were formulated or known</li>
<li>libraries written to older/different standards</li>
<li>code written under “unusual” constraints</li>
<li>code that we just haven’t gotten around to modernizing</li>
</ul>
<p>If we have a million lines of new code, the idea of “just changing it all at once” is typically unrealistic.<br>Thus, we need a way of gradually modernizing a code base.</p>
<p>Upgrading older code to modern style can be a daunting task.<br>Often, the old code is both a mess (hard to understand) and working correctly (for the current range of uses).<br>Typically, the original programmer is not around and the test cases incomplete.<br>The fact that the code is a mess dramatically increases the effort needed to make any change and the risk of introducing errors.<br>Often, messy old code runs unnecessarily slowly because it requires outdated compilers and cannot take advantage of modern hardware.<br>In many cases, automated “modernizer”-style tool support would be required for major upgrade efforts.</p>
<p>The purpose of modernizing code is to simplify adding new functionality, to ease maintenance, and to increase performance (throughput or latency), and to better utilize modern hardware.<br>Making code “look pretty” or “follow modern style” are not by themselves reasons for change.<br>There are risks implied by every change and costs (including the cost of lost opportunities) implied by having an outdated code base.<br>The cost reductions must outweigh the risks.</p>
<p>But how?</p>
<p>There is no one approach to modernizing code.<br>How best to do it depends on the code, the pressure for updates, the backgrounds of the developers, and the available tool.<br>Here are some (very general) ideas:</p>
<ul>
<li>The ideal is “just upgrade everything.” That gives the most benefits for the shortest total time.<br>In most circumstances, it is also impossible.</li>
<li>We could convert a code base module for module, but any rules that affects interfaces (especially ABIs), such as <a href="#SS-views">use <code>span</code></a>, cannot be done on a per-module basis.</li>
<li>We could convert code “bottom up” starting with the rules we estimate will give the greatest benefits and/or the least trouble in a given code base.</li>
<li>We could start by focusing on the interfaces, e.g., make sure that no resources are lost and no pointer is misused.<br>This would be a set of changes across the whole code base, but would most likely have huge benefits.<br>Afterwards, code hidden behind those interfaces can be gradually modernized without affecting other code.</li>
</ul>
<p>Whichever way you choose, please note that the most advantages come with the highest conformance to the guidelines.<br>The guidelines are not a random set of unrelated rules where you can randomly pick and choose with an expectation of success.</p>
<p>We would dearly love to hear about experience and about tools used.<br>Modernization can be much faster, simpler, and safer when supported with analysis tools and even code transformation tools.</p>
<h1 id="Appendix-C-Discussion"><a href="#Appendix-C-Discussion" class="headerlink" title="Appendix C: Discussion"></a><a name="S-discussion"></a>Appendix C: Discussion</h1><p>This section contains follow-up material on rules and sets of rules.<br>In particular, here we present further rationale, longer examples, and discussions of alternatives.</p>
<h3 id="Discussion-Define-and-initialize-member-variables-in-the-order-of-member-declaration"><a href="#Discussion-Define-and-initialize-member-variables-in-the-order-of-member-declaration" class="headerlink" title="Discussion: Define and initialize member variables in the order of member declaration"></a><a name="Sd-order"></a>Discussion: Define and initialize member variables in the order of member declaration</h3><p>Member variables are always initialized in the order they are declared in the class definition, so write them in that order in the constructor initialization list. Writing them in a different order just makes the code confusing because it won’t run in the order you see, and that can make it hard to see order-dependent bugs.</p>
<pre><code>class Employee &#123;
    string email, first, last;
public:
    Employee(const char* firstName, const char* lastName);
    // ...
&#125;;

Employee::Employee(const char* firstName, const char* lastName)
  : first(firstName),
    last(lastName),
    // BAD: first and last not yet constructed
    email(first + &quot;.&quot; + last + &quot;@acme.com&quot;)
&#123;&#125;
</code></pre>
<p>In this example, <code>email</code> will be constructed before <code>first</code> and <code>last</code> because it is declared first. That means its constructor will attempt to use <code>first</code> and <code>last</code> too soon – not just before they are set to the desired values, but before they are constructed at all.</p>
<p>If the class definition and the constructor body are in separate files, the long-distance influence that the order of member variable declarations has over the constructor’s correctness will be even harder to spot.</p>
<p><strong>References</strong>:</p>
<p><a href="#Cline99">[Cline99]</a> §22.03-11, <a href="#Dewhurst03">[Dewhurst03]</a> §52-53, <a href="#Koenig97">[Koenig97]</a> §4, <a href="#Lakos96">[Lakos96]</a> §10.3.5, <a href="#Meyers97">[Meyers97]</a> §13, <a href="#Murray93">[Murray93]</a> §2.1.3, <a href="#Sutter00">[Sutter00]</a> §47</p>
<h3 id="Discussion-Use-of-and-as-initializers"><a href="#Discussion-Use-of-and-as-initializers" class="headerlink" title="Discussion: Use of =, {}, and () as initializers"></a><a name="Sd-init"></a>Discussion: Use of <code>=</code>, <code>&#123;&#125;</code>, and <code>()</code> as initializers</h3><p>???</p>
<h3 id="Discussion-Use-a-factory-function-if-you-need-“virtual-behavior”-during-initialization"><a href="#Discussion-Use-a-factory-function-if-you-need-“virtual-behavior”-during-initialization" class="headerlink" title="Discussion: Use a factory function if you need “virtual behavior” during initialization"></a><a name="Sd-factory"></a>Discussion: Use a factory function if you need “virtual behavior” during initialization</h3><p>If your design wants virtual dispatch into a derived class from a base class constructor or destructor for functions like <code>f</code> and <code>g</code>, you need other techniques, such as a post-constructor – a separate member function the caller must invoke to complete initialization, which can safely call <code>f</code> and <code>g</code> because in member functions virtual calls behave normally. Some techniques for this are shown in the References. Here’s a non-exhaustive list of options:</p>
<ul>
<li><em>Pass the buck:</em> Just document that user code must call the post-initialization function right after constructing an object.</li>
<li><em>Post-initialize lazily:</em> Do it during the first call of a member function. A Boolean flag in the base class tells whether or not post-construction has taken place yet.</li>
<li><em>Use virtual base class semantics:</em> Language rules dictate that the constructor most-derived class decides which base constructor will be invoked; you can use that to your advantage. (See <a href="#Taligent94">[Taligent94]</a>.)</li>
<li><em>Use a factory function:</em> This way, you can easily force a mandatory invocation of a post-constructor function.</li>
</ul>
<p>Here is an example of the last option:</p>
<pre><code>class B &#123;
public:
    B() &#123; /* ... */ f(); /* ... */ &#125;   // BAD: see Item 49.1

    virtual void f() = 0;

    // ...
&#125;;

class B &#123;
protected:
    B() &#123; /* ... */ &#125;
    virtual void post_initialize()    // called right after construction
        &#123; /* ... */ f(); /* ... */ &#125;   // GOOD: virtual dispatch is safe
public:
    virtual void f() = 0;

    template&lt;class T&gt;
    static shared_ptr&lt;T&gt; create()    // interface for creating objects
    &#123;
        auto p = make_shared&lt;T&gt;();
        p-&gt;post_initialize();
        return p;
    &#125;
&#125;;


class D : public B &#123;                 // some derived class
public:
    void f() override &#123; /* ...  */ &#125;;

protected:
    D() &#123;&#125;

    template&lt;class T&gt;
    friend shared_ptr&lt;T&gt; B::Create();
&#125;;

shared_ptr&lt;D&gt; p = D::Create&lt;D&gt;();    // creating a D object
</code></pre>
<p>This design requires the following discipline:</p>
<ul>
<li>Derived classes such as <code>D</code> must not expose a public constructor. Otherwise, <code>D</code>‘s users could create <code>D</code> objects that don’t invoke <code>PostInitialize</code>.</li>
<li>Allocation is limited to <code>operator new</code>. <code>B</code> can, however, override <code>new</code> (see Items 45 and 46).</li>
<li><code>D</code> must define a constructor with the same parameters that <code>B</code> selected. Defining several overloads of <code>Create</code> can assuage this problem, however; and the overloads can even be templated on the argument types.</li>
</ul>
<p>If the requirements above are met, the design guarantees that <code>PostInitialize</code> has been called for any fully constructed <code>B</code>-derived object. <code>PostInitialize</code> doesn’t need to be virtual; it can, however, invoke virtual functions freely.</p>
<p>In summary, no post-construction technique is perfect. The worst techniques dodge the whole issue by simply asking the caller to invoke the post-constructor manually. Even the best require a different syntax for constructing objects (easy to check at compile time) and/or cooperation from derived class authors (impossible to check at compile time).</p>
<p><strong>References</strong>: <a href="#Alexandrescu01">[Alexandrescu01]</a> §3, <a href="#Boost">[Boost]</a>, <a href="#Dewhurst03">[Dewhurst03]</a> §75, <a href="#Meyers97">[Meyers97]</a> §46, <a href="#Stroustrup00">[Stroustrup00]</a> §15.4.3, <a href="#Taligent94">[Taligent94]</a></p>
<h3 id="Discussion-Make-base-class-destructors-public-and-virtual-or-protected-and-nonvirtual"><a href="#Discussion-Make-base-class-destructors-public-and-virtual-or-protected-and-nonvirtual" class="headerlink" title="Discussion: Make base class destructors public and virtual, or protected and nonvirtual"></a><a name="Sd-dtor"></a>Discussion: Make base class destructors public and virtual, or protected and nonvirtual</h3><p>Should destruction behave virtually? That is, should destruction through a pointer to a <code>base</code> class be allowed? If yes, then <code>base</code>‘s destructor must be public in order to be callable, and virtual otherwise calling it results in undefined behavior. Otherwise, it should be protected so that only derived classes can invoke it in their own destructors, and nonvirtual since it doesn’t need to behave virtually virtual.</p>
<h5 id="Example-386"><a href="#Example-386" class="headerlink" title="Example"></a>Example</h5><p>The common case for a base class is that it’s intended to have publicly derived classes, and so calling code is just about sure to use something like a <code>shared_ptr&lt;base&gt;</code>:</p>
<pre><code>class Base &#123;
public:
    ~Base();                   // BAD, not virtual
    virtual ~Base();           // GOOD
    // ...
&#125;;

class Derived : public Base &#123; /* ... */ &#125;;

&#123;
    unique_ptr&lt;Base&gt; pb = make_unique&lt;Derived&gt;();
    // ...
&#125; // ~pb invokes correct destructor only when ~Base is virtual
</code></pre>
<p>In rarer cases, such as policy classes, the class is used as a base class for convenience, not for polymorphic behavior. It is recommended to make those destructors protected and nonvirtual:</p>
<pre><code>class My_policy &#123;
public:
    virtual ~My_policy();      // BAD, public and virtual
protected:
    ~My_policy();              // GOOD
    // ...
&#125;;

template&lt;class Policy&gt;
class customizable : Policy &#123; /* ... */ &#125;; // note: private inheritance
</code></pre>
<h5 id="Note-376"><a href="#Note-376" class="headerlink" title="Note"></a>Note</h5><p>This simple guideline illustrates a subtle issue and reflects modern uses of inheritance and object-oriented design principles.</p>
<p>For a base class <code>Base</code>, calling code might try to destroy derived objects through pointers to <code>Base</code>, such as when using a <code>unique_ptr&lt;Base&gt;</code>. If <code>Base</code>‘s destructor is public and nonvirtual (the default), it can be accidentally called on a pointer that actually points to a derived object, in which case the behavior of the attempted deletion is undefined. This state of affairs has led older coding standards to impose a blanket requirement that all base class destructors must be virtual. This is overkill (even if it is the common case); instead, the rule should be to make base class destructors virtual if and only if they are public.</p>
<p>To write a base class is to define an abstraction (see Items 35 through 37). Recall that for each member function participating in that abstraction, you need to decide:</p>
<ul>
<li>Whether it should behave virtually or not.</li>
<li>Whether it should be publicly available to all callers using a pointer to <code>Base</code> or else be a hidden internal implementation detail.</li>
</ul>
<p>As described in Item 39, for a normal member function, the choice is between allowing it to be called via a pointer to <code>Base</code> nonvirtually (but possibly with virtual behavior if it invokes virtual functions, such as in the NVI or Template Method patterns), virtually, or not at all. The NVI pattern is a technique to avoid public virtual functions.</p>
<p>Destruction can be viewed as just another operation, albeit with special semantics that make nonvirtual calls dangerous or wrong. For a base class destructor, therefore, the choice is between allowing it to be called via a pointer to <code>Base</code> virtually or not at all; “nonvirtually” is not an option. Hence, a base class destructor is virtual if it can be called (i.e., is public), and nonvirtual otherwise.</p>
<p>Note that the NVI pattern cannot be applied to the destructor because constructors and destructors cannot make deep virtual calls. (See Items 39 and 55.)</p>
<p>Corollary: When writing a base class, always write a destructor explicitly, because the implicitly generated one is public and nonvirtual. You can always <code>=default</code> the implementation if the default body is fine and you’re just writing the function to give it the proper visibility and virtuality.</p>
<h5 id="Exception-54"><a href="#Exception-54" class="headerlink" title="Exception"></a>Exception</h5><p>Some component architectures (e.g., COM and CORBA) don’t use a standard deletion mechanism, and foster different protocols for object disposal. Follow the local patterns and idioms, and adapt this guideline as appropriate.</p>
<p>Consider also this rare case:</p>
<ul>
<li><code>B</code> is both a base class and a concrete class that can be instantiated by itself, and so the destructor must be public for <code>B</code> objects to be created and destroyed.</li>
<li>Yet <code>B</code> also has no virtual functions and is not meant to be used polymorphically, and so although the destructor is public it does not need to be virtual.</li>
</ul>
<p>Then, even though the destructor has to be public, there can be great pressure to not make it virtual because as the first virtual function it would incur all the run-time type overhead when the added functionality should never be needed.</p>
<p>In this rare case, you could make the destructor public and nonvirtual but clearly document that further-derived objects must not be used polymorphically as <code>B</code>‘s. This is what was done with <code>std::unary_function</code>.</p>
<p>In general, however, avoid concrete base classes (see Item 35). For example, <code>unary_function</code> is a bundle-of-typedefs that was never intended to be instantiated standalone. It really makes no sense to give it a public destructor; a better design would be to follow this Item’s advice and give it a protected nonvirtual destructor.</p>
<p><strong>References</strong>: <a href="#CplusplusCS">[C++CS]</a> Item 50, <a href="#Cargill92">[Cargill92]</a> pp. 77-79, 207, <a href="#Cline99">[Cline99]</a> §21.06, 21.12-13, <a href="#Henricson97">[Henricson97]</a> pp. 110-114, <a href="#Koenig97">[Koenig97]</a> Chapters 4, 11, <a href="#Meyers97">[Meyers97]</a> §14, <a href="#Stroustrup00">[Stroustrup00]</a> §12.4.2, <a href="#Sutter02">[Sutter02]</a> §27, <a href="#Sutter04">[Sutter04]</a> §18</p>
<h3 id="Discussion-Usage-of-noexcept"><a href="#Discussion-Usage-of-noexcept" class="headerlink" title="Discussion: Usage of noexcept"></a><a name="Sd-noexcept"></a>Discussion: Usage of noexcept</h3><p>???</p>
<h3 id="Discussion-Destructors-deallocation-and-swap-must-never-fail"><a href="#Discussion-Destructors-deallocation-and-swap-must-never-fail" class="headerlink" title="Discussion: Destructors, deallocation, and swap must never fail"></a><a name="Sd-never-fail"></a>Discussion: Destructors, deallocation, and swap must never fail</h3><p>Never allow an error to be reported from a destructor, a resource deallocation function (e.g., <code>operator delete</code>), or a <code>swap</code> function using <code>throw</code>. It is nearly impossible to write useful code if these operations can fail, and even if something does go wrong it nearly never makes any sense to retry. Specifically, types whose destructors may throw an exception are flatly forbidden from use with the C++ Standard Library. Most destructors are now implicitly <code>noexcept</code> by default.</p>
<h5 id="Example-387"><a href="#Example-387" class="headerlink" title="Example"></a>Example</h5><pre><code>class Nefarious &#123;
public:
    Nefarious()  &#123; /* code that could throw */ &#125;   // ok
    ~Nefarious() &#123; /* code that could throw */ &#125;   // BAD, should not throw
    // ...
&#125;;
</code></pre>
<ol>
<li><code>Nefarious</code> objects are hard to use safely even as local variables:</li>
</ol>
<pre><code>    void test(string&amp; s)
    &#123;
        Nefarious n;          // trouble brewing
        string copy = s;      // copy the string
    &#125; // destroy copy and then n

Here, copying `s` could throw, and if that throws and if `n`&#39;s destructor then also throws, the program will exit via `std::terminate` because two exceptions can&#39;t be propagated simultaneously.
</code></pre>
<ol start="2">
<li>Classes with <code>Nefarious</code> members or bases are also hard to use safely, because their destructors must invoke <code>Nefarious</code>‘ destructor, and are similarly poisoned by its poor behavior:</li>
</ol>
<pre><code>    class Innocent_bystander &#123;
        Nefarious member;     // oops, poisons the enclosing class&#39;s destructor
        // ...
    &#125;;

    void test(string&amp; s)
    &#123;
        Innocent_bystander i; // more trouble brewing
        string copy2 = s;      // copy the string
    &#125; // destroy copy and then i

Here, if constructing `copy2` throws, we have the same problem because `i`&#39;s destructor now also can throw, and if so we&#39;ll invoke `std::terminate`.
</code></pre>
<ol start="3">
<li>You can’t reliably create global or static <code>Nefarious</code> objects either:</li>
</ol>
<pre><code>    static Nefarious n;       // oops, any destructor exception can&#39;t be caught
</code></pre>
<ol start="4">
<li>You can’t reliably create arrays of <code>Nefarious</code>:</li>
</ol>
<pre><code>    void test()
    &#123;
        std::array&lt;Nefarious, 10&gt; arr; // this line can std::terminate(!)
    &#125;

The behavior of arrays is undefined in the presence of destructors that throw because there is no reasonable rollback behavior that could ever be devised. Just think: What code can the compiler generate for constructing an `arr` where, if the fourth object&#39;s constructor throws, the code has to give up and in its cleanup mode tries to call the destructors of the already-constructed objects ... and one or more of those destructors throws? There is no satisfactory answer.
</code></pre>
<ol start="5">
<li>You can’t use <code>Nefarious</code> objects in standard containers:</li>
</ol>
<pre><code>    std::vector&lt;Nefarious&gt; vec(10);   // this line can std::terminate()

The standard library forbids all destructors used with it from throwing. You can&#39;t store `Nefarious` objects in standard containers or use them with any other part of the standard library.
</code></pre>
<h5 id="Note-377"><a href="#Note-377" class="headerlink" title="Note"></a>Note</h5><p>These are key functions that must not fail because they are necessary for the two key operations in transactional programming: to back out work if problems are encountered during processing, and to commit work if no problems occur. If there’s no way to safely back out using no-fail operations, then no-fail rollback is impossible to implement. If there’s no way to safely commit state changes using a no-fail operation (notably, but not limited to, <code>swap</code>), then no-fail commit is impossible to implement.</p>
<p>Consider the following advice and requirements found in the C++ Standard:</p>
<blockquote>
<p>If a destructor called during stack unwinding exits with an exception, terminate is called (15.5.1). So destructors should generally catch exceptions and not let them propagate out of the destructor. –<a href="#Cplusplus03">[C++03]</a> §15.2(3)</p>
<p>No destructor operation defined in the C++ Standard Library (including the destructor of any type that is used to instantiate a standard-library template) will throw an exception. –<a href="#Cplusplus03">[C++03]</a> §17.4.4.8(3)</p>
</blockquote>
<p>Deallocation functions, including specifically overloaded <code>operator delete</code> and <code>operator delete[]</code>, fall into the same category, because they too are used during cleanup in general, and during exception handling in particular, to back out of partial work that needs to be undone.<br>Besides destructors and deallocation functions, common error-safety techniques rely also on <code>swap</code> operations never failing – in this case, not because they are used to implement a guaranteed rollback, but because they are used to implement a guaranteed commit. For example, here is an idiomatic implementation of <code>operator=</code> for a type <code>T</code> that performs copy construction followed by a call to a no-fail <code>swap</code>:</p>
<pre><code>T&amp; T::operator=(const T&amp; other) &#123;
    auto temp = other;
    swap(temp);
&#125;
</code></pre>
<p>(See also Item 56. ???)</p>
<p>Fortunately, when releasing a resource, the scope for failure is definitely smaller. If using exceptions as the error reporting mechanism, make sure such functions handle all exceptions and other errors that their internal processing might generate. (For exceptions, simply wrap everything sensitive that your destructor does in a <code>try/catch(...)</code> block.) This is particularly important because a destructor might be called in a crisis situation, such as failure to allocate a system resource (e.g., memory, files, locks, ports, windows, or other system objects).</p>
<p>When using exceptions as your error handling mechanism, always document this behavior by declaring these functions <code>noexcept</code>. (See Item 75.)</p>
<p><strong>References</strong>: <a href="#CplusplusCS">[C++CS]</a> Item 51; <a href="#Cplusplus03">[C++03]</a> §15.2(3), §17.4.4.8(3), <a href="#Meyers96">[Meyers96]</a> §11, <a href="#Stroustrup00">[Stroustrup00]</a> §14.4.7, §E.2-4, <a href="#Sutter00">[Sutter00]</a> §8, §16, <a href="#Sutter02">[Sutter02]</a> §18-19</p>
<h2 id="Define-Copy-move-and-destroy-consistently"><a href="#Define-Copy-move-and-destroy-consistently" class="headerlink" title="Define Copy, move, and destroy consistently"></a><a name="Sd-consistent"></a>Define Copy, move, and destroy consistently</h2><h5 id="Reason-434"><a href="#Reason-434" class="headerlink" title="Reason"></a>Reason</h5><p> ???</p>
<h5 id="Note-378"><a href="#Note-378" class="headerlink" title="Note"></a>Note</h5><p>If you define a copy constructor, you must also define a copy assignment operator.</p>
<h5 id="Note-379"><a href="#Note-379" class="headerlink" title="Note"></a>Note</h5><p>If you define a move constructor, you must also define a move assignment operator.</p>
<h5 id="Example-388"><a href="#Example-388" class="headerlink" title="Example"></a>Example</h5><pre><code>class X &#123;
    // ...
public:
    X(const X&amp;) &#123; /* stuff */ &#125;

    // BAD: failed to also define a copy assignment operator

    X(x&amp;&amp;) noexcept &#123; /* stuff */ &#125;

    // BAD: failed to also define a move assignment operator
&#125;;

X x1;
X x2 = x1; // ok
x2 = x1;   // pitfall: either fails to compile, or does something suspicious
</code></pre>
<p>If you define a destructor, you should not use the compiler-generated copy or move operation; you probably need to define or suppress copy and/or move.</p>
<pre><code>class X &#123;
    HANDLE hnd;
    // ...
public:
    ~X() &#123; /* custom stuff, such as closing hnd */ &#125;
    // suspicious: no mention of copying or moving -- what happens to hnd?
&#125;;

X x1;
X x2 = x1; // pitfall: either fails to compile, or does something suspicious
x2 = x1;   // pitfall: either fails to compile, or does something suspicious
</code></pre>
<p>If you define copying, and any base or member has a type that defines a move operation, you should also define a move operation.</p>
<pre><code>class X &#123;
    string s; // defines more efficient move operations
    // ... other data members ...
public:
    X(const X&amp;) &#123; /* stuff */ &#125;
    X&amp; operator=(const X&amp;) &#123; /* stuff */ &#125;

    // BAD: failed to also define a move construction and move assignment
    // (why wasn&#39;t the custom &quot;stuff&quot; repeated here?)
&#125;;

X test()
&#123;
    X local;
    // ...
    return local;  // pitfall: will be inefficient and/or do the wrong thing
&#125;
</code></pre>
<p>If you define any of the copy constructor, copy assignment operator, or destructor, you probably should define the others.</p>
<h5 id="Note-380"><a href="#Note-380" class="headerlink" title="Note"></a>Note</h5><p>If you need to define any of these five functions, it means you need it to do more than its default behavior – and the five are asymmetrically interrelated. Here’s how:</p>
<ul>
<li>If you write/disable either of the copy constructor or the copy assignment operator, you probably need to do the same for the other: If one does “special” work, probably so should the other because the two functions should have similar effects. (See Item 53, which expands on this point in isolation.)</li>
<li>If you explicitly write the copying functions, you probably need to write the destructor: If the “special” work in the copy constructor is to allocate or duplicate some resource (e.g., memory, file, socket), you need to deallocate it in the destructor.</li>
<li>If you explicitly write the destructor, you probably need to explicitly write or disable copying: If you have to write a non-trivial destructor, it’s often because you need to manually release a resource that the object held. If so, it is likely that those resources require careful duplication, and then you need to pay attention to the way objects are copied and assigned, or disable copying completely.</li>
</ul>
<p>In many cases, holding properly encapsulated resources using RAII “owning” objects can eliminate the need to write these operations yourself. (See Item 13.)</p>
<p>Prefer compiler-generated (including <code>=default</code>) special members; only these can be classified as “trivial”, and at least one major standard library vendor heavily optimizes for classes having trivial special members. This is likely to become common practice.</p>
<p><strong>Exceptions</strong>: When any of the special functions are declared only to make them nonpublic or virtual, but without special semantics, it doesn’t imply that the others are needed.<br>In rare cases, classes that have members of strange types (such as reference members) are an exception because they have peculiar copy semantics.<br>In a class holding a reference, you likely need to write the copy constructor and the assignment operator, but the default destructor already does the right thing. (Note that using a reference member is almost always wrong.)</p>
<p><strong>References</strong>: <a href="#CplusplusCS">[C++CS]</a> Item 52; <a href="#Cline99">[Cline99]</a> §30.01-14, <a href="#Koenig97">[Koenig97]</a> §4, <a href="#Stroustrup00">[Stroustrup00]</a> §5.5, §10.4, <a href="#SuttHysl04b">[SuttHysl04b]</a></p>
<p>Resource management rule summary:</p>
<ul>
<li><a href="#Cr-safety">Provide strong resource safety; that is, never leak anything that you think of as a resource</a></li>
<li><a href="#Cr-never">Never throw while holding a resource not owned by a handle</a></li>
<li><a href="#Cr-raw">A “raw” pointer or reference is never a resource handle</a></li>
<li><a href="#Cr-outlive">Never let a pointer outlive the object it points to</a></li>
<li><a href="#Cr-templates">Use templates to express containers (and other resource handles)</a></li>
<li><a href="#Cr-value-return">Return containers by value (relying on move or copy elision for efficiency)</a></li>
<li><a href="#Cr-handle">If a class is a resource handle, it needs a constructor, a destructor, and copy and/or move operations</a></li>
<li><a href="#Cr-list">If a class is a container, give it an initializer-list constructor</a></li>
</ul>
<h3 id="Discussion-Provide-strong-resource-safety-that-is-never-leak-anything-that-you-think-of-as-a-resource"><a href="#Discussion-Provide-strong-resource-safety-that-is-never-leak-anything-that-you-think-of-as-a-resource" class="headerlink" title="Discussion: Provide strong resource safety; that is, never leak anything that you think of as a resource"></a><a name="Cr-safety"></a>Discussion: Provide strong resource safety; that is, never leak anything that you think of as a resource</h3><h5 id="Reason-435"><a href="#Reason-435" class="headerlink" title="Reason"></a>Reason</h5><p>Prevent leaks. Leaks can lead to performance degradation, mysterious error, system crashes, and security violations.</p>
<p><strong>Alternative formulation</strong>: Have every resource represented as an object of some class managing its lifetime.</p>
<h5 id="Example-389"><a href="#Example-389" class="headerlink" title="Example"></a>Example</h5><pre><code>template&lt;class T&gt;
class Vector &#123;
// ...
private:
    T* elem;   // sz elements on the free store, owned by the class object
    int sz;
&#125;;
</code></pre>
<p>This class is a resource handle. It manages the lifetime of the <code>T</code>s. To do so, <code>Vector</code> must define or delete <a href="???">the set of special operations</a> (constructors, a destructor, etc.).</p>
<h5 id="Example-390"><a href="#Example-390" class="headerlink" title="Example"></a>Example</h5><pre><code>??? &quot;odd&quot; non-memory resource ???
</code></pre>
<h5 id="Enforcement-396"><a href="#Enforcement-396" class="headerlink" title="Enforcement"></a>Enforcement</h5><p>The basic technique for preventing leaks is to have every resource owned by a resource handle with a suitable destructor. A checker can find “naked <code>new</code>s”. Given a list of C-style allocation functions (e.g., <code>fopen()</code>), a checker can also find uses that are not managed by a resource handle. In general, “naked pointers” can be viewed with suspicion, flagged, and/or analyzed. A complete list of resources cannot be generated without human input (the definition of “a resource” is necessarily too general), but a tool can be “parameterized” with a resource list.</p>
<h3 id="Discussion-Never-throw-while-holding-a-resource-not-owned-by-a-handle"><a href="#Discussion-Never-throw-while-holding-a-resource-not-owned-by-a-handle" class="headerlink" title="Discussion: Never throw while holding a resource not owned by a handle"></a><a name="Cr-never"></a>Discussion: Never throw while holding a resource not owned by a handle</h3><h5 id="Reason-436"><a href="#Reason-436" class="headerlink" title="Reason"></a>Reason</h5><p>That would be a leak.</p>
<h5 id="Example-391"><a href="#Example-391" class="headerlink" title="Example"></a>Example</h5><pre><code>void f(int i)
&#123;
    FILE* f = fopen(&quot;a file&quot;, &quot;r&quot;);
    ifstream is &#123; &quot;another file&quot; &#125;;
    // ...
    if (i == 0) return;
    // ...
    fclose(f);
&#125;
</code></pre>
<p>If <code>i == 0</code> the file handle for <code>a file</code> is leaked. On the other hand, the <code>ifstream</code> for <code>another file</code> will correctly close its file (upon destruction). If you must use an explicit pointer, rather than a resource handle with specific semantics, use a <code>unique_ptr</code> or a <code>shared_ptr</code> with a custom deleter:</p>
<pre><code>void f(int i)
&#123;
    unique_ptr&lt;FILE, int(*)(FILE*)&gt; f(fopen(&quot;a file&quot;, &quot;r&quot;), fclose);
    // ...
    if (i == 0) return;
    // ...
&#125;
</code></pre>
<p>Better:</p>
<pre><code>void f(int i)
&#123;
    ifstream input &#123;&quot;a file&quot;&#125;;
    // ...
    if (i == 0) return;
    // ...
&#125;
</code></pre>
<h5 id="Enforcement-397"><a href="#Enforcement-397" class="headerlink" title="Enforcement"></a>Enforcement</h5><p>A checker must consider all “naked pointers” suspicious.<br>A checker probably must rely on a human-provided list of resources.<br>For starters, we know about the standard-library containers, <code>string</code>, and smart pointers.<br>The use of <code>span</code> and <code>string_span</code> should help a lot (they are not resource handles).</p>
<h3 id="Discussion-A-“raw”-pointer-or-reference-is-never-a-resource-handle"><a href="#Discussion-A-“raw”-pointer-or-reference-is-never-a-resource-handle" class="headerlink" title="Discussion: A “raw” pointer or reference is never a resource handle"></a><a name="Cr-raw"></a>Discussion: A “raw” pointer or reference is never a resource handle</h3><h5 id="Reason-437"><a href="#Reason-437" class="headerlink" title="Reason"></a>Reason</h5><p>To be able to distinguish owners from views.</p>
<h5 id="Note-381"><a href="#Note-381" class="headerlink" title="Note"></a>Note</h5><p>This is independent of how you “spell” pointer: <code>T*</code>, <code>T&amp;</code>, <code>Ptr&lt;T&gt;</code> and <code>Range&lt;T&gt;</code> are not owners.</p>
<h3 id="Discussion-Never-let-a-pointer-outlive-the-object-it-points-to"><a href="#Discussion-Never-let-a-pointer-outlive-the-object-it-points-to" class="headerlink" title="Discussion: Never let a pointer outlive the object it points to"></a><a name="Cr-outlive"></a>Discussion: Never let a pointer outlive the object it points to</h3><h5 id="Reason-438"><a href="#Reason-438" class="headerlink" title="Reason"></a>Reason</h5><p>To avoid extremely hard-to-find errors. Dereferencing such a pointer is undefined behavior and could lead to violations of the type system.</p>
<h5 id="Example-392"><a href="#Example-392" class="headerlink" title="Example"></a>Example</h5><pre><code>string* bad()   // really bad
&#123;
    vector&lt;string&gt; v = &#123; &quot;This&quot;, &quot;will&quot;, &quot;cause&quot;, &quot;trouble&quot;, &quot;!&quot; &#125;;
    // leaking a pointer into a destroyed member of a destroyed object (v)
    return &amp;v[0];
&#125;

void use()
&#123;
    string* p = bad();
    vector&lt;int&gt; xx = &#123;7, 8, 9&#125;;
    // undefined behavior: x may not be the string &quot;This&quot;
    string x = *p;
    // undefined behavior: we don&#39;t know what (if anything) is allocated a location p
    *p = &quot;Evil!&quot;;
&#125;
</code></pre>
<p>The <code>string</code>s of <code>v</code> are destroyed upon exit from <code>bad()</code> and so is <code>v</code> itself. The returned pointer points to unallocated memory on the free store. This memory (pointed into by <code>p</code>) may have been reallocated by the time <code>*p</code> is executed. There may be no <code>string</code> to read and a write through <code>p</code> could easily corrupt objects of unrelated types.</p>
<h5 id="Enforcement-398"><a href="#Enforcement-398" class="headerlink" title="Enforcement"></a>Enforcement</h5><p>Most compilers already warn about simple cases and has the information to do more. Consider any pointer returned from a function suspect. Use containers, resource handles, and views (e.g., <code>span</code> known not to be resource handles) to lower the number of cases to be examined. For starters, consider every class with a destructor as resource handle.</p>
<h3 id="Discussion-Use-templates-to-express-containers-and-other-resource-handles"><a href="#Discussion-Use-templates-to-express-containers-and-other-resource-handles" class="headerlink" title="Discussion: Use templates to express containers (and other resource handles)"></a><a name="Cr-templates"></a>Discussion: Use templates to express containers (and other resource handles)</h3><h5 id="Reason-439"><a href="#Reason-439" class="headerlink" title="Reason"></a>Reason</h5><p>To provide statically type-safe manipulation of elements.</p>
<h5 id="Example-393"><a href="#Example-393" class="headerlink" title="Example"></a>Example</h5><pre><code>template&lt;typename T&gt; class Vector &#123;
    // ...
    T* elem;   // point to sz elements of type T
    int sz;
&#125;;
</code></pre>
<h3 id="Discussion-Return-containers-by-value-relying-on-move-or-copy-elision-for-efficiency"><a href="#Discussion-Return-containers-by-value-relying-on-move-or-copy-elision-for-efficiency" class="headerlink" title="Discussion: Return containers by value (relying on move or copy elision for efficiency)"></a><a name="Cr-value-return"></a>Discussion: Return containers by value (relying on move or copy elision for efficiency)</h3><h5 id="Reason-440"><a href="#Reason-440" class="headerlink" title="Reason"></a>Reason</h5><p>To simplify code and eliminate a need for explicit memory management. To bring an object into a surrounding scope, thereby extending its lifetime.</p>
<p><strong>See also</strong>: <a href="#Rf-out">F.20, the general item about “out” output values</a></p>
<h5 id="Example-394"><a href="#Example-394" class="headerlink" title="Example"></a>Example</h5><pre><code>vector&lt;int&gt; get_large_vector()
&#123;
    return ...;
&#125;

auto v = get_large_vector(); //  return by value is ok, most modern compilers will do copy elision
</code></pre>
<h5 id="Exception-55"><a href="#Exception-55" class="headerlink" title="Exception"></a>Exception</h5><p>See the Exceptions in <a href="#Rf-out">F.20</a>.</p>
<h5 id="Enforcement-399"><a href="#Enforcement-399" class="headerlink" title="Enforcement"></a>Enforcement</h5><p>Check for pointers and references returned from functions and see if they are assigned to resource handles (e.g., to a <code>unique_ptr</code>).</p>
<h3 id="Discussion-If-a-class-is-a-resource-handle-it-needs-a-constructor-a-destructor-and-copy-and-or-move-operations"><a href="#Discussion-If-a-class-is-a-resource-handle-it-needs-a-constructor-a-destructor-and-copy-and-or-move-operations" class="headerlink" title="Discussion: If a class is a resource handle, it needs a constructor, a destructor, and copy and/or move operations"></a><a name="Cr-handle"></a>Discussion: If a class is a resource handle, it needs a constructor, a destructor, and copy and/or move operations</h3><h5 id="Reason-441"><a href="#Reason-441" class="headerlink" title="Reason"></a>Reason</h5><p>To provide complete control of the lifetime of the resource. To provide a coherent set of operations on the resource.</p>
<h5 id="Example-395"><a href="#Example-395" class="headerlink" title="Example"></a>Example</h5><pre><code>??? Messing with pointers
</code></pre>
<h5 id="Note-382"><a href="#Note-382" class="headerlink" title="Note"></a>Note</h5><p>If all members are resource handles, rely on the default special operations where possible.</p>
<pre><code>template&lt;typename T&gt; struct Named &#123;
    string name;
    T value;
&#125;;
</code></pre>
<p>Now <code>Named</code> has a default constructor, a destructor, and efficient copy and move operations, provided <code>T</code> has.</p>
<h5 id="Enforcement-400"><a href="#Enforcement-400" class="headerlink" title="Enforcement"></a>Enforcement</h5><p>In general, a tool cannot know if a class is a resource handle. However, if a class has some of <a href="#SS-ctor">the default operations</a>, it should have all, and if a class has a member that is a resource handle, it should be considered as resource handle.</p>
<h3 id="Discussion-If-a-class-is-a-container-give-it-an-initializer-list-constructor"><a href="#Discussion-If-a-class-is-a-container-give-it-an-initializer-list-constructor" class="headerlink" title="Discussion: If a class is a container, give it an initializer-list constructor"></a><a name="Cr-list"></a>Discussion: If a class is a container, give it an initializer-list constructor</h3><h5 id="Reason-442"><a href="#Reason-442" class="headerlink" title="Reason"></a>Reason</h5><p>It is common to need an initial set of elements.</p>
<h5 id="Example-396"><a href="#Example-396" class="headerlink" title="Example"></a>Example</h5><pre><code>template&lt;typename T&gt; class Vector &#123;
public:
    Vector(std::initializer_list&lt;T&gt;);
    // ...
&#125;;

Vector&lt;string&gt; vs &#123; &quot;Nygaard&quot;, &quot;Ritchie&quot; &#125;;
</code></pre>
<h5 id="Enforcement-401"><a href="#Enforcement-401" class="headerlink" title="Enforcement"></a>Enforcement</h5><p>When is a class a container? ???</p>
<h1 id="Appendix-D-Supporting-tools"><a href="#Appendix-D-Supporting-tools" class="headerlink" title="Appendix D: Supporting tools"></a><a name="S-tools"></a>Appendix D: Supporting tools</h1><p>This section contains a list of tools that directly support adoption of the C++ Core Guidelines. This list is not intended to be an exhaustive list of tools<br>that are helpful in writing good C++ code. If a tool is designed specifically to support and links to the C++ Core Guidelines it is a candidate for inclusion.</p>
<h3 id="Tools-Clang-tidy"><a href="#Tools-Clang-tidy" class="headerlink" title="Tools: Clang-tidy"></a><a name="St-clangtidy"></a>Tools: <a href="http://clang.llvm.org/extra/clang-tidy/checks/list.html">Clang-tidy</a></h3><p>Clang-tidy has a set of rules that specifically enforce the C++ Core Guidelines. These rules are named in the pattern <code>cppcoreguidelines-*</code>.</p>
<h3 id="Tools-CppCoreCheck"><a href="#Tools-CppCoreCheck" class="headerlink" title="Tools: CppCoreCheck"></a><a name="St-cppcorecheck"></a>Tools: <a href="https://docs.microsoft.com/en-us/visualstudio/code-quality/using-the-cpp-core-guidelines-checkers">CppCoreCheck</a></h3><p>The Microsoft compiler’s C++ code analysis contains a set of rules specifically aimed at enforcement of the C++ Core Guidelines.</p>
<h1 id="Glossary"><a href="#Glossary" class="headerlink" title="Glossary"></a><a name="S-glossary"></a>Glossary</h1><p>A relatively informal definition of terms used in the guidelines<br>(based of the glossary in <a href="http://www.stroustrup.com/programming.html">Programming: Principles and Practice using C++</a>)</p>
<p>More information on many topics about C++ can be found on the <a href="https://isocpp.org/">Standard C++ Foundation</a>‘s site.</p>
<ul>
<li><em>ABI</em>: Application Binary Interface, a specification for a specific hardware platform combined with the operating system. Contrast with API.</li>
<li><em>abstract class</em>: a class that cannot be directly used to create objects; often used to define an interface to derived classes.<br>A class is made abstract by having a pure virtual function or only protected constructors.</li>
<li><em>abstraction</em>: a description of something that selectively and deliberately ignores (hides) details (e.g., implementation details); selective ignorance.</li>
<li><em>address</em>: a value that allows us to find an object in a computer’s memory.</li>
<li><em>algorithm</em>: a procedure or formula for solving a problem; a finite series of computational steps to produce a result.</li>
<li><em>alias</em>: an alternative way of referring to an object; often a name, pointer, or reference.</li>
<li><em>API</em>: Application Programming Interface, a set of functions that form the communication between various software components. Contrast with ABI.</li>
<li><em>application</em>: a program or a collection of programs that is considered an entity by its users.</li>
<li><em>approximation</em>: something (e.g., a value or a design) that is close to the perfect or ideal (value or design).<br>Often an approximation is a result of trade-offs among ideals.</li>
<li><em>argument</em>: a value passed to a function or a template, in which it is accessed through a parameter.</li>
<li><em>array</em>: a homogeneous sequence of elements, usually numbered, e.g., <code>[0:max)</code>.</li>
<li><em>assertion</em>: a statement inserted into a program to state (assert) that something must always be true at this point in the program.</li>
<li><em>base class</em>: a class used as the base of a class hierarchy. Typically a base class has one or more virtual functions.</li>
<li><em>bit</em>: the basic unit of information in a computer. A bit can have the value 0 or the value 1.</li>
<li><em>bug</em>: an error in a program.</li>
<li><em>byte</em>: the basic unit of addressing in most computers. Typically, a byte holds 8 bits.</li>
<li><em>class</em>: a user-defined type that may contain data members, function members, and member types.</li>
<li><em>code</em>: a program or a part of a program; ambiguously used for both source code and object code.</li>
<li><em>compiler</em>: a program that turns source code into object code.</li>
<li><em>complexity</em>: a hard-to-precisely-define notion or measure of the difficulty of constructing a solution to a problem or of the solution itself.<br>Sometimes complexity is used to (simply) mean an estimate of the number of operations needed to execute an algorithm.</li>
<li><em>computation</em>: the execution of some code, usually taking some input and producing some output.</li>
<li><em>concept</em>: (1) a notion, and idea; (2) a set of requirements, usually for a template argument.</li>
<li><em>concrete class</em>: class for which objects can be created.</li>
<li><em>constant</em>: a value that cannot be changed (in a given scope); not mutable.</li>
<li><em>constructor</em>: an operation that initializes (“constructs”) an object.<br>Typically a constructor establishes an invariant and often acquires resources needed for an object to be used (which are then typically released by a destructor).</li>
<li><em>container</em>: an object that holds elements (other objects).</li>
<li><em>copy</em>: an operation that makes two object have values that compare equal. See also move.</li>
<li><em>correctness</em>: a program or a piece of a program is correct if it meets its specification.<br>Unfortunately, a specification can be incomplete or inconsistent, or can fail to meet users’ reasonable expectations.<br>Thus, to produce acceptable code, we sometimes have to do more than just follow the formal specification.</li>
<li><em>cost</em>: the expense (e.g., in programmer time, run time, or space) of producing a program or of executing it.<br>Ideally, cost should be a function of complexity.</li>
<li><em>customization point</em>: ???</li>
<li><em>data</em>: values used in a computation.</li>
<li><em>debugging</em>: the act of searching for and removing errors from a program; usually far less systematic than testing.</li>
<li><em>declaration</em>: the specification of a name with its type in a program.</li>
<li><em>definition</em>: a declaration of an entity that supplies all information necessary to complete a program using the entity.<br>Simplified definition: a declaration that allocates memory.</li>
<li><em>derived class</em>: a class derived from one or more base classes.</li>
<li><em>design</em>: an overall description of how a piece of software should operate to meet its specification.</li>
<li><em>destructor</em>: an operation that is implicitly invoked (called) when an object is destroyed (e.g., at the end of a scope). Often, it releases resources.</li>
<li><em>encapsulation</em>: protecting something meant to be private (e.g., implementation details) from unauthorized access.</li>
<li><em>error</em>: a mismatch between reasonable expectations of program behavior (often expressed as a requirement or a users’ guide) and what a program actually does.</li>
<li><em>executable</em>: a program ready to be run (executed) on a computer.</li>
<li><em>feature creep</em>: a tendency to add excess functionality to a program “just in case.”</li>
<li><em>file</em>: a container of permanent information in a computer.</li>
<li><em>floating-point number</em>: a computer’s approximation of a real number, such as 7.93 and 10.78e-3.</li>
<li><em>function</em>: a named unit of code that can be invoked (called) from different parts of a program; a logical unit of computation.</li>
<li><em>generic programming</em>: a style of programming focused on the design and efficient implementation of algorithms.<br>A generic algorithm will work for all argument types that meet its requirements. In C++, generic programming typically uses templates.</li>
<li><em>global variable</em>: technically, a named object in namespace scope.</li>
<li><em>handle</em>: a class that allows access to another through a member pointer or reference. See also resource, copy, move.</li>
<li><em>header</em>: a file containing declarations used to share interfaces between parts of a program.</li>
<li><em>hiding</em>: the act of preventing a piece of information from being directly seen or accessed.<br>For example, a name from a nested (inner) scope can prevent that same name from an outer (enclosing) scope from being directly used.</li>
<li><em>ideal</em>: the perfect version of something we are striving for. Usually we have to make trade-offs and settle for an approximation.</li>
<li><em>implementation</em>: (1) the act of writing and testing code; (2) the code that implements a program.</li>
<li><em>infinite loop</em>: a loop where the termination condition never becomes true. See iteration.</li>
<li><em>infinite recursion</em>: a recursion that doesn’t end until the machine runs out of memory to hold the calls.<br>In reality, such recursion is never infinite but is terminated by some hardware error.</li>
<li><em>information hiding</em>: the act of separating interface and implementation, thus hiding implementation details not meant for the user’s attention and providing an abstraction.</li>
<li><em>initialize</em>: giving an object its first (initial) value.</li>
<li><em>input</em>: values used by a computation (e.g., function arguments and characters typed on a keyboard).</li>
<li><em>integer</em>: a whole number, such as 42 and -99.</li>
<li><em>interface</em>: a declaration or a set of declarations specifying how a piece of code (such as a function or a class) can be called.</li>
<li><em>invariant</em>: something that must be always true at a given point (or points) of a program; typically used to describe the state (set of values) of an object or the state of a loop before entry into the repeated statement.</li>
<li><em>iteration</em>: the act of repeatedly executing a piece of code; see recursion.</li>
<li><em>iterator</em>: an object that identifies an element of a sequence.</li>
<li><em>ISO</em>: International Organization for Standardization. The C++ language is an ISO standard, ISO/IEC 14882. More information at <a href="http://iso.org/">iso.org</a>.</li>
<li><em>library</em>: a collection of types, functions, classes, etc. implementing a set of facilities (abstractions) meant to be potentially used as part of more that one program.</li>
<li><em>lifetime</em>: the time from the initialization of an object until it becomes unusable (goes out of scope, is deleted, or the program terminates).</li>
<li><em>linker</em>: a program that combines object code files and libraries into an executable program.</li>
<li><em>literal</em>: a notation that directly specifies a value, such as 12 specifying the integer value “twelve.”</li>
<li><em>loop</em>: a piece of code executed repeatedly; in C++, typically a for-statement or a <code>while</code>-statement.</li>
<li><em>move</em>: an operation that transfers a value from one object to another leaving behind a value representing “empty.” See also copy.</li>
<li><em>mutable</em>: changeable; the opposite of immutable, constant, and invariable.</li>
<li><em>object</em>: (1) an initialized region of memory of a known type which holds a value of that type; (2) a region of memory.</li>
<li><em>object code</em>: output from a compiler intended as input for a linker (for the linker to produce executable code).</li>
<li><em>object file</em>: a file containing object code.</li>
<li><em>object-oriented programming</em>: (OOP) a style of programming focused on the design and use of classes and class hierarchies.</li>
<li><em>operation</em>: something that can perform some action, such as a function and an operator.</li>
<li><em>output</em>: values produced by a computation (e.g., a function result or lines of characters written on a screen).</li>
<li><em>overflow</em>: producing a value that cannot be stored in its intended target.</li>
<li><em>overload</em>: defining two functions or operators with the same name but different argument (operand) types.</li>
<li><em>override</em>: defining a function in a derived class with the same name and argument types as a virtual function in the base class, thus making the function callable through the interface defined by the base class.</li>
<li><em>owner</em>: an object responsible for releasing a resource.</li>
<li><em>paradigm</em>: a somewhat pretentious term for design or programming style; often used with the (erroneous) implication that there exists a paradigm that is superior to all others.</li>
<li><em>parameter</em>: a declaration of an explicit input to a function or a template. When called, a function can access the arguments passed through the names of its parameters.</li>
<li><em>pointer</em>: (1) a value used to identify a typed object in memory; (2) a variable holding such a value.</li>
<li><em>post-condition</em>: a condition that must hold upon exit from a piece of code, such as a function or a loop.</li>
<li><em>pre-condition</em>: a condition that must hold upon entry into a piece of code, such as a function or a loop.</li>
<li><em>program</em>: code (possibly with associated data) that is sufficiently complete to be executed by a computer.</li>
<li><em>programming</em>: the art of expressing solutions to problems as code.</li>
<li><em>programming language</em>: a language for expressing programs.</li>
<li><em>pseudo code</em>: a description of a computation written in an informal notation rather than a programming language.</li>
<li><em>pure virtual function</em>: a virtual function that must be overridden in a derived class.</li>
<li><em>RAII</em>: (“Resource Acquisition Is Initialization”) a basic technique for resource management based on scopes.</li>
<li><em>range</em>: a sequence of values that can be described by a start point and an end point. For example, <code>[0:5)</code> means the values 0, 1, 2, 3, and 4.</li>
<li><em>recursion</em>: the act of a function calling itself; see also iteration.</li>
<li><em>reference</em>: (1) a value describing the location of a typed value in memory; (2) a variable holding such a value.</li>
<li><em>regular expression</em>: a notation for patterns in character strings.</li>
<li><em>regular</em>: a type that behaves similarly to built-in types like <code>int</code> and can be compared with <code>==</code>.<br>In particular, an object of a regular type can be copied and the result of a copy is a separate object that compares equal to the original. See also <em>semiregular type</em>.</li>
<li><em>requirement</em>: (1) a description of the desired behavior of a program or part of a program; (2) a description of the assumptions a function or template makes of its arguments.</li>
<li><em>resource</em>: something that is acquired and must later be released, such as a file handle, a lock, or memory. See also handle, owner.</li>
<li><em>rounding</em>: conversion of a value to the mathematically nearest value of a less precise type.</li>
<li><em>RTTI</em>: Run-Time Type Information. ???</li>
<li><em>scope</em>: the region of program text (source code) in which a name can be referred to.</li>
<li><em>semiregular</em>: a type that behaves roughly like an built-in type like <code>int</code>, but possibly without a <code>==</code> operator. See also <em>regular type</em>.</li>
<li><em>sequence</em>: elements that can be visited in a linear order.</li>
<li><em>software</em>: a collection of pieces of code and associated data; often used interchangeably with program.</li>
<li><em>source code</em>: code as produced by a programmer and (in principle) readable by other programmers.</li>
<li><em>source file</em>: a file containing source code.</li>
<li><em>specification</em>: a description of what a piece of code should do.</li>
<li><em>standard</em>: an officially agreed upon definition of something, such as a programming language.</li>
<li><em>state</em>: a set of values.</li>
<li><em>STL</em>: the containers, iterators, and algorithms part of the standard library.</li>
<li><em>string</em>: a sequence of characters.</li>
<li><em>style</em>: a set of techniques for programming leading to a consistent use of language features; sometimes used in a very restricted sense to refer just to low-level rules for naming and appearance of code.</li>
<li><em>subtype</em>: derived type; a type that has all the properties of a type and possibly more.</li>
<li><em>supertype</em>: base type; a type that has a subset of the properties of a type.</li>
<li><em>system</em>: (1) a program or a set of programs for performing a task on a computer; (2) a shorthand for “operating system”, that is, the fundamental execution environment and tools for a computer.</li>
<li><em>TS</em>: <a href="https://www.iso.org/deliverables-all.html?type=ts">Technical Specification</a>, A Technical Specification addresses work still under technical development, or where it is believed that there will be a future, but not immediate, possibility of agreement on an International Standard. A Technical Specification is published for immediate use, but it also provides a means to obtain feedback. The aim is that it will eventually be transformed and republished as an International Standard.</li>
<li><em>template</em>: a class or a function parameterized by one or more types or (compile-time) values; the basic C++ language construct supporting generic programming.</li>
<li><em>testing</em>: a systematic search for errors in a program.</li>
<li><em>trade-off</em>: the result of balancing several design and implementation criteria.</li>
<li><em>truncation</em>: loss of information in a conversion from a type into another that cannot exactly represent the value to be converted.</li>
<li><em>type</em>: something that defines a set of possible values and a set of operations for an object.</li>
<li><em>uninitialized</em>: the (undefined) state of an object before it is initialized.</li>
<li><em>unit</em>: (1) a standard measure that gives meaning to a value (e.g., km for a distance); (2) a distinguished (e.g., named) part of a larger whole.</li>
<li><em>use case</em>: a specific (typically simple) use of a program meant to test its functionality and demonstrate its purpose.</li>
<li><em>value</em>: a set of bits in memory interpreted according to a type.</li>
<li><em>variable</em>: a named object of a given type; contains a value unless uninitialized.</li>
<li><em>virtual function</em>: a member function that can be overridden in a derived class.</li>
<li><em>word</em>: a basic unit of memory in a computer, often the unit used to hold an integer.</li>
</ul>
<h1 id="To-do-Unclassified-proto-rules"><a href="#To-do-Unclassified-proto-rules" class="headerlink" title="To-do: Unclassified proto-rules"></a><a name="S-unclassified"></a>To-do: Unclassified proto-rules</h1><p>This is our to-do list.<br>Eventually, the entries will become rules or parts of rules.<br>Alternatively, we will decide that no change is needed and delete the entry.</p>
<ul>
<li><p>No long-distance friendship</p>
</li>
<li><p>Should physical design (what’s in a file) and large-scale design (libraries, groups of libraries) be addressed?</p>
</li>
<li><p>Namespaces</p>
</li>
<li><p>Avoid using directives in the global scope (except for std, and other “fundamental” namespaces (e.g. experimental))</p>
</li>
<li><p>How granular should namespaces be? All classes/functions designed to work together and released together (as defined in Sutter/Alexandrescu) or something narrower or wider?</p>
</li>
<li><p>Should there be inline namespaces (à la <code>std::literals::*_literals</code>)?</p>
</li>
<li><p>Avoid implicit conversions</p>
</li>
<li><p>Const member functions should be thread safe … aka, but I don’t really change the variable, just assign it a value the first time it’s called … argh</p>
</li>
<li><p>Always initialize variables, use initialization lists for member variables.</p>
</li>
<li><p>Anyone writing a public interface which takes or returns <code>void*</code> should have their toes set on fire. That one has been a personal favorite of mine for a number of years. :)</p>
</li>
<li><p>Use <code>const</code>-ness wherever possible: member functions, variables and (yippee) <code>const_iterators</code></p>
</li>
<li><p>Use <code>auto</code></p>
</li>
<li><p><code>(size)</code> vs. <code>&#123;initializers&#125;</code> vs. <code>&#123;Extent&#123;size&#125;&#125;</code></p>
</li>
<li><p>Don’t overabstract</p>
</li>
<li><p>Never pass a pointer down the call stack</p>
</li>
<li><p>falling through a function bottom</p>
</li>
<li><p>Should there be guidelines to choose between polymorphisms? YES. classic (virtual functions, reference semantics) vs. Sean Parent style (value semantics, type-erased, kind of like <code>std::function</code>)  vs. CRTP/static? YES Perhaps even vs. tag dispatch?</p>
</li>
<li><p>should virtual calls be banned from ctors/dtors in your guidelines? YES. A lot of people ban them, even though I think it’s a big strength of C++ that they are ??? -preserving (D disappointed me so much when it went the Java way). WHAT WOULD BE A GOOD EXAMPLE?</p>
</li>
<li><p>Speaking of lambdas, what would weigh in on the decision between lambdas and (local?) classes in algorithm calls and other callback scenarios?</p>
</li>
<li><p>And speaking of <code>std::bind</code>, Stephen T. Lavavej criticizes it so much I’m starting to wonder if it is indeed going to fade away in future. Should lambdas be recommended instead?</p>
</li>
<li><p>What to do with leaks out of temporaries? : <code>p = (s1 + s2).c_str();</code></p>
</li>
<li><p>pointer/iterator invalidation leading to dangling pointers:</p>
<pre><code>  void bad()
  &#123;
      int* p = new int[700];
      int* q = &amp;p[7];
      delete p;
  
      vector&lt;int&gt; v(700);
      int* q2 = &amp;v[7];
      v.resize(900);
  
      // ... use q and q2 ...
  &#125;
</code></pre>
</li>
<li><p>LSP</p>
</li>
<li><p>private inheritance vs/and membership</p>
</li>
<li><p>avoid static class members variables (race conditions, almost-global variables)</p>
</li>
<li><p>Use RAII lock guards (<code>lock_guard</code>, <code>unique_lock</code>, <code>shared_lock</code>), never call <code>mutex.lock</code> and <code>mutex.unlock</code> directly (RAII)</p>
</li>
<li><p>Prefer non-recursive locks (often used to work around bad reasoning, overhead)</p>
</li>
<li><p>Join your threads! (because of <code>std::terminate</code> in destructor if not joined or detached … is there a good reason to detach threads?) – ??? could support library provide a RAII wrapper for <code>std::thread</code>?</p>
</li>
<li><p>If two or more mutexes must be acquired at the same time, use <code>std::lock</code> (or another deadlock avoidance algorithm?)</p>
</li>
<li><p>When using a <code>condition_variable</code>, always protect the condition by a mutex (atomic bool whose value is set outside of the mutex is wrong!), and use the same mutex for the condition variable itself.</p>
</li>
<li><p>Never use <code>atomic_compare_exchange_strong</code> with <code>std::atomic&lt;user-defined-struct&gt;</code> (differences in padding matter, while <code>compare_exchange_weak</code> in a loop converges to stable padding)</p>
</li>
<li><p>individual <code>shared_future</code> objects are not thread-safe: two threads cannot wait on the same <code>shared_future</code> object (they can wait on copies of a <code>shared_future</code> that refer to the same shared state)</p>
</li>
<li><p>individual <code>shared_ptr</code> objects are not thread-safe: different threads can call non-<code>const</code> member functions on <em>different</em> <code>shared_ptr</code>s that refer to the same shared object, but one thread cannot call a non-<code>const</code> member function of a <code>shared_ptr</code> object while another thread accesses that same <code>shared_ptr</code> object (if you need that, consider <code>atomic_shared_ptr</code> instead)</p>
</li>
<li><p>rules for arithmetic</p>
</li>
</ul>
<h1 id="Bibliography"><a href="#Bibliography" class="headerlink" title="Bibliography"></a>Bibliography</h1><ul>
<li><a name="Abrahams01"></a><br>[Abrahams01]:  D. Abrahams. <a href="http://www.boost.org/community/exception_safety.html">Exception-Safety in Generic Components</a>.</li>
<li><a name="Alexandrescu01"></a><br>[Alexandrescu01]:  A. Alexandrescu. Modern C++ Design (Addison-Wesley, 2001).</li>
<li><a name="Cplusplus03"></a><br>[C++03]:           ISO/IEC 14882:2003(E), Programming Languages — C++ (updated ISO and ANSI C++ Standard including the contents of (C++98) plus errata corrections).</li>
<li><a name="CplusplusCS"></a><br>[C++CS]:           ???</li>
<li><a name="Cargill92"></a><br>[Cargill92]:       T. Cargill. C++ Programming Style (Addison-Wesley, 1992).</li>
<li><a name="Cline99"></a><br>[Cline99]:         M. Cline, G. Lomow, and M. Girou. C++ FAQs (2ndEdition) (Addison-Wesley, 1999).</li>
<li><a name="Dewhurst03"></a><br>[Dewhurst03]:      S. Dewhurst. C++ Gotchas (Addison-Wesley, 2003).</li>
<li><a name="Henricson97"></a><br>[Henricson97]:     M. Henricson and E. Nyquist. Industrial Strength C++ (Prentice Hall, 1997).</li>
<li><a name="Koenig97"></a><br>[Koenig97]:        A. Koenig and B. Moo. Ruminations on C++ (Addison-Wesley, 1997).</li>
<li><a name="Lakos96"></a><br>[Lakos96]:         J. Lakos. Large-Scale C++ Software Design (Addison-Wesley, 1996).</li>
<li><a name="Meyers96"></a><br>[Meyers96]:        S. Meyers. More Effective C++ (Addison-Wesley, 1996).</li>
<li><a name="Meyers97"></a><br>[Meyers97]:        S. Meyers. Effective C++ (2nd Edition) (Addison-Wesley, 1997).</li>
<li><a name="Meyers15"></a><br>[Meyers15]:        S. Meyers. Effective Modern C++ (O’Reilly, 2015).</li>
<li><a name="Murray93"></a><br>[Murray93]:        R. Murray. C++ Strategies and Tactics (Addison-Wesley, 1993).</li>
<li><a name="Stroustrup94"></a><br>[Stroustrup94]:    B. Stroustrup. The Design and Evolution of C++ (Addison-Wesley, 1994).</li>
<li><a name="Stroustrup00"></a><br>[Stroustrup00]:    B. Stroustrup. The C++ Programming Language (Special 3rdEdition) (Addison-Wesley, 2000).</li>
<li><a name="Stroustrup05"></a><br>[Stroustrup05]:    B. Stroustrup. <a href="http://www.stroustrup.com/SELLrationale.pdf">A rationale for semantically enhanced library languages</a>.</li>
<li><a name="Stroustrup13"></a><br>[Stroustrup13]:    B. Stroustrup. <a href="http://www.stroustrup.com/4th.html">The C++ Programming Language (4th Edition)</a>. Addison Wesley 2013.</li>
<li><a name="Stroustrup14"></a><br>[Stroustrup14]:    B. Stroustrup. <a href="http://www.stroustrup.com/Tour.html">A Tour of C++</a>.<br>Addison Wesley 2014.</li>
<li><a name="Stroustrup15"></a><br>[Stroustrup15]:    B. Stroustrup, Herb Sutter, and G. Dos Reis: <a href="https://github.com/isocpp/CppCoreGuidelines/blob/master/docs/Introduction%20to%20type%20and%20resource%20safety.pdf">A brief introduction to C++’s model for type- and resource-safety</a>.</li>
<li><a name="SuttHysl04b"></a><br>[SuttHysl04b]:     H. Sutter and J. Hyslop. “Collecting Shared Objects” (C/C++ Users Journal, 22(8), August 2004).</li>
<li><a name="SuttAlex05"></a><br>[SuttAlex05]:      H. Sutter and  A. Alexandrescu. C++ Coding Standards. Addison-Wesley 2005.</li>
<li><a name="Sutter00"></a><br>[Sutter00]:        H. Sutter. Exceptional C++ (Addison-Wesley, 2000).</li>
<li><a name="Sutter02"></a><br>[Sutter02]:        H. Sutter. More Exceptional C++ (Addison-Wesley, 2002).</li>
<li><a name="Sutter04"></a><br>[Sutter04]:        H. Sutter. Exceptional C++ Style (Addison-Wesley, 2004).</li>
<li><a name="Taligent94"></a><br>[Taligent94]: Taligent’s Guide to Designing Programs (Addison-Wesley, 1994).</li>
</ul>
]]></content>
  </entry>
  <entry>
    <title>备案</title>
    <url>/2021/07/30/beian-note/</url>
    <content><![CDATA[<p>国内备案实在太烦了，放弃了，迁外网了。</p>
]]></content>
  </entry>
  <entry>
    <title>解决xbox手柄扳机键回弹慢的问题</title>
    <url>/2021/08/14/how-to-fix-xbox-controller-trigger-key-slow-springback/</url>
    <content><![CDATA[<p>xbox one的手柄已经用了三年了，最近明显感觉到扳机键回弹不灵敏了。在万能的B站搜了一波，对着拆机视频搞起来。</p>
<span id="more"></span>

<p>在B站找到<a href="https://www.bilibili.com/video/BV1x7411s7s3?from=search&seid=18075264222408655437">这个</a>视频，再次感谢该阿婆主。有点困难的是拆xbox背扣，需要大力出奇迹。上一张正面图</p>
<p><img src="/2021/08/14/how-to-fix-xbox-controller-trigger-key-slow-springback/xbox-front.JPG"></p>
<p><img src="/2021/08/14/how-to-fix-xbox-controller-trigger-key-slow-springback/xbox-back.JPG"></p>
<p>不得不说，xbox做工还是很精良的，特别是经过阿婆主的解说，xbox的按键都是通过立体注塑，特别是西瓜键，是分体键，是由两个组件组合起来的，不是简单的雕刻成型的。</p>
<p>搞定了拆机之后，发现Xbox的扳机键就是一个弹簧，并没有其他组件！那扳机键是如何感知射击动作，并转化成电信号的呢？</p>
<p><img src="/2021/08/14/how-to-fix-xbox-controller-trigger-key-slow-springback/xbox-trigger-key.JPG"></p>
<p>在网上找了一波资料，原来xbox手柄在扳机键使用的霍尔传感器，物理知识已经还给老师的请看下面介绍：</p>
<blockquote>
<p>The <strong>Hall effect</strong> is the production of a <a href="https://en.wikipedia.org/wiki/Voltage">voltage</a> difference (the <strong>Hall voltage</strong>) across an <a href="https://en.wikipedia.org/wiki/Electrical_conductor">electrical conductor</a> that is transverse to an <a href="https://en.wikipedia.org/wiki/Electric_current">electric current</a> in the conductor and to an applied <a href="https://en.wikipedia.org/wiki/Magnetic_field">magnetic field</a> perpendicular to the current</p>
</blockquote>
<p>简单来说就是载流半导体在磁场中会形成电位差。在xbox手柄的扳机键中下面有一块磁铁，在扣动扳机键时，磁铁与霍尔元器件距离变化，带来磁场变化，再带来电压的变化。</p>
<p>搞清楚扳机键的工作原理之后，回弹慢的问题就很简单了：1) 弹簧的问题 2) 扳机键缓冲垫老化导致粘滞。把扳机键拆除再扣动，发现弹簧无问题。把扳机键下方的缓冲垫刮除，问题解决。</p>
<p><img src="/2021/08/14/how-to-fix-xbox-controller-trigger-key-slow-springback/problem-solve.JPG"></p>
]]></content>
      <categories>
        <category>how-to</category>
      </categories>
  </entry>
  <entry>
    <title>amazon fire tv 无法安装应用</title>
    <url>/2021/08/13/fix-amazon-fire-tv-purchase-failure/</url>
    <content><![CDATA[<p>在fire tv上绑定美亚账号之后发现，还是无法下载应用。解决办法如下：</p>
<span id="more"></span>

<ul>
<li>确定绑定的是美区账号，在PC上登录亚马逊账号，确认在content-&gt;device preference中设置region未US，同时enable one-click shopping setting</li>
<li>添加billing address，主要如果绑定了国内信用卡的话，需要将信用卡解绑！然后设置default billing address，地址可以随便在google map上找一个美区地址</li>
<li>连接wifi的时候，设置advanced，网关地址设置为旁路有地址。</li>
</ul>
]]></content>
  </entry>
  <entry>
    <title>我说宋Plus</title>
    <url>/2022/10/30/review-on-my-byd-song/</url>
    <content><![CDATA[<p>提车一个月，里程1400公里，想着总结下用车一个月来的体验。</p>
<span id="more"></span>

<h1 id="等车五个月"><a href="#等车五个月" class="headerlink" title="等车五个月"></a>等车五个月</h1><p>宋Plus DMi等车时间实在是太长了，22年五月2号订车，开始销售说三个月左右（合同直接写车到提车），到9月初一定能提，到国庆后能提，真正拿车是9月30号。等车过程太难受，特别是9月初得到销售肯定答复后却一再推迟，差点换其他车了。不过幸好还是在国庆前提车，而且由于购车补贴在9月30号结束，相当于最后还拿到了街道的补贴，也是不幸中的万幸。</p>
<img src="/2022/10/30/review-on-my-byd-song/Song-Plus-DMI.JPG" class="">

<p>比亚迪今年确实卖的挺火，我还是挺为国产车高兴，买车前我就没有考虑过合资车，试驾只去了比亚迪和吉利店。一个是支持国产，另一个是预算内合资车内饰配置太拉了。况且电动车国内已经弯道超车了，必须支持一把。但是等车时间太长，体验不佳，希望比亚迪产能上来之后能解决这个问题。</p>
<h1 id="用车数据"><a href="#用车数据" class="headerlink" title="用车数据"></a>用车数据</h1><table>
<thead>
<tr>
<th>item</th>
<th>data</th>
</tr>
</thead>
<tbody><tr>
<td>总里程</td>
<td>1395</td>
</tr>
<tr>
<td>电费</td>
<td>134.03</td>
</tr>
<tr>
<td>油费</td>
<td>442*（1-0.33）= 296</td>
</tr>
</tbody></table>
<p>上面的数据是一个月的用车数据。用车情况除去国庆假期，其他基本是通勤，每天60公里。不堵车的情况下几乎全程高速。因为看保养手册前2000公里建议ECO+HEV，且HEV里程占总里程的50%以上，所以我都是按保养手册执行，大概一周充一次电。</p>
<p>最关心的肯定是用车成本。从比亚迪app查到的数据是累计平均能耗<strong>4.1升/百公里=6.1度+2.2升</strong>，统计的每公里费用<strong>0.26</strong>元。</p>
<img src="/2022/10/30/review-on-my-byd-song/Gas-station.JPG" class="">

<p>我自己估算成本：<strong>油费296 + 电费134 / 1395 = 0.31元/公里</strong>。</p>
<p>因为目前还是在使用外面的商业充电桩（1.2元/度），后期加装家用装，且增加EV里程比例，应该用车成本还可以降低。</p>
<h1 id="遇到的“问题”"><a href="#遇到的“问题”" class="headerlink" title="遇到的“问题”"></a>遇到的“问题”</h1><p>提车之后，遇到几个闹心的事情。虽然最后发现都“不是”问题，但是也从侧面反映出比亚迪工作人员专业度还需要提升。</p>
<h2 id="无法开电尾门？"><a href="#无法开电尾门？" class="headerlink" title="无法开电尾门？"></a>无法开电尾门？</h2><p>一个是发现智能钥匙无法开启有时候无法开启后备箱，进一步发现是在点火状态无法开启后备箱，车辆闪黄灯，但是下车手动可以开启。在车友群里问，大家都可以开启，导致我以为我车子有问题，电话给销售，他让转给售后，售后致电让我去4S点检测。当时心里就很不舒服，以为自己“中奖”了。提车前在懂车帝车友圈看到一些有关宋Plus DMi的问题贴，以至于当时提车的时候专门看了视频教学，如何验车。</p>
<p>后来确认是正常现象。想来也是，点火状态如果使用智能钥匙开后备箱，这样如果行车过程中钥匙误触，那可能有安全隐患。这个体现了比亚迪售前售后不专业，不能及时解决客户问题。同时车友圈给的信息可能要仔细甄别。</p>
<p>有个插曲：说来也巧，当天上牌同样碰到一个车友（非比亚迪），当时需要检查后备箱的三脚架和反光背心，也是用钥匙无法开电尾门。正当他很疑惑的时候，我深藏功与名的点了他一句：是不是车子没有熄火？哈哈。</p>
<h2 id="充电口锁死？"><a href="#充电口锁死？" class="headerlink" title="充电口锁死？"></a>充电口锁死？</h2><p>第一次在商业电桩充电的时候，充电结束，发现充电接口拔不下来。似乎接口被锁死了。求助了现场一些充电的车友，说可能是锁死了。去电特来电客服，答曰是比亚迪的问题。去电比亚迪销售，开锁，重新开关锁，都无法拔出。又是比亚迪售后电话，说要等救援。我…</p>
<p>还是上网查了一些资料，有人说特来电的充电枪太重且紧，需要提着充电枪上下摇动才可拔出。看来是自己因为是新车不太造次，哈哈。问题解决。欸，比亚迪售后太不专业第二次！</p>
<h2 id="发动机灯报警？"><a href="#发动机灯报警？" class="headerlink" title="发动机灯报警？"></a>发动机灯报警？</h2><p>点火发现发动机灯告警亮起，偶发现象。查阅了车主手册，手册中说需要尽快联系4S店。我还专门录制视频发给销售，销售让售后联系。没多久售后电话过来问了几个问题。</p>
<p>“你这个车开了几万公里了？上一次保养是什么时候”<br>“提车没几天，不会真的是发动机有我问题吧？”<br>“你来4s店检测升级一下吧。”<br>“…”</p>
<p>我当时心里是崩溃的，不会真的中奖了吧？火急火燎开到4S店，售后在忙，等了半个小时，答应帮我先看一下，眼看售后小哥拿着检测仪器来 读取行车数据，扫描一遍发现没有故障。</p>
<p>“没看到有问题啊”<br>我在等待的时间里，又求助万能的车友群，在群里得到回复是说没有踩刹车启动，导致发动机冷却液告警？<br>看着售后小哥有点迷茫的还在查问题，我试探这问是不是这个问题？小哥说噢，你没踩刹车是会有这样的问题。车子没问题，你开走吧。</p>
<p>车没问题，当然是好的，但是比亚迪售前售后的体现出来的专业程度让人不敢恭维。仿佛售后遇到问题，第一个告诉你的是你先在4S店升级下吧。当然这里面有很大原因可能是我自己，新手不熟悉，一些常识并不理解等等。</p>
<h1 id="用车体验"><a href="#用车体验" class="headerlink" title="用车体验"></a>用车体验</h1><p><strong>外观</strong>：我个人还是很喜欢宋的外观的，前网格栅，很霸气，有种大嘴吞噬一切的感觉，虽然是前奥迪总设计师设计的，跟很多奥迪车前脸撞脸。车标为“宋”，很独特的中国风。</p>
<p><strong>内饰</strong>：没有考虑合资车的一个原因就是内饰太拉了。两田的不管轿车还是SUV，特别是中控这一块，慢慢的老年风格既视感，必须直接PASS。</p>
<p><strong>智能化</strong>：国产车在这一方面都很有优势。APP远程控制，手机NFC钥匙，外加语音控制，虽然比亚迪车机用的芯片不是目前最强的高通8155，但是实际使用下来，也不卡顿。而且常用的APP预装都有，车机上的高德地图明显感觉比手机版好用！驾驶辅助这些由于我车并没有，此处略过，不过据说ACC自适应巡航效果还不错。</p>
<p><strong>隔音</strong>：订车前看过相关的评测，宋前面使用的双层夹胶玻璃，隔音效果不错。在纯电模式下，几乎听不到其他噪音。</p>
<p><strong>娱乐化</strong>: 宋竟然随车还有K歌的麦克风，把车窗一关，可以在车里high歌，这个功能偶尔还是有用的！另外一个对我来说比较重要的是音响效果还可以，经常在上下班路上听歌，多几个喇叭还是有效果的。</p>
<img src="/2022/10/30/review-on-my-byd-song/KTV.JPG" class="">

<p><strong>底盘&amp;滤震</strong>：唯一让我有点不太满意的，要算滤震效果了。在前排，依然能感觉到底盘很硬。通过减速带可以很清晰的感受到滤震效果不佳。</p>
<p><strong>新车散味</strong>：味道有点大，目前一个月了，停车一天上车还是有些味道，让我不得不在车里使用口罩。</p>
<p><strong>有关充电</strong>：110km的版本，从20%充满到100%，在快充电桩一个小时即可充满，所以即使无家用桩的情况下，只要家里附近商用桩方便充电，也不会很麻烦。目前一周大概充一次电，下班开到充电站，回家歇一歇，遛完狗，差不多充满了，开回家即可。</p>
<p>整体上来说，宋Plus DMi在这个价位性价比还是很高。其经济性，空间，外观内饰配置都可圈可点。稍有遗憾的是可惜定的不是高配版本，高配低配相差一万，但是多了很多辅助驾驶相关的feature，我最想要的是ACC自动巡航和座椅通风。当时销售劝说高配等车时间太长，定低配，后来发现高配提车反而更快…</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>目前为止，还是对宋挺满意的，期待宋给自己带来的不仅仅是出行半径的简单拓宽，还有与家人一起参与的未来可能。</p>
]]></content>
      <categories>
        <category>notes</category>
      </categories>
  </entry>
</search>
